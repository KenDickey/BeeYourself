'From Cuis 6.0 [latest update: #6072] on 27 November 2023 at 2:27:19 pm'!
'Description Egg -- refactoring of Bee runtime

Note fork: `https://github.com/KenDickey/egg`'''!
!provides: 'Egg' 1 1!
!requires: 'BeeCompatibility' 1 46 nil!
!requires: 'RISC5-Instructions' 1 74 nil!
SystemOrganization addCategory: #'Egg-Builder'!
SystemOrganization addCategory: #'Egg-Compatibility-Pharo'!
SystemOrganization addCategory: #'Egg-Core-Assembler-Intel'!
SystemOrganization addCategory: #'Egg-Core-Assembly'!
SystemOrganization addCategory: #'Egg-Core-Assembly-Intel-Parser'!
SystemOrganization addCategory: #'Egg-Core-Assembly-Intel-Tools'!
SystemOrganization addCategory: #'Egg-Core-Assembly-RISCV'!
SystemOrganization addCategory: #'Egg-Core-Building'!
SystemOrganization addCategory: #'Egg-Core-Execution'!
SystemOrganization addCategory: #'Egg-Core-Execution-LMR'!
SystemOrganization addCategory: #'Egg-Core-Execution-Ring'!
SystemOrganization addCategory: #'Egg-Core-Metaphysics'!
SystemOrganization addCategory: #'Egg-Core-Mirrors'!
SystemOrganization addCategory: #'Egg-Core-Nativization'!
SystemOrganization addCategory: #'Egg-Core-SExpressions'!
SystemOrganization addCategory: #'Egg-IR'!
SystemOrganization addCategory: #'Egg-LMR-Bootstrapper'!
SystemOrganization addCategory: #'Egg-OCompiler'!
SystemOrganization addCategory: #'Egg-OCompiler-Core-IR'!
SystemOrganization addCategory: #'Egg-OCompiler-Core-Main'!
SystemOrganization addCategory: #'Egg-SCompiler'!
SystemOrganization addCategory: #'Egg-SCompiler-Backend'!
SystemOrganization addCategory: #'Egg-SCompiler-Bindings'!
SystemOrganization addCategory: #'Egg-SCompiler-Frontend'!
SystemOrganization addCategory: #'Egg-SCompiler-Parser'!


!classDefinition: #PSharedPool category: #'Egg-Compatibility-Pharo'!
SharedPool subclass: #PSharedPool
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Compatibility-Pharo'!
!classDefinition: 'PSharedPool class' category: #'Egg-Compatibility-Pharo'!
PSharedPool class
	instanceVariableNames: ''!

!classDefinition: #CharacterConstants category: #'Egg-Compatibility-Pharo'!
PSharedPool subclass: #CharacterConstants
	instanceVariableNames: ''
	classVariableNames: 'Cr Lf Space Tab'
	poolDictionaries: ''
	category: 'Egg-Compatibility-Pharo'!
!classDefinition: 'CharacterConstants class' category: #'Egg-Compatibility-Pharo'!
CharacterConstants class
	instanceVariableNames: 'Cr Lf Space Tab'!

!classDefinition: #OperandTypeFlags category: #'Egg-Core-Assembler-Intel'!
PSharedPool subclass: #OperandTypeFlags
	instanceVariableNames: ''
	classVariableNames: 'ConstantType ImmediateType MemoryType RegisterGP RegisterGroupMask RegisterSIMD RegisterSegment RegisterSpecific RegisterType'
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'OperandTypeFlags class' category: #'Egg-Core-Assembler-Intel'!
OperandTypeFlags class
	instanceVariableNames: 'ConstantType ImmediateType MemoryType RegisterGP RegisterGroupMask RegisterSIMD RegisterSegment RegisterSpecific RegisterType'!

!classDefinition: #Prefixes category: #'Egg-Core-Assembler-Intel'!
PSharedPool subclass: #Prefixes
	instanceVariableNames: ''
	classVariableNames: 'AddressSize_Override LOCK OperandSize_Override REP REPE REPNE REPNZ REPZ REX REX_R REX_W'
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'Prefixes class' category: #'Egg-Core-Assembler-Intel'!
Prefixes class
	instanceVariableNames: 'AddressSize_Override LOCK OperandSize_Override REP REPE REPNE REPNZ REPZ REX REX_R REX_W'!

!classDefinition: #Registers category: #'Egg-Core-Assembler-Intel'!
PSharedPool subclass: #Registers
	instanceVariableNames: ''
	classVariableNames: 'ah al ax bh bl bp bpl bx ch cl cs cx dh di dil dl ds dx eax ebp ebx ecx edi edx es esi esp fs gs mmx0 mmx1 mmx2 mmx3 mmx4 mmx5 mmx6 mmx7 r10 r10b r10d r10w r11 r11b r11d r11w r12 r12b r12d r12w r13 r13b r13d r13w r14 r14b r14d r14w r15 r15b r15d r15w r8 r8b r8d r8w r9 r9b r9d r9w rax rbp rbx rcx rdi rdx rip rsi rsp si sil sp spl ss xmm0 xmm1 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 ymm0 ymm1 ymm10 ymm11 ymm12 ymm13 ymm14 ymm15 ymm2 ymm3 ymm4 ymm5 ymm6 ymm7 ymm8 ymm9'
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'Registers class' category: #'Egg-Core-Assembler-Intel'!
Registers class
	instanceVariableNames: 'ah al ax bh bl bp bpl bx ch cl cs cx dh di dil dl ds dx eax ebp ebx ecx edi edx es esi esp fs gs mmx0 mmx1 mmx2 mmx3 mmx4 mmx5 mmx6 mmx7 r10 r10b r10d r10w r11 r11b r11d r11w r12 r12b r12d r12w r13 r13b r13d r13w r14 r14b r14d r14w r15 r15b r15d r15w r8 r8b r8d r8w r9 r9b r9d r9w rax rbp rbx rcx rdi rdx rip rsi rsp si sil sp spl ss xmm0 xmm1 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 ymm0 ymm1 ymm10 ymm11 ymm12 ymm13 ymm14 ymm15 ymm2 ymm3 ymm4 ymm5 ymm6 ymm7 ymm8 ymm9'!

!classDefinition: #ObjectHeaderMasks category: #'Egg-Core-Metaphysics'!
PSharedPool subclass: #ObjectHeaderMasks
	instanceVariableNames: ''
	classVariableNames: 'IsArrayed IsBytes IsNamed IsSmall'
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'ObjectHeaderMasks class' category: #'Egg-Core-Metaphysics'!
ObjectHeaderMasks class
	instanceVariableNames: 'IsArrayed IsBytes IsNamed IsSmall'!

!classDefinition: #ObjectHeaderOffsets category: #'Egg-Core-Metaphysics'!
PSharedPool subclass: #ObjectHeaderOffsets
	instanceVariableNames: ''
	classVariableNames: 'BehaviorOffset FlagsOffset HashOffset LargeSizeOffset SizeOffset'
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'ObjectHeaderOffsets class' category: #'Egg-Core-Metaphysics'!
ObjectHeaderOffsets class
	instanceVariableNames: 'BehaviorOffset FlagsOffset HashOffset LargeSizeOffset SizeOffset'!

!classDefinition: #CompiledBlockFormatMasks category: #'Egg-Core-Mirrors'!
PSharedPool subclass: #CompiledBlockFormatMasks
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'CompiledBlockFormatMasks class' category: #'Egg-Core-Mirrors'!
CompiledBlockFormatMasks class
	instanceVariableNames: ''!

!classDefinition: #CompiledMethodFormatMasks category: #'Egg-Core-Mirrors'!
PSharedPool subclass: #CompiledMethodFormatMasks
	instanceVariableNames: ''
	classVariableNames: 'ArgCount BlockCount TempCount'
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'CompiledMethodFormatMasks class' category: #'Egg-Core-Mirrors'!
CompiledMethodFormatMasks class
	instanceVariableNames: 'ArgCount BlockCount TempCount'!

!classDefinition: #FrameOffsets category: #'Egg-Core-Mirrors'!
PSharedPool subclass: #FrameOffsets
	instanceVariableNames: ''
	classVariableNames: 'CallerIndex LastArgumentIndex MethodIndex ReceiverIndex ReturnAddressIndex'
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'FrameOffsets class' category: #'Egg-Core-Mirrors'!
FrameOffsets class
	instanceVariableNames: 'CallerIndex LastArgumentIndex MethodIndex ReceiverIndex ReturnAddressIndex'!

!classDefinition: #SpeciesFormatMasks category: #'Egg-Core-Mirrors'!
PSharedPool subclass: #SpeciesFormatMasks
	instanceVariableNames: ''
	classVariableNames: 'InstSize IsPointers'
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'SpeciesFormatMasks class' category: #'Egg-Core-Mirrors'!
SpeciesFormatMasks class
	instanceVariableNames: 'InstSize IsPointers'!

!classDefinition: #InlineMessageLinkerFlags category: #'Egg-Core-Nativization'!
PSharedPool subclass: #InlineMessageLinkerFlags
	instanceVariableNames: ''
	classVariableNames: '_ExtendedSize _Flags _Hash _Reserved _SmallSize'
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'InlineMessageLinkerFlags class' category: #'Egg-Core-Nativization'!
InlineMessageLinkerFlags class
	instanceVariableNames: '_ExtendedSize _Flags _Hash _Reserved _SmallSize'!

!classDefinition: #SendSiteFlags category: #'Egg-Core-Nativization'!
PSharedPool subclass: #SendSiteFlags
	instanceVariableNames: ''
	classVariableNames: 'HasBeenReset IsPolymorphic IsStaticSend IsSuperSend'
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'SendSiteFlags class' category: #'Egg-Core-Nativization'!
SendSiteFlags class
	instanceVariableNames: 'HasBeenReset IsPolymorphic IsStaticSend IsSuperSend'!

!classDefinition: #SExpressionTypes category: #'Egg-Core-SExpressions'!
PSharedPool subclass: #SExpressionTypes
	instanceVariableNames: ''
	classVariableNames: 'AssignmentId BlockId BraceId CascadeId IdentifierId LiteralId MessageId MethodId ReturnId'
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SExpressionTypes class' category: #'Egg-Core-SExpressions'!
SExpressionTypes class
	instanceVariableNames: 'AssignmentId BlockId BraceId CascadeId IdentifierId LiteralId MessageId MethodId ReturnId'!

!classDefinition: #AstBindingTypes category: #'Egg-SCompiler-Backend'!
PSharedPool subclass: #AstBindingTypes
	instanceVariableNames: ''
	classVariableNames: 'ArgumentId DynamicVarId FalseId NestedDynamicVarId NilId PopRid PushRid SelfId SuperId TemporaryId TrueId'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'AstBindingTypes class' category: #'Egg-SCompiler-Backend'!
AstBindingTypes class
	instanceVariableNames: 'ArgumentId DynamicVarId FalseId NestedDynamicVarId NilId PopRid PushRid SelfId SuperId TemporaryId TrueId'!

!classDefinition: #AstNodeTypes category: #'Egg-SCompiler-Backend'!
PSharedPool subclass: #AstNodeTypes
	instanceVariableNames: ''
	classVariableNames: 'AssignmentId BlockId BraceId CascadeId IdentifierId LiteralId MessageId MethodId PragmaId ReturnId'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'AstNodeTypes class' category: #'Egg-SCompiler-Backend'!
AstNodeTypes class
	instanceVariableNames: 'AssignmentId BlockId BraceId CascadeId IdentifierId LiteralId MessageId MethodId PragmaId ReturnId'!

!classDefinition: #ClosureElementTypes category: #'Egg-SCompiler-Backend'!
PSharedPool subclass: #ClosureElementTypes
	instanceVariableNames: ''
	classVariableNames: 'Environment EnvironmentValue LocalArgument Self'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'ClosureElementTypes class' category: #'Egg-SCompiler-Backend'!
ClosureElementTypes class
	instanceVariableNames: 'Environment EnvironmentValue LocalArgument Self'!

!classDefinition: #SCompiledBlockFlags category: #'Egg-SCompiler-Backend'!
PSharedPool subclass: #SCompiledBlockFlags
	instanceVariableNames: ''
	classVariableNames: 'BlockArgCount BlockCapturesHome BlockCapturesSelf BlockEnvCount BlockId BlockTempCount'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'SCompiledBlockFlags class' category: #'Egg-SCompiler-Backend'!
SCompiledBlockFlags class
	instanceVariableNames: 'BlockArgCount BlockCapturesHome BlockCapturesSelf BlockEnvCount BlockId BlockTempCount'!

!classDefinition: #SCompiledMethodFlags category: #'Egg-SCompiler-Backend'!
PSharedPool subclass: #SCompiledMethodFlags
	instanceVariableNames: ''
	classVariableNames: 'ArgCount BlockCount CapturesSelf Debuggable EnvCount HasEnvironment HasFrame TempCount'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'SCompiledMethodFlags class' category: #'Egg-SCompiler-Backend'!
SCompiledMethodFlags class
	instanceVariableNames: 'ArgCount BlockCount CapturesSelf Debuggable EnvCount HasEnvironment HasFrame TempCount'!

!classDefinition: #RegistersRISCV category: #'Egg-Core-Assembly-RISCV'!
SharedPool subclass: #RegistersRISCV
	instanceVariableNames: ''
	classVariableNames: 'RegA RegE RegFP RegFalse RegFlags RegG RegLink RegM RegNil RegR RegS RegSP RegT RegTmp0 RegTmp1 RegTrue RegV RegX0 RegX1 RegZero'
	poolDictionaries: 'RISC5Regs'
	category: 'Egg-Core-Assembly-RISCV'!
!classDefinition: 'RegistersRISCV class' category: #'Egg-Core-Assembly-RISCV'!
RegistersRISCV class
	instanceVariableNames: ''!

!classDefinition: #Subject category: #'Egg-Core-Metaphysics'!
ProtoObject subclass: #Subject
	instanceVariableNames: 'gate'
	classVariableNames: 'Counts'
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'Subject class' category: #'Egg-Core-Metaphysics'!
Subject class
	instanceVariableNames: 'Counts'!

!classDefinition: #SClosure category: #'Egg-Core-Metaphysics'!
Array variableSubclass: #SClosure
	instanceVariableNames: 'block home'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'SClosure class' category: #'Egg-Core-Metaphysics'!
SClosure class
	instanceVariableNames: ''!

!classDefinition: #NativeCode category: #'Egg-Core-Nativization'!
Array variableSubclass: #NativeCode
	instanceVariableNames: 'machineCode compiledCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'NativeCode class' category: #'Egg-Core-Nativization'!
NativeCode class
	instanceVariableNames: ''!

!classDefinition: #SCompiledMethod category: #'Egg-SCompiler-Backend'!
Array variableSubclass: #SCompiledMethod
	instanceVariableNames: 'format optimizedCode astcodes class selector source'
	classVariableNames: ''
	poolDictionaries: 'private'
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'SCompiledMethod class' category: #'Egg-SCompiler-Backend'!
SCompiledMethod class
	instanceVariableNames: ''!

!classDefinition: #SCallbackMethod category: #'Egg-SCompiler-Backend'!
SCompiledMethod variableSubclass: #SCallbackMethod
	instanceVariableNames: 'receiver descriptor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'SCallbackMethod class' category: #'Egg-SCompiler-Backend'!
SCallbackMethod class
	instanceVariableNames: ''!

!classDefinition: #SCalloutMethod category: #'Egg-SCompiler-Backend'!
SCompiledMethod variableSubclass: #SCalloutMethod
	instanceVariableNames: 'descriptor symbol address'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'SCalloutMethod class' category: #'Egg-SCompiler-Backend'!
SCalloutMethod class
	instanceVariableNames: ''!

!classDefinition: #SFFIDescriptor category: #'Egg-SCompiler-Parser'!
ByteArray variableByteSubclass: #SFFIDescriptor
	instanceVariableNames: ''
	classVariableNames: 'FFICallingConventions FFITypes'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SFFIDescriptor class' category: #'Egg-SCompiler-Parser'!
SFFIDescriptor class
	instanceVariableNames: 'FFICallingConventions FFITypes'!

!classDefinition: #PoolDictionary category: #'Egg-Compatibility-Pharo'!
Dictionary subclass: #PoolDictionary
	instanceVariableNames: 'constant'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Compatibility-Pharo'!
!classDefinition: 'PoolDictionary class' category: #'Egg-Compatibility-Pharo'!
PoolDictionary class
	instanceVariableNames: ''!

!classDefinition: #Builder category: #'Egg-Builder'!
Object subclass: #Builder
	instanceVariableNames: 'stream objects space nextHash offsets size base module wordSize roots index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Builder'!
!classDefinition: 'Builder class' category: #'Egg-Builder'!
Builder class
	instanceVariableNames: ''!

!classDefinition: #NumberParser2 category: #'Egg-Compatibility-Pharo'!
Object subclass: #NumberParser2
	instanceVariableNames: 'stream error return'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Compatibility-Pharo'!
!classDefinition: 'NumberParser2 class' category: #'Egg-Compatibility-Pharo'!
NumberParser2 class
	instanceVariableNames: ''!

!classDefinition: #Stretch category: #'Egg-Compatibility-Pharo'!
Object subclass: #Stretch
	instanceVariableNames: 'start end'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Compatibility-Pharo'!
!classDefinition: 'Stretch class' category: #'Egg-Compatibility-Pharo'!
Stretch class
	instanceVariableNames: ''!

!classDefinition: #ISAInstruction category: #'Egg-Core-Assembler-Intel'!
Object subclass: #ISAInstruction
	instanceVariableNames: 'prefix mnemonic operands template'
	classVariableNames: ''
	poolDictionaries: 'private'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'ISAInstruction class' category: #'Egg-Core-Assembler-Intel'!
ISAInstruction class
	instanceVariableNames: ''!

!classDefinition: #ISAOperand category: #'Egg-Core-Assembler-Intel'!
Object subclass: #ISAOperand
	instanceVariableNames: 'length'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'ISAOperand class' category: #'Egg-Core-Assembler-Intel'!
ISAOperand class
	instanceVariableNames: ''!

!classDefinition: #ISAImmediate category: #'Egg-Core-Assembler-Intel'!
ISAOperand subclass: #ISAImmediate
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'ISAImmediate class' category: #'Egg-Core-Assembler-Intel'!
ISAImmediate class
	instanceVariableNames: ''!

!classDefinition: #MemoryOperand category: #'Egg-Core-Assembler-Intel'!
ISAOperand subclass: #MemoryOperand
	instanceVariableNames: 'base index scale displacement segment'
	classVariableNames: ''
	poolDictionaries: 'Registers'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'MemoryOperand class' category: #'Egg-Core-Assembler-Intel'!
MemoryOperand class
	instanceVariableNames: ''!

!classDefinition: #Register category: #'Egg-Core-Assembler-Intel'!
ISAOperand subclass: #Register
	instanceVariableNames: 'name index family flags'
	classVariableNames: ''
	poolDictionaries: 'OperandTypeFlags Registers'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'Register class' category: #'Egg-Core-Assembler-Intel'!
Register class
	instanceVariableNames: ''!

!classDefinition: #ISAOperandType category: #'Egg-Core-Assembler-Intel'!
Object subclass: #ISAOperandType
	instanceVariableNames: 'type length memoryLength flags'
	classVariableNames: 'Types'
	poolDictionaries: 'OperandTypeFlags private'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'ISAOperandType class' category: #'Egg-Core-Assembler-Intel'!
ISAOperandType class
	instanceVariableNames: 'Types'!

!classDefinition: #InstructionEncoder category: #'Egg-Core-Assembler-Intel'!
Object subclass: #InstructionEncoder
	instanceVariableNames: 'instruction spec stream prefixes rex vex opcode modrm sib displacement immediate immediate2 wordSize'
	classVariableNames: 'Cache'
	poolDictionaries: 'Registers'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'InstructionEncoder class' category: #'Egg-Core-Assembler-Intel'!
InstructionEncoder class
	instanceVariableNames: 'Cache'!

!classDefinition: #InstructionPrefix category: #'Egg-Core-Assembler-Intel'!
Object subclass: #InstructionPrefix
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: 'private'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'InstructionPrefix class' category: #'Egg-Core-Assembler-Intel'!
InstructionPrefix class
	instanceVariableNames: ''!

!classDefinition: #LegacyPrefix category: #'Egg-Core-Assembler-Intel'!
InstructionPrefix subclass: #LegacyPrefix
	instanceVariableNames: 'group value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'LegacyPrefix class' category: #'Egg-Core-Assembler-Intel'!
LegacyPrefix class
	instanceVariableNames: ''!

!classDefinition: #REXPrefix category: #'Egg-Core-Assembler-Intel'!
InstructionPrefix subclass: #REXPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'REXPrefix class' category: #'Egg-Core-Assembler-Intel'!
REXPrefix class
	instanceVariableNames: ''!

!classDefinition: #SegmentPrefix category: #'Egg-Core-Assembler-Intel'!
InstructionPrefix subclass: #SegmentPrefix
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'SegmentPrefix class' category: #'Egg-Core-Assembler-Intel'!
SegmentPrefix class
	instanceVariableNames: ''!

!classDefinition: #VEXPrefix category: #'Egg-Core-Assembler-Intel'!
InstructionPrefix subclass: #VEXPrefix
	instanceVariableNames: 'signature'
	classVariableNames: 'Signatures'
	poolDictionaries: 'CharacterConstants'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'VEXPrefix class' category: #'Egg-Core-Assembler-Intel'!
VEXPrefix class
	instanceVariableNames: 'Signatures'!

!classDefinition: #InstructionSpec category: #'Egg-Core-Assembler-Intel'!
Object subclass: #InstructionSpec
	instanceVariableNames: 'opcode primary extension instruction opEncoding properties implicitRead implicitWrite implicitUndef useful protected mode compat features atnt preferred description prefixes mnemonic operands'
	classVariableNames: 'Specs'
	poolDictionaries: 'CharacterConstants'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'InstructionSpec class' category: #'Egg-Core-Assembler-Intel'!
InstructionSpec class
	instanceVariableNames: 'Specs'!

!classDefinition: #OperandEncoding category: #'Egg-Core-Assembler-Intel'!
Object subclass: #OperandEncoding
	instanceVariableNames: 'name selectors descriptions immediate modrm'
	classVariableNames: 'Encodings'
	poolDictionaries: 'Registers'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'OperandEncoding class' category: #'Egg-Core-Assembler-Intel'!
OperandEncoding class
	instanceVariableNames: 'Encodings'!

!classDefinition: #ABI category: #'Egg-Core-Assembly'!
Object subclass: #ABI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly'!
!classDefinition: 'ABI class' category: #'Egg-Core-Assembly'!
ABI class
	instanceVariableNames: ''!

!classDefinition: #X64ABI category: #'Egg-Core-Assembler-Intel'!
ABI subclass: #X64ABI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'private'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'X64ABI class' category: #'Egg-Core-Assembler-Intel'!
X64ABI class
	instanceVariableNames: ''!

!classDefinition: #SysVX64ABI category: #'Egg-Core-Assembler-Intel'!
X64ABI subclass: #SysVX64ABI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'SysVX64ABI class' category: #'Egg-Core-Assembler-Intel'!
SysVX64ABI class
	instanceVariableNames: ''!

!classDefinition: #WinX64ABI category: #'Egg-Core-Assembler-Intel'!
X64ABI subclass: #WinX64ABI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'WinX64ABI class' category: #'Egg-Core-Assembler-Intel'!
WinX64ABI class
	instanceVariableNames: ''!

!classDefinition: #X86ABI category: #'Egg-Core-Assembler-Intel'!
ABI subclass: #X86ABI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'Registers'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'X86ABI class' category: #'Egg-Core-Assembler-Intel'!
X86ABI class
	instanceVariableNames: ''!

!classDefinition: #RV64GABI category: #'Egg-Core-Assembly-RISCV'!
ABI subclass: #RV64GABI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'RegistersRISCV'
	category: 'Egg-Core-Assembly-RISCV'!
!classDefinition: 'RV64GABI class' category: #'Egg-Core-Assembly-RISCV'!
RV64GABI class
	instanceVariableNames: ''!

!classDefinition: #Assembler category: #'Egg-Core-Assembly'!
Object subclass: #Assembler
	instanceVariableNames: 'codegen labels literals'
	classVariableNames: 'IndexedLabels'
	poolDictionaries: ''
	category: 'Egg-Core-Assembly'!
!classDefinition: 'Assembler class' category: #'Egg-Core-Assembly'!
Assembler class
	instanceVariableNames: 'IndexedLabels'!

!classDefinition: #AMD64TemplateAssembler category: #'Egg-Core-Assembler-Intel'!
Assembler subclass: #AMD64TemplateAssembler
	instanceVariableNames: 'wordSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'AMD64TemplateAssembler class' category: #'Egg-Core-Assembler-Intel'!
AMD64TemplateAssembler class
	instanceVariableNames: ''!

!classDefinition: #CodeGenerator category: #'Egg-Core-Assembly'!
Object subclass: #CodeGenerator
	instanceVariableNames: 'abi wordSize memory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly'!
!classDefinition: 'CodeGenerator class' category: #'Egg-Core-Assembly'!
CodeGenerator class
	instanceVariableNames: ''!

!classDefinition: #AMD64CodeGenerator category: #'Egg-Core-Assembler-Intel'!
CodeGenerator subclass: #AMD64CodeGenerator
	instanceVariableNames: 'instruction operands1 operands2 operands3 pointer immediate encoder'
	classVariableNames: ''
	poolDictionaries: 'private'
	category: 'Egg-Core-Assembler-Intel'!
!classDefinition: 'AMD64CodeGenerator class' category: #'Egg-Core-Assembler-Intel'!
AMD64CodeGenerator class
	instanceVariableNames: ''!

!classDefinition: #RISCCodeGenerator category: #'Egg-Core-Assembly'!
CodeGenerator subclass: #RISCCodeGenerator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'RegistersRISCV'
	category: 'Egg-Core-Assembly'!
!classDefinition: 'RISCCodeGenerator class' category: #'Egg-Core-Assembly'!
RISCCodeGenerator class
	instanceVariableNames: ''!

!classDefinition: #RV64CodeGenerator category: #'Egg-Core-Assembly-RISCV'!
RISCCodeGenerator subclass: #RV64CodeGenerator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'RegistersRISCV'
	category: 'Egg-Core-Assembly-RISCV'!
!classDefinition: 'RV64CodeGenerator class' category: #'Egg-Core-Assembly-RISCV'!
RV64CodeGenerator class
	instanceVariableNames: ''!

!classDefinition: #RV64GCodeGenerator category: #'Egg-Core-Assembly-RISCV'!
RISCCodeGenerator subclass: #RV64GCodeGenerator
	instanceVariableNames: 'zeroReg flagsReg tmp0Reg tmp1Reg linkReg'
	classVariableNames: ''
	poolDictionaries: 'RegistersRISCV'
	category: 'Egg-Core-Assembly-RISCV'!
!classDefinition: 'RV64GCodeGenerator class' category: #'Egg-Core-Assembly-RISCV'!
RV64GCodeGenerator class
	instanceVariableNames: ''!

!classDefinition: #NativeCodeReference category: #'Egg-Core-Assembly'!
Object subclass: #NativeCodeReference
	instanceVariableNames: 'source sourceOffset target absolute'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly'!
!classDefinition: 'NativeCodeReference class' category: #'Egg-Core-Assembly'!
NativeCodeReference class
	instanceVariableNames: ''!

!classDefinition: #RelocatableBuffer category: #'Egg-Core-Assembly'!
Object subclass: #RelocatableBuffer
	instanceVariableNames: 'stream address fixups'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly'!
!classDefinition: 'RelocatableBuffer class' category: #'Egg-Core-Assembly'!
RelocatableBuffer class
	instanceVariableNames: ''!

!classDefinition: #RelocationFixup category: #'Egg-Core-Assembly'!
Object subclass: #RelocationFixup
	instanceVariableNames: 'source target relative size'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly'!
!classDefinition: 'RelocationFixup class' category: #'Egg-Core-Assembly'!
RelocationFixup class
	instanceVariableNames: ''!

!classDefinition: #Assembly category: #'Egg-Core-Assembly-Intel-Parser'!
Object subclass: #Assembly
	instanceVariableNames: 'labels instructions source parser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Parser'!
!classDefinition: 'Assembly class' category: #'Egg-Core-Assembly-Intel-Parser'!
Assembly class
	instanceVariableNames: ''!

!classDefinition: #ISAInstructionPartReader category: #'Egg-Core-Assembly-Intel-Tools'!
Object subclass: #ISAInstructionPartReader
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'ISAInstructionPartReader class' category: #'Egg-Core-Assembly-Intel-Tools'!
ISAInstructionPartReader class
	instanceVariableNames: ''!

!classDefinition: #ISAModRMReader category: #'Egg-Core-Assembly-Intel-Tools'!
ISAInstructionPartReader subclass: #ISAModRMReader
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'ISAModRMReader class' category: #'Egg-Core-Assembly-Intel-Tools'!
ISAModRMReader class
	instanceVariableNames: ''!

!classDefinition: #ISAOpcodeReader category: #'Egg-Core-Assembly-Intel-Tools'!
ISAInstructionPartReader subclass: #ISAOpcodeReader
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'ISAOpcodeReader class' category: #'Egg-Core-Assembly-Intel-Tools'!
ISAOpcodeReader class
	instanceVariableNames: ''!

!classDefinition: #ISAPrefixReader category: #'Egg-Core-Assembly-Intel-Tools'!
ISAInstructionPartReader subclass: #ISAPrefixReader
	instanceVariableNames: 'legacy rex vex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'ISAPrefixReader class' category: #'Egg-Core-Assembly-Intel-Tools'!
ISAPrefixReader class
	instanceVariableNames: ''!

!classDefinition: #ISASibReader category: #'Egg-Core-Assembly-Intel-Tools'!
ISAInstructionPartReader subclass: #ISASibReader
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'ISASibReader class' category: #'Egg-Core-Assembly-Intel-Tools'!
ISASibReader class
	instanceVariableNames: ''!

!classDefinition: #ISAInstructionReader category: #'Egg-Core-Assembly-Intel-Tools'!
Object subclass: #ISAInstructionReader
	instanceVariableNames: 'prefixes opcode modrm sib displacement immediate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'ISAInstructionReader class' category: #'Egg-Core-Assembly-Intel-Tools'!
ISAInstructionReader class
	instanceVariableNames: ''!

!classDefinition: #OctalStructure category: #'Egg-Core-Assembly-Intel-Tools'!
Object subclass: #OctalStructure
	instanceVariableNames: 'byte'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'OctalStructure class' category: #'Egg-Core-Assembly-Intel-Tools'!
OctalStructure class
	instanceVariableNames: ''!

!classDefinition: #ModRM category: #'Egg-Core-Assembly-Intel-Tools'!
OctalStructure subclass: #ModRM
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'ModRM class' category: #'Egg-Core-Assembly-Intel-Tools'!
ModRM class
	instanceVariableNames: ''!

!classDefinition: #SIB category: #'Egg-Core-Assembly-Intel-Tools'!
OctalStructure subclass: #SIB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Assembly-Intel-Tools'!
!classDefinition: 'SIB class' category: #'Egg-Core-Assembly-Intel-Tools'!
SIB class
	instanceVariableNames: ''!

!classDefinition: #RVMemoryReference category: #'Egg-Core-Assembly-RISCV'!
Object subclass: #RVMemoryReference
	instanceVariableNames: 'widthInBits baseRegister indexRegister offset'
	classVariableNames: ''
	poolDictionaries: 'Registers'
	category: 'Egg-Core-Assembly-RISCV'!
!classDefinition: 'RVMemoryReference class' category: #'Egg-Core-Assembly-RISCV'!
RVMemoryReference class
	instanceVariableNames: ''!

!classDefinition: #LookupNativizer category: #'Egg-Core-Building'!
Object subclass: #LookupNativizer
	instanceVariableNames: 'bootstrapper methods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Building'!
!classDefinition: 'LookupNativizer class' category: #'Egg-Core-Building'!
LookupNativizer class
	instanceVariableNames: ''!

!classDefinition: #ObjectMap category: #'Egg-Core-Building'!
Object subclass: #ObjectMap
	instanceVariableNames: 'behavior spec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Building'!
!classDefinition: 'ObjectMap class' category: #'Egg-Core-Building'!
ObjectMap class
	instanceVariableNames: ''!

!classDefinition: #BootstrapDictionaryMap category: #'Egg-Core-Execution-Ring'!
ObjectMap subclass: #BootstrapDictionaryMap
	instanceVariableNames: 'image assocs realSpec constant'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'BootstrapDictionaryMap class' category: #'Egg-Core-Execution-Ring'!
BootstrapDictionaryMap class
	instanceVariableNames: ''!

!classDefinition: #ByteObjectMap category: #'Egg-Core-Execution-Ring'!
ObjectMap subclass: #ByteObjectMap
	instanceVariableNames: 'bytes hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'ByteObjectMap class' category: #'Egg-Core-Execution-Ring'!
ByteObjectMap class
	instanceVariableNames: ''!

!classDefinition: #SymbolMap category: #'Egg-Core-Execution-Ring'!
ByteObjectMap subclass: #SymbolMap
	instanceVariableNames: 'symbol'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'SymbolMap class' category: #'Egg-Core-Execution-Ring'!
SymbolMap class
	instanceVariableNames: ''!

!classDefinition: #SlotObjectMap category: #'Egg-Core-Execution-Ring'!
ObjectMap subclass: #SlotObjectMap
	instanceVariableNames: 'slots hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'SlotObjectMap class' category: #'Egg-Core-Execution-Ring'!
SlotObjectMap class
	instanceVariableNames: ''!

!classDefinition: #ClosureMap category: #'Egg-Core-Execution-Ring'!
SlotObjectMap subclass: #ClosureMap
	instanceVariableNames: 'block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'ClosureMap class' category: #'Egg-Core-Execution-Ring'!
ClosureMap class
	instanceVariableNames: ''!

!classDefinition: #SpeciesMap category: #'Egg-Core-Execution-Ring'!
SlotObjectMap subclass: #SpeciesMap
	instanceVariableNames: 'instanceSpec slotNames'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'SpeciesMap class' category: #'Egg-Core-Execution-Ring'!
SpeciesMap class
	instanceVariableNames: ''!

!classDefinition: #ClassMap category: #'Egg-Core-Execution-Ring'!
SpeciesMap subclass: #ClassMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'ClassMap class' category: #'Egg-Core-Execution-Ring'!
ClassMap class
	instanceVariableNames: ''!

!classDefinition: #MetaclassMap category: #'Egg-Core-Execution-Ring'!
SpeciesMap subclass: #MetaclassMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'MetaclassMap class' category: #'Egg-Core-Execution-Ring'!
MetaclassMap class
	instanceVariableNames: ''!

!classDefinition: #SmallintObjectMap category: #'Egg-Core-Execution-Ring'!
ObjectMap subclass: #SmallintObjectMap
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'SmallintObjectMap class' category: #'Egg-Core-Execution-Ring'!
SmallintObjectMap class
	instanceVariableNames: ''!

!classDefinition: #SmalltalkBootstrapper category: #'Egg-Core-Building'!
Object subclass: #SmalltalkBootstrapper
	instanceVariableNames: 'builder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Building'!
!classDefinition: 'SmalltalkBootstrapper class' category: #'Egg-Core-Building'!
SmalltalkBootstrapper class
	instanceVariableNames: ''!

!classDefinition: #DMRBootstrapper category: #'Egg-Core-Building'!
SmalltalkBootstrapper subclass: #DMRBootstrapper
	instanceVariableNames: 'nativizer image'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Building'!
!classDefinition: 'DMRBootstrapper class' category: #'Egg-Core-Building'!
DMRBootstrapper class
	instanceVariableNames: ''!

!classDefinition: #EvaluationContext category: #'Egg-Core-Execution'!
Object subclass: #EvaluationContext
	instanceVariableNames: 'system'
	classVariableNames: ''
	poolDictionaries: 'ClosureElementTypes'
	category: 'Egg-Core-Execution'!
!classDefinition: 'EvaluationContext class' category: #'Egg-Core-Execution'!
EvaluationContext class
	instanceVariableNames: ''!

!classDefinition: #LinkedEvaluationContext category: #'Egg-Core-Execution'!
EvaluationContext subclass: #LinkedEvaluationContext
	instanceVariableNames: 'parent method arguments temporaries environment isBlock _self'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'LinkedEvaluationContext class' category: #'Egg-Core-Execution'!
LinkedEvaluationContext class
	instanceVariableNames: ''!

!classDefinition: #IterativeLinkedEvaluationContext category: #'Egg-Core-Execution'!
LinkedEvaluationContext subclass: #IterativeLinkedEvaluationContext
	instanceVariableNames: 'operands work'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'IterativeLinkedEvaluationContext class' category: #'Egg-Core-Execution'!
IterativeLinkedEvaluationContext class
	instanceVariableNames: ''!

!classDefinition: #LinkedLinearEvaluationContext category: #'Egg-Core-Execution'!
IterativeLinkedEvaluationContext subclass: #LinkedLinearEvaluationContext
	instanceVariableNames: 'pc'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'LinkedLinearEvaluationContext class' category: #'Egg-Core-Execution'!
LinkedLinearEvaluationContext class
	instanceVariableNames: ''!

!classDefinition: #LinkedTreeEvaluationContext category: #'Egg-Core-Execution'!
IterativeLinkedEvaluationContext subclass: #LinkedTreeEvaluationContext
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'LinkedTreeEvaluationContext class' category: #'Egg-Core-Execution'!
LinkedTreeEvaluationContext class
	instanceVariableNames: ''!

!classDefinition: #RecursiveLinkedEvaluationContext category: #'Egg-Core-Execution'!
LinkedEvaluationContext subclass: #RecursiveLinkedEvaluationContext
	instanceVariableNames: 'nonLocalReturn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'RecursiveLinkedEvaluationContext class' category: #'Egg-Core-Execution'!
RecursiveLinkedEvaluationContext class
	instanceVariableNames: ''!

!classDefinition: #StackedEvaluationContext category: #'Egg-Core-Execution'!
EvaluationContext subclass: #StackedEvaluationContext
	instanceVariableNames: 'stack regSP regBP regM regS regE pc'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'StackedEvaluationContext class' category: #'Egg-Core-Execution'!
StackedEvaluationContext class
	instanceVariableNames: ''!

!classDefinition: #PowertalkEvaluator category: #'Egg-Core-Execution'!
Object subclass: #PowertalkEvaluator
	instanceVariableNames: 'runtime falseObj trueObj nilObj context undermessages primitives messageCount'
	classVariableNames: ''
	poolDictionaries: 'ClosureElementTypes'
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkEvaluator class' category: #'Egg-Core-Execution'!
PowertalkEvaluator class
	instanceVariableNames: ''!

!classDefinition: #PowertalkIterativeInterpreter category: #'Egg-Core-Execution'!
PowertalkEvaluator subclass: #PowertalkIterativeInterpreter
	instanceVariableNames: 'regR'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkIterativeInterpreter class' category: #'Egg-Core-Execution'!
PowertalkIterativeInterpreter class
	instanceVariableNames: ''!

!classDefinition: #PowertalkIterativeLinkedInterpreter category: #'Egg-Core-Execution'!
PowertalkIterativeInterpreter subclass: #PowertalkIterativeLinkedInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkIterativeLinkedInterpreter class' category: #'Egg-Core-Execution'!
PowertalkIterativeLinkedInterpreter class
	instanceVariableNames: ''!

!classDefinition: #PowertalkLinkedLinearInterpreter category: #'Egg-Core-Execution'!
PowertalkIterativeLinkedInterpreter subclass: #PowertalkLinkedLinearInterpreter
	instanceVariableNames: 'linearizer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkLinkedLinearInterpreter class' category: #'Egg-Core-Execution'!
PowertalkLinkedLinearInterpreter class
	instanceVariableNames: ''!

!classDefinition: #PowertalkLinkedTreeInterpreter category: #'Egg-Core-Execution'!
PowertalkIterativeLinkedInterpreter subclass: #PowertalkLinkedTreeInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkLinkedTreeInterpreter class' category: #'Egg-Core-Execution'!
PowertalkLinkedTreeInterpreter class
	instanceVariableNames: ''!

!classDefinition: #PowertalkIterativeStackedInterpreter category: #'Egg-Core-Execution'!
PowertalkIterativeInterpreter subclass: #PowertalkIterativeStackedInterpreter
	instanceVariableNames: 'linearizer work'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkIterativeStackedInterpreter class' category: #'Egg-Core-Execution'!
PowertalkIterativeStackedInterpreter class
	instanceVariableNames: ''!

!classDefinition: #PowertalkRecursiveInterpreter category: #'Egg-Core-Execution'!
PowertalkEvaluator subclass: #PowertalkRecursiveInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkRecursiveInterpreter class' category: #'Egg-Core-Execution'!
PowertalkRecursiveInterpreter class
	instanceVariableNames: ''!

!classDefinition: #PowertalkRuntime category: #'Egg-Core-Execution'!
Object subclass: #PowertalkRuntime
	instanceVariableNames: 'methodCache falseObj trueObj nilObj interpreter overrides symbolCache'
	classVariableNames: ''
	poolDictionaries: 'ClosureElementTypes'
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkRuntime class' category: #'Egg-Core-Execution'!
PowertalkRuntime class
	instanceVariableNames: ''!

!classDefinition: #PowertalkLMR category: #'Egg-Core-Execution-LMR'!
PowertalkRuntime subclass: #PowertalkLMR
	instanceVariableNames: 'kernel wordSize bootstrapper behaviorNextIndex behaviorMethodDictionaryIndex behaviorClassIndex classNameIndex methodFlagsIndex symbolTable maxSMI minSMI knownSymbols arrayClass metaclassClass speciesInstanceBehaviorIndex speciesFormatIndex methodAstcodesIndex methodInstSize methodClassBindingIndex speciesSuperclassIndex methodClass smallIntegerClass blockClass speciesIvarsIndex dictionaryTableIndex metaclassInstanceClassIndex classModuleIndex moduleNamespaceIndex byteArrayClass stringClass closureBlockIndex closureClass lastHash blockMethodIndex behaviorClass classNamespacesIndex largePositiveIntegerClass largeNegativeIntegerClass methodSelectorIndex compiledCodeExecutableCodeIndex'
	classVariableNames: ''
	poolDictionaries: 'SCompiledBlockFlags SCompiledMethodFlags'
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'PowertalkLMR class' category: #'Egg-Core-Execution-LMR'!
PowertalkLMR class
	instanceVariableNames: ''!

!classDefinition: #PowertalkRingRuntime category: #'Egg-Core-Execution-Ring'!
PowertalkRuntime subclass: #PowertalkRingRuntime
	instanceVariableNames: 'image sexpressionsCache'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'PowertalkRingRuntime class' category: #'Egg-Core-Execution-Ring'!
PowertalkRingRuntime class
	instanceVariableNames: ''!

!classDefinition: #SExpressionLinearizer category: #'Egg-Core-Execution'!
Object subclass: #SExpressionLinearizer
	instanceVariableNames: 'operations primitives inBlock runtime greaterThan one plus stackTop dropsArguments not equalsEquals ifTrue ifFalse ifTrueIfFalse ifFalseIfTrue ifNil ifNotNil ifNilIfNotNil ifNotNilIfNil whileTrue whileFalse whileTrue_ whileFalse_ toDo toByDo repeat timesRepeat andNot orNot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'SExpressionLinearizer class' category: #'Egg-Core-Execution'!
SExpressionLinearizer class
	instanceVariableNames: ''!

!classDefinition: #LMRObject category: #'Egg-Core-Execution-LMR'!
Object subclass: #LMRObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRObject class' category: #'Egg-Core-Execution-LMR'!
LMRObject class
	instanceVariableNames: ''!

!classDefinition: #LMRHeapObject category: #'Egg-Core-Execution-LMR'!
LMRObject subclass: #LMRHeapObject
	instanceVariableNames: 'header'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRHeapObject class' category: #'Egg-Core-Execution-LMR'!
LMRHeapObject class
	instanceVariableNames: ''!

!classDefinition: #LMRByteObject category: #'Egg-Core-Execution-LMR'!
LMRHeapObject subclass: #LMRByteObject
	instanceVariableNames: 'bytes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRByteObject class' category: #'Egg-Core-Execution-LMR'!
LMRByteObject class
	instanceVariableNames: ''!

!classDefinition: #LMRExecutableCode category: #'Egg-Core-Execution-LMR'!
LMRHeapObject subclass: #LMRExecutableCode
	instanceVariableNames: 'code'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRExecutableCode class' category: #'Egg-Core-Execution-LMR'!
LMRExecutableCode class
	instanceVariableNames: ''!

!classDefinition: #LMRSlotObject category: #'Egg-Core-Execution-LMR'!
LMRHeapObject subclass: #LMRSlotObject
	instanceVariableNames: 'slots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRSlotObject class' category: #'Egg-Core-Execution-LMR'!
LMRSlotObject class
	instanceVariableNames: ''!

!classDefinition: #LMRBehaviorObject category: #'Egg-Core-Execution-LMR'!
LMRSlotObject subclass: #LMRBehaviorObject
	instanceVariableNames: 'runtime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRBehaviorObject class' category: #'Egg-Core-Execution-LMR'!
LMRBehaviorObject class
	instanceVariableNames: ''!

!classDefinition: #LMRSmallInteger category: #'Egg-Core-Execution-LMR'!
LMRObject subclass: #LMRSmallInteger
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRSmallInteger class' category: #'Egg-Core-Execution-LMR'!
LMRSmallInteger class
	instanceVariableNames: ''!

!classDefinition: #LMRObjectHeader category: #'Egg-Core-Execution-LMR'!
Object subclass: #LMRObjectHeader
	instanceVariableNames: 'behavior flags size hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'LMRObjectHeader class' category: #'Egg-Core-Execution-LMR'!
LMRObjectHeader class
	instanceVariableNames: ''!

!classDefinition: #RingBasedLMRBootstrapper category: #'Egg-Core-Execution-LMR'!
Object subclass: #RingBasedLMRBootstrapper
	instanceVariableNames: 'source dest nilObj trueObj falseObj behaviors mapping stack closureMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-LMR'!
!classDefinition: 'RingBasedLMRBootstrapper class' category: #'Egg-Core-Execution-LMR'!
RingBasedLMRBootstrapper class
	instanceVariableNames: ''!

!classDefinition: #PowertalkRingModule category: #'Egg-Core-Execution-Ring'!
Object subclass: #PowertalkRingModule
	instanceVariableNames: 'nilObj falseObj trueObj classes metaclasses runtime symbols identityMap specs vmPrimitivesSpec module kernel'
	classVariableNames: 'KernelSpec VMPrimitivesSpec'
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'PowertalkRingModule class' category: #'Egg-Core-Execution-Ring'!
PowertalkRingModule class
	instanceVariableNames: 'KernelSpec VMPrimitivesSpec'!

!classDefinition: #PowertalkRingImage category: #'Egg-Core-Execution-Ring'!
PowertalkRingModule subclass: #PowertalkRingImage
	instanceVariableNames: 'bootstrapDicts arraySpec closureSpec smiSpec symbolSpec wordSize minSMI maxSMI'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution-Ring'!
!classDefinition: 'PowertalkRingImage class' category: #'Egg-Core-Execution-Ring'!
PowertalkRingImage class
	instanceVariableNames: ''!

!classDefinition: #Bridge category: #'Egg-Core-Metaphysics'!
Object subclass: #Bridge
	instanceVariableNames: 'cache objects runtime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'Bridge class' category: #'Egg-Core-Metaphysics'!
Bridge class
	instanceVariableNames: ''!

!classDefinition: #SmalltalkBridge category: #'Egg-Core-Metaphysics'!
Bridge subclass: #SmalltalkBridge
	instanceVariableNames: 'nilObj trueObj falseObj'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'SmalltalkBridge class' category: #'Egg-Core-Metaphysics'!
SmalltalkBridge class
	instanceVariableNames: ''!

!classDefinition: #BootstrappedPstBridge category: #'Egg-Core-Metaphysics'!
SmalltalkBridge subclass: #BootstrappedPstBridge
	instanceVariableNames: 'bootstrapper'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'BootstrappedPstBridge class' category: #'Egg-Core-Metaphysics'!
BootstrappedPstBridge class
	instanceVariableNames: ''!

!classDefinition: #PharoBridge category: #'Egg-Core-Metaphysics'!
SmalltalkBridge subclass: #PharoBridge
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'PharoBridge class' category: #'Egg-Core-Metaphysics'!
PharoBridge class
	instanceVariableNames: ''!

!classDefinition: #PstBridge category: #'Egg-Core-Metaphysics'!
SmalltalkBridge subclass: #PstBridge
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'PstBridge class' category: #'Egg-Core-Metaphysics'!
PstBridge class
	instanceVariableNames: ''!

!classDefinition: #Gate category: #'Egg-Core-Metaphysics'!
Object subclass: #Gate
	instanceVariableNames: 'handle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'Gate class' category: #'Egg-Core-Metaphysics'!
Gate class
	instanceVariableNames: ''!

!classDefinition: #DirectGate category: #'Egg-Core-Metaphysics'!
Gate subclass: #DirectGate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'DirectGate class' category: #'Egg-Core-Metaphysics'!
DirectGate class
	instanceVariableNames: ''!

!classDefinition: #MirageGate category: #'Egg-Core-Metaphysics'!
Gate subclass: #MirageGate
	instanceVariableNames: 'class'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'MirageGate class' category: #'Egg-Core-Metaphysics'!
MirageGate class
	instanceVariableNames: ''!

!classDefinition: #Handle category: #'Egg-Core-Metaphysics'!
Object subclass: #Handle
	instanceVariableNames: 'runtime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'Handle class' category: #'Egg-Core-Metaphysics'!
Handle class
	instanceVariableNames: ''!

!classDefinition: #ObjectHandle category: #'Egg-Core-Metaphysics'!
Handle subclass: #ObjectHandle
	instanceVariableNames: 'oid'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'ObjectHandle class' category: #'Egg-Core-Metaphysics'!
ObjectHandle class
	instanceVariableNames: ''!

!classDefinition: #LocalHandle category: #'Egg-Core-Metaphysics'!
ObjectHandle subclass: #LocalHandle
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'LocalHandle class' category: #'Egg-Core-Metaphysics'!
LocalHandle class
	instanceVariableNames: ''!

!classDefinition: #PstFrameHandle category: #'Egg-Core-Metaphysics'!
Handle subclass: #PstFrameHandle
	instanceVariableNames: 'frame'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'PstFrameHandle class' category: #'Egg-Core-Metaphysics'!
PstFrameHandle class
	instanceVariableNames: ''!

!classDefinition: #MethodLookup category: #'Egg-Core-Metaphysics'!
Object subclass: #MethodLookup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'MethodLookup class' category: #'Egg-Core-Metaphysics'!
MethodLookup class
	instanceVariableNames: ''!

!classDefinition: #EmulationLookup category: #'Egg-Core-Metaphysics'!
MethodLookup subclass: #EmulationLookup
	instanceVariableNames: 'spec globals cache'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'EmulationLookup class' category: #'Egg-Core-Metaphysics'!
EmulationLookup class
	instanceVariableNames: ''!

!classDefinition: #MirrorLookup category: #'Egg-Core-Metaphysics'!
MethodLookup subclass: #MirrorLookup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'MirrorLookup class' category: #'Egg-Core-Metaphysics'!
MirrorLookup class
	instanceVariableNames: ''!

!classDefinition: #PharoLookup category: #'Egg-Core-Metaphysics'!
MethodLookup subclass: #PharoLookup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'PharoLookup class' category: #'Egg-Core-Metaphysics'!
PharoLookup class
	instanceVariableNames: ''!

!classDefinition: #ObjectFormat category: #'Egg-Core-Metaphysics'!
Object subclass: #ObjectFormat
	instanceVariableNames: 'runtime storage'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'ObjectFormat class' category: #'Egg-Core-Metaphysics'!
ObjectFormat class
	instanceVariableNames: ''!

!classDefinition: #BootstrapObjectFormat category: #'Egg-Core-Metaphysics'!
ObjectFormat subclass: #BootstrapObjectFormat
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'BootstrapObjectFormat class' category: #'Egg-Core-Metaphysics'!
BootstrapObjectFormat class
	instanceVariableNames: ''!

!classDefinition: #DmrObjectFormat category: #'Egg-Core-Metaphysics'!
ObjectFormat subclass: #DmrObjectFormat
	instanceVariableNames: 'wordSize'
	classVariableNames: ''
	poolDictionaries: 'ObjectHeaderMasks ObjectHeaderOffsets'
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'DmrObjectFormat class' category: #'Egg-Core-Metaphysics'!
DmrObjectFormat class
	instanceVariableNames: ''!

!classDefinition: #PharoObjectFormat category: #'Egg-Core-Metaphysics'!
ObjectFormat subclass: #PharoObjectFormat
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'PharoObjectFormat class' category: #'Egg-Core-Metaphysics'!
PharoObjectFormat class
	instanceVariableNames: ''!

!classDefinition: #ObjectShape category: #'Egg-Core-Metaphysics'!
Object subclass: #ObjectShape
	instanceVariableNames: 'name fields'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'ObjectShape class' category: #'Egg-Core-Metaphysics'!
ObjectShape class
	instanceVariableNames: ''!

!classDefinition: #Runtime category: #'Egg-Core-Metaphysics'!
Object subclass: #Runtime
	instanceVariableNames: 'lookup storage objectFormat bridge sources shapeMap objectModel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'Runtime class' category: #'Egg-Core-Metaphysics'!
Runtime class
	instanceVariableNames: ''!

!classDefinition: #SExpressionInterpreter category: #'Egg-Core-Metaphysics'!
Object subclass: #SExpressionInterpreter
	instanceVariableNames: 'receiver arguments temporaries returned returnValue method parent gateBuilder blockAstcodes environment'
	classVariableNames: ''
	poolDictionaries: 'ClosureElementTypes'
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'SExpressionInterpreter class' category: #'Egg-Core-Metaphysics'!
SExpressionInterpreter class
	instanceVariableNames: ''!

!classDefinition: #SmalltalkInterpreter category: #'Egg-Core-Metaphysics'!
SExpressionInterpreter subclass: #SmalltalkInterpreter
	instanceVariableNames: 'localRuntime'
	classVariableNames: 'underprimitives'
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'SmalltalkInterpreter class' category: #'Egg-Core-Metaphysics'!
SmalltalkInterpreter class
	instanceVariableNames: 'underprimitives'!

!classDefinition: #ShapeMap category: #'Egg-Core-Metaphysics'!
Object subclass: #ShapeMap
	instanceVariableNames: 'shapes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'ShapeMap class' category: #'Egg-Core-Metaphysics'!
ShapeMap class
	instanceVariableNames: ''!

!classDefinition: #Storage category: #'Egg-Core-Metaphysics'!
Object subclass: #Storage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'Storage class' category: #'Egg-Core-Metaphysics'!
Storage class
	instanceVariableNames: ''!

!classDefinition: #BootstrapStorage category: #'Egg-Core-Metaphysics'!
Storage subclass: #BootstrapStorage
	instanceVariableNames: 'bootstrapper'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'BootstrapStorage class' category: #'Egg-Core-Metaphysics'!
BootstrapStorage class
	instanceVariableNames: ''!

!classDefinition: #ByteArrayAdapter category: #'Egg-Core-Metaphysics'!
Storage subclass: #ByteArrayAdapter
	instanceVariableNames: 'bytes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'ByteArrayAdapter class' category: #'Egg-Core-Metaphysics'!
ByteArrayAdapter class
	instanceVariableNames: ''!

!classDefinition: #StorageReadError category: #'Egg-Core-Metaphysics'!
Object subclass: #StorageReadError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Metaphysics'!
!classDefinition: 'StorageReadError class' category: #'Egg-Core-Metaphysics'!
StorageReadError class
	instanceVariableNames: ''!

!classDefinition: #Mirror category: #'Egg-Core-Mirrors'!
Object subclass: #Mirror
	instanceVariableNames: 'handle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'Mirror class' category: #'Egg-Core-Mirrors'!
Mirror class
	instanceVariableNames: ''!

!classDefinition: #ObjectMirror category: #'Egg-Core-Mirrors'!
Mirror subclass: #ObjectMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'ObjectMirror class' category: #'Egg-Core-Mirrors'!
ObjectMirror class
	instanceVariableNames: ''!

!classDefinition: #AssociationMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #AssociationMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'AssociationMirror class' category: #'Egg-Core-Mirrors'!
AssociationMirror class
	instanceVariableNames: ''!

!classDefinition: #BehaviorMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #BehaviorMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'BehaviorMirror class' category: #'Egg-Core-Mirrors'!
BehaviorMirror class
	instanceVariableNames: ''!

!classDefinition: #ClosureMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #ClosureMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'ClosureMirror class' category: #'Egg-Core-Mirrors'!
ClosureMirror class
	instanceVariableNames: ''!

!classDefinition: #CompiledBlockMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #CompiledBlockMirror
	instanceVariableNames: ''
	classVariableNames: 'Flags'
	poolDictionaries: 'CompiledBlockFormatMasks'
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'CompiledBlockMirror class' category: #'Egg-Core-Mirrors'!
CompiledBlockMirror class
	instanceVariableNames: 'Flags'!

!classDefinition: #CompiledMethodMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #CompiledMethodMirror
	instanceVariableNames: ''
	classVariableNames: 'Flags'
	poolDictionaries: 'CompiledMethodFormatMasks'
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'CompiledMethodMirror class' category: #'Egg-Core-Mirrors'!
CompiledMethodMirror class
	instanceVariableNames: 'Flags'!

!classDefinition: #DictionaryMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #DictionaryMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'DictionaryMirror class' category: #'Egg-Core-Mirrors'!
DictionaryMirror class
	instanceVariableNames: ''!

!classDefinition: #MethodDictionaryMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #MethodDictionaryMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'MethodDictionaryMirror class' category: #'Egg-Core-Mirrors'!
MethodDictionaryMirror class
	instanceVariableNames: ''!

!classDefinition: #SpeciesMirror category: #'Egg-Core-Mirrors'!
ObjectMirror subclass: #SpeciesMirror
	instanceVariableNames: ''
	classVariableNames: 'Flags'
	poolDictionaries: 'SpeciesFormatMasks'
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'SpeciesMirror class' category: #'Egg-Core-Mirrors'!
SpeciesMirror class
	instanceVariableNames: 'Flags'!

!classDefinition: #ClassMirror category: #'Egg-Core-Mirrors'!
SpeciesMirror subclass: #ClassMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'ClassMirror class' category: #'Egg-Core-Mirrors'!
ClassMirror class
	instanceVariableNames: ''!

!classDefinition: #MetaclassMirror category: #'Egg-Core-Mirrors'!
SpeciesMirror subclass: #MetaclassMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'MetaclassMirror class' category: #'Egg-Core-Mirrors'!
MetaclassMirror class
	instanceVariableNames: ''!

!classDefinition: #StackFrameMirror category: #'Egg-Core-Mirrors'!
Mirror subclass: #StackFrameMirror
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'FrameOffsets'
	category: 'Egg-Core-Mirrors'!
!classDefinition: 'StackFrameMirror class' category: #'Egg-Core-Mirrors'!
StackFrameMirror class
	instanceVariableNames: ''!

!classDefinition: #BinaryMessageNativizer category: #'Egg-Core-Nativization'!
Object subclass: #BinaryMessageNativizer
	instanceVariableNames: 'message assembler nativizer done failed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'BinaryMessageNativizer class' category: #'Egg-Core-Nativization'!
BinaryMessageNativizer class
	instanceVariableNames: ''!

!classDefinition: #InlinedMessageNativizer category: #'Egg-Core-Nativization'!
Object subclass: #InlinedMessageNativizer
	instanceVariableNames: 'message assembler nativizer start end'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'InlinedMessageNativizer class' category: #'Egg-Core-Nativization'!
InlinedMessageNativizer class
	instanceVariableNames: ''!

!classDefinition: #MessageLinker category: #'Egg-Core-Nativization'!
Object subclass: #MessageLinker
	instanceVariableNames: 'filter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'MessageLinker class' category: #'Egg-Core-Nativization'!
MessageLinker class
	instanceVariableNames: ''!

!classDefinition: #CompositeMessageLinker category: #'Egg-Core-Nativization'!
MessageLinker subclass: #CompositeMessageLinker
	instanceVariableNames: 'candidates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'CompositeMessageLinker class' category: #'Egg-Core-Nativization'!
CompositeMessageLinker class
	instanceVariableNames: ''!

!classDefinition: #HaltingSend category: #'Egg-Core-Nativization'!
MessageLinker subclass: #HaltingSend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'HaltingSend class' category: #'Egg-Core-Nativization'!
HaltingSend class
	instanceVariableNames: ''!

!classDefinition: #InlineMessageLinker category: #'Egg-Core-Nativization'!
MessageLinker subclass: #InlineMessageLinker
	instanceVariableNames: 'assembler map'
	classVariableNames: ''
	poolDictionaries: 'InlineMessageLinkerFlags Registers'
	category: 'Egg-Core-Nativization'!
!classDefinition: 'InlineMessageLinker class' category: #'Egg-Core-Nativization'!
InlineMessageLinker class
	instanceVariableNames: ''!

!classDefinition: #InvokeLinker category: #'Egg-Core-Nativization'!
MessageLinker subclass: #InvokeLinker
	instanceVariableNames: 'invoker sends'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'InvokeLinker class' category: #'Egg-Core-Nativization'!
InvokeLinker class
	instanceVariableNames: ''!

!classDefinition: #LookupLinker category: #'Egg-Core-Nativization'!
MessageLinker subclass: #LookupLinker
	instanceVariableNames: 'lookup lookupSuper'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'LookupLinker class' category: #'Egg-Core-Nativization'!
LookupLinker class
	instanceVariableNames: ''!

!classDefinition: #LazyLinker category: #'Egg-Core-Nativization'!
LookupLinker subclass: #LazyLinker
	instanceVariableNames: 'sends'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'LazyLinker class' category: #'Egg-Core-Nativization'!
LazyLinker class
	instanceVariableNames: ''!

!classDefinition: #NativizationEnvironment category: #'Egg-Core-Nativization'!
Object subclass: #NativizationEnvironment
	instanceVariableNames: 'platform optimizedMethods invokedMethods inlinedMethods messageLinker globals writeBarrier safepointCheck cachedNativizer busy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'NativizationEnvironment class' category: #'Egg-Core-Nativization'!
NativizationEnvironment class
	instanceVariableNames: ''!

!classDefinition: #NativizationPlatform category: #'Egg-Core-Nativization'!
Object subclass: #NativizationPlatform
	instanceVariableNames: 'name wordSize abi codeGeneratorClass'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'NativizationPlatform class' category: #'Egg-Core-Nativization'!
NativizationPlatform class
	instanceVariableNames: 'Default'!

!classDefinition: #SExpressionNativizer category: #'Egg-Core-Nativization'!
Object subclass: #SExpressionNativizer
	instanceVariableNames: 'environment method remainingBlocks safepointCheck mainCode stackCount fallbacks activeScript ir'
	classVariableNames: ''
	poolDictionaries: 'ClosureElementTypes'
	category: 'Egg-Core-Nativization'!
!classDefinition: 'SExpressionNativizer class' category: #'Egg-Core-Nativization'!
SExpressionNativizer class
	instanceVariableNames: ''!

!classDefinition: #SendSite category: #'Egg-Core-Nativization'!
Object subclass: #SendSite
	instanceVariableNames: 'instructions selector cache tally format'
	classVariableNames: ''
	poolDictionaries: 'SendSiteFlags'
	category: 'Egg-Core-Nativization'!
!classDefinition: 'SendSite class' category: #'Egg-Core-Nativization'!
SendSite class
	instanceVariableNames: ''!

!classDefinition: #StackFrameCursor category: #'Egg-Core-Nativization'!
Object subclass: #StackFrameCursor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Nativization'!
!classDefinition: 'StackFrameCursor class' category: #'Egg-Core-Nativization'!
StackFrameCursor class
	instanceVariableNames: ''!

!classDefinition: #AstcodeDecoder category: #'Egg-Core-SExpressions'!
Object subclass: #AstcodeDecoder
	instanceVariableNames: 'method stream builder'
	classVariableNames: 'BindingTypes NodeTypes'
	poolDictionaries: 'AstBindingTypes AstNodeTypes'
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'AstcodeDecoder class' category: #'Egg-Core-SExpressions'!
AstcodeDecoder class
	instanceVariableNames: 'BindingTypes NodeTypes'!

!classDefinition: #SBinding category: #'Egg-Core-SExpressions'!
Object subclass: #SBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SBinding class' category: #'Egg-Core-SExpressions'!
SBinding class
	instanceVariableNames: ''!

!classDefinition: #SAssociationBinding category: #'Egg-Core-SExpressions'!
SBinding subclass: #SAssociationBinding
	instanceVariableNames: 'index association'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SAssociationBinding class' category: #'Egg-Core-SExpressions'!
SAssociationBinding class
	instanceVariableNames: ''!

!classDefinition: #SDynamicBinding category: #'Egg-Core-SExpressions'!
SBinding subclass: #SDynamicBinding
	instanceVariableNames: 'name cache'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SDynamicBinding class' category: #'Egg-Core-SExpressions'!
SDynamicBinding class
	instanceVariableNames: ''!

!classDefinition: #SNestedDynamicBinding category: #'Egg-Core-SExpressions'!
SDynamicBinding subclass: #SNestedDynamicBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SNestedDynamicBinding class' category: #'Egg-Core-SExpressions'!
SNestedDynamicBinding class
	instanceVariableNames: ''!

!classDefinition: #SInstVarBinding category: #'Egg-Core-SExpressions'!
SBinding subclass: #SInstVarBinding
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SInstVarBinding class' category: #'Egg-Core-SExpressions'!
SInstVarBinding class
	instanceVariableNames: ''!

!classDefinition: #SLiteralBinding category: #'Egg-Core-SExpressions'!
SBinding subclass: #SLiteralBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SLiteralBinding class' category: #'Egg-Core-SExpressions'!
SLiteralBinding class
	instanceVariableNames: ''!

!classDefinition: #SFalseBinding category: #'Egg-Core-SExpressions'!
SLiteralBinding subclass: #SFalseBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SFalseBinding class' category: #'Egg-Core-SExpressions'!
SFalseBinding class
	instanceVariableNames: ''!

!classDefinition: #SNilBinding category: #'Egg-Core-SExpressions'!
SLiteralBinding subclass: #SNilBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SNilBinding class' category: #'Egg-Core-SExpressions'!
SNilBinding class
	instanceVariableNames: ''!

!classDefinition: #STrueBinding category: #'Egg-Core-SExpressions'!
SLiteralBinding subclass: #STrueBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'STrueBinding class' category: #'Egg-Core-SExpressions'!
STrueBinding class
	instanceVariableNames: ''!

!classDefinition: #SLocalBinding category: #'Egg-Core-SExpressions'!
SBinding subclass: #SLocalBinding
	instanceVariableNames: 'position environment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SLocalBinding class' category: #'Egg-Core-SExpressions'!
SLocalBinding class
	instanceVariableNames: ''!

!classDefinition: #SArgumentBinding category: #'Egg-Core-SExpressions'!
SLocalBinding subclass: #SArgumentBinding
	instanceVariableNames: 'inlined'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SArgumentBinding class' category: #'Egg-Core-SExpressions'!
SArgumentBinding class
	instanceVariableNames: ''!

!classDefinition: #STemporaryBinding category: #'Egg-Core-SExpressions'!
SLocalBinding subclass: #STemporaryBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'STemporaryBinding class' category: #'Egg-Core-SExpressions'!
STemporaryBinding class
	instanceVariableNames: ''!

!classDefinition: #SSelfBinding category: #'Egg-Core-SExpressions'!
SBinding subclass: #SSelfBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SSelfBinding class' category: #'Egg-Core-SExpressions'!
SSelfBinding class
	instanceVariableNames: ''!

!classDefinition: #SSuperBinding category: #'Egg-Core-SExpressions'!
SSelfBinding subclass: #SSuperBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SSuperBinding class' category: #'Egg-Core-SExpressions'!
SSuperBinding class
	instanceVariableNames: ''!

!classDefinition: #SExpression category: #'Egg-Core-SExpressions'!
Object subclass: #SExpression
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SExpression class' category: #'Egg-Core-SExpressions'!
SExpression class
	instanceVariableNames: ''!

!classDefinition: #SAssignment category: #'Egg-Core-SExpressions'!
SExpression subclass: #SAssignment
	instanceVariableNames: 'assignees expression'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SAssignment class' category: #'Egg-Core-SExpressions'!
SAssignment class
	instanceVariableNames: ''!

!classDefinition: #SCascade category: #'Egg-Core-SExpressions'!
SExpression subclass: #SCascade
	instanceVariableNames: 'receiver messages'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SCascade class' category: #'Egg-Core-SExpressions'!
SCascade class
	instanceVariableNames: ''!

!classDefinition: #SCascadeMessage category: #'Egg-Core-SExpressions'!
SExpression subclass: #SCascadeMessage
	instanceVariableNames: 'selector arguments cascade cache'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SCascadeMessage class' category: #'Egg-Core-SExpressions'!
SCascadeMessage class
	instanceVariableNames: ''!

!classDefinition: #SIdentifier category: #'Egg-Core-SExpressions'!
SExpression subclass: #SIdentifier
	instanceVariableNames: 'binding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SIdentifier class' category: #'Egg-Core-SExpressions'!
SIdentifier class
	instanceVariableNames: ''!

!classDefinition: #SLiteralVar category: #'Egg-Core-SExpressions'!
SExpression subclass: #SLiteralVar
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SLiteralVar class' category: #'Egg-Core-SExpressions'!
SLiteralVar class
	instanceVariableNames: ''!

!classDefinition: #SLiteral category: #'Egg-Core-SExpressions'!
SLiteralVar subclass: #SLiteral
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SLiteral class' category: #'Egg-Core-SExpressions'!
SLiteral class
	instanceVariableNames: ''!

!classDefinition: #SMessage category: #'Egg-Core-SExpressions'!
SExpression subclass: #SMessage
	instanceVariableNames: 'selector receiver arguments cache inlined'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SMessage class' category: #'Egg-Core-SExpressions'!
SMessage class
	instanceVariableNames: ''!

!classDefinition: #SOperation category: #'Egg-Core-SExpressions'!
SExpression subclass: #SOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOperation class' category: #'Egg-Core-SExpressions'!
SOperation class
	instanceVariableNames: ''!

!classDefinition: #SInlinerOperation category: #'Egg-Core-SExpressions'!
SOperation subclass: #SInlinerOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SInlinerOperation class' category: #'Egg-Core-SExpressions'!
SInlinerOperation class
	instanceVariableNames: ''!

!classDefinition: #SOpJump category: #'Egg-Core-SExpressions'!
SInlinerOperation subclass: #SOpJump
	instanceVariableNames: 'target'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpJump class' category: #'Egg-Core-SExpressions'!
SOpJump class
	instanceVariableNames: ''!

!classDefinition: #SOpJumpFalse category: #'Egg-Core-SExpressions'!
SOpJump subclass: #SOpJumpFalse
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpJumpFalse class' category: #'Egg-Core-SExpressions'!
SOpJumpFalse class
	instanceVariableNames: ''!

!classDefinition: #SOpJumpTrue category: #'Egg-Core-SExpressions'!
SOpJump subclass: #SOpJumpTrue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpJumpTrue class' category: #'Egg-Core-SExpressions'!
SOpJumpTrue class
	instanceVariableNames: ''!

!classDefinition: #SOpLoadRfromFrame category: #'Egg-Core-SExpressions'!
SInlinerOperation subclass: #SOpLoadRfromFrame
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpLoadRfromFrame class' category: #'Egg-Core-SExpressions'!
SOpLoadRfromFrame class
	instanceVariableNames: ''!

!classDefinition: #SOpPopR category: #'Egg-Core-SExpressions'!
SInlinerOperation subclass: #SOpPopR
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpPopR class' category: #'Egg-Core-SExpressions'!
SOpPopR class
	instanceVariableNames: ''!

!classDefinition: #SOpStoreRintoFrame category: #'Egg-Core-SExpressions'!
SInlinerOperation subclass: #SOpStoreRintoFrame
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpStoreRintoFrame class' category: #'Egg-Core-SExpressions'!
SOpStoreRintoFrame class
	instanceVariableNames: ''!

!classDefinition: #SOpAssign category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpAssign
	instanceVariableNames: 'assignees'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpAssign class' category: #'Egg-Core-SExpressions'!
SOpAssign class
	instanceVariableNames: ''!

!classDefinition: #SOpDispatchMessage category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpDispatchMessage
	instanceVariableNames: 'message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpDispatchMessage class' category: #'Egg-Core-SExpressions'!
SOpDispatchMessage class
	instanceVariableNames: ''!

!classDefinition: #SOpDropToS category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpDropToS
	instanceVariableNames: 'count'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpDropToS class' category: #'Egg-Core-SExpressions'!
SOpDropToS class
	instanceVariableNames: ''!

!classDefinition: #SOpLoadRfromStack category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpLoadRfromStack
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpLoadRfromStack class' category: #'Egg-Core-SExpressions'!
SOpLoadRfromStack class
	instanceVariableNames: ''!

!classDefinition: #SOpLoadRwithNil category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpLoadRwithNil
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpLoadRwithNil class' category: #'Egg-Core-SExpressions'!
SOpLoadRwithNil class
	instanceVariableNames: ''!

!classDefinition: #SOpLoadRwithSelf category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpLoadRwithSelf
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpLoadRwithSelf class' category: #'Egg-Core-SExpressions'!
SOpLoadRwithSelf class
	instanceVariableNames: ''!

!classDefinition: #SOpPrimitive category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpPrimitive
	instanceVariableNames: 'block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpPrimitive class' category: #'Egg-Core-SExpressions'!
SOpPrimitive class
	instanceVariableNames: ''!

!classDefinition: #SOpPushR category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpPushR
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpPushR class' category: #'Egg-Core-SExpressions'!
SOpPushR class
	instanceVariableNames: ''!

!classDefinition: #SOpRestart category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpRestart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpRestart class' category: #'Egg-Core-SExpressions'!
SOpRestart class
	instanceVariableNames: ''!

!classDefinition: #SOpReturn category: #'Egg-Core-SExpressions'!
SOperation subclass: #SOpReturn
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpReturn class' category: #'Egg-Core-SExpressions'!
SOpReturn class
	instanceVariableNames: ''!

!classDefinition: #SOpNonLocalReturn category: #'Egg-Core-SExpressions'!
SOpReturn subclass: #SOpNonLocalReturn
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SOpNonLocalReturn class' category: #'Egg-Core-SExpressions'!
SOpNonLocalReturn class
	instanceVariableNames: ''!

!classDefinition: #SPragma category: #'Egg-Core-SExpressions'!
SExpression subclass: #SPragma
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SPragma class' category: #'Egg-Core-SExpressions'!
SPragma class
	instanceVariableNames: ''!

!classDefinition: #SReturn category: #'Egg-Core-SExpressions'!
SExpression subclass: #SReturn
	instanceVariableNames: 'local expression'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SReturn class' category: #'Egg-Core-SExpressions'!
SReturn class
	instanceVariableNames: ''!

!classDefinition: #SScript category: #'Egg-Core-SExpressions'!
SExpression subclass: #SScript
	instanceVariableNames: 'statements compiledCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SScript class' category: #'Egg-Core-SExpressions'!
SScript class
	instanceVariableNames: ''!

!classDefinition: #SBlock category: #'Egg-Core-SExpressions'!
SScript subclass: #SBlock
	instanceVariableNames: 'index capturedVariables inlinedArgs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SBlock class' category: #'Egg-Core-SExpressions'!
SBlock class
	instanceVariableNames: ''!

!classDefinition: #SMethod category: #'Egg-Core-SExpressions'!
SScript subclass: #SMethod
	instanceVariableNames: 'pragma'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-SExpressions'!
!classDefinition: 'SMethod class' category: #'Egg-Core-SExpressions'!
SMethod class
	instanceVariableNames: ''!

!classDefinition: #OBasicBlock category: #'Egg-IR'!
Object subclass: #OBasicBlock
	instanceVariableNames: 'firstInstruction lastInstruction predecessors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OBasicBlock class' category: #'Egg-IR'!
OBasicBlock class
	instanceVariableNames: ''!

!classDefinition: #ODominatorTree category: #'Egg-IR'!
Object subclass: #ODominatorTree
	instanceVariableNames: 'block dominators dominated'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'ODominatorTree class' category: #'Egg-IR'!
ODominatorTree class
	instanceVariableNames: ''!

!classDefinition: #OLiveRange category: #'Egg-IR'!
Object subclass: #OLiveRange
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OLiveRange class' category: #'Egg-IR'!
OLiveRange class
	instanceVariableNames: ''!

!classDefinition: #OComposedLiveRange category: #'Egg-IR'!
OLiveRange subclass: #OComposedLiveRange
	instanceVariableNames: 'ranges'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OComposedLiveRange class' category: #'Egg-IR'!
OComposedLiveRange class
	instanceVariableNames: ''!

!classDefinition: #OSimpleLiveRange category: #'Egg-IR'!
OLiveRange subclass: #OSimpleLiveRange
	instanceVariableNames: 'definition uses definitionBlock usesBlocks isSpilled'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OSimpleLiveRange class' category: #'Egg-IR'!
OSimpleLiveRange class
	instanceVariableNames: ''!

!classDefinition: #OOperand category: #'Egg-IR'!
Object subclass: #OOperand
	instanceVariableNames: 'instruction name nextUse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OOperand class' category: #'Egg-IR'!
OOperand class
	instanceVariableNames: ''!

!classDefinition: #OTiling category: #'Egg-IR'!
Object subclass: #OTiling
	instanceVariableNames: 'action cost used instruction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OTiling class' category: #'Egg-IR'!
OTiling class
	instanceVariableNames: ''!

!classDefinition: #OValue category: #'Egg-IR'!
Object subclass: #OValue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OValue class' category: #'Egg-IR'!
OValue class
	instanceVariableNames: ''!

!classDefinition: #OConstant category: #'Egg-IR'!
OValue subclass: #OConstant
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OConstant class' category: #'Egg-IR'!
OConstant class
	instanceVariableNames: ''!

!classDefinition: #OInstruction category: #'Egg-IR'!
OValue subclass: #OInstruction
	instanceVariableNames: 'prev next firstUse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OInstruction class' category: #'Egg-IR'!
OInstruction class
	instanceVariableNames: ''!

!classDefinition: #OBeginInstruction category: #'Egg-IR'!
OInstruction subclass: #OBeginInstruction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OBeginInstruction class' category: #'Egg-IR'!
OBeginInstruction class
	instanceVariableNames: ''!

!classDefinition: #OBlockClosure category: #'Egg-IR'!
OInstruction subclass: #OBlockClosure
	instanceVariableNames: 'firstBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OBlockClosure class' category: #'Egg-IR'!
OBlockClosure class
	instanceVariableNames: ''!

!classDefinition: #ODefineArgument category: #'Egg-IR'!
OInstruction subclass: #ODefineArgument
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'ODefineArgument class' category: #'Egg-IR'!
ODefineArgument class
	instanceVariableNames: ''!

!classDefinition: #OEndInstruction category: #'Egg-IR'!
OInstruction subclass: #OEndInstruction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OEndInstruction class' category: #'Egg-IR'!
OEndInstruction class
	instanceVariableNames: ''!

!classDefinition: #OJump category: #'Egg-IR'!
OInstruction subclass: #OJump
	instanceVariableNames: 'target'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OJump class' category: #'Egg-IR'!
OJump class
	instanceVariableNames: ''!

!classDefinition: #OJumpConditional category: #'Egg-IR'!
OInstruction subclass: #OJumpConditional
	instanceVariableNames: 'variable target implicitTarget'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OJumpConditional class' category: #'Egg-IR'!
OJumpConditional class
	instanceVariableNames: ''!

!classDefinition: #OJumpFalse category: #'Egg-IR'!
OJumpConditional subclass: #OJumpFalse
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OJumpFalse class' category: #'Egg-IR'!
OJumpFalse class
	instanceVariableNames: ''!

!classDefinition: #OJumpTrue category: #'Egg-IR'!
OJumpConditional subclass: #OJumpTrue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OJumpTrue class' category: #'Egg-IR'!
OJumpTrue class
	instanceVariableNames: ''!

!classDefinition: #OLoadConstant category: #'Egg-IR'!
OInstruction subclass: #OLoadConstant
	instanceVariableNames: 'constant'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OLoadConstant class' category: #'Egg-IR'!
OLoadConstant class
	instanceVariableNames: ''!

!classDefinition: #OLoadImplicit category: #'Egg-IR'!
OInstruction subclass: #OLoadImplicit
	instanceVariableNames: 'name source'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OLoadImplicit class' category: #'Egg-IR'!
OLoadImplicit class
	instanceVariableNames: ''!

!classDefinition: #OActivationContext category: #'Egg-IR'!
OLoadImplicit subclass: #OActivationContext
	instanceVariableNames: 'hasFrame temporaries storesPreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OActivationContext class' category: #'Egg-IR'!
OActivationContext class
	instanceVariableNames: ''!

!classDefinition: #OMessageSend category: #'Egg-IR'!
OInstruction subclass: #OMessageSend
	instanceVariableNames: 'receiver selector arguments'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OMessageSend class' category: #'Egg-IR'!
OMessageSend class
	instanceVariableNames: ''!

!classDefinition: #OPhi category: #'Egg-IR'!
OInstruction subclass: #OPhi
	instanceVariableNames: 'variables blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OPhi class' category: #'Egg-IR'!
OPhi class
	instanceVariableNames: ''!

!classDefinition: #OPrimitiveOperation category: #'Egg-IR'!
OInstruction subclass: #OPrimitiveOperation
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OPrimitiveOperation class' category: #'Egg-IR'!
OPrimitiveOperation class
	instanceVariableNames: ''!

!classDefinition: #OBinaryOperation category: #'Egg-IR'!
OPrimitiveOperation subclass: #OBinaryOperation
	instanceVariableNames: 'left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OBinaryOperation class' category: #'Egg-IR'!
OBinaryOperation class
	instanceVariableNames: ''!

!classDefinition: #OBinaryConstantOperation category: #'Egg-IR'!
OBinaryOperation subclass: #OBinaryConstantOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OBinaryConstantOperation class' category: #'Egg-IR'!
OBinaryConstantOperation class
	instanceVariableNames: ''!

!classDefinition: #OBinaryVariableOperation category: #'Egg-IR'!
OBinaryOperation subclass: #OBinaryVariableOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OBinaryVariableOperation class' category: #'Egg-IR'!
OBinaryVariableOperation class
	instanceVariableNames: ''!

!classDefinition: #OTernaryOperation category: #'Egg-IR'!
OPrimitiveOperation subclass: #OTernaryOperation
	instanceVariableNames: 'receiver left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OTernaryOperation class' category: #'Egg-IR'!
OTernaryOperation class
	instanceVariableNames: ''!

!classDefinition: #OUnaryOperation category: #'Egg-IR'!
OPrimitiveOperation subclass: #OUnaryOperation
	instanceVariableNames: 'receiver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OUnaryOperation class' category: #'Egg-IR'!
OUnaryOperation class
	instanceVariableNames: ''!

!classDefinition: #OMemoryOperation category: #'Egg-OCompiler-Core-IR'!
OPrimitiveOperation subclass: #OMemoryOperation
	instanceVariableNames: 'base index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler-Core-IR'!
!classDefinition: 'OMemoryOperation class' category: #'Egg-OCompiler-Core-IR'!
OMemoryOperation class
	instanceVariableNames: ''!

!classDefinition: #OLoadOperation category: #'Egg-OCompiler-Core-IR'!
OMemoryOperation subclass: #OLoadOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler-Core-IR'!
!classDefinition: 'OLoadOperation class' category: #'Egg-OCompiler-Core-IR'!
OLoadOperation class
	instanceVariableNames: ''!

!classDefinition: #OStoreOperation category: #'Egg-OCompiler-Core-IR'!
OMemoryOperation subclass: #OStoreOperation
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler-Core-IR'!
!classDefinition: 'OStoreOperation class' category: #'Egg-OCompiler-Core-IR'!
OStoreOperation class
	instanceVariableNames: ''!

!classDefinition: #OReturn category: #'Egg-IR'!
OInstruction subclass: #OReturn
	instanceVariableNames: 'source frame argumentsCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OReturn class' category: #'Egg-IR'!
OReturn class
	instanceVariableNames: ''!

!classDefinition: #OUseVariable category: #'Egg-IR'!
OInstruction subclass: #OUseVariable
	instanceVariableNames: 'binding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OUseVariable class' category: #'Egg-IR'!
OUseVariable class
	instanceVariableNames: ''!

!classDefinition: #OReadVariable category: #'Egg-IR'!
OUseVariable subclass: #OReadVariable
	instanceVariableNames: 'source'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OReadVariable class' category: #'Egg-IR'!
OReadVariable class
	instanceVariableNames: ''!

!classDefinition: #OWriteVariable category: #'Egg-IR'!
OUseVariable subclass: #OWriteVariable
	instanceVariableNames: 'source'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OWriteVariable class' category: #'Egg-IR'!
OWriteVariable class
	instanceVariableNames: ''!

!classDefinition: #OControlInstruction category: #'Egg-OCompiler-Core-IR'!
OInstruction subclass: #OControlInstruction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler-Core-IR'!
!classDefinition: 'OControlInstruction class' category: #'Egg-OCompiler-Core-IR'!
OControlInstruction class
	instanceVariableNames: ''!

!classDefinition: #OVariable category: #'Egg-IR'!
Object subclass: #OVariable
	instanceVariableNames: 'binding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OVariable class' category: #'Egg-IR'!
OVariable class
	instanceVariableNames: ''!

!classDefinition: #OTemporary category: #'Egg-IR'!
OVariable subclass: #OTemporary
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-IR'!
!classDefinition: 'OTemporary class' category: #'Egg-IR'!
OTemporary class
	instanceVariableNames: ''!

!classDefinition: #ModuleLoader category: #'Egg-LMR-Bootstrapper'!
Object subclass: #ModuleLoader
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-LMR-Bootstrapper'!
!classDefinition: 'ModuleLoader class' category: #'Egg-LMR-Bootstrapper'!
ModuleLoader class
	instanceVariableNames: ''!

!classDefinition: #OptimizingBlockInliner category: #'Egg-OCompiler'!
Object subclass: #OptimizingBlockInliner
	instanceVariableNames: 'firstBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingBlockInliner class' category: #'Egg-OCompiler'!
OptimizingBlockInliner class
	instanceVariableNames: ''!

!classDefinition: #OptimizingBraunAllocator category: #'Egg-OCompiler'!
Object subclass: #OptimizingBraunAllocator
	instanceVariableNames: 'firstBlock currentBlock loops liveness allocationEntry allocationExit distancesExit spillExit currentlyAvailable currentlySpilled temporaries amountOfRegisters scheduledSpills scheduledReloads blocksDone deferredCouplings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingBraunAllocator class' category: #'Egg-OCompiler'!
OptimizingBraunAllocator class
	instanceVariableNames: ''!

!classDefinition: #OptimizingBraunAssigner category: #'Egg-OCompiler'!
Object subclass: #OptimizingBraunAssigner
	instanceVariableNames: 'firstBlock liveness allocationEntry temporaries preferences occupied assignments clusters processed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingBraunAssigner class' category: #'Egg-OCompiler'!
OptimizingBraunAssigner class
	instanceVariableNames: ''!

!classDefinition: #OptimizingCFGSimplifier category: #'Egg-OCompiler'!
Object subclass: #OptimizingCFGSimplifier
	instanceVariableNames: 'firstBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingCFGSimplifier class' category: #'Egg-OCompiler'!
OptimizingCFGSimplifier class
	instanceVariableNames: ''!

!classDefinition: #OptimizingCSSATransformer category: #'Egg-OCompiler'!
Object subclass: #OptimizingCSSATransformer
	instanceVariableNames: 'firstBlock liveness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingCSSATransformer class' category: #'Egg-OCompiler'!
OptimizingCSSATransformer class
	instanceVariableNames: ''!

!classDefinition: #OptimizingCodeEmitter category: #'Egg-OCompiler'!
Object subclass: #OptimizingCodeEmitter
	instanceVariableNames: 'allocation assembler abi jumpDestinations assemblers method firstBlock currentBlockIndex blocks messageLinker'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingCodeEmitter class' category: #'Egg-OCompiler'!
OptimizingCodeEmitter class
	instanceVariableNames: ''!

!classDefinition: #OptimizingInstructionFragmenter category: #'Egg-OCompiler'!
Object subclass: #OptimizingInstructionFragmenter
	instanceVariableNames: 'method messages firstBlock abi'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingInstructionFragmenter class' category: #'Egg-OCompiler'!
OptimizingInstructionFragmenter class
	instanceVariableNames: ''!

!classDefinition: #OptimizingInstructionSelector category: #'Egg-OCompiler'!
Object subclass: #OptimizingInstructionSelector
	instanceVariableNames: 'firstBlock tiles roots messages'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingInstructionSelector class' category: #'Egg-OCompiler'!
OptimizingInstructionSelector class
	instanceVariableNames: ''!

!classDefinition: #OptimizingLivenessAnalysis category: #'Egg-OCompiler'!
Object subclass: #OptimizingLivenessAnalysis
	instanceVariableNames: 'firstBlock liveIn liveOut loops pressures expirations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingLivenessAnalysis class' category: #'Egg-OCompiler'!
OptimizingLivenessAnalysis class
	instanceVariableNames: ''!

!classDefinition: #OptimizingMethodInliner category: #'Egg-OCompiler'!
Object subclass: #OptimizingMethodInliner
	instanceVariableNames: 'firstBlock methods abi'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingMethodInliner class' category: #'Egg-OCompiler'!
OptimizingMethodInliner class
	instanceVariableNames: ''!

!classDefinition: #OptimizingNativizer category: #'Egg-OCompiler'!
Object subclass: #OptimizingNativizer
	instanceVariableNames: 'method firstBlock messageLinker inlinedMethods abi'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingNativizer class' category: #'Egg-OCompiler'!
OptimizingNativizer class
	instanceVariableNames: ''!

!classDefinition: #OptimizingPhiSimplification category: #'Egg-OCompiler'!
Object subclass: #OptimizingPhiSimplification
	instanceVariableNames: 'marks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingPhiSimplification class' category: #'Egg-OCompiler'!
OptimizingPhiSimplification class
	instanceVariableNames: ''!

!classDefinition: #OptimizingRegisterAllocator category: #'Egg-OCompiler'!
Object subclass: #OptimizingRegisterAllocator
	instanceVariableNames: 'abi liveRanges unifiedLiveRanges expirations allocation free used usedOut locals currentBlock firstBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingRegisterAllocator class' category: #'Egg-OCompiler'!
OptimizingRegisterAllocator class
	instanceVariableNames: ''!

!classDefinition: #OptimizingSSAReconstructor category: #'Egg-OCompiler'!
Object subclass: #OptimizingSSAReconstructor
	instanceVariableNames: 'firstBlock variable reloads idoms iteratedFrontiers insertedPhis blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingSSAReconstructor class' category: #'Egg-OCompiler'!
OptimizingSSAReconstructor class
	instanceVariableNames: ''!

!classDefinition: #OptimizingTwoAddressEnforcer category: #'Egg-OCompiler'!
Object subclass: #OptimizingTwoAddressEnforcer
	instanceVariableNames: 'allocation firstBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingTwoAddressEnforcer class' category: #'Egg-OCompiler'!
OptimizingTwoAddressEnforcer class
	instanceVariableNames: ''!

!classDefinition: #OptimizingUsesVerifier category: #'Egg-OCompiler'!
Object subclass: #OptimizingUsesVerifier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingUsesVerifier class' category: #'Egg-OCompiler'!
OptimizingUsesVerifier class
	instanceVariableNames: ''!

!classDefinition: #OptimizingValueNumbering category: #'Egg-OCompiler'!
Object subclass: #OptimizingValueNumbering
	instanceVariableNames: 'firstBlock currentBlock names hashes hashesOut'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingValueNumbering class' category: #'Egg-OCompiler'!
OptimizingValueNumbering class
	instanceVariableNames: ''!

!classDefinition: #OptimizingVariableBinder category: #'Egg-OCompiler'!
Object subclass: #OptimizingVariableBinder
	instanceVariableNames: 'definitions currentBlock dominatorTree immediateDominators dominanceFrontiers pendingReads pendingPhis abi'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingVariableBinder class' category: #'Egg-OCompiler'!
OptimizingVariableBinder class
	instanceVariableNames: ''!

!classDefinition: #ODispatchInliner category: #'Egg-OCompiler-Core-Main'!
Object subclass: #ODispatchInliner
	instanceVariableNames: 'methodInliner types send receiver arguments phi currentBlock end'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler-Core-Main'!
!classDefinition: 'ODispatchInliner class' category: #'Egg-OCompiler-Core-Main'!
ODispatchInliner class
	instanceVariableNames: ''!

!classDefinition: #ParseTreeVisitor category: #'Egg-OCompiler-Core-Main'!
Object subclass: #ParseTreeVisitor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler-Core-Main'!
!classDefinition: 'ParseTreeVisitor class' category: #'Egg-OCompiler-Core-Main'!
ParseTreeVisitor class
	instanceVariableNames: ''!

!classDefinition: #OptimizingVisitor category: #'Egg-OCompiler'!
ParseTreeVisitor subclass: #OptimizingVisitor
	instanceVariableNames: 'firstBlock currentBlock isReceiver argumentsCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-OCompiler'!
!classDefinition: 'OptimizingVisitor class' category: #'Egg-OCompiler'!
OptimizingVisitor class
	instanceVariableNames: ''!

!classDefinition: #MessageInliner category: #'Egg-SCompiler'!
Object subclass: #MessageInliner
	instanceVariableNames: 'message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler'!
!classDefinition: 'MessageInliner class' category: #'Egg-SCompiler'!
MessageInliner class
	instanceVariableNames: ''!

!classDefinition: #SCompiledBlock category: #'Egg-SCompiler-Backend'!
Object subclass: #SCompiledBlock
	instanceVariableNames: 'format optimizedCode method'
	classVariableNames: ''
	poolDictionaries: 'private'
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'SCompiledBlock class' category: #'Egg-SCompiler-Backend'!
SCompiledBlock class
	instanceVariableNames: ''!

!classDefinition: #Binding category: #'Egg-SCompiler-Bindings'!
Object subclass: #Binding
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'Binding class' category: #'Egg-SCompiler-Bindings'!
Binding class
	instanceVariableNames: ''!

!classDefinition: #DynamicBinding category: #'Egg-SCompiler-Bindings'!
Binding subclass: #DynamicBinding
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'DynamicBinding class' category: #'Egg-SCompiler-Bindings'!
DynamicBinding class
	instanceVariableNames: 'Default'!

!classDefinition: #NestedDynamicBinding category: #'Egg-SCompiler-Bindings'!
DynamicBinding subclass: #NestedDynamicBinding
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'NestedDynamicBinding class' category: #'Egg-SCompiler-Bindings'!
NestedDynamicBinding class
	instanceVariableNames: ''!

!classDefinition: #LiteralBinding category: #'Egg-SCompiler-Bindings'!
Binding subclass: #LiteralBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'LiteralBinding class' category: #'Egg-SCompiler-Bindings'!
LiteralBinding class
	instanceVariableNames: ''!

!classDefinition: #FalseBinding category: #'Egg-SCompiler-Bindings'!
LiteralBinding subclass: #FalseBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'FalseBinding class' category: #'Egg-SCompiler-Bindings'!
FalseBinding class
	instanceVariableNames: ''!

!classDefinition: #NilBinding category: #'Egg-SCompiler-Bindings'!
LiteralBinding subclass: #NilBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'NilBinding class' category: #'Egg-SCompiler-Bindings'!
NilBinding class
	instanceVariableNames: ''!

!classDefinition: #TrueBinding category: #'Egg-SCompiler-Bindings'!
LiteralBinding subclass: #TrueBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'TrueBinding class' category: #'Egg-SCompiler-Bindings'!
TrueBinding class
	instanceVariableNames: ''!

!classDefinition: #LocalBinding category: #'Egg-SCompiler-Bindings'!
Binding subclass: #LocalBinding
	instanceVariableNames: 'index environment declaration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'LocalBinding class' category: #'Egg-SCompiler-Bindings'!
LocalBinding class
	instanceVariableNames: ''!

!classDefinition: #ArgumentBinding category: #'Egg-SCompiler-Bindings'!
LocalBinding subclass: #ArgumentBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'ArgumentBinding class' category: #'Egg-SCompiler-Bindings'!
ArgumentBinding class
	instanceVariableNames: ''!

!classDefinition: #TemporaryBinding category: #'Egg-SCompiler-Bindings'!
LocalBinding subclass: #TemporaryBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'TemporaryBinding class' category: #'Egg-SCompiler-Bindings'!
TemporaryBinding class
	instanceVariableNames: ''!

!classDefinition: #SelfBinding category: #'Egg-SCompiler-Bindings'!
Binding subclass: #SelfBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'SelfBinding class' category: #'Egg-SCompiler-Bindings'!
SelfBinding class
	instanceVariableNames: ''!

!classDefinition: #SuperBinding category: #'Egg-SCompiler-Bindings'!
SelfBinding subclass: #SuperBinding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'SuperBinding class' category: #'Egg-SCompiler-Bindings'!
SuperBinding class
	instanceVariableNames: ''!

!classDefinition: #LocalEnvironment category: #'Egg-SCompiler-Bindings'!
Object subclass: #LocalEnvironment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'private'
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'LocalEnvironment class' category: #'Egg-SCompiler-Bindings'!
LocalEnvironment class
	instanceVariableNames: ''!

!classDefinition: #ArrayEnvironment category: #'Egg-SCompiler-Bindings'!
LocalEnvironment subclass: #ArrayEnvironment
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'ArrayEnvironment class' category: #'Egg-SCompiler-Bindings'!
ArrayEnvironment class
	instanceVariableNames: ''!

!classDefinition: #StackEnvironment category: #'Egg-SCompiler-Bindings'!
LocalEnvironment subclass: #StackEnvironment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'StackEnvironment class' category: #'Egg-SCompiler-Bindings'!
StackEnvironment class
	instanceVariableNames: ''!

!classDefinition: #ArgumentEnvironment category: #'Egg-SCompiler-Bindings'!
StackEnvironment subclass: #ArgumentEnvironment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'ArgumentEnvironment class' category: #'Egg-SCompiler-Bindings'!
ArgumentEnvironment class
	instanceVariableNames: ''!

!classDefinition: #InlinedArgEnvironment category: #'Egg-SCompiler-Bindings'!
StackEnvironment subclass: #InlinedArgEnvironment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Bindings'!
!classDefinition: 'InlinedArgEnvironment class' category: #'Egg-SCompiler-Bindings'!
InlinedArgEnvironment class
	instanceVariableNames: ''!

!classDefinition: #SCompilationResult category: #'Egg-SCompiler-Frontend'!
Object subclass: #SCompilationResult
	instanceVariableNames: 'compiler error ast method'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Frontend'!
!classDefinition: 'SCompilationResult class' category: #'Egg-SCompiler-Frontend'!
SCompilationResult class
	instanceVariableNames: ''!

!classDefinition: #SCompiler category: #'Egg-SCompiler-Frontend'!
Object subclass: #SCompiler
	instanceVariableNames: 'errorHandler result class'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Frontend'!
!classDefinition: 'SCompiler class' category: #'Egg-SCompiler-Frontend'!
SCompiler class
	instanceVariableNames: ''!

!classDefinition: #SSmalltalkCompiler category: #'Egg-SCompiler-Frontend'!
Object subclass: #SSmalltalkCompiler
	instanceVariableNames: 'frontend source ast result headless blocks leaf activeScript'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Frontend'!
!classDefinition: 'SSmalltalkCompiler class' category: #'Egg-SCompiler-Frontend'!
SSmalltalkCompiler class
	instanceVariableNames: ''!

!classDefinition: #IdentifierBinder category: #'Egg-SCompiler-Parser'!
Object subclass: #IdentifierBinder
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'IdentifierBinder class' category: #'Egg-SCompiler-Parser'!
IdentifierBinder class
	instanceVariableNames: ''!

!classDefinition: #StaticBinder category: #'Egg-SCompiler-Parser'!
IdentifierBinder subclass: #StaticBinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'StaticBinder class' category: #'Egg-SCompiler-Parser'!
StaticBinder class
	instanceVariableNames: ''!

!classDefinition: #SParseTreeVisitor category: #'Egg-SCompiler-Parser'!
Object subclass: #SParseTreeVisitor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SParseTreeVisitor class' category: #'Egg-SCompiler-Parser'!
SParseTreeVisitor class
	instanceVariableNames: ''!

!classDefinition: #AstcodeEncoder category: #'Egg-SCompiler-Backend'!
SParseTreeVisitor subclass: #AstcodeEncoder
	instanceVariableNames: 'method stream script'
	classVariableNames: ''
	poolDictionaries: 'AstBindingTypes AstNodeTypes ClosureElementTypes'
	category: 'Egg-SCompiler-Backend'!
!classDefinition: 'AstcodeEncoder class' category: #'Egg-SCompiler-Backend'!
AstcodeEncoder class
	instanceVariableNames: ''!

!classDefinition: #SSemanticVisitor category: #'Egg-SCompiler-Frontend'!
SParseTreeVisitor subclass: #SSemanticVisitor
	instanceVariableNames: 'inliner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Frontend'!
!classDefinition: 'SSemanticVisitor class' category: #'Egg-SCompiler-Frontend'!
SSemanticVisitor class
	instanceVariableNames: ''!

!classDefinition: #SSmalltalkParser category: #'Egg-SCompiler-Parser'!
Object subclass: #SSmalltalkParser
	instanceVariableNames: 'compiler scanner token next'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SSmalltalkParser class' category: #'Egg-SCompiler-Parser'!
SSmalltalkParser class
	instanceVariableNames: ''!

!classDefinition: #SSmalltalkScanner category: #'Egg-SCompiler-Parser'!
Object subclass: #SSmalltalkScanner
	instanceVariableNames: 'compiler stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SSmalltalkScanner class' category: #'Egg-SCompiler-Parser'!
SSmalltalkScanner class
	instanceVariableNames: ''!

!classDefinition: #SToken category: #'Egg-SCompiler-Parser'!
Object subclass: #SToken
	instanceVariableNames: 'compiler stretch comments'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SToken class' category: #'Egg-SCompiler-Parser'!
SToken class
	instanceVariableNames: ''!

!classDefinition: #SEndToken category: #'Egg-SCompiler-Parser'!
SToken subclass: #SEndToken
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SEndToken class' category: #'Egg-SCompiler-Parser'!
SEndToken class
	instanceVariableNames: ''!

!classDefinition: #SParseNode category: #'Egg-SCompiler-Parser'!
SToken subclass: #SParseNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SParseNode class' category: #'Egg-SCompiler-Parser'!
SParseNode class
	instanceVariableNames: ''!

!classDefinition: #SAssignmentNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SAssignmentNode
	instanceVariableNames: 'assignees expression operators'
	classVariableNames: 'Token'
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SAssignmentNode class' category: #'Egg-SCompiler-Parser'!
SAssignmentNode class
	instanceVariableNames: 'Token'!

!classDefinition: #SBraceNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SBraceNode
	instanceVariableNames: 'elements message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SBraceNode class' category: #'Egg-SCompiler-Parser'!
SBraceNode class
	instanceVariableNames: ''!

!classDefinition: #SCascadeNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SCascadeNode
	instanceVariableNames: 'receiver messages optimized'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SCascadeNode class' category: #'Egg-SCompiler-Parser'!
SCascadeNode class
	instanceVariableNames: ''!

!classDefinition: #SCommentNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SCommentNode
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SCommentNode class' category: #'Egg-SCompiler-Parser'!
SCommentNode class
	instanceVariableNames: ''!

!classDefinition: #SIdentifierNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SIdentifierNode
	instanceVariableNames: 'name binding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SIdentifierNode class' category: #'Egg-SCompiler-Parser'!
SIdentifierNode class
	instanceVariableNames: ''!

!classDefinition: #SLiteralNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SLiteralNode
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SLiteralNode class' category: #'Egg-SCompiler-Parser'!
SLiteralNode class
	instanceVariableNames: ''!

!classDefinition: #SNumberNode category: #'Egg-SCompiler-Parser'!
SLiteralNode subclass: #SNumberNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SNumberNode class' category: #'Egg-SCompiler-Parser'!
SNumberNode class
	instanceVariableNames: ''!

!classDefinition: #SStringNode category: #'Egg-SCompiler-Parser'!
SLiteralNode subclass: #SStringNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SStringNode class' category: #'Egg-SCompiler-Parser'!
SStringNode class
	instanceVariableNames: ''!

!classDefinition: #SMessageNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SMessageNode
	instanceVariableNames: 'selector receiver arguments inlined'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SMessageNode class' category: #'Egg-SCompiler-Parser'!
SMessageNode class
	instanceVariableNames: ''!

!classDefinition: #SCascadeMessageNode category: #'Egg-SCompiler-Parser'!
SMessageNode subclass: #SCascadeMessageNode
	instanceVariableNames: 'cascade'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SCascadeMessageNode class' category: #'Egg-SCompiler-Parser'!
SCascadeMessageNode class
	instanceVariableNames: ''!

!classDefinition: #SReturnNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SReturnNode
	instanceVariableNames: 'expression return'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SReturnNode class' category: #'Egg-SCompiler-Parser'!
SReturnNode class
	instanceVariableNames: ''!

!classDefinition: #SScriptNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SScriptNode
	instanceVariableNames: 'statements arguments temporaries children scope'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SScriptNode class' category: #'Egg-SCompiler-Parser'!
SScriptNode class
	instanceVariableNames: ''!

!classDefinition: #SBlockNode category: #'Egg-SCompiler-Parser'!
SScriptNode subclass: #SBlockNode
	instanceVariableNames: 'inlined index parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SBlockNode class' category: #'Egg-SCompiler-Parser'!
SBlockNode class
	instanceVariableNames: ''!

!classDefinition: #SMethodNode category: #'Egg-SCompiler-Parser'!
SScriptNode subclass: #SMethodNode
	instanceVariableNames: 'selector pragma'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SMethodNode class' category: #'Egg-SCompiler-Parser'!
SMethodNode class
	instanceVariableNames: ''!

!classDefinition: #SSelectorNode category: #'Egg-SCompiler-Parser'!
SParseNode subclass: #SSelectorNode
	instanceVariableNames: 'symbol keywords'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SSelectorNode class' category: #'Egg-SCompiler-Parser'!
SSelectorNode class
	instanceVariableNames: ''!

!classDefinition: #SPragmaNode category: #'Egg-SCompiler-Parser'!
SToken subclass: #SPragmaNode
	instanceVariableNames: 'type name info'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SPragmaNode class' category: #'Egg-SCompiler-Parser'!
SPragmaNode class
	instanceVariableNames: ''!

!classDefinition: #SSymbolicToken category: #'Egg-SCompiler-Parser'!
SToken subclass: #SSymbolicToken
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SSymbolicToken class' category: #'Egg-SCompiler-Parser'!
SSymbolicToken class
	instanceVariableNames: ''!

!classDefinition: #SDelimiterToken category: #'Egg-SCompiler-Parser'!
SSymbolicToken subclass: #SDelimiterToken
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SDelimiterToken class' category: #'Egg-SCompiler-Parser'!
SDelimiterToken class
	instanceVariableNames: ''!

!classDefinition: #SStringToken category: #'Egg-SCompiler-Parser'!
SSymbolicToken subclass: #SStringToken
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'SStringToken class' category: #'Egg-SCompiler-Parser'!
SStringToken class
	instanceVariableNames: ''!

!classDefinition: #ScriptScope category: #'Egg-SCompiler-Parser'!
Object subclass: #ScriptScope
	instanceVariableNames: 'script arguments temporaries stackSize envSize captureSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'ScriptScope class' category: #'Egg-SCompiler-Parser'!
ScriptScope class
	instanceVariableNames: ''!

!classDefinition: #BlockScope category: #'Egg-SCompiler-Parser'!
ScriptScope subclass: #BlockScope
	instanceVariableNames: 'environments captured'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'BlockScope class' category: #'Egg-SCompiler-Parser'!
BlockScope class
	instanceVariableNames: ''!

!classDefinition: #MethodScope category: #'Egg-SCompiler-Parser'!
ScriptScope subclass: #MethodScope
	instanceVariableNames: 'pseudo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Parser'!
!classDefinition: 'MethodScope class' category: #'Egg-SCompiler-Parser'!
MethodScope class
	instanceVariableNames: ''!

!classDefinition: #PowertalkEvaluatorError category: #'Egg-Core-Execution'!
Error subclass: #PowertalkEvaluatorError
	instanceVariableNames: 'context'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-Core-Execution'!
!classDefinition: 'PowertalkEvaluatorError class' category: #'Egg-Core-Execution'!
PowertalkEvaluatorError class
	instanceVariableNames: ''!

!classDefinition: #SCompilationError category: #'Egg-SCompiler-Frontend'!
Error subclass: #SCompilationError
	instanceVariableNames: 'compiler resumable retryable stretch'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Frontend'!
!classDefinition: 'SCompilationError class' category: #'Egg-SCompiler-Frontend'!
SCompilationError class
	instanceVariableNames: ''!

!classDefinition: #SInvalidPragmaError category: #'Egg-SCompiler-Frontend'!
SCompilationError subclass: #SInvalidPragmaError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Frontend'!
!classDefinition: 'SInvalidPragmaError class' category: #'Egg-SCompiler-Frontend'!
SInvalidPragmaError class
	instanceVariableNames: ''!

!classDefinition: #SUndeclaredIdentifierError category: #'Egg-SCompiler-Frontend'!
SCompilationError subclass: #SUndeclaredIdentifierError
	instanceVariableNames: 'identifier assigned'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Egg-SCompiler-Frontend'!
!classDefinition: 'SUndeclaredIdentifierError class' category: #'Egg-SCompiler-Frontend'!
SUndeclaredIdentifierError class
	instanceVariableNames: ''!


!RegistersRISCV commentStamp: '<historical>' prior: 0!
For now, pretend to be a register starved Intel x86-64 CPU.
Just symbolic register indexes. See self class>>#initialize!

!Builder commentStamp: '<historical>' prior: 0!
Copyright (c) 2022, Javier Pimás.
    See (MIT) license in root directory.
!

!ISAInstruction commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAOperand commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAImmediate commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!MemoryOperand commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!Register commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAOperandType commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!InstructionEncoder commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!InstructionPrefix commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!LegacyPrefix commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!REXPrefix commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!SegmentPrefix commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!VEXPrefix commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!InstructionSpec commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!OperandEncoding commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ABI commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.

`ABI` seems to serve two different purposes:

 i) provide support for calling (native) function with system
	calling convention for given architecture and OS combination

ii) provide fixed mapping from 'IR' registers (such as A, R, M and so on)
	to real machine registers

!

!X64ABI commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!X86ABI commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!Assembler commentStamp: '<historical>' prior: 0!
I am the JIT assembler frontend. 
I provide a high-level assembler interface (if that really exists)
and delegate writing of the actual bytes to my backends.
!

!AMD64TemplateAssembler commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!AMD64CodeGenerator commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!RV64GCodeGenerator commentStamp: '<historical>' prior: 0!
RISC-V RV64G
See specs at:
  https://riscv.org/technical/specifications/

Linux System Call Convention (RV64G)
    syscall number is passed in a7
    syscall arguments are passed in a0 to a5
    unused arguments are set to 0
    return value is returned in a0
!

!RelocatableBuffer commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!RelocationFixup commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!Assembly commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAInstructionPartReader commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAModRMReader commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAOpcodeReader commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAPrefixReader commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISASibReader commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ISAInstructionReader commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!OctalStructure commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!ModRM commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!SIB commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
	See (MIT) license in root directory.
!

!RVMemoryReference commentStamp: '<historical>' prior: 0!
I am an abstract description of a location in memory which is `widthInBits` wide.

The `offset` part of a memory address can be specified directly as a static value 
or through an address computation made up of one or more of the following components:

      offset - An 8, 16, or 32-bit value.
      baseRegister - contains the base address.
      indexRegister - contains an index off of the base.
Note:
      scale - A value of 1, 2, 4, or 8 that is multiplied by the value in the indexRegister
		This is simply the number of bytes per index, i.e. (widthInBits / bitsPerByte).

    The offset which results from adding these components is called an `effective address`. 
    Each of these components can have either a positive or negative (2s complement) value, 
    with the exception of the scaling factor.

   Symbolically:
        EffectiveAddress := Base + (Index*Scale) + Offset

   For OOPS (Object Pointers):

                 header
   Base---> slot1
                 slot2
                 slot3

   With zero based index, 8 byte addresses,
      slot3 is at address: (Base + (index=2 * scale=8) + offset=0)

  Note Calculations in:
	 #CodeGenerator>>memRef:indexImm:
	 #RV64GCodeGenerator>>lea:withMem: 
!

!PowertalkRingRuntime commentStamp: '<historical>' prior: 0!
I allow sending messages to objects of the `VirtualSmalltalkImage`.
The messages are interpreted and evaluated with the objects living in
that virtual image, and our semantics tries to mimic as much as possible
the one of the final system.
!

!RingBasedLMRBootstrapper commentStamp: '<historical>' prior: 0!
A base instance of VirtualSmalltalkImage only contains empty classes, nil, true, false,
and barely anything else. I am in charge of adding the Kernel module object to it and the
methods to the classes.
!

!PowertalkRingModule commentStamp: '<historical>' prior: 0!
I'm in charge of creating and managing the objects of an image. I'm created from a spec,
and I know how to bootstrap and connect an initial graph of objects and classes.

I do not add the spec methods to classes, as it requires some emulation done by
the `VirtualRuntime`. That step is left to the `VirtualImage`
that also creates the Kernel module.
!

!Bridge commentStamp: '<historical>' prior: 0!
I am the one in charge of 'discovering' well known objects in
the remote image, giving my clients handles to them. For example,
the Smalltalk bridge allows to get a handle to the remote Smalltalk
object. Subclasses of SmalltalkBridge implement this functionality,
as it is runtime specific.

!

!Gate commentStamp: '<historical>' prior: 0!
I am a proxy to a remote object given by my `handle`. My main goal is
to abstract semantics with which messages sent to me will be executed.
My subclasses implement those different semantics: 
 - DirectGate executes locally, doing lookup within the remote behavior
   of object.
 - MirageGate executes locally, doing lookup within a local specification
   of the behavior of the remote object.
!

!Handle commentStamp: '<historical>' prior: 0!
I represent entities in a remote Runtime. My subclasses determine
which kind of entity: ObjectHandles have an `oid` to uniquely referencing
an object of that runtime, FrameHandles have a `frame` to refer to a
particular stack frame in a frozen process of that runtime.

I could be seen as a lower-level mirror
!

!DmrObjectFormat commentStamp: '<historical>' prior: 0!
I represent the format of objects in the DMR. Ask me questions about
the header of an object.
!

!ShapeMap commentStamp: '<historical>' prior: 0!
I represent the shape of objects as used by mirrors. Mirrors
access instance variables by name, asking the runtime the for
the offsets of the instVars.
!

!SExpression commentStamp: '<historical>' prior: 0!
I am a Smalltalk expression, the minimal unit of Smalltalk semantics, expressed as a tree
!

!OBasicBlock commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!ODominatorTree commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OLiveRange commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OComposedLiveRange commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OSimpleLiveRange commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OOperand commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OTiling commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OValue commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OConstant commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OInstruction commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OBeginInstruction commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OBlockClosure commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!ODefineArgument commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OEndInstruction commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OJump commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OJumpConditional commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OJumpFalse commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OJumpTrue commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OLoadConstant commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OLoadImplicit commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OActivationContext commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OMessageSend commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OPhi commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OPrimitiveOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OBinaryOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OBinaryConstantOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OBinaryVariableOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OTernaryOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OUnaryOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OMemoryOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020-2023 Quorum Software.
	See (MIT) license in root directory.
!

!OLoadOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020-2023 Quorum Software.
	See (MIT) license in root directory.
!

!OStoreOperation commentStamp: '<historical>' prior: 0!
Copyright (c) 2020-2023 Quorum Software.
	See (MIT) license in root directory.
!

!OReturn commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OUseVariable commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OReadVariable commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OWriteVariable commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OControlInstruction commentStamp: '<historical>' prior: 0!
Copyright (c) 2020-2023 Quorum Software.
	See (MIT) license in root directory.
!

!OVariable commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OTemporary commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingBlockInliner commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingBraunAllocator commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingBraunAssigner commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingCFGSimplifier commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingCSSATransformer commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingCodeEmitter commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingInstructionFragmenter commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingInstructionSelector commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingLivenessAnalysis commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingMethodInliner commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingNativizer commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingPhiSimplification commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingRegisterAllocator commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingSSAReconstructor commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingTwoAddressEnforcer commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingUsesVerifier commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingValueNumbering commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!OptimizingVariableBinder commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!ODispatchInliner commentStamp: '<historical>' prior: 0!
Copyright (c) 2020-2023 Quorum Software.
	See (MIT) license in root directory.
!

!OptimizingVisitor commentStamp: '<historical>' prior: 0!
Copyright (c) 2020 Aucerna.
    See (MIT) license in root directory.
!

!PSharedPool class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:13'!
asArray
	^self classPool asArray
! !

!PSharedPool class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:13'!
at: aString
	| var |
	var :=  self classPool
		associationAt: aString asSymbol
		ifAbsent: [ self error: 'no such pool var' ].
	^var value
! !

!PSharedPool class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:13'!
at: aString ifAbsent: aBlock
	| var |
	var := self classPool associationAt: aString asSymbol ifAbsent: [^aBlock value].
	^ var value
! !

!PSharedPool class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:13'!
at: aString put: anObject
	^self classPool
		at: aString 
		put: anObject
! !

!PSharedPool class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:13'!
detect: aBlock ifNone: anotherBlock
	^self classPool detect: aBlock  ifNone: [ ^ anotherBlock value ].
	
! !

!PSharedPool class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:13'!
do: aBlock
	^self classPool do: aBlock

! !

!CharacterConstants class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:41:13'!
initialize
	Cr := Character cr.
	Lf := Character lf.
	Tab := Character tab.
	Space := Character space.
! !

!OperandTypeFlags class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:58:12'!
initialize
MemoryType := 4.
RegisterGroupMask := 3840.
ConstantType := 2.
RegisterSIMD := 256.
ImmediateType := 1.
RegisterGP := 0.
RegisterType := 8.
RegisterSegment := 512.
RegisterSpecific := 768.

! !

!Prefixes class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:44:18'!
initialize
"	LOCK := LegacyPrefix basicNew
		instVarAt: 1 put: 'LOCK';
		instVarAt: 2 put: 1;
		instVarAt: 3 put: 240;
		yourself.
	REPNZ := LegacyPrefix basicNew
		instVarAt: 1 put: 'REPNE';
		instVarAt: 2 put: 1;
		instVarAt: 3 put: 242;
		yourself."
	REX := REXPrefix basicNew
		instVarAt: 1 put: 'REX';
		yourself.
"	REPNE := LegacyPrefix basicNew
		instVarAt: 1 put: 'REPNE';
		instVarAt: 2 put: 1;
		instVarAt: 3 put: 242;
		yourself.
	REPE := LegacyPrefix basicNew
		instVarAt: 1 put: 'REP';
		instVarAt: 2 put: 1;
		instVarAt: 3 put: 243;
		yourself.
	AddressSize_Override := LegacyPrefix basicNew
		instVarAt: 1 put: 'AddressSize_Override';
		instVarAt: 2 put: 4;
		instVarAt: 3 put: 103;
		yourself."
	REX_W := REXPrefix basicNew
		instVarAt: 1 put: 'REX.W';
		yourself.
"	REPZ := LegacyPrefix basicNew
		instVarAt: 1 put: 'REP';
		instVarAt: 2 put: 1;
		instVarAt: 3 put: 243;
		yourself."
	REX_R := REXPrefix basicNew
		instVarAt: 1 put: 'REX.R';
		yourself.
"	OperandSize_Override := LegacyPrefix basicNew
		instVarAt: 1 put: 'OperandSize_Override';
		instVarAt: 2 put: 3;
		instVarAt: 3 put: 102;
		yourself.
	REP := LegacyPrefix basicNew
		instVarAt: 1 put: 'REP';
		instVarAt: 2 put: 1;
		instVarAt: 3 put: 243;
		yourself"
! !

!Registers class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:44:23'!
initialize
	"Nothing to be done here, the initialization is done in Register class >> initializeRegisters."
! !

!ObjectHeaderMasks class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:48:51'!
initialize
		IsBytes := 16r1.
		IsArrayed := 16r2.
		IsNamed := 16r4.
		IsSmall := 16r80

! !

!ObjectHeaderOffsets class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:49:12'!
initialize
	BehaviorOffset := -4.
	FlagsOffset := -5.
	SizeOffset := -6.
	HashOffset := -8.
	LargeSizeOffset := -16
! !

!InlineMessageLinkerFlags class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 13:59:45'!
initialize
	_Flags := -5.
	_SmallSize := -6.
	_Hash := -8.
	_Reserved := -2.
	_ExtendedSize := -3.

! !

!SendSiteFlags class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 13:59:45'!
initialize
		IsStaticSend := 16r1.
		IsSuperSend := 16r2.
		IsPolymorphic := 16r4.
		HasBeenReset := 16r8
	
! !

!SExpressionTypes class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:49:05'!
initialize
	MethodId := 1.
	BlockId := 2.
	IdentifierId := 3.
	LiteralId := 4.
	MessageId :=5.
	CascadeId := 6.
	BraceId := 7.
	AssignmentId := 8.
	ReturnId := 9
! !

!AstBindingTypes class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:42:20'!
initialize
	NilId := 1.
	TrueId := 2.
	FalseId := 3.
	ArgumentId := 4.
	TemporaryId := 5.
	SelfId := 6.
	SuperId := 7.
	DynamicVarId := 14.
	NestedDynamicVarId := 15.
	PushRid := 50.
	PopRid := 51
! !

!AstNodeTypes class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:41:16'!
initialize
	MethodId := 101.
	BlockId := 102.
	IdentifierId := 103.
	LiteralId := 104.
	MessageId := 105.
	CascadeId := 106.
	BraceId := 107.
	AssignmentId := 108.
	ReturnId := 109.
	PragmaId := 110
! !

!ClosureElementTypes class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:41:25'!
initialize
	Self := 0.
	LocalArgument := 1.
	Environment := 2.
	EnvironmentValue := 3
! !

!SCompiledBlockFlags class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:42:28'!
initialize
	BlockArgCount := 1 thru: 6.
	BlockTempCount := 7 thru: 14.
	BlockId := 15 thru: 22.
	BlockCapturesSelf := 1 bitShift: 23 - 1.
	BlockCapturesHome := 1 bitShift: 24 - 1.
	BlockEnvCount := 25 thru: 31
! !

!SCompiledMethodFlags class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:42:22'!
initialize
	ArgCount := 1 thru: 6.
	BlockCount := 7 thru: 13.
	TempCount := 14 thru: 21.
	CapturesSelf := 1 bitShift: 22 - 1.
	HasEnvironment := 1 bitShift: 23 - 1.
	HasFrame := 1 bitShift: 24 - 1.
	Debuggable := 1 bitShift: 25 - 1.
	EnvCount := 26 thru: 31
! !

!RegistersRISCV class methodsFor: 'class initialization' stamp: 'KenD 10/14/2022 13:18:08'!
initialize

	RegR        := Tmp0. "X5 Receiver/Result"
	RegA        := Tmp1. "X6 Arg"
	RegT        := Tmp2. "X7 Temp"
	RegV        := Tmp3. "X28"
	RegTmp0 := Tmp4. "X29"
	RegFlags := Tmp5.  "X30 Condition Flags"
	RegTmp1 := Tmp6. "X31"

	RegM       := Sav1.   "X9"
	RegS        := Sav2.  "X18 Selector"
	RegE        := Sav3.  "X19 Environment"
	RegNil      := Sav4. "X20"
	RegTrue  := Sav5. "X21"
	RegFalse := Sav6. "X22"
	RegG       := Sav7. "X23 Globals"
	
	RegZero := Zero.          "X0"
	RegLink := ReturnAddr. "X1"
	RegSP   := StackPtr.      "X2"
	RegFP   := FramePtr.     "X8"

	RegX0 := FTmp0. "F0"
	RegX1 := FTmp1. "F1"
	
! !

!Subject methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:10'!
_gate
	^gate
! !

!Subject methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:10'!
_gate: aMirageGate
	gate := aMirageGate
! !

!Subject methodsFor: 'system' stamp: 'KenD 11/22/2023 07:49:10'!
doesNotUnderstand: aMessage
	| send |
	send := MessageSend message: aMessage to: self.
			^ gate dispatch: send
! !

!Subject methodsFor: 'inspector extensions' stamp: 'KenD 11/22/2023 07:49:10'!
gtDisplayString
	^self printString
! !

!Subject methodsFor: 'inspector extensions' stamp: 'KenD 11/22/2023 07:49:10'!
isSelfEvaluating
	^false
! !

!Subject methodsFor: 'inspector extensions' stamp: 'KenD 11/22/2023 07:49:10'!
shouldBePrintedAsLiteral
	^false
! !

!Subject methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:10'!
isKindOf: aClass
	"Answer whether the class, aClass, is a superclass or class of the receiver.
	The current implemementation allows for a Trait to be used as argument"

	^ self class == aClass or: [ self class inheritsFrom: aClass ]
! !

!Subject methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:10'!
perform: aSymbol withArguments: anArray
	| message |
	message := Message
		selector: #perform:withArguments:
		arguments: (Array with: aSymbol with: anArray).
	^ self doesNotUnderstand: message
! !

!Subject methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:10'!
printOn: aStream
	aStream nextPutAll: '{'; print: gate; nextPutAll: '}'

! !

!Subject methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:10'!
printString
	^String streamContents: [ :s | self printOn: s ]
! !

!Subject methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:10'!
printString2
	| message |
	message := MessageSend
		receiver: self
		selector: #printString
		arguments: #().
	^ self doesNotUnderstand: message
! !

!Subject class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:10'!
initialize
	Counts := IdentityDictionary new
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
block
	^block
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
block: aPCompiledMethod
	block := aPCompiledMethod
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
evaluateWith: anObject with: anotherObject
	block argumentCount = 2
		ifFalse: [^super evaluateWith: anObject with: anotherObject].
	^self value: anObject value: anotherObject
	
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
home: anObject
	home := anObject
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
isSelfEvaluating
	^false
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
value
	^ home evaluateClosure: self
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
value: anObject
	^home evaluateClosure: self with: anObject
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
value: anObject1 value: anObject2
	^ home evaluateClosure: self with: anObject1 with: anObject2
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
value: anObject1 value: anObject2 with: anObject3
	^ home evaluateBlock: self with: anObject1 with: anObject2 with: anObject3
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
whileFalse: aBlockSubject
	| result |
	[ result := home evaluateClosure: self.
	result _gate handle asLocalBoolean ] 
		whileFalse: [ home evaluateClosure: aBlockSubject _gate handle oid ]
! !

!SClosure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
whileTrue: aBlockSubject
	| result |
	[ result := home evaluateClosure: self.
	result _gate handle asLocalBoolean ]
		whileTrue: [ home evaluateClosure: aBlockSubject _gate handle oid ]
! !

!NativeCode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:59:43'!
code
	^machineCode
! !

!NativeCode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:59:43'!
code: bytes
	machineCode := bytes.

! !

!NativeCode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:59:43'!
compiledCode: anObject
	compiledCode := anObject

! !

!NativeCode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:59:43'!
disassembledAmd64
	^machineCode disassembledAmd64
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
argumentCount
	^format bitsAt: ArgCount
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
argumentCount: anInteger
	format := format bitsAt: ArgCount put: anInteger
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
astcodes
	^astcodes
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
astcodes: aCollection
	astcodes := aCollection
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
beDebugabble
	format := format bitOr: Debuggable
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
blockCount
	^format bitsAt: BlockCount
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
blockCount: anInteger
	format := format bitsAt: BlockCount put: anInteger
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
blocks
	self hasBlocks ifFalse: [^#()].
	^self select: [:literal | literal isBlock]
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
capturesSelf
	^ format anyMask: CapturesSelf
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
capturesSelf: aBoolean
	format := aBoolean
				  ifTrue: [ format bitOr: CapturesSelf ]
				  ifFalse: [ format bitClear: CapturesSelf ]
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
classBinding
	^class
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
classBinding: aClass
	class := aClass
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
copyWithLiterals: aCollection
	| result |
	result := self species withAll: aCollection.
	^ result
		astcodes: astcodes;
		classBinding: class;
		format: format;
		optimizedCode: optimizedCode;
		selector: selector;
		source: source;
		yourself
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
dynamicVariableNamed: aSymbol
	^class dynamicVariableNamed: aSymbol
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
environmentCount
	^format bitsAt: EnvCount
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
environmentCount: anInteger
	format := format bitsAt: EnvCount put: anInteger
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
hasBlocks
	^self blockCount > 0
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
hasEnvironment
	^ format anyMask: HasEnvironment
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
hasEnvironment: aBoolean
	format := aBoolean
				  ifTrue: [ format bitOr: HasEnvironment ]
				  ifFalse: [ format bitClear: HasEnvironment ]
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
hasFrame
	^ format anyMask: HasFrame
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
hasFrame: aBoolean
	format := aBoolean
				  ifTrue: [ format bitOr: HasFrame ]
				  ifFalse: [ format bitClear: HasFrame ]
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
initialize
	super initialize.
	format := 0
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
isCallback
	^false
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
isCalloutMethod
	^ false
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
isDebuggable
	^ format anyMask: Debuggable
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
isFrameless
	^ self hasFrame not
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
literals
	^Array withAll: self
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
pragma: aPragmaNode

! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
selector
	^selector
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
selector: aSymbol
	selector := aSymbol
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
sexpressions
	| decoder |
	decoder := AstcodeDecoder new
		stream: astcodes readStream;
		method: self.
	^decoder decodeMethod
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
signature
	^class-> selector
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
source
	^source
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
source: aString
	source := aString
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
tempCount
	^format bitsAt: TempCount
! !

!SCompiledMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:17'!
tempCount: anInteger
	format := format bitsAt: TempCount put: anInteger
! !

!SCompiledMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
format
	^format
! !

!SCompiledMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
format: anInteger
	format := anInteger
! !

!SCompiledMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
optimizedCode
	^optimizedCode
! !

!SCompiledMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
optimizedCode: anObject
	optimizedCode := anObject
! !

!SCompiledMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
prepareForExecution
	optimizedCode ifNil: [ optimizedCode := self sexpressions ].
	^ optimizedCode
! !

!SCompiledMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:17'!
gtDisplayOn: stream
stream
		nextPutAll: self classBinding name;
		nextPutAll: '>>';
		print: selector
! !

!SCompiledMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:17'!
printOn: aStream
	aStream
		print: self classBinding;
		nextPutAll: '>>';
		print: selector;
		cr.
	source
		ifNotNil: [ aStream
				cr;
				nextPutAll: source ]
! !

!SCompiledMethod class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:17'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SCompiledMethod class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:17'!
new: anInteger
	^ (self basicNew: anInteger) initialize
! !

!SCallbackMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
descriptor
	^descriptor
! !

!SCallbackMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
descriptor: anFFIDescriptor
	descriptor := anFFIDescriptor 
! !

!SCallbackMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
isCallback
	^true
! !

!SCallbackMethod methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
pragma: anSPragmaNode
	descriptor := anSPragmaNode info
! !

!SCallbackMethod class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:41:17'!
behaviorNativeCodeSlot
	"callback methods have a special machine code. Its bytes are of
	class ByteArray, but the behavior of this ByteArray is special:
	it has an extra slot that allows to find the native code object
	corresponding to this callback"
	^4
! !

!SCalloutMethod methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
pragma: anSPragmaNode
	descriptor := anSPragmaNode info.
	symbol := anSPragmaNode name
! !

!SFFIDescriptor methodsFor: 'calls' stamp: 'KenD 11/22/2023 07:42:26'!
arguments: aCollection
	self replaceFrom: 3 to: 3 + aCollection size -1 with: aCollection
! !

!SFFIDescriptor methodsFor: 'calls' stamp: 'KenD 11/22/2023 07:42:26'!
callingConvention: anInteger
	self at: 1 put: anInteger
! !

!SFFIDescriptor methodsFor: 'calls' stamp: 'KenD 11/22/2023 07:42:26'!
return: anInteger
	self at: 2 put: anInteger
! !

!SFFIDescriptor class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:42:26'!
initialize
	self initializeFFITypes; initializeCallingConventions
! !

!SFFIDescriptor class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:42:26'!
initializeCallingConventions
	FFICallingConventions := Dictionary new.
	FFICallingConventions
		at: 'cdecl' put: 20;
		at: 'com' put: 21;
		at: 'callback' put: 22
! !

!SFFIDescriptor class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:42:26'!
initializeFFITypes
	FFITypes := Dictionary new.
	FFITypes
		at: 'char' put: 1;
		at: 'uchar' put: 2;
		at: 'short' put: 3;
		at: 'ushort' put: 4;
		at: 'long' put: 5;
		at: 'ulong' put: 6;
		at: 'large' put: 7;
		at: 'ularge' put: 8;
		at: 'intptr' put: 9;
		at: 'uintptr' put: 10;
		at: 'pointer' put: 11;
		at: 'struct' put: 12;
		at: 'float' put: 13;
		at: 'double' put: 14
! !

!SFFIDescriptor class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:26'!
ret: aString args: aCollection cc: ccName
	| args return cc result |
	args := aCollection
		collect: [ :argname | 
			FFITypes
				at: argname asString
				ifAbsent: [ self error: 'undefined argument type ' , argname ] ].
	return := FFITypes
		at: aString
		ifAbsent: [ self error: 'undefined result type ' , aString ].
	cc := FFICallingConventions
		at: ccName
		ifAbsent: [ self error: 'unsupported calling convention ' , ccName ].
	result := self new: args size + 2.
	^ result
		callingConvention: cc;
		return: return;
		arguments: args
! !

!PoolDictionary methodsFor: 'adding' stamp: 'KenD 11/22/2023 07:41:12'!
add: anAssociation
	anAssociation key isString
		ifFalse: [self error: 'Pools are keyed with Strings'].
	^super add: anAssociation
! !

!PoolDictionary methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:12'!
at: key
	^super at: key asString reduced
! !

!PoolDictionary methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:12'!
at: key ifAbsent: aBlock
	^super at: key asString reduced ifAbsent: aBlock
! !

!PoolDictionary methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:12'!
at: key ifPresent: aBlock
	^super at: key asString reduced ifPresent: aBlock
! !

!PoolDictionary methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:12'!
at: key put: value
	^super at: key asString put: value
! !

!PoolDictionary methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:12'!
beConstant: aBoolean
	constant := aBoolean
! !

!PoolDictionary methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:12'!
beConstantPool
	constant := true
! !

!PoolDictionary methodsFor: 'inquiries' stamp: 'KenD 11/22/2023 07:41:12'!
includesKey: key
	^super includesKey: key asString reduced
! !

!PoolDictionary methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:12'!
initialize: anInteger
	super initialize: anInteger.
	constant := false
! !

!PoolDictionary methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:12'!
isConstant
	^constant
! !

!PoolDictionary methodsFor: 'removing' stamp: 'KenD 11/22/2023 07:41:12'!
removeKey: key ifAbsent: aBlock
	super removeKey: key asString reduced ifAbsent: aBlock.
	^key
! !

!PoolDictionary class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:12'!
newConstantPool
	^self new beConstantPool
! !

!Builder methodsFor: 'services' stamp: 'KenD 11/22/2023 07:57:23'!
add: anObject
	offsets at: anObject put: nil.
	objects add: anObject
! !

!Builder methodsFor: 'closure' stamp: 'KenD 11/22/2023 07:57:23'!
addClosure
	closure := ModuleClosure new module: module; builder: self.
	closure traverse: roots.
! !

!Builder methodsFor: 'querying' stamp: 'KenD 11/22/2023 07:57:23'!
alreadyAdded: anObject
	^offsets includesKey: b
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
base
	"
		Return preferred base address for this segment
	"
	^ base
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
base: anInteger
	"
	 Set the preferred base address for this segment. 
	 This is a hint only, loaders may load a segment
	 at a different address but then they must relocate.
	"
	base := anInteger
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
configureSpace
	| basemap free limit |
	basemap := base // 2.
	free := base + size // 2.
	limit := base + size + 16r20000 // 2.
	space
		base: basemap;
		nextFree: free;
		softLimit: limit;
		commitedLimit: limit;
		reservedLimit: limit
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
encodedReferenceTo: anObject
	| offset |
	anObject _isSmallInteger
		ifTrue: [ ^ anObject value * 2 + 1 ].
	offset := offsets at: anObject.
	^base + offset
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
image
	^stream contents
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
initialize
	offsets := IdentityDictionary new.
	objects := OrderedCollection new.
	stream := ByteArray new writeStream.
	nextHash := 1.
	base := 0
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
layoutObjects
	| offset oop |
	offset := self objectsOffset.
	objects
		do: [ :obj | 
			oop := offset + obj headerSizeInBytes.
			offsets at: obj put: oop.
			offset := oop + obj bodySizeInBytes ].
	size := offset
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
nextHash
	"
		Local version of ProtoObject>>basicHash
	"
	
	| result shifted |
	result := nextHash.	
	shifted := nextHash bitShift: -1.
	nextHash := (nextHash bitAnd: 1) = 0
		ifTrue: [shifted]
		ifFalse: [shifted bitXor: 16rB9C8].
	^result
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
objectsOffset
	^self class objectsOffset
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
offsetOf: anObject
	^ offsets at: anObject
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
stream: aWriteStream
	stream := aWriteStream
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
wordSize: anInteger
	wordSize := anInteger
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
write
	module prepareForSnapshot: self.
	self
		addClosure;
		layoutObjects;
		configureSpace;
		writeSignature;
		writeHeader;
		writeObjects
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
writeObjectBody: obj
	obj isBytes
		ifTrue: [ self writeObjectBytes: obj ]
		ifFalse: [ self writeObjectSlots: obj ]
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
writeObjectBytes: obj
	| current aligned |
	stream nextPutAll: obj bytes.
	current := stream position.
	aligned := current alignedTo: wordSize.
	aligned - current timesRepeat: [ stream nextPut: 0 ]

! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
writeObjectHeader: obj
	| behavior |
	obj isSmall
		ifFalse: [ stream
				uint32le: obj size;
				uint32le: 0 ].
	behavior := self encodedReferenceTo: obj behavior.
	stream
		uint16le: obj headerHash;
		nextPut: obj headerSmallSize;
		nextPut: obj headerFlags;
		uint32le: behavior.
	self ASSERT: stream position == (self offsetOf: obj)
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
writeObjectSlots: obj
	obj slots do: [ :slot | self writeReferenceTo: slot ].

! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
writeObjects
	self ASSERT: stream position == self objectsOffset.
	objects
		do: [ :obj | 
			self
				writeObjectHeader: obj;
				writeObjectBody: obj ]
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
writeReferenceTo: slot
	| encoded |
	encoded := self encodedReferenceTo: slot.
	wordSize = 8
		ifFalse: [ self ASSERT: false ].
	stream uint64le: encoded
! !

!Builder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
writeSignature
	stream
		nextPutAll: 'P_IM_S' asByteArray;
		nextPut: Character lf asInteger;
		nextPut: 0
! !

!Builder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:57:23'!
module: aModule
	module := aModule
! !

!Builder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:57:23'!
objects
	^ objects
! !

!Builder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:57:23'!
roots: aCollection
	roots := aCollection
! !

!Builder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:57:23'!
space: aGCSpace
	space := aGCSpace
! !

!Builder methodsFor: 'own services' stamp: 'KenD 11/22/2023 07:57:23'!
writeHeader
	"See ImageSegment.h for structure of a segment header"
	| reserved |
	reserved := (space reservedLimit value - space base value) * 2.
	stream uint64le: base; uint64le: size; uint64le: reserved.
	self writeReferenceTo: module
! !

!Builder methodsFor: 'writing' stamp: 'KenD 11/22/2023 07:57:23'!
writeTo: aStream
	self stream: aStream; write.

! !

!Builder methodsFor: 'writing' stamp: 'KenD 11/22/2023 07:57:23'!
writeToFile: filename
	filename binaryWriteStreamDo: [ :s | self writeTo: byteStream ]
! !

!Builder class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
behaviorOffset
	"
		The offset at which the behavior is from the oop (negated)
	"

	^ -4
! !

!Builder class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
nilOffset
	^self objectsOffset + 8
! !

!Builder class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:57:23'!
objectsOffset
	"
		The offset at which header terminates and objects are stored.
		See ImageSegment.h for structure of a segment header
	"
	^40
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
checkNumberEnd: position
	| char |
	stream atEnd ifTrue: [^self].
	char := stream peek.
	char = $. ifFalse: [^self].
	stream skip: 1.
	stream atEnd
		ifFalse: [stream peek isDigit
			ifTrue: [self error: 'invalid number' at: position]].
	stream skip: -1
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
completeFloat: anInteger
	| tenth |
	tenth := 10 raisedToInteger: self nextExponent.
	^(anInteger * tenth) asFloat
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
completeNumber: anInteger after: aCharacter
	aCharacter = $. ifTrue: [
		^(stream peekFor: $s)
			ifTrue: [self nextScaledFrom: anInteger fractionDigits: 0]
			ifFalse: [self nextFloat: anInteger]].
	(aCharacter = $e or: [aCharacter = $E])
		ifTrue: [^self completeFloat: anInteger].
	aCharacter = $r ifTrue: [^self nextIntegerRadix: anInteger].
	aCharacter = $s ifTrue: [^self nextScaledFrom: anInteger fractionDigits: 0].
	(anInteger = 0 and: [aCharacter = $x or: [aCharacter = $X]])
		ifTrue: [^self nextIntegerRadix: 16].
	stream skip: -1.
	^anInteger
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
completeNumber: anInteger at: start
	| number |
	stream atEnd ifTrue: [^anInteger].
	number := anInteger.
	number := self completeNumber: anInteger after: stream next.
	self checkNumberEnd: start.
	^number
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
digitFromChar: char base: radix
	| c |
	char isDigit ifTrue: [^char digitValue].
	char = $r ifTrue: [^nil].
	char = $x ifTrue: [^nil].
	char = $X ifTrue: [^nil].
	c := char asUppercase.
	(c asInteger between: $A asInteger and: $Z asInteger) ifFalse: [^nil].
	(c !!= $E and: [radix <= c digitValue]) ifTrue: [^nil].
	(c = $E and: [radix = 10]) ifTrue: [^nil].
	^c digitValue
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
endToken
	self error: 'end of stream' at: stream position
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
error: aString at: position
	error := aString -> position.
	return value: nil
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
negativeNumber
	| position |
	stream atEnd ifTrue: [^nil].
	stream peek isDigit ifFalse: [^nil].
	position := stream position.
	^self next key negated -> position
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
next
	| char |
	return isNil ifTrue: [return := [:value | ^value]].
	char := self nextChar.
	char isNil ifTrue: [^self endToken].
	char = $- ifTrue: [^self negativeNumber].
	char = $+ ifTrue: [^self positiveNumber].
	char isDigit ifTrue: [^self nextNumber: char].
	^nil
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
nextChar
	^stream skipSeparators atEnd ifFalse: [stream next]
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
nextDigit: radix
	| char digit |
	stream atEnd ifTrue: [^nil].
	char := stream next.
	digit := self digitFromChar: char base: radix.
	digit isNil ifTrue: [
		stream skip: -1.
		^nil].
	radix <= digit
		ifTrue: [self error: 'digit greater than radix' at: stream position].
	^digit
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
nextExponent
	| negated exp |
	negated := false.
	(stream peekFor: $+) ifFalse: [negated := stream peekFor: $-].
	exp := self nextIntegerRadix: 10.
	negated ifTrue: [exp := exp negated].
	^exp
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
nextFloat: aNumber
	| base digit e exp |
	digit := self nextDigit: 10.
	digit isNil ifTrue: [
		stream skip: -1.
		^aNumber].
	e := 1.
	base := aNumber * 10 + digit.
	[
		digit := self nextDigit: 10.
		digit isNil]
		whileFalse: [
			base := base * 10 + digit.
			e := e + 1].
	((stream peekFor: $E) or: [stream peekFor: $e]) ifTrue: [
		exp := self nextExponent.
		^(base * (10 raisedToInteger: exp - e)) asFloat].
	(stream peekFor: $s) ifTrue: [^self nextScaledFrom: base fractionDigits: e].
	^(base * (10 raisedToInteger: e negated)) asFloat
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
nextIntegerRadix: radix
	| value valid digit |
	value := 0.
	valid := false.
	[
		digit := self nextDigit: radix.
		digit isNil]
		whileFalse: [
			valid := true.
			value := value * radix + digit].
	valid ifFalse: [self error: 'digit missing' at: stream position + 1].
	^value
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
nextNumber: aCharacter
	| start number digit |
	start := stream position.
	number := aCharacter digitValue.
	[
		digit := self nextDigit: 10.
		digit isNil]
		whileFalse: [number := number * 10 + digit].
	number := self completeNumber: number at: start.
	^number -> (start thru: stream position)
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
nextScaledFrom: aNumber fractionDigits: digits
	| scale denominator sd |
	scale := (stream atEnd not and: [stream peek isDigit])
		ifTrue: [self nextIntegerRadix: 10].
	denominator := 10 raisedToInteger: digits.
	sd := ScaledDecimal
		numerator: aNumber
		denominator: denominator
		scale: scale.
	^sd reduced
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
positiveNumber
	| position |
	stream peek isDigit ifFalse: [^nil].
	position := stream position.
	^self next key -> position
! !

!NumberParser2 methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:11'!
reset
	stream reset.
	return := nil
! !

!NumberParser2 methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:11'!
error
	^error
! !

!NumberParser2 methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:11'!
on: aString
	stream := aString readStream.
	return := nil
! !

!NumberParser2 methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:11'!
nextValue
	^self next ifNil: [0] ifNotNil: [:assoc | assoc key]
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
+ delta
	delta isInteger ifTrue: [^start + delta thru: end + delta].
	delta isPoint ifTrue: [^start + delta x thru: end + delta y].
	^start + delta start thru: end + delta end
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
- delta
	^self + delta negated
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
// anInteger
	^start // anInteger thru: end // anInteger
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
center
	^start + end // 2
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
down: anInteger
	^start thru: end + anInteger
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
length
	^end - start + 1
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
mask
	^(2 raisedTo: end) - (2 raisedTo: start - 1)
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
max
	^start max: end
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
min
	^start min: end
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
negated
	^start negated thru: end negated
! !

!Stretch methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 07:41:10'!
shift
	^(start - 1) negated
! !

!Stretch methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:41:10'!
= aStretch
	self class == aStretch class ifFalse: [^false].
	^start = aStretch start and: [end = aStretch end]
! !

!Stretch methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:41:10'!
hash
	^start hashWith: end
! !

!Stretch methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:10'!
end
	^end
! !

!Stretch methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:10'!
end: anInteger
	end := anInteger
! !

!Stretch methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:10'!
start
	^start
! !

!Stretch methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:10'!
start: anInteger
	start := anInteger
! !

!Stretch methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:10'!
includes: anInteger
	^anInteger between: start and: end
! !

!Stretch methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:10'!
intersects: aStretch
	self isEmpty ifTrue: [^false].
	(aStretch includes: start) ifTrue: [^true].
	^aStretch includes: end
! !

!Stretch methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:10'!
isEmpty
	^end < start
! !

!Stretch methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:10'!
notEmpty
	^start <= end
! !

!Stretch methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:10'!
printOn: aStream
	aStream
		nextPutAll: start asString;
		nextPutAll: ' thru: ';
		nextPutAll: end asString
! !

!Stretch class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:10'!
from: start thru: end
	^self new start: start; end: end
! !

!ISAInstruction methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:58:12'!
= instruction
	self class == instruction class ifFalse: [^false].
	prefix = instruction prefix ifFalse: [^false].
	mnemonic = instruction mnemonic ifFalse: [^false].
	(self hasOperands or: [instruction hasOperands]) ifFalse: [^true].
	operands isNil ifTrue: [^false].
	operands size = instruction arity ifFalse: [^false].
	operands
		with: instruction operands
		do: [:op1 :op2 | op1 = op2 ifFalse: [^false]].
	^true
! !

!ISAInstruction methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:58:12'!
hasOperands
	^operands notNil and: [operands size > 0]
! !

!ISAInstruction methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:58:12'!
hash
	^prefix hashWith: mnemonic with: self operand1 with: self operand2
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
arity
	^operands size
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
beTemplate
	1 to: operands size do: [:i | | op |
		op := operands at: i.
		operands at: i put: op template]
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
jumpOffset32
	self ASSERT:
		((self isJump or: [ self isCall ]) and: [ 
			 operands anyone isImmediate ]).
	^ operands first value + self sizeInBytes32
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
jumpOffset64
	self ASSERT:
		((self isJump or: [ self isCall ]) and: [ 
			 operands anyone isImmediate ]).
	^ operands first value + self sizeInBytes64
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
mnemonic
	^mnemonic
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
mnemonic: aString
	mnemonic := aString asLowercase.
	template notNil ifTrue: [template mnemonic: aString]
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
operand1
	^operands notNil ifTrue: [operands at: 1 ifAbsent: nil]
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
operand2
	^operands notNil ifTrue: [operands at: 2 ifAbsent: nil]
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
operand3
	^operands at: 3
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
operand4
	^operands at: 4
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
operands
	^operands ifNil: #()
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
operands: aCollection
	operands := aCollection collect: [:op | self operandFrom: op].
	template notNil
		ifTrue: [template operands: (operands collect: [:op | op template])]
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
prefix
	^prefix
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
prefix: aLegacyPrefix
	prefix := aLegacyPrefix.
	template notNil ifTrue: [template prefix: aLegacyPrefix]
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
sizeInBytes32
	| stream |
	stream := #[  ] writeStream.
	self writeEncoding32On: stream.
	^ stream size
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
sizeInBytes64
	| stream |
	stream := #[  ] writeStream.
	self writeEncoding64On: stream.
	^ stream size
! !

!ISAInstruction methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:12'!
spec
	^self encoder spec
! !

!ISAInstruction methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:12'!
db: byte
	| imm |
	mnemonic := '.db'.
	imm := ISAImmediate new value: byte.
	operands := {imm}
! !

!ISAInstruction methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:12'!
operandFrom: anObject
	anObject isInteger ifTrue: [^ISAImmediate new value: anObject].
	anObject isString ifTrue: [
		^anObject first = $@
			ifTrue: [anObject]
			ifFalse: [MemoryOperand fromString: anObject]].
	^anObject
! !

!ISAInstruction methodsFor: 'encoding' stamp: 'KenD 11/22/2023 07:58:12'!
encoder
	^InstructionEncoder new instruction: self
! !

!ISAInstruction methodsFor: 'encoding' stamp: 'KenD 11/22/2023 07:58:12'!
encoding32
	| s |

	s := ReadWriteStream on: ByteArray new.
	self writeEncoding32On: s.
	^ s contents.

! !

!ISAInstruction methodsFor: 'encoding' stamp: 'KenD 11/22/2023 07:58:12'!
encoding64
	| s |

	s := ReadWriteStream on: ByteArray new.
	self writeEncoding64On: s.
	^ s contents.

! !

!ISAInstruction methodsFor: 'encoding' stamp: 'KenD 11/22/2023 07:58:12'!
mod
	(operands conform: [:op | op isRegister or: [op isImmediate]])
		ifTrue: [^2r11].
	operands do: [:op | op isMemory ifTrue: [^op mod]]
! !

!ISAInstruction methodsFor: 'encoding' stamp: 'KenD 11/22/2023 07:58:12'!
writeEncoding32On: aStream
	^self encoder wordSize: 4; writeEncodingOn: aStream
! !

!ISAInstruction methodsFor: 'encoding' stamp: 'KenD 11/22/2023 07:58:12'!
writeEncoding64On: aStream
	^self encoder wordSize: 8; writeEncodingOn: aStream
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
hasDirectMemoryReference
	^operands anySatisfy: [:op | op isDirectMemoryReference]
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
hasDisplacement
	operands isNil ifTrue: [^false].
	^operands anySatisfy: [:op | op isMemory and: [op hasDisplacement]]
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
hasSib
	operands isNil ifTrue: [^false].
	^operands anySatisfy: [:op | op isMemory and: [op hasSib]]
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
isCall
	^mnemonic = 'call'
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
isJump
	^mnemonic first = $j or: [mnemonic beginsWith: 'loop']
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
isLike: anISAInstruction
	self class = anISAInstruction class ifFalse: [^false].
	mnemonic = anISAInstruction mnemonic ifTrue: [^self = anISAInstruction].
	operands = anISAInstruction operands ifFalse: [^false].
	^self spec isLike: anISAInstruction spec
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
isPushFP
	| operand |
	^(mnemonic beginsWith: 'push')
		and: [
			operand := operands at: 1.
			operand isRegister]
		and: [operand index = rbp index]
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
isReturn
	^mnemonic = 'ret'
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
isTemplate
	1
		to: operands size
		do: [:i | (operands at: i) isTemplate ifFalse: [^false]].
	^true
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
isTestAL1
	mnemonic = 'test' ifFalse: [^false].
	operands first = al ifFalse: [^false].
	operands second isImmediate ifFalse: [^false].
	^operands second value = 1
! !

!ISAInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:12'!
overridesAddressSize: anInteger
	| length |
	operands isNil ifTrue: [^false].
	length := anInteger bitShift: 3.
	^operands
		anySatisfy: [:op | op isMemory
			and: [op base notNil]
			and: [op pointerLength !!= length]]
! !

!ISAInstruction methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:58:12'!
printOn: aStream
	aStream nextPutAll: mnemonic.
	operands isNil ifTrue: [^self].
	operands
		do: [:op | aStream space; nextPutAll: op asString]
		separatedBy: [aStream nextPut: $,]
! !

!ISAInstruction methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:12'!
template
	^template
! !

!ISAInstruction methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:12'!
useTemplate
	template := self shallowCopy.
	mnemonic isNil ifTrue: [^self].
	template mnemonic: mnemonic; prefix: prefix.
	operands notNil
		ifTrue: [template operands: (operands collect: [:op | op template])]
! !

!ISAInstruction methodsFor: 'updating' stamp: 'KenD 11/22/2023 07:58:12'!
updateTemplate: anISAInstruction
	| arity array |
	arity := operands size.
	array := Array new: arity.
	1 to: arity do: [:i | array at: i put: (operands at: i) template].
	anISAInstruction
		prefix: prefix;
		mnemonic: mnemonic;
		operands: array
! !

!ISAInstruction class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:58:12'!
db: byte
	^self new db: byte
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
, anISAOperand
	^{self. anISAOperand}
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
baseExtension
	^0
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
indexExtension
	^0
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
length
	^length
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
length: anInteger
	length := anInteger
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
memoryLength
	^length
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
offsetOfIndex: index
	length = 64 ifTrue: [^index - 1 bitShift: 3].
	length = 32 ifTrue: [^index - 1 bitShift: 2].
	length = 8 ifTrue: [^index - 1].
	self error: 'invalid operand'
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
operand1
	^self
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
operand2
	^self
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
regExtension
	^0
! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
sizeInBits
	^self length

! !

!ISAOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
sizeInBytes
	^length // 8
! !

!ISAOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isDirectMemoryReference
	^false
! !

!ISAOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isImmediate
	^false
! !

!ISAOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isMemory
	^false
! !

!ISAOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isRegister
	^false
! !

!ISAOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isTemplate
	^false
! !

!ISAOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
needsExtraBit
	^false
! !

!ISAOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
prefers: anOperandType to: anotherOperandType
	^false
! !

!ISAOperand methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:23'!
template
	^self
! !

!ISAOperand class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:23'!
new
	^super new initialize
! !

!ISAImmediate methodsFor: 'comparing' stamp: 'KenD 11/22/2023 13:56:07'!
= operand
	self class == operand class ifFalse: [^false].
	value = operand value ifFalse: [^false].
	^length = operand length
! !

!ISAImmediate methodsFor: 'comparing' stamp: 'KenD 11/22/2023 13:56:07'!
hash
	^value hashWith: length
! !

!ISAImmediate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
bytes
	| bytes v |
	bytes := ByteArray new: length // 8.
	v := value.
	v < 0 ifTrue: [v := v + (1 bitShift: length)].
	1 to: bytes size do: [:i | 
		bytes at: i put: (v bitAnd: 16rFF).
		v := v bitShift: -8].
	^bytes
! !

!ISAImmediate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
defaultLength
	value < -168000000000000000 ifTrue: [^128].
	value < -16r80000000 ifTrue: [^64].
	value < -16r8000 ifTrue: [^32].
	value < -16r80 ifTrue: [^16].
	value < 16r80 ifTrue: [^8].
	value < 16r8000 ifTrue: [^16].
	value < 16r80000000 ifTrue: [^32].
	value < 16r8000000000000000 ifTrue: [^64].
	^128
! !

!ISAImmediate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
memoryLength
	^nil
! !

!ISAImmediate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
value
	^value
! !

!ISAImmediate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
value: anInteger
	value := anInteger.
	length := self defaultLength
! !

!ISAImmediate methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
isCompatibleWith: anOperandType
	(value = 0 and: [anOperandType name = '0']) ifTrue: [^true].
	(value = 1 and: [anOperandType name = '1']) ifTrue: [^true].
	(value = 3 and: [anOperandType name = '3']) ifTrue: [^true].
	^anOperandType isImmediate
		and: [anOperandType hasImmediateFlag]
		and: [length <= anOperandType length]
! !

!ISAImmediate methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
prefers: anOperandType to: otherOperandType
	anOperandType length < otherOperandType length ifTrue: [^true].
	(value = 0 and: [anOperandType name = '0']) ifTrue: [^true].
	(value = 1 and: [anOperandType name = '1']) ifTrue: [^true].
	(value = 3 and: [anOperandType name = '3']) ifTrue: [^true].
	^false
! !

!ISAImmediate methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isImmediate
	^true
! !

!ISAImmediate methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
looksLikeAddress
	^value > 65536 and: [value even]
! !

!ISAImmediate methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:56:07'!
printOn: aStream
	| v |
	v := value isNil ifTrue: ['???'] ifFalse: [value hex].
	aStream nextPutAll: v
! !

!ISAImmediate methodsFor: 'services' stamp: 'KenD 11/22/2023 13:56:07'!
template
	(0 <= value and: [value < 4]) ifTrue: [^self copy].
	^self class new value: length; length: length
! !

!MemoryOperand methodsFor: 'comparing' stamp: 'KenD 11/22/2023 13:23:23'!
= operand
	self class == operand class ifFalse: [^false].
	length = operand length ifFalse: [^false].
	base = operand base ifFalse: [^false].
	index = operand index ifFalse: [^false].
	self scale = operand scale ifFalse: [^false].
	displacement = operand displacement ifFalse: [^false].
	^segment = operand segment
! !

!MemoryOperand methodsFor: 'comparing' stamp: 'KenD 11/22/2023 13:23:23'!
hash
	^length
		hashWith: base
		with: index
		with: scale
		with: displacement
		with: segment
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
base
	^base
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
base: aRegister
	base := aRegister
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
baseExtension
	^base notNil ifTrue: [base extensionBit] ifFalse: [0]
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
displacement
	^displacement

! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
displacement: anInteger
	self ASSERT: anInteger isInteger.
	self ASSERT: (anInteger between: -2147483648 and: 2147483647).
	displacement := anInteger

! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
index
	^index
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
index: aRegister
	index := aRegister
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
indexExtension
	^index notNil ifTrue: [index extensionBit] ifFalse: [0]
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
length: anInteger
	self ASSERT: (#(8 16 32 64 128) includes: anInteger).
	length := anInteger

! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
memoryLength
	^length
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
pointerLength
	base notNil ifTrue: [^base length].
	^self displacementLength
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
scale
	^scale

! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
scale: anInteger
	self ASSERT: (#(1 2 4 8) includes: anInteger).
	scale := anInteger

! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
segment
	^segment
! !

!MemoryOperand methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
segment: aRegister
	segment := aRegister
! !

!MemoryOperand methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:23:23'!
displacementBytes
	| bytes displ n |
	n := (base notNil and: [displacement between: -128 and: 127])
		ifTrue: [1]
		ifFalse: [4].
	base == rip ifTrue: [n := 4].
	bytes := ByteArray new: n.
	displ := displacement.
	1 to: bytes size do: [:i | 
		bytes at: i put: (displ bitAnd: 16rFF).
		displ := displ bitShift: -8].
	^bytes
! !

!MemoryOperand methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:23:23'!
displacementLength
	displacement = 0 ifTrue: [^0].
	^(base notNil and: [displacement between: -128 and: 127])
		ifTrue: [1]
		ifFalse: [4]
! !

!MemoryOperand methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:23:23'!
encodeSib: aSIB
	| s i b |
	s := scale ifNil: 1.
	i := index isNil ifTrue: [rsp index] ifFalse: [index index \\ 8].
	b := base isNil ifTrue: [rbp index] ifFalse: [base index \\ 8].
	aSIB
		scaleFactor: s;
		index: i;
		base: b
! !

!MemoryOperand methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:23:23'!
mod
	base == rip ifTrue: [^2r0].
	base isNil ifTrue: [^0].
	self hasDisplacement ifFalse: [^0].
	(displacement between: -128 and: 127) ifTrue: [^2r1] ifFalse: [^2r10]
! !

!MemoryOperand methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:23:23'!
rm
	self hasSib ifTrue: [^2r100].
	^base ifNil: [2r101] ifNotNil: [base index]
! !

!MemoryOperand methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:23:23'!
sib
	| factor s i b |
	factor := scale ifNil: 1.
	s := #[1 2 4 8] indexOf: factor.
	i := index isNil ifTrue: [rsp index] ifFalse: [index index bitAnd: 8r7].
	b := base isNil ifTrue: [rbp index] ifFalse: [base index bitAnd: 8r7].
	^((s - 1 bitShift: 6) bitOr: (i bitShift: 3)) bitOr: b
! !

!MemoryOperand methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:23:23'!
displacementValue
	| value |
	displacement isNumber ifTrue: [^displacement].
	displacement size = 4 ifTrue: [^displacement longAtOffset: 0].
	displacement size = 2 ifTrue: [^displacement shortAtOffset: 0].
	value := displacement at: 1.
	(value isOnBit: 16r80) ifTrue: [^value - (1 bitShift: displacement size * 8)].
	^value
! !

!MemoryOperand methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:23:23'!
lengthString
	length = 256 ifTrue: [^'ymmword ptr'].
	length = 128 ifTrue: [^'xmmword ptr'].
	(length isNil or: [length = 64]) ifTrue: [^'qword ptr'].
	length = 32 ifTrue: [^'dword ptr'].
	length = 16 ifTrue: [^'word ptr'].
	length = 8 ifTrue: [^'byte ptr'].
	self ASSERT: false.
	^''
! !

!MemoryOperand methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:23:23'!
printOn: aStream
	| sign displ |
	aStream nextPutAll: self lengthString; nextPutAll: ' ['.
	segment notNil ifTrue: [
		segment printOn: aStream.
		aStream nextPut: $:].
	base notNil ifTrue: [base printOn: aStream].
	index notNil ifTrue: [
		base notNil ifTrue: [aStream nextPutAll: ' + '].
		index printOn: aStream.
		scale isNil
			ifFalse: [aStream nextPutAll: ' * '; nextPutAll: scale asString]].
	displ := self displacementValue.
	displ !!= 0 ifTrue: [
		(base notNil or: [index notNil]) ifTrue: [
			sign := displ > 0 ifTrue: [' + '] ifFalse: [' - '].
			aStream nextPutAll: sign].
		aStream nextPutAll: '0x'; nextPutAll: displ abs hex].
	aStream nextPut: $]
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
hasDisplacement
	^self hasExplicitDisplacement
		or: [base isNil]
		or: [self requiresSpecialCaseDisplacement]
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
hasExplicitDisplacement
	^displacement !!= 0
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
hasOnlyDisplacement
	^index isNil and: [base isNil]
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
hasSib
	^index notNil or: [self requiresSpecialCaseSib]
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isCompatibleWith: anOperandType
	^anOperandType isMemory
		and: [length = anOperandType memoryLength
			or: [anOperandType memoryLength isNil]]
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isDirectMemoryReference
	^self hasOnlyDisplacement
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isMemory
	^true
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isTemplate
	^displacement = 0
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
needsExtraBit
	(base notNil and: [base needsExtraBit]) ifTrue: [^true].
	^index notNil and: [index needsExtraBit]
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
requiresSpecialCaseDisplacement
	^base notNil and: [base == r13 or: [base r == rbp]]
! !

!MemoryOperand methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
requiresSpecialCaseSib
	base ifNil: [^true].
	^base == r12 or: [base r == rsp]
! !

!MemoryOperand methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:23:23'!
initialize
	super initialize.
	displacement := 0.
	scale := 1
! !

!MemoryOperand methodsFor: 'private' stamp: 'KenD 11/22/2023 13:23:23'!
reset
	base := index := segment := length := nil.
	displacement := 0.
	scale := 1
! !

!MemoryOperand methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:23'!
template
	| template bits d |
	template := self copy.
	displacement = 0 ifTrue: [^template].
	bits := self displacementLength.
	d := bits = 1 ifTrue: [16r3F] ifFalse: [16r3FFFFFFF].
	^template displacement: d
! !

!MemoryOperand class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:23'!
fromStream: aStream
	| memory |
	memory := AssemblerParser new memory parse: aStream.
	memory isPetitFailure
		ifTrue: [self error: 'invalid operand: ' , memory message].
	^memory
! !

!MemoryOperand class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:23'!
fromString: aString
	"
	MemoryOperand fromString: 'qword ptr [rbx]'
	"
	^self fromStream: aString readStream
! !

!MemoryOperand class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:23'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!Register methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
addFlag: flagBit
	flags := flags bitOr: flagBit
! !

!Register methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeFamily
	(name first = $r and: [length = 64]) ifTrue: [
		family := {self getB. self getW. self getE. self}.
		family select: #notNil thenDo: [:reg | reg family: family]]
! !

!Register methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeFlags
	flags := 0.
	self initializeRegisterGroupFlag
! !

!Register methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeRegisterGroupFlag
	(name includesString: 'mm') ifTrue: [^self addFlag: RegisterSIMD].
	(#('es' 'cs' 'ss' 'ds' 'fs' 'gs') includes: name)
		ifTrue: [^self addFlag: RegisterSegment].
	self addFlag: RegisterGP
! !

!Register methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
isCompatibleWith: anOperandType
	anOperandType isRegister ifFalse: [^false].
	(anOperandType registerGroup = self registerGroup
		and: [length = anOperandType length or: [anOperandType length isNil]])
		ifTrue: [^true].
	^anOperandType isSpecificRegister and: [name = anOperandType name]
! !

!Register methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
prefers: anOperandType to: anotherOperandType
	^anOperandType name = name
! !

!Register methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
registerGroup
	^flags bitAnd: RegisterGroupMask
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
b
	^family at: 1
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
e
	^family at: 3
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
extensionBit
	^self isExtended ifTrue: [1] ifFalse: [0]
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
forLength: reglength
	self ASSERT: (#(8 16 32 64) includes: reglength).

	reglength ==  8 ifTrue: [ ^ self b ].
	reglength == 16 ifTrue: [ ^ self w ].
	reglength == 32 ifTrue: [ ^ self e ].
	reglength == 64 ifTrue: [ ^ self r ].

! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
index
	^index
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
index: anInteger
	index := anInteger
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
long
	^ family at: 3
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
name
	^name
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
name: aString
	name := aString asLowercase
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
r
	^family at: 4
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
regExtension
	^self extensionBit
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
short
	^ family at: 2
! !

!Register methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
w
	^family at: 2
! !

!Register methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:07'!
byte
	^self b
! !

!Register methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:07'!
rm
	^index
! !

!Register methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:07'!
family: anArray
	family := anArray
! !

!Register methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:07'!
getB
	self == rax ifTrue: [^al].
	self == rcx ifTrue: [^cl].
	self == rdx ifTrue: [^dl].
	self == rbx ifTrue: [^bl].
	self == rsi ifTrue: [^sil].
	self == rdi ifTrue: [^dil].
	self == rbp ifTrue: [^bpl].
	self == rsp ifTrue: [^spl].
	self == r8 ifTrue: [^r8b].
	self == r9 ifTrue: [^r9b].
	self == r10 ifTrue: [^r10b].
	self == r11 ifTrue: [^r11b].
	self == r12 ifTrue: [^r12b].
	self == r13 ifTrue: [^r13b].
	self == r14 ifTrue: [^r14b].
	self == r15 ifTrue: [^r15b].
	^nil
! !

!Register methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:07'!
getE
	self == rax ifTrue: [^eax].
	self == rcx ifTrue: [^ecx].
	self == rdx ifTrue: [^edx].
	self == rbx ifTrue: [^ebx].
	self == rsi ifTrue: [^esi].
	self == rdi ifTrue: [^edi].
	self == rbp ifTrue: [^ebp].
	self == rsp ifTrue: [^esp].
	self == r8 ifTrue: [^r8d].
	self == r9 ifTrue: [^r9d].
	self == r10 ifTrue: [^r10d].
	self == r11 ifTrue: [^r11d].
	self == r12 ifTrue: [^r12d].
	self == r13 ifTrue: [^r13d].
	self == r14 ifTrue: [^r14d].
	self == r15 ifTrue: [^r15d].
	^nil
! !

!Register methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:07'!
getW
	self == rax ifTrue: [^ax].
	self == rcx ifTrue: [^cx].
	self == rdx ifTrue: [^dx].
	self == rbx ifTrue: [^bx].
	self == rsi ifTrue: [^si].
	self == rdi ifTrue: [^di].
	self == rbp ifTrue: [^bp].
	self == rsp ifTrue: [^sp].
	self == r8 ifTrue: [^r8w].
	self == r9 ifTrue: [^r9w].
	self == r10 ifTrue: [^r10w].
	self == r11 ifTrue: [^r11w].
	self == r12 ifTrue: [^r12w].
	self == r13 ifTrue: [^r13w].
	self == r14 ifTrue: [^r14w].
	self == r15 ifTrue: [^r15w].
	^nil
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isExtended
	^index > 7
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isGeneral
	^self registerGroup = RegisterGP
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isLongModeOld8BitRegister
	self = spl ifTrue: [^true].
	self = bpl ifTrue: [^true].
	self = sil ifTrue: [^true].
	self = dil ifTrue: [^true].
	^false
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isRegister
	^true
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isSIMD
	^self registerGroup = RegisterSIMD
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isSegment
	^self registerGroup = RegisterSegment
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isTemplate
	^true
! !

!Register methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
needsExtraBit
	^self isExtended
! !

!Register methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:56:07'!
printOn: aStream
	name isNil ifTrue: [^super printOn: aStream].
	aStream nextPutAll: name
! !

!Register class methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:07'!
addRegister: aRegister
	Registers at: aRegister name put: aRegister
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initialize
	self initializeRegisters; initializeFamilies
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initialize16BitRegisters
	#('ax' 'cx' 'dx' 'bx' 'sp' 'bp' 'si' 'di' 'r8w' 'r9w' 'r10w' 'r11w' 'r12w' 'r13w' 'r14w' 'r15w')
		withIndexDo: [:r :i | | register |
			register := self new
				name: r;
				index: i - 1;
				length: 16;
				initializeFlags.
			self addRegister: register]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initialize32BitRegisters
	#('eax' 'ecx' 'edx' 'ebx' 'esp' 'ebp' 'esi' 'edi' 'r8d' 'r9d' 'r10d' 'r11d' 'r12d' 'r13d' 'r14d' 'r15d')
		withIndexDo: [:r :i | | register |
			register := self new
				name: r;
				index: i - 1;
				length: 32;
				initializeFlags.
			self addRegister: register]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initialize64BitRegisters
	#('rax' 'rcx' 'rdx' 'rbx' 'rsp' 'rbp' 'rsi' 'rdi' 'r8' 'r9' 'r10' 'r11' 'r12' 'r13' 'r14' 'r15')
		withIndexDo: [:r :i | | register |
			register := self new
				name: r;
				index: i - 1;
				length: 64;
				initializeFlags.
			self addRegister: register]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initialize8BitRegisters
	#('al' 'cl' 'dl' 'bl' 'ah' 'ch' 'dh' 'bh') withIndexDo: [:r :i | | register |
		register := Register new
			name: r;
			index: i - 1;
			length: 8;
			initializeFlags.
		self addRegister: register]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initialize8BitRexRegisters
	#('spl' 'bpl' 'sil' 'dil' 'r8b' 'r9b' 'r10b' 'r11b' 'r12b' 'r13b' 'r14b' 'r15b')
		withIndexDo: [:r :i | | register |
			register := self new
				name: r;
				index: i + 3;
				length: 8;
				initializeFlags.
			self addRegister: register]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeFamilies
	Registers do: [:reg | reg initializeFamily]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeMMXRegisters
	0 to: 7 do: [:i | | mmx |
		mmx := self new
			name: 'mmx' , i asString;
			index: i;
			length: 64;
			initializeFlags.
		self addRegister: mmx]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeRIPRegister
	| register |
	register := self new
		name: 'rip';
		index: 5;
		length: 64;
		initializeFlags.
	self addRegister: register
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeRegisters
	
	"Make sure OperandTypeFlags are initialized since
	 it is required and order of initialization is not 
	 defined in Pharo and Smallltalk/X."
	OperandTypeFlags initialize.

	self
		initialize8BitRegisters;
		initialize8BitRexRegisters;
		initialize16BitRegisters;
		initialize32BitRegisters;
		initialize64BitRegisters;
		initializeRIPRegister;
		initializeMMXRegisters;
		initializeSSERegisters;
		initializeSegmentRegisters
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeSSERegisters
	0 to: 15 do: [:i | | xmm |
		xmm := self new
			name: 'xmm' , i asString;
			index: i;
			length: 128;
			initializeFlags.
		self addRegister: xmm].
	0 to: 15 do: [:i | | ymm |
		ymm := self new
			name: 'ymm' , i asString;
			index: i;
			length: 256;
			initializeFlags.
		self addRegister: ymm]
! !

!Register class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeSegmentRegisters
	#('es' 'cs' 'ss' 'ds' 'fs' 'gs') withIndexDo: [:r :i | | register |
		register := self new
			name: r;
			index: i - 1;
			length: 16;
			initializeFlags.
		self addRegister: register]
! !

!Register class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
named: aString
	"
	Register named: 'rax'
	"
	^Registers at: aString asLowercase ifAbsent: nil
! !

!Register class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
segment: index
	index = 0 ifTrue: [^cs].
	index = 1 ifTrue: [^ss].
	index = 2 ifTrue: [^ds].
	index = 3 ifTrue: [^es].
	index = 4 ifTrue: [^fs].
	index = 5 ifTrue: [^gs].
	^nil
! !

!Register class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
withIndex: index length: length
	^Registers detect: [:r | 
		r index = index
			and: [r length = length]
			and: [(r name beginsWith: 'mmx') not]
			and: [r isSegment not]]
! !

!Register class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
withIndex: index length: length long: aBoolean
	^Registers detect: [:r | 
		r index = index
			and: [r length = length]
			and: [(r name beginsWith: 'mmx') not]
			and: [r isSegment not]
			and: [r isLongModeOld8BitRegister ifTrue: [aBoolean] ifFalse: [true]]]
! !

!Register class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
xmm: i
	^self named: 'xmm' , i asString
! !

!Register class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
ymm: i
	^self named: 'ymm' , i asString
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
addFlag: flagBit
	flags := flags bitOr: flagBit
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
getMemoryLength
	(type includesString: '/m8') ifTrue: [^8].
	(type includesString: '/m16') ifTrue: [^16].
	(type includesString: '/m32') ifTrue: [^32].
	(type includesString: '/m64') ifTrue: [^64].
	(type includesString: '/m128') ifTrue: [^128].
	(type includesString: ':16') ifTrue: [^0].
	(type includesString: ':32') ifTrue: [^0].
	(type includesString: ':64') ifTrue: [^0].
	^length
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:27:13'!
hasFlag: flagBit
	^(flags bitAnd: flagBit) > 0
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
initializeMemoryLength
	memoryLength := self getMemoryLength
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
length
	^length
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
length: aString
	length := aString = '?' ifFalse: [aString asInteger]
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
lengthForBits: n
	^(type beginsWith: 'moff') ifTrue: [n] ifFalse: [length]
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
memoryLength
	^memoryLength
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
name
	^type
! !

!ISAOperandType methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
type: aString
	type := aString.
	flags := 0.
	self
		initializeMemoryLength;
		initializeConstantFlag;
		initializeImmediateFlag;
		initializeMemoryFlag;
		initializeRegisterFlag;
		initializeSegmentFlag;
		initializeRegisterGroupFlag
! !

!ISAOperandType methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
constant
	| i |
	i := #('0' '1' '3') indexOf: type.
	^i > 0 ifTrue: [#[0 1 3] at: i]
! !

!ISAOperandType methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
normalized
	type first = $r ifFalse: [^self].
	type = 'rel8' ifTrue: [^self class imm8].
	type = 'rel16' ifTrue: [^self class imm16].
	type = 'rel32' ifTrue: [^self class imm32].
	type = 'r32a' ifTrue: [^self class r32].
	type = 'r32b' ifTrue: [^self class r32].
	type = 'r64a' ifTrue: [^self class r64].
	type = 'r64b' ifTrue: [^self class r64]
! !

!ISAOperandType methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
register
	type = '<xmm0>' ifTrue: [^xmm0].
	type = 'r8' ifTrue: [^nil].
	^Register named: type
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
hasImmediateFlag
	^self hasFlag: ImmediateType
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
isConstant
	^self hasFlag: ConstantType
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:39:10'!
isImmediate
	^self hasFlag: 1 "ImmediateType"
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
isMemory
	^self hasFlag: MemoryType
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
isMoff
	^type beginsWith: 'moff'
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
isRegister
	^self hasFlag: RegisterType
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
isSegment
	^self hasFlag: RegisterSegment
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
isSpecificRegister
	^self registerGroup = RegisterSpecific
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
registerGroup
	^flags bitAnd: RegisterGroupMask
! !

!ISAOperandType methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
specificRegisterNames
	^#('rax' 'eax' 'ax' 'al' 'cl' 'dx' 'es' 'cs' 'ss' 'ds' 'fs' 'gs')
! !

!ISAOperandType methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:40:39'!
initializeConstantFlag
	type anyOne isDigit ifTrue: [self addFlag: 2 "ConstantType"]

! !

!ISAOperandType methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:23:24'!
initializeImmediateFlag
	((type includesString: 'imm') or: [type includesString: 'rel'])
		ifTrue: [self addFlag: ImmediateType]
! !

!ISAOperandType methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:38:36'!
initializeMemoryFlag
self flag: #bogus.
^self
"	self isImmediate ifTrue: [^self].
	(#('m8' 'm16' 'm32' 'm64' 'm128' 'm256' 'm512')
		anySatisfy: [:s | type includesString: s])
		ifTrue: [^self addFlag: MemoryType].
	((type includes: $m)
		and: [(type includesString: 'mm') not]
		and: [(type includesString: 'vm') not]
		and: [(type includesString: 'offs') not])
		ifTrue: [self addFlag: MemoryType]
"! !

!ISAOperandType methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:41:26'!
initializeRegisterFlag
	self isImmediate ifTrue: [^self].
	(type includesString: 'r/m') ifTrue: [^self addFlag: 8 "RegisterType"].
	(#('r8' 'r16' 'r32' 'r64' 'reg') anySatisfy: [:s | type includesString: s])
		ifTrue: [^self addFlag: RegisterType].
	(type includesString: 'mm') ifTrue: [^self addFlag: 8 "RegisterType"].
	(self specificRegisterNames includes: type)
		ifTrue: [self addFlag: 8 "RegisterType"]
! !

!ISAOperandType methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:42:42'!
initializeRegisterGroupFlag
	self isImmediate ifTrue: [^self].
	(type includesString: 'r/m') ifTrue: [^self addFlag: 0 "RegisterGP"].
	(#('r8' 'r16' 'r32' 'r64' 'reg') anySatisfy: [:s | type includesString: s])
		ifTrue: [^self addFlag: 0 "RegisterGP"].
	(type includesString: 'mm') ifTrue: [^self addFlag: 256 "RegisterSIMD"].
	(self specificRegisterNames includes: type)
		ifTrue: [^self addFlag: 768 "RegisterSpecific"].
	type = 'sreg' ifTrue: [^self addFlag: 512 "RegisterSegment"]
! !

!ISAOperandType methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:43:00'!
initializeSegmentFlag
	^type = 'sreg' ifTrue: [self addFlag: 768 "RegisterSegment"]
! !

!ISAOperandType methodsFor: 'private' stamp: 'KenD 11/22/2023 13:23:24'!
operandFrom: anInteger
	self ASSERT: self isMoff.
	^MemoryOperand new displacement: anInteger; length: memoryLength
! !

!ISAOperandType methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:23:24'!
printOn: aStream
	aStream nextPutAll: type
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
imm16
	^self named: 'imm16'
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
imm32
	^self named: 'imm32'
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
imm8
	^self named: 'imm8'
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
immediateTypes
	^Types select: [:t | t isImmediate]
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
memoryTypes
	^Types select: [:t | t isMemory] in: OrderedCollection new
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
r32
	^self named: 'r32'
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
r64
	^self named: 'r64'
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
typeOfSpecialRegister: aRegister
	aRegister = rax ifTrue: [^self named: 'rax'].
	aRegister = eax ifTrue: [^self named: 'eax'].
	aRegister = ax ifTrue: [^self named: 'ax'].
	aRegister = al ifTrue: [^self named: 'al'].
	aRegister = cl ifTrue: [^self named: 'cl'].
	aRegister = dx ifTrue: [^self named: 'dx']
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
typesOfGeneralRegister: aRegister
	| bits associations |
	bits := aRegister length asString.
	associations := OrderedCollection new: 4.
	Types do: [:type | | n |
		n := type name.
		n = ('r' , bits) ifTrue: [associations add: 1 -> type].
		n = 'reg' ifTrue: [associations add: 2 -> type].
		n = ('r/m' , bits) ifTrue: [associations add: 3 -> type].
		n = ('r' , bits , '/m' , bits) ifTrue: [associations add: 4 -> type]].
	^(associations sortBy: #key) collect: #value
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
typesOfSIMDRegister: aRegister
	| s |
	s := aRegister name.
	^Types select: [:type | | n |
		(#('0' '1' '3') includes: type name) not
			and: [
				n := type name upTo: $/.
				n size >= 3]
			and: [n first !!= $m]
			and: [s includesString: n]]
! !

!ISAOperandType class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
typesOfSegmentRegister: aRegister
	| type sreg |
	type := self named: aRegister name.
	sreg := self named: 'sreg'.
	^{type. sreg}
! !

!ISAOperandType class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:23:24'!
initialize
	OperandTypeFlags initialize.
	self initializeTypes

! !

!ISAOperandType class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:23:24'!
initializeTypes
	| dictionary |
	dictionary := Dictionary new.
	self typeNames lines collect: [:s | | pair type |
		pair := s substrings.
		type := self new type: pair first; length: pair second.
		dictionary at: type name put: type].
	Types := dictionary
! !

!ISAOperandType class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:24'!
named: aString
	^Types at: aString
! !

!ISAOperandType class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
typeNames
	^'<xmm0> 128
		0 8
		1 8
		3 0
		al 8
		dx 16
		ax 16
		cl 8
		cr0-cr7 ?
		cr8 ?
		cs 16
		dr0-dr7 ?
		ds 16
		dx 16
		eax 32
		dx 16
		es 16
		far 0
		fs 16
		gs 16
		imm16 16
		imm32 32
		imm64 64
		imm8 8
		m ?
		m108byte ?
		m128 128
		m16 16
		m16&16 16
		m16&32 ?
		m16&64 ?
		m16:16 16
		m16:32 48
		m16:64 80
		m16int 16
		m256 256
		m28byte 7
		m2byte 16
		m32 32
		m32&32 32
		m32fp 32
		m32int 32
		m512byte 512
		m64 64
		m64fp 64
		m64int 64
		m8 8
		m80bcd 80
		m80fp 80
		mem ?
		mm 64
		mm1 64
		mm2 64
		mm/m32 64
		mm/m64 64
		mm2/m64 64
		moffs16 16
		moffs32 32
		moffs64 64
		moffs8 8
		p66 0
		ptr16:16 16
		ptr16:32 16
		pw 0
		r/m16 16
		r/m32 32
		r/m64 64
		r/m8 8
		r/m8 8
		r8 8
		r16 16
		r16/m16 16
		r32 32
		r32/m16 32
		r32/m32 32
		r32/m8 32
		r32a 32
		r32b 32
		r64 64
		r64/m16 64
		r64/m64 64
		r64a 64
		r64b 64
		rax 64
		reg ?
		reg/m16 16
		reg/m32 32
		reg/m8 8
		rel16 16
		rel32 32
		rel8 8
		sreg 16
		ss 16
		st ?
		st(0) ?
		st(i) ?
		vm32x 32
		vm32y 32
		vm64x 64
		vm64y 64
		xmm 128
		xmm/m128 128
		xmm/m32 128
		xmm/m64 128
		xmm0 128
		xmm1 128
		xmm1/m128 128
		xmm1/m32 128
		xmm1/m64 128
		xmm2 128
		xmm2/m128 128
		xmm2/m16 128
		xmm2/m32 128
		xmm2/m64 128
		xmm2/m8 128
		xmm3 128
		xmm3/m128 128
		xmm3/m32 128
		xmm3/m64 128
		xmm4 128
		ymm0 256
		ymm1 256
		ymm2 256
		ymm2/m256 256
		ymm3/m256 256
		ymm4 256'
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
arity
	^spec arity
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
indexExtension
	^instruction operands maxValue: [:op | op indexExtension]
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
instruction: anISAInstruction
	instruction := anISAInstruction.
	instruction useTemplate
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
operand1
	^instruction operand1
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
operand2
	^instruction operand2
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
operand3
	^instruction operand3
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
operand4
	^instruction operand4
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
operands
	^instruction operands
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
reg: aRegister
	| index prev |
	modrm isNil
		ifTrue: [modrm := stream position]
		ifFalse: [prev := stream position].
	stream position: modrm.
	index := aRegister isInteger ifTrue: [aRegister] ifFalse: [aRegister index].
	self
		writeMid: index;
		rexR: index > 7.
	sib := stream position.
	(prev notNil and: [prev > sib]) ifTrue: [stream position: prev]
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
reset
	spec := rex := modrm := sib := displacement := immediate := nil
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
rm: anInteger
	modrm isNil ifTrue: [modrm := stream position].
	stream position: modrm.
	self
		writeLo: anInteger;
		rexB: anInteger > 7.
	sib := stream position.
	self writeSib; writeDisplacement
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
spec
	spec notNil ifTrue: [^spec].
	^spec := self bestMatchingSpec
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
vreg: aRegister
	| index |
	modrm isNil ifTrue: [modrm := stream position].
	stream position: modrm.
	index := aRegister isInteger ifTrue: [aRegister] ifFalse: [aRegister index].
	self
		writeMid: index;
		vexR: index < 8.
	sib := stream position
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
vrm: anInteger
	modrm isNil ifTrue: [modrm := stream position].
	stream position: modrm.
	self
		writeLo: anInteger;
		vexB: anInteger < 8;
		vexX: self rexX = 0.
	sib := stream position.
	self writeSib; writeDisplacement
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
wordSize
	^wordSize
! !

!InstructionEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:06'!
wordSize: anInteger
	self ASSERT: (anInteger = 4 or: [anInteger = 8]).
	wordSize := anInteger
! !

!InstructionEncoder methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:06'!
at: position
	| pos |
	pos := stream position.
	^[stream position: position; peek] ensure: [stream position: pos]
! !

!InstructionEncoder methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:06'!
bestMatchingSpec
	| template s |
	template := instruction template.
	s := Cache at: template ifAbsent: nil.
	s notNil ifTrue: [^s].
	s := InstructionSpec
		bestMatchForMnemonic: template mnemonic
		operands: template operands
		wordSize: wordSize.
	Cache at: template copy put: s.
	^s
! !

!InstructionEncoder methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:06'!
displacementOffset
	^displacement
! !

!InstructionEncoder methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:06'!
immediate2Offset
	^immediate2
! !

!InstructionEncoder methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:06'!
immediateOffset
	^immediate
! !

!InstructionEncoder methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:06'!
hasDisplacement
	^instruction hasDisplacement
! !

!InstructionEncoder methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:06'!
hasModRM
	^spec hasModRM
! !

!InstructionEncoder methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:06'!
hasRex
	^vex > rex
! !

!InstructionEncoder methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:06'!
hasSib
	^instruction hasSib
! !

!InstructionEncoder methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:06'!
hasVex
	^opcode > vex
! !

!InstructionEncoder methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:06'!
overridesOperandSize
	| operands op |
	operands := instruction operands.
	operands size = 0 ifTrue: [^false].
	op := operands first.
	(op isRegister and: [op isSegment]) ifTrue: [^false].
	op memoryLength = 16 ifTrue: [
		^instruction mnemonic first = $f
			ifTrue: [spec operands first length !!= 16]
			ifFalse: [true]].
	operands with: spec operands do: [:a :f | 
		(a isImmediate not
			and: [a memoryLength !!= f memoryLength]
			and: [a memoryLength !!= f length]
			and: [(a isMemory and: [f name = 'm']) not])
			ifTrue: [^true]].
	^false
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
immediate2: aByteArray
	stream position: immediate2; nextPutAll: aByteArray
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
immediate: aByteArray
	immediate isNil ifTrue: [
		immediate := stream position.
		modrm isNil ifTrue: [modrm := sib := displacement := immediate]].
	stream position: immediate.
	aByteArray isCollection
		ifTrue: [stream nextPutAll: aByteArray]
		ifFalse: [stream nextPut: aByteArray].
	immediate2 := stream position
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
mmmmm: anInteger
	| pos byte |
	pos := stream position.
	byte := stream position: vex + 1; peek.
	byte := byte bitOr: anInteger.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
opcode: aByteArray
	| pos |
	pos := stream position.
	stream
		position: opcode;
		nextPutAll: aByteArray;
		position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
pp: anInteger
	| pos offset byte |
	pos := stream position.
	offset := stream peek = 16rC5 ifTrue: [2] ifFalse: [1].
	byte := stream position: vex + offset; peek.
	byte := byte bitOr: anInteger.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
rexB: aBoolean
	| pos byte |
	aBoolean ifFalse: [^self].
	pos := stream position.
	byte := stream position: rex; peek.
	byte := byte bitOr: REXPrefix b.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
rexB: aBoolean opcode: aByteArray
	(rex isNil or: [rex = opcode]) ifTrue: [
		rex := opcode.
		stream position: rex; nextPut: REXPrefix rex value.
		opcode := opcode + 1].
	self rexB: aBoolean; opcode: aByteArray.
	stream position: opcode; skip: aByteArray size
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
rexR: aBoolean
	| pos byte |
	aBoolean ifFalse: [^self].
	pos := stream position.
	byte := stream position: rex; peek.
	byte := byte bitOr: REXPrefix r value.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
rexX
	self hasSib ifFalse: [^0].
	instruction operands
		select: [:op | op isMemory]
		thenDo: [:op | ^op indexExtension]
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
rexX: aBoolean
	| pos byte |
	aBoolean ifFalse: [^self].
	pos := stream position.
	byte := stream position: rex; peek.
	byte := byte bitOr: REXPrefix x.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
vexB: aBoolean
	| pos byte |
	(self at: vex) = 16rC5 ifTrue: [^self].
	aBoolean ifFalse: [^self].
	pos := stream position.
	byte := stream position: vex + 1; peek.
	byte := byte bitOr: VEXPrefix b.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
vexL: aBoolean
	| pos offset byte |
	aBoolean ifFalse: [^self].
	pos := stream position.
	offset := stream peek = 16rC5 ifTrue: [2] ifFalse: [1].
	byte := stream position: vex + offset; peek.
	byte := byte bitOr: VEXPrefix l.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
vexR: aBoolean
	| pos byte |
	aBoolean ifFalse: [^self].
	pos := stream position.
	byte := stream position: vex + 1; peek.
	byte := byte bitOr: VEXPrefix r.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
vexW: aBoolean
	| pos byte |
	aBoolean ifFalse: [^self].
	pos := stream position.
	byte := stream position: vex + 2; peek.
	byte := byte bitOr: VEXPrefix w.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
vexX: aBoolean
	| pos byte |
	(self at: vex) = 16rC5 ifTrue: [^self].
	aBoolean ifFalse: [^self].
	pos := stream position.
	byte := stream position: vex + 1; peek.
	byte := byte bitOr: VEXPrefix x.
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
vvvv: anInteger
	| pos offset byte vvvv |
	pos := stream position.
	stream position: vex.
	offset := stream peek = 16rC5 ifTrue: [1] ifFalse: [2].
	byte := stream position: vex + offset; peek.
	vvvv := (anInteger bitInvert bitShift: 3) bitAnd: 2r1111000.
	byte := (byte bitAnd: 2r10000111) bitOr: vvvv.
	byte < 0 ifTrue: [byte := 256 + byte].
	stream nextPut: byte; position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeDisplacement
	self hasDisplacement ifTrue: [
		instruction operands
			select: [:op | op isMemory]
			thenDo: [:op | stream nextPutAll: op displacementBytes]].
	immediate isNil ifTrue: [immediate := stream position]
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeEncodingOn: aStream
	stream := aStream.
	prefixes := rex := vex := stream position.
	self writePrefixes; writeOpcode; writeOperands
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeExtension: anInteger
	| pos bit4 |
	pos := stream position.
	stream position: modrm.
	self writeMid: anInteger.
	(self hasRex and: [bit4 := anInteger > 7]) ifTrue: [self rexR: bit4].
	(self hasVex and: [bit4 := anInteger < 8]) ifTrue: [self vexR: bit4].
	sib := stream position.
	stream position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeHi: anInteger
	| bits byte |
	bits := (anInteger bitAnd: 8r3) bitShift: 6.
	byte := stream peek ifNil: 0.
	byte := (byte bitAnd: 8r77) bitOr: bits.
	stream nextPut: byte
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeLegacyPrefix: byte
	stream nextPut: byte.
	rex := vex := stream position
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeLo: anInteger
	| byte modReg rm |
	byte := stream peek ifNil: 0.
	modReg := byte bitAnd: 8r370.
	rm := anInteger bitAnd: 8r7.
	byte := modReg bitOr: rm.
	stream nextPut: byte
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeMid: anInteger
	| bits byte |
	bits := (anInteger bitAnd: 8r7) bitShift: 3.
	byte := stream peek ifNil: 0.
	byte := (byte bitAnd: 8r307) bitOr: bits.
	stream nextPut: byte
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeMod
	| pos |
	pos := stream position.
	stream position: modrm.
	self writeHi: instruction mod.
	stream position: pos
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeOpcode
	stream position: opcode; nextPutAll: spec primaryOpcode.
	modrm := stream position.
	spec extension ifNotNil: [:e | self writeExtension: e]
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeOperands
	spec operandEncoding ifNotNil: [:oe | 
		oe encodeOperands: self.
		self hasModRM ifTrue: [self writeMod]]
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writePrefixes
	| head p67 p66 |
	self writeSegmentPrefixes.
	instruction prefix notNil ifTrue: [instruction prefix writeOn: self].
	head := self spec prefixes asOrderedCollection.
	p66 := LegacyPrefix operandSizeOverride.
	p67 := LegacyPrefix addressSizeOverride.
	(head anySatisfy: [:p | p = p66 or: [p = p67] or: [p isVex]]) ifFalse: [
		self overridesOperandSize ifTrue: [head addFirst: p66].
		(instruction overridesAddressSize: wordSize) ifTrue: [head addFirst: p67]].
	head do: [:prefix | prefix writeOn: self].
	((head noneSatisfy: [:p | p isRex or: [p isVex]]) and: [
		(instruction operands anySatisfy: [:op | op needsExtraBit]) or: [
			instruction operands
				anySatisfy: [:op | op = spl or: [op = bpl] or: [op = sil] or: [op = dil]]]])
		ifTrue: [REXPrefix rex writeOn: self].
	opcode := stream position
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeRexPrefix: byte
	self ASSERT: wordSize = 8.
	stream nextPut: byte.
	vex := stream position
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeSegmentPrefixes
	instruction operands
		select: [:op | op isMemory andNot: [op segment isNil]]
		thenDo: [:op | | seg |
			seg := op segment.
			seg = cs ifTrue: [self writeLegacyPrefix: 16r2E].
			seg = ss ifTrue: [self writeLegacyPrefix: 16r36].
			seg = ds ifTrue: [self writeLegacyPrefix: 16r3E].
			seg = es ifTrue: [self writeLegacyPrefix: 16r26].
			seg = fs ifTrue: [self writeLegacyPrefix: 16r64].
			seg = gs ifTrue: [self writeLegacyPrefix: 16r65]]
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeSib
	| operand |
	self hasSib ifTrue: [
		operand := instruction operands detect: [:op | op isMemory].
		stream nextPut: operand sib.
		opcode - vex > 0
			ifTrue: [
				self
					vexX: operand indexExtension = 0;
					vexB: operand baseExtension = 0]
			ifFalse: [
				self
					rexX: operand indexExtension > 0;
					rexB: operand baseExtension > 0]].
	displacement := stream position
! !

!InstructionEncoder methodsFor: 'encoding' stamp: 'KenD 11/22/2023 13:56:06'!
writeVexPrefix: aByteArray
	vex := stream position.
	stream nextPutAll: aByteArray
! !

!InstructionEncoder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:06'!
initialize
	super initialize.
	wordSize := 8
! !

!InstructionEncoder methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:56:06'!
legacyMap
	^String streamContents: [:strm | 
		(prefixes to: rex - 1)
			do: [:i | | p |
				p := self at: i.
				strm nextPutAll: p hex]
			separatedBy: [strm space]]
! !

!InstructionEncoder methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:56:06'!
prefixesMap
	| parts |
	parts := {self legacyMap. self rexMap. self vexMap}.
	parts := parts select: #notEmpty.
	^String
		streamContents: [:strm | parts do: [:p | strm nextPutAll: p; space]]
! !

!InstructionEncoder methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:56:06'!
rexMap
	^String streamContents: [:strm | 
		(rex to: vex - 1)
			do: [:i | | p |
				p := self at: i.
				REXPrefix print: p on: strm]
			separatedBy: [strm space]]
! !

!InstructionEncoder methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:56:06'!
vexMap
	^String streamContents: [:strm | 
		(vex to: opcode - 1)
			do: [:i | | p |
				p := self at: i.
				VEXPrefix print: p on: strm]
			separatedBy: [strm space]]
! !

!InstructionEncoder class methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:06'!
checkCache64
	Cache keysAndValuesDo: [:k :v | | s |
		s := InstructionSpec
			bestMatchForMnemonic: k mnemonic
			operands: k operands
			wordSize: 8.
		self ASSERT: s = v]
! !

!InstructionEncoder class methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:06'!
invalidateCache
	Cache removeAll
! !

!InstructionEncoder class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:06'!
initialize
	self initializeCache

! !

!InstructionEncoder class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:06'!
initializeCache
	Cache := Dictionary new
! !

!InstructionEncoder class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:56:06'!
new
	^super new initialize
! !

!InstructionPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:10'!
isLegacy
	^false
! !

!InstructionPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:10'!
isRex
	^false
! !

!InstructionPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:10'!
isSegment
	^false
! !

!InstructionPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:10'!
isVex
	^false
! !

!InstructionPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:10'!
name
	^name
! !

!InstructionPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:10'!
name: aString
	name := aString
! !

!InstructionPrefix methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:58:10'!
printOn: aStream
	(name includes: Character space)
		ifTrue: [
			aStream
				nextPut: ${;
				nextPutAll: name;
				nextPut: $}]
		ifFalse: [aStream nextPutAll: name]
! !

!InstructionPrefix methodsFor: 'writing' stamp: 'KenD 11/22/2023 07:58:10'!
writeOn: anInstruction
	self subclassResponsibility
! !

!InstructionPrefix class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:10'!
classFor: aString
	(aString beginsWith: 'REX') ifTrue: [^REXPrefix].
	(aString beginsWith: 'VEX') ifTrue: [^VEXPrefix].
	^LegacyPrefix
! !

!InstructionPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:58:10'!
fromString: aString
	| reader prefixes rex |
	reader := aString readStream.
	prefixes := Prefixes
		select: [:p | reader peekForAll: p value hex]
		in: OrderedCollection new.
	(reader peek: 'REX' size) = 'REX' ifTrue: [
		rex := REXPrefix fromStream: reader.
		prefixes add: rex].
	(reader peek: 'VEX' size) = 'VEX' ifTrue: [
		rex := VEXPrefix fromStream: reader.
		prefixes add: rex].
	^prefixes
! !

!InstructionPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:58:10'!
initializePrefixes
	self == InstructionPrefix
		ifTrue: [ self allSubclasses do: #initializePrefixes ].
	self compileAll.
	self class compileAll
! !

!InstructionPrefix class methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:10'!
peekFrom: aStream
	(aStream peekFor: LOCK value) ifTrue: [^LOCK].
	(aStream peekFor: REPNE value) ifTrue: [^REPNE].
	(aStream peekFor: REP value) ifTrue: [^REP].
	(aStream peekFor: OperandSize_Override value)
		ifTrue: [^OperandSize_Override].
	(aStream peekFor: AddressSize_Override value)
		ifTrue: [^AddressSize_Override].
	^nil
! !

!InstructionPrefix class methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:10'!
prefixes
	^Prefixes
! !

!LegacyPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
group
	^group
! !

!LegacyPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
group: anInteger
	group := anInteger
! !

!LegacyPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
value
	^value
! !

!LegacyPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
value: anInteger
	value := anInteger
! !

!LegacyPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
isLegacy
	^true
! !

!LegacyPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
matches: aLegacyPrefix
	^self == aLegacyPrefix
! !

!LegacyPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
overridesAddressSize
	^self = AddressSize_Override
! !

!LegacyPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:07'!
overridesOperandSize
	^self = OperandSize_Override
! !

!LegacyPrefix methodsFor: 'writing' stamp: 'KenD 11/22/2023 13:56:07'!
writeOn: instruction
	instruction writeLegacyPrefix: value
! !

!LegacyPrefix class methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:07'!
addressSizeOverride
	^AddressSize_Override
! !

!LegacyPrefix class methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:07'!
operandSizeOverride
	^OperandSize_Override
! !

!LegacyPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeGroup1
	#(#(0xF0 'LOCK') #(0xF2 'REPNE/REPNZ') #(0xF3 'REP/REPE/REPZ'))
		do: [:pair | | names prefix |
			names := $/ split: pair second.
			prefix := self new
				group: 1;
				value: pair first;
				name: names first.
			names do: [:aka | Prefixes at: aka put: prefix]]
! !

!LegacyPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeGroup2
	#(#(0x2E 'CS') #(0x36 'SS') #(0x3E 'DS') #(0x26 'ES') #(0x64 FS) #(0x65 'GS'))
		do: [:pair | | prefix |
			prefix := self new
				group: 2;
				value: pair first;
				name: pair second , ' segment override'.
			self disableCode: [Prefixes at: prefix name put: prefix]].
	#(#(0x2E 'not') #(0x3E '')) do: [:pair | | prefix |
		prefix := self new
			group: 2;
			value: pair first;
			name: 'Branch ' , pair second , ' taken'.
		self disableCode: [Prefixes at: prefix name put: prefix]]
! !

!LegacyPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeGroup3
	| prefix |
	prefix := self new
		group: 3;
		value: 16r66;
		name: 'OperandSize_Override'.
	Prefixes at: prefix name put: prefix
! !

!LegacyPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializeGroup4
	| prefix |
	prefix := self new
		group: 4;
		value: 16r67;
		name: 'AddressSize_Override'.
	Prefixes at: prefix name put: prefix
! !

!LegacyPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:07'!
initializePrefixes
	self
		initializeGroup1;
		initializeGroup2;
		initializeGroup3;
		initializeGroup4.
	super initializePrefixes
! !

!LegacyPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:07'!
withValue: byte
	^Prefixes
		detect: [:prefix | prefix isLegacy and: [prefix value = byte]]
		ifNone: nil
! !

!REXPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:11'!
isRex
	^true
! !

!REXPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:11'!
matches: anInteger
	^anInteger isOnBit: self value
! !

!REXPrefix methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:58:11'!
value
	self == REX_W ifTrue: [^16r48].
	self == REX_R ifTrue: [^16r44].
	self == REX ifTrue: [^16r40].
	self ASSERT: false.
	^nil
! !

!REXPrefix methodsFor: 'writing' stamp: 'KenD 11/22/2023 07:58:11'!
writeOn: instruction
	instruction writeRexPrefix: self value
! !

!REXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
b
	^1
! !

!REXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
r
	^REX_R
! !

!REXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
rex
	^REX
! !

!REXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
w
	^REX_W
! !

!REXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
x
	^2
! !

!REXPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:58:11'!
fromStream: aStream
	| s |
	s := aStream upTo: $+.
	^self fromString: s
! !

!REXPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:58:11'!
fromString: aString
	(aString endsWith: 'REX.W') ifTrue: [^self w].
	(aString endsWith: 'REX.R') ifTrue: [^self r].
	(aString endsWith: 'REX') ifTrue: [^self rex].
	^nil
! !

!REXPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:58:11'!
new
	^super new initialize
! !

!REXPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:58:11'!
initializePrefixes
	#('REX' 'REX_W' 'REX_R')
		do: [ :s | 
			| rex |
			rex := self new name: s.
			Prefixes at: s put: rex ].
	super initializePrefixes.
	self	compileAll.
	self class compileAll.

! !

!REXPrefix class methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:11'!
peekFrom: aStream
	^(aStream peek bitAnd: 16rF0) = 16r40 ifTrue: [aStream next]
! !

!REXPrefix class methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:58:11'!
print: byte on: aStream
	self ASSERT: (byte isOnBit: REX value).
	aStream nextPutAll: '0100'.
	(byte isOnBit: self w value) ifTrue: [aStream nextPut: $w].
	(byte isOnBit: self r) ifTrue: [aStream nextPut: $r].
	(byte isOnBit: self x) ifTrue: [aStream nextPut: $x].
	(byte isOnBit: self b) ifTrue: [aStream nextPut: $b]
! !

!SegmentPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:44:22'!
isSegment
	^true
! !

!SegmentPrefix methodsFor: 'services' stamp: 'KenD 11/22/2023 13:44:22'!
register
	^Register named: name allButLast
! !

!SegmentPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:44:22'!
value
	^value
! !

!SegmentPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:44:22'!
value: aInteger
	value := aInteger
! !

!SegmentPrefix methodsFor: 'writing' stamp: 'KenD 11/22/2023 13:44:22'!
writeOn: instruction
	instruction writeSegmentPrefix: value
! !

!SegmentPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:44:22'!
cs
	^self new name: 'cs:'; value: 16r2E
! !

!SegmentPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:44:22'!
ds
	^self new name: 'ds:'; value: 16r3E
! !

!SegmentPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:44:22'!
es
	^self new name: 'es:'; value: 16r26
! !

!SegmentPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:44:22'!
fs
	^self new name: 'fs:'; value: 16r64
! !

!SegmentPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:44:22'!
gs
	^self new name: 'gs:'; value: 16r65
! !

!SegmentPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:44:22'!
named: aString
	| string char |
	aString size < 2 ifTrue: [^nil].
	string := aString asLowercase.
	(string at: 2) = $s ifFalse: [^nil].
	char := string at: 1.
	char = $c ifTrue: [^self cs].
	char = $s ifTrue: [^self ss].
	char = $d ifTrue: [^self ds].
	char = $e ifTrue: [^self es].
	char = $f ifTrue: [^self fs].
	char = $g ifTrue: [^self gs].
	^nil
! !

!SegmentPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:44:22'!
ss
	^self new name: 'ss:'; value: 16r36
! !

!SegmentPrefix class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:44:22'!
peekFrom: aStream
	(aStream peekFor: 16r2E) ifTrue: [^self cs].
	(aStream peekFor: 16r3E) ifTrue: [^self ds].
	(aStream peekFor: 16r26) ifTrue: [^self es].
	(aStream peekFor: 16r64) ifTrue: [^self fs].
	(aStream peekFor: 16r65) ifTrue: [^self gs].
	^nil
! !

!VEXPrefix methodsFor: 'input' stamp: 'KenD 11/22/2023 13:23:23'!
fromStream: aStream
	| stream |
	stream := (aStream upTo: Space) readStream.
	signature := Array streamContents: [:strm | 
		[stream atEnd] whileFalse: [| part |
			part := stream upTo: $..
			strm nextPut: part]]
! !

!VEXPrefix methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:23:23'!
initialize
	super initialize.
	name = 'VEX'
! !

!VEXPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
isVex
	^true
! !

!VEXPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
matches: aByteArray
	| size last mmmmm |
	(self mayMatchSize: aByteArray) ifFalse: [^false].
	size := aByteArray size.
	last := aByteArray at: size.
	(signature includes: 'LIG')
		ifFalse: [(signature includes: '256') = (last isOnBit: self class l)
			ifFalse: [^false]].
	(signature includes: '66') = (last isOnBit: 2r1) ifFalse: [^false].
	(signature includes: 'F2') = (last isOnBit: 2r10) ifFalse: [^false].
	(signature includes: 'F3') = (last isOnBit: 2r11) ifFalse: [^false].
	(signature includes: 'WIG')
		ifFalse: [(signature includes: 'W1') = (last isOnBit: self class w)
			ifFalse: [^false]].
	size = 3 ifTrue: [
		mmmmm := (aByteArray at: 2) bitAnd: 2r11111.
		(signature includes: '0F') = (mmmmm = 1) ifFalse: [^false].
		(signature includes: '0F38') = (mmmmm = 2r10) ifFalse: [^false].
		(signature includes: '0F3A') = (mmmmm = 2r11) ifFalse: [^false]].
	^true
! !

!VEXPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:23'!
mayMatchSize: aByteArray
	| n |
	n := aByteArray first = 16rC4 ifTrue: [3] ifFalse: [2].
	((signature includes: 'WIG') or: [signature includes: 'W0']) ifFalse: [^n
		= 3].
	(signature includes: 'W1') ifTrue: [^n = 3].
	(signature includes: '0F3A') ifTrue: [^n = 3].
	(signature includes: '0F38') ifTrue: [^n = 3].
	^true
! !

!VEXPrefix methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:23:24'!
overridesOperandSize
	^signature includes: '66'
! !

!VEXPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:23'!
length
	signature first = 16rC5 ifTrue: [^16].
	^24
! !

!VEXPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
signature
	^signature
! !

!VEXPrefix methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
signature: anArray
	signature := anArray
! !

!VEXPrefix methodsFor: 'private' stamp: 'KenD 11/22/2023 13:23:24'!
operandSize
	(signature includes: '128') ifTrue: [^128].
	(signature includes: '256') ifTrue: [^256].
	^nil
! !

!VEXPrefix methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:23:24'!
printOn: aStream
	signature isNil ifTrue: [^super printOn: aStream].
	signature
		do: [:s | aStream nextPutAll: s]
		separatedBy: [aStream nextPut: $.]
! !

!VEXPrefix methodsFor: 'isEvaluating' stamp: 'KenD 11/22/2023 13:23:24'!
sizeFor: instruction
	| encoding |
	((signature includes: 'WIG') or: [signature includes: 'W0']) ifFalse: [^3].
	(signature includes: 'W1') ifTrue: [^3].
	(signature includes: '0F3A') ifTrue: [^3].
	(signature includes: '0F38') ifTrue: [^3].
	instruction hasSib ifTrue: [^3].
	encoding := instruction spec operandEncoding.
	instruction operands withIndexDo: [:op :i | 
		op isMemory
			ifTrue: [(op baseExtension = 0 or: [op indexExtension = 0]) ifTrue: [^3]]
			ifFalse: [
				(op isRegister and: [op index > 7] andNot: [encoding isVvvvOperand: i])
					ifTrue: [^3]]].
	^2
! !

!VEXPrefix methodsFor: 'isEvaluating' stamp: 'KenD 11/22/2023 13:23:24'!
valueFor: instruction
	| size bytes last |
	size := self sizeFor: instruction.
	bytes := ByteArray new: size.
	size = 2 ifTrue: [bytes at: 1 put: 16rC5] ifFalse: [bytes at: 1 put: 16rC4].
	last := 0.
	(signature includes: '256')
		ifTrue: [bytes at: size put: (bytes last bitOr: self class l)].
	(signature includes: '66')
		ifTrue: [last := bytes at: size put: (last bitOr: 2r1)].
	(signature includes: 'F2')
		ifTrue: [last := bytes at: size put: (last bitOr: 2r10)].
	(signature includes: 'F3')
		ifTrue: [last := bytes at: size put: (last bitOr: 2r11)].
	(signature includes: 'W1')
		ifTrue: [last := bytes at: size put: (last bitOr: self class w)].
	(size = 3 and: [signature includes: '0F']) ifTrue: [bytes at: 2 put: 1].
	(signature includes: '0F38') ifTrue: [bytes at: 2 put: 2r10].
	(signature includes: '0F3A') ifTrue: [bytes at: 2 put: 2r11].
	^bytes
! !

!VEXPrefix methodsFor: 'writing' stamp: 'KenD 11/22/2023 13:23:24'!
writeOn: instruction
	| value |
	value := self valueFor: instruction.
	instruction writeVexPrefix: value
! !

!VEXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
b
	^16r20
! !

!VEXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
l
	^2r100
! !

!VEXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
r
	^16r80
! !

!VEXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
w
	^16r80
! !

!VEXPrefix class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:23:24'!
x
	^16r40
! !

!VEXPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:24'!
fromStream: aStream
	^self withSignature: (aStream upTo: Space)
! !

!VEXPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:24'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!VEXPrefix class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:23:24'!
withSignature: aString
	^Signatures at: aString
! !

!VEXPrefix class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:23:24'!
initializeSignatures
	Signatures isNil
		ifTrue: [ Signatures := Dictionary new ].
	'VEX.128.0F.WIG
	VEX.128.66.0F.W0
	VEX.128.66.0F.W1
	VEX.128.66.0F.WIG
	VEX.128.66.0F38.W0
	VEX.128.66.0F38.WIG
	VEX.128.66.0F3A.W0
	VEX.128.66.0F3A.W1
	VEX.128.66.0F3A.WIG
	VEX.128.F2.0F.WIG
	VEX.128.F3.0F.WIG
	VEX.256.0F.WIG
	VEX.256.66.0F.WIG
	VEX.256.66.0F38.W0
	VEX.256.66.0F38.WIG
	VEX.256.66.0F3A.W0
	VEX.256.66.0F3A.W1
	VEX.256.66.0F3A.WIG
	VEX.256.F2.0F.WIG
	VEX.256.F3.0F.WIG
	VEX.DDS.128.66.0F38.W0
	VEX.DDS.128.66.0F38.W1
	VEX.DDS.256.66.0F38.0
	VEX.DDS.256.66.0F38.W0
	VEX.DDS.256.66.0F38.W1
	VEX.DDS.LIG.128.66.0F38.W0
	VEX.DDS.LIG.128.66.0F38.W1
	VEX.LIG.0F.WIG
	VEX.LIG.66.0F.WIG
	VEX.LIG.F2.0F.W0
	VEX.LIG.F2.0F.W1
	VEX.LIG.F2.0F.WIG
	VEX.LIG.F3.0F.W0
	VEX.LIG.F3.0F.W1
	VEX.LIG.F3.0F.WIG
	VEX.LZ.0F.WIG
	VEX.LZ.F2.0F3A.W0
	VEX.LZ.F2.0F3A.W1
	VEX.NDD.128.66.0F.WIG
	VEX.NDD.256.66.0F.WIG
	VEX.NDD.LZ.0F38.W0
	VEX.NDD.LZ.0F38.W1
	VEX.NDD.LZ.F2.0F38.W0
	VEX.NDD.LZ.F2.0F38.W1
	VEX.NDS.128.0F.WIG
	VEX.NDS.128.66.0F.W0
	VEX.NDS.128.66.0F.WIG
	VEX.NDS.128.66.0F38.W0
	VEX.NDS.128.66.0F38.W1
	VEX.NDS.128.66.0F38.WIG
	VEX.NDS.128.66.0F3A.W0
	VEX.NDS.128.66.0F3A.W1
	VEX.NDS.128.66.0F3A.WIG
	VEX.NDS.128.F2.0F.WIG
	VEX.NDS.256.0F.WIG
	VEX.NDS.256.66.0F.WIG
	VEX.NDS.256.66.0F38.W0
	VEX.NDS.256.66.0F38.W1
	VEX.NDS.256.66.0F38.WIG
	VEX.NDS.256.66.0F3A.W0
	VEX.NDS.256.66.0F3A.WIG
	VEX.NDS.256.F2.0F.WIG
	VEX.NDS.LIG.66.0F3A.WIG
	VEX.NDS.LIG.F2.0F.W0
	VEX.NDS.LIG.F2.0F.W1
	VEX.NDS.LIG.F2.0F.WIG
	VEX.NDS.LIG.F3.0F.W0
	VEX.NDS.LIG.F3.0F.W1
	VEX.NDS.LIG.F3.0F.WIG
	VEX.NDS.LZ.0F38.W0
	VEX.NDS.LZ.0F38.W1
	VEX.NDS.LZ.66.0F38.W0
	VEX.NDS.LZ.66.0F38.W1
	VEX.NDS.LZ.F2.0F38.W0
	VEX.NDS.LZ.F2.0F38.W1
	VEX.NDS.LZ.F3.0F38.W0
	VEX.NDS.LZ.F3.0F38.W1
	VEX128.66.0F.WIG' lines
		do: [ :line | 
			| s vex |
			s := line trimBlanks.
			vex := self new signature: ($. split: s).
			Signatures at: s put: vex ]
! !

!VEXPrefix class methodsFor: 'private' stamp: 'KenD 11/22/2023 13:23:24'!
operandSizeOverrideBits
	^1
! !

!VEXPrefix class methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:24'!
peekFrom: aStream
	aStream peek = 16rC4 ifTrue: [^aStream next: 3].
	aStream peek = 16rC5 ifTrue: [^aStream next: 2].
	^nil
! !

!VEXPrefix class methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:23:24'!
print: byte on: stream
	stream nextPutAll: byte hex
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
acceptsOperands: aCollection
	operands size = aCollection size ifFalse: [^false].
	aCollection
		with: operands
		do: [:real :spec | (real isCompatibleWith: spec) ifFalse: [^false]].
	^true
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
hasImmediate2Data
	^opEncoding usesImmediate2
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
hasImmediateData
	^opEncoding usesImmediate
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
hasModRM
	| arity |
	extension notNil ifTrue: [^true].
	arity := self arity.
	arity = 0 ifTrue: [^false].
	(arity = 1 and: [operands first isConstant]) ifTrue: [^false].
	^opEncoding usesModRM
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
hasOperandEncoding: anOperandEncoding
	opEncoding = anOperandEncoding ifTrue: [^true].
	(opEncoding isNil and: [anOperandEncoding name = 'NP']) ifTrue: [^true].
	^opEncoding name = 'NP' and: [anOperandEncoding isNil]
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
isLike: anInstructionSpec
	opcode = anInstructionSpec opcode ifFalse: [^false].
	primary = anInstructionSpec primaryOpcode ifFalse: [^false].
	extension = anInstructionSpec extension ifFalse: [^false].
	(self hasOperandEncoding: anInstructionSpec operandEncoding)
		ifFalse: [^false].
	properties = anInstructionSpec properties ifFalse: [^false].
	implicitRead = anInstructionSpec implicitRead ifFalse: [^false].
	implicitWrite = anInstructionSpec implicitWrite ifFalse: [^false].
	implicitUndef = anInstructionSpec implicitUndef ifFalse: [^false].
	useful = anInstructionSpec useful ifFalse: [^false].
	protected = anInstructionSpec protected ifFalse: [^false].
	mode = anInstructionSpec mode ifFalse: [^false].
	compat = anInstructionSpec compat ifFalse: [^false].
	features = anInstructionSpec features ifFalse: [^false].
	preferred = anInstructionSpec isPreferred ifFalse: [^false].
	prefixes = anInstructionSpec prefixes ifFalse: [^false].
	^operands = anInstructionSpec operands
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
isPreferred
	^preferred
! !

!InstructionSpec methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:58:14'!
isPreferredTo: otherSpec for: realOperands
	1 to: operands size do: [:i | | real this other |
		real := realOperands at: i.
		this := operands at: i.
		other := otherSpec operands at: i.
		(real prefers: this to: other) ifTrue: [^true]].
	^false
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
arity
	^operands size
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
atnt
	^atnt
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
compat
	^compat
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
description
	^description
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
existsInWordSize: wordSize
	^wordSize = 8 ifTrue: [mode first = $V] ifFalse: [compat first = $V]
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
extension
	^extension
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
features
	^features
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:17:56'!
fromString: aString
	| fields |
	fields := Character tab split: aString.
	self
		instruction: fields second;
		opcode: fields first;
		operandEncoding: fields third trimBlanks.
	properties := fields at: 4.
	implicitRead := fields at: 5.
	implicitWrite := fields at: 6.
	implicitUndef := fields at: 7.
	useful := fields at: 8.
	protected := (fields at: 9) = 'YES'.
	mode := fields at: 10.
	compat := fields at: 11.
	features := fields at: 12.
	atnt := fields at: 13.
	preferred := (fields at: 14) = 'YES'.
	description := fields at: 15.
	self fixDocumentation
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
implicitRead
	^implicitRead
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
implicitUndef
	^implicitUndef
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
implicitWrite
	^implicitWrite
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
instruction
	^instruction
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
instruction: aString
	| substrings |
	instruction := aString asLowercase.
	substrings := (instruction replaceAllSubstrings: ',' with: ' ') substrings.
	mnemonic := substrings first.
	self operandsFrom: substrings
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
mnemonic
	^mnemonic
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
mode
	^mode
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
opcode
	^opcode
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
opcode: aString
	| reader |
	opcode := self opcodeFrom: aString.
	reader := opcode readStream.
	prefixes := OrderedCollection new.
	self
		legacyPrefixesFrom: reader;
		rexPrefixFrom: reader;
		vexPrefixFrom: reader;
		primaryOpcodeFrom: reader;
		opcodeExtensionFrom: reader.
	prefixes := prefixes asArray
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
operand: index of: decoder
	| op type |
	op := opEncoding operand: index of: decoder.
	type := operands at: index.
	type isMoff ifTrue: [^type operandFrom: op value].
	op isMemory ifTrue: [op length: type memoryLength].
	op isImmediate ifTrue: [op length: type length].
	^op
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
operandEncoding
	^opEncoding
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
operandEncoding: aString
	opEncoding := OperandEncoding named: aString
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
operands
	^operands
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
prefixes
	^prefixes
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
primaryOpcode
	^primary
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
primaryOpcodeFrom: aStream
	| oc |
	primary := #[].
	[
		aStream atEnd not
			and: [
				oc := aStream peek: 2.
				oc := self fixOpcode: oc.
				oc size = 2]
			and: [oc asUppercase = oc]
			and: [oc conform: [:ch | ch isHexDigit]]]
		whileTrue: [
			primary := primary
				copyWith: oc first digitValue * 16 + oc second digitValue.
			aStream upTo: Space]
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
properties
	^properties
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
protected
	^protected
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
rexPrefixFrom: aStream
	| rex |
	(aStream peekForAll: 'REX') ifTrue: [
		aStream skip: 'REX' size negated.
		rex := REXPrefix fromStream: aStream.
		aStream upTo: Space.
		prefixes add: rex]
! !

!InstructionSpec methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:14'!
useful
	^useful
! !

!InstructionSpec methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:14'!
encodingSelectors
	opEncoding isNil ifTrue: [^#()].
	^opEncoding selectors
! !

!InstructionSpec methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:14'!
family
	^Specs at: mnemonic
! !

!InstructionSpec methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:14'!
operandLength
	operands do: [:op | op length ifNotNil: [:l | ^l]].
	^nil
! !

!InstructionSpec methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:58:14'!
fixDocumentation
	(mnemonic = 'enter' and: [operands second length = 16])
		ifTrue: [operands swap: 1 with: 2].
	(mnemonic = 'pushq' and: [operands first length !!= 16])
		ifTrue: [mnemonic := 'push'].
	(instruction = 'vmovsd xmm1, xmm2, xmm3' and: [primary = #[16r11]]) ifTrue: [
		operands swap: 1 with: 3.
		instruction := 'vmovsd xmm3, xmm2, xmm1']
! !

!InstructionSpec methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:58:14'!
fixOpcode: oc
	^oc = '0f' ifTrue: ['0F'] ifFalse: [oc]
! !

!InstructionSpec methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:22:50'!
operandsFrom: substrings
	"operands := substrings allButFirst collect: [:s | ISAOperandType named: s]"
	self flag: #bogus.
	^666 
! !

!InstructionSpec methodsFor: 'private' stamp: 'KenD 11/22/2023 13:20:10'!
legacyPrefixesFrom: aStream
"	| prefix |
	aStream peekForAll: 'PREF.'.
	[| hex |
		hex := aStream peek: 2.
		hex !!= 'RE' and: [hex !!= 'VE'] and: [hex size = 2] and: [
			prefix := LegacyPrefix
				withValue: hex first asUppercase digitValue * 16
					+ hex second asUppercase digitValue.
			prefix notNil]]
		whileTrue: [
			prefixes add: prefix.
			aStream upTo: Space]
"	self flag: 'unused'.
	^'BOGUS'! !

!InstructionSpec methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
opcodeExtensionFrom: aStream
	(aStream peekFor: $/) ifFalse: [^self].
	extension := aStream peek digitValue < 8 ifTrue: [aStream next digitValue]
! !

!InstructionSpec methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
opcodeFrom: aString
	(aString includesString: '66') ifTrue: [^aString].
	(instruction endsWith: '16, imm8') ifTrue: [^'66 ' , aString].
	(instruction endsWith: '16, imm16') ifTrue: [^'66 ' , aString].
	(instruction endsWith: ' ax, imm16') ifTrue: [^'66 ' , aString].
	^aString
! !

!InstructionSpec methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
vexPrefixFrom: aStream
	| vex |
	(aStream peekForAll: 'VEX') ifTrue: [
		aStream skip: 'VEX' size negated.
		vex := VEXPrefix fromStream: aStream.
		prefixes add: vex]
! !

!InstructionSpec methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:58:14'!
printOn: aStream
	instruction isNil ifTrue: [^super printOn: aStream].
	aStream nextPutAll: instruction
! !

!InstructionSpec class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
addendum32
	^'
FF /2	CALL r/m32	M		rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			NE	V				Call near, absolute indirect, address given in r/m32.
48 +rw	DEC r16 	O							NE	V				Decrement r16 by 1.
48 +rd	DEC r32	O							NE	V				Decrement r32 by 1.
40 +rw 	INC r16 	O							NE	V				Increment word register by 1.
40 +rd 	INC r32 	O							NE	V				Increment doubleword register by 1.
FF /4 	JMP r/m32 	M	R						NS	V				Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode.

66 REX.W+ 0F 3A 22 /r ib 	PINSRQ xmm1, r/m64, imm8 	RMI							NE	V	SSE4_1	pinsrq		Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8.
8F /0 	POP r/m32 	M		RSP	RSP				NE	V				Pop top of stack into m32; increment stack pointer.
58 +rd 	POP r32 	O		RSP	RSP				NE	V				Pop top of stack into r32; increment stack pointer.
FF /6	PUSH r/m32	M		RSP	RSP				NE	V				Push r/m32.
50 +rd	PUSH r32	O		RSP	RSP				NE	V			YES	Push r32.'
! !

!InstructionSpec class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
bestMatchForMnemonic: aString operands: operands
	| current family |
	current := nil.
	family := Specs at: aString.
	family do: [:spec | | fits |
		fits := spec acceptsOperands: operands.
		fits ifTrue: [
			spec isPreferred ifTrue: [^spec].
			(current isNil or: [spec isPreferredTo: current for: operands])
				ifTrue: [current := spec]]].
	current ifNil: [self error: 'cannot identify the instruction'].
	^current
! !

!InstructionSpec class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
bestMatchForMnemonic: aString operands: operands wordSize: wordSize
	| current family |
	current := nil.
	family := Specs at: aString.
	family
		select: [:spec | (spec existsInWordSize: wordSize)
			and: [spec acceptsOperands: operands]]
		thenDo: [:spec | 
			spec isPreferred ifTrue: [^spec].
			(current isNil or: [spec isPreferredTo: current for: operands])
				ifTrue: [current := spec]].
	current ifNil: [self error: 'cannot identify the instruction'].
	^current
! !

!InstructionSpec class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
byteSpecs
	^self selectSpecs: [:s | s opcode includesString: '+r']
! !

!InstructionSpec class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
selectSpecs: aBlock
	^Array
		streamContents: [:strm | Specs
			do: [:specs | specs select: aBlock thenDo: [:s | strm nextPut: s]]]
! !

!InstructionSpec class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
specsByOpcode
	| specs |
	specs := Dictionary new.
	Specs do: [:family | 
		family do: [:s | | group |
			group := specs at: s primaryOpcode ifAbsentPut: [OrderedCollection new].
			group add: s]].
	^specs
! !

!InstructionSpec class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:58:14'!
specsCollect: aBlock
	^Array streamContents: [:strm | 
		Specs
			do: [:specs | specs
				collect: aBlock
				thenDo: [:aspect | strm nextPut: aspect]]]
! !

!InstructionSpec class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:58:14'!
fromString: aString
	^self new fromString: aString
! !

!InstructionSpec class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:23:19'!
initialize
	OperandEncoding initializeEncodings.
	Prefixes initialize.
"	VEXPrefix initializeSignatures.
	ISAOperandType initialize.
	self initializeSpecs.
	Smalltalk at: #Decoder64 ifPresent: [ :d | d initializeSpecs ]
"

! !

!InstructionSpec class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:58:14'!
initializeSpecs
	| dict reader |
	dict := Dictionary new.
	reader := (self x86 , self addendum32) readStream.
	reader nextLine.
	[reader atEnd] whileFalse: [| line spec family |
		line := reader nextLine.
		line trimBlanks notEmpty ifTrue: [
			spec := self fromString: line.
			family := dict at: spec mnemonic ifAbsentPut: [OrderedCollection new].
			(spec arity = 0 orNot: [spec operandEncoding isNil])
				ifTrue: [family add: spec]]].
	Specs := dict
! !

!InstructionSpec class methodsFor: 'documentation' stamp: 'KenD 11/22/2023 07:58:14'!
x86
	^
'Opcode	Instruction	Op/En	Properties	Implicit Read	Implicit Write	Implicit Undef	Useful	Protected	64-bit Mode	Compat/32-bit-Legacy Mode	CPUID Feature Flags	AT&T Mnemonic	Preferred 	Description
														
37	AAA								I	V				ASCII adjust AL after addition.
														
D5 0A	AAD								I	V				ASCII adjust AX before division.
D5 ib	AAD imm8								I	V				Adjust AX before division to number base imm8.
														
D4 0A	AAM								I	V				ASCII adjust AX after multiply.
D4 ib	AAM imm8								I	V				Adjust AX after multiply to number base imm8.
														
3F	AAS								I	V				ASCII adjust AL after subtraction.
														
14 ib	ADC AL, imm8	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcb		Add with carry imm8 to AL
15 iw	ADC AX, imm16	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcw		Add with carry imm16 to AX.
15 id	ADC EAX, imm32	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcl		Add with carry imm32 to EAX.
REX.W+ 15 id	ADC RAX, imm32	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcq		Add with carry imm32 sign extended to 64- bits to RAX.
80 /2 ib	ADC r/m8, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcb		Add with carry imm8 to r/m8.
REX+ 80 /2 ib	ADC r/m8, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcb		Add with carry imm8 to r/m8.
81 /2 iw	ADC r/m16, imm16	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcw		Add with carry imm16 to r/m16.
81 /2 id	ADC r/m32, imm32	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcl		Add with CF imm32 to r/m32.
REX.W+ 81 /2 id	ADC r/m64, imm32	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcq		Add with CF imm32 sign extended to 64-bits to r/m64.
83 /2 ib	ADC r/m16, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcw	YES	Add with CF sign-extended imm8 to r/m16.
83 /2 ib	ADC r/m32, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcl	YES	Add with CF sign-extended imm8 into r/m32.
REX.W+ 83 /2 ib	ADC r/m64, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcq	YES	Add with CF sign-extended imm8 into r/m64.
10 /r	ADC r/m8, r8	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcb	YES	Add with carry byte register to r/m8.
REX+ 10 /r	ADC r/m8, r8	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcb	YES	Add with carry byte register to r/m8.
11 /r	ADC r/m16, r16	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcw	YES	Add with carry r16 to r/m16.
11 /r	ADC r/m32, r32	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcl	YES	Add with CF r32 to r/m32.
REX.W+ 11 /r	ADC r/m64, r64	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcq	YES	Add with CF r64 to r/m64.
12 /r	ADC r8, r/m8	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcb		Add with carry r/m8 to byte register.
REX+ 12 /r	ADC r8, r/m8	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcb		Add with carry r/m64 to byte register.
13 /r	ADC r16, r/m16	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcw		Add with carry r/m16 to r16.
13 /r	ADC r32, r/m32	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		adcl		Add with CF r/m32 to r32.
REX.W+ 13 /r	ADC r64, r/m64	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		adcq		Add with CF r/m64 to r64.
														
04 ib	ADD AL, imm8	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addb		Add imm8 to AL.
05 iw	ADD AX, imm16 	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addw		Add imm16 to AX.
05 id	ADD EAX, imm32 	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addl		Add imm32 to EAX.
REX.W+ 05 id 	ADD RAX, imm32 	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addq		Add imm32 sign-extended to 64-bits to RAX.  
80 /0 ib	ADD r/m8, imm8 	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addb		Add imm8 to r/m8.
REX+ 80 /0 ib 	ADD r/m8, imm8 	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addb		Add sign-extended imm8 to r/m64.
81 /0 iw	ADD r/m16, imm16 	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addw		Add imm16 to r/m16.
81 /0 id	ADD r/m32, imm32 	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addl		Add imm32 to r/m32.
REX.W+ 81 /0 id	ADD r/m64, imm32	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addq		Add imm32 sign-extended to 64-bits to r/m64.
83 /0 ib	ADD r/m16, imm8 	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addw	YES	Add sign-extended imm8 to r/m16. 
83 /0 ib	ADD r/m32, imm8	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addl	YES	Add sign-extended imm8 to r/m32. 
REX.W+ 83 /0 ib 	ADD r/m64, imm8 	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addq	YES	Add sign-extended imm8 to r/m64. 
00 /r 	ADD r/m8, r8 	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addb	YES	Add r8 to r/m8.
REX+ 00 /r	ADD r/m8, r8	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addb	YES	Add r8 to r/m8. 
01 /r	ADD r/m16, r16 	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addw	YES	Add r16 to r/m16. 
01 /r	ADD r/m32, r32 	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addl	YES	Add r32 to r/m32. 
REX.W+ 01 /r 	ADD r/m64, r64 	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addq	YES	Add r64 to r/m64. 
02 /r 	ADD r8, r/m8 	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addb		Add r/m8 to r8. 
REX+ 02 /r	ADD r8, r/m8	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addb		Add r/m8 to r8. 
03 /r	ADD r16, r/m16 	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addw		Add r/m16 to r16. 
03 /r	ADD r32, r/m32 	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		addl		Add r/m32 to r32. 
REX.W+ 03 /r	ADD r64, r/m64	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		addq		Add r/m64 to r64.
														
66 0F 58 /r	ADDPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	addpd		Add packed double-precision floating-point values from xmm2/m128 to xmm1.
VEX.NDS.128.66.0F.WIG 58 /r	VADDPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vaddpd		Add packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
VEX.NDS.256.66.0F.WIG 58 /r	VADDPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vaddpd		Add packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
														
0F 58 /r	ADDPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	addps		Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.
VEX.NDS.128.0F.WIG 58 /r	VADDPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vaddps		Add packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
VEX.NDS.256.0F.WIG 58 /r	VADDPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vaddps		Add packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
														
F2 0F 58 /r	ADDSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	addsd		Add the low double-precision floating-point value from xmm2/m64 to xmm1.
VEX.NDS.LIG.F2.0F.WIG 58 /r	VADDSD xmm1, xmm2, xmm3/m64	RVM	Z, R, R						V	V	AVX	vaddsd		Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.
														
F3 0F 58 /r	ADDSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	addss		Add the low single-precision floating-point value from xmm2/m32 to xmm1.
VEX.NDS.LIG.F3.0F.WIG 58 /r	VADDSS xmm1, xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vaddss		Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.
														
66 0F D0 /r	ADDSUBPD xmm1, xmm2/m128	RM	RW, R						V	V	PNI	addsubpd		Add/subtract double-precision floating-point values from xmm2/m128 to xmm1.
VEX.NDS.128.66.0F.WIG D0 /r	VADDSUBPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vaddsubpd		Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
VEX.NDS.256.66.0F.WIG D0 /r	VADDSUBPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vaddsubpd		Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
														
F2 0F D0 /r	ADDSUBPS xmm1, xmm2/m128	RM	RW, R						V	V	PNI	addsubps		Add/subtract single-precision floating-point values from xmm2/m128 to xmm1.
VEX.NDS.128.F2.0F.WIG D0 /r	VADDSUBPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vaddsubps		Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
VEX.NDS.256.F2.0F.WIG D0 /r	VADDSUBPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vaddsubps		Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
														
66 0F 38 DE /r	AESDEC xmm1, xmm2/m128	RM	RW, R						V	V	AES	aesdec		Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
VEX.NDS.128.66.0F38.WIG DE /r	VAESDEC xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AES AVX	vaesdec		Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.
														
66 0F 38 DF /r	AESDECLAST xmm1, xmm2/m128	RM	RW, R						V	V	AES	aesdeclast		Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
VEX.NDS.128.66.0F38.WIG DF /r	VAESDECLAST xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AES AVX	vaesdeclast		Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.
														
66 0F 38 DC /r	AESENC xmm1, xmm2/m128	RM	RW, R						V	V	AES	aesenc		Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
VEX.NDS.128.66.0F38.WIG DC /r	VAESENC xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AES AVX	vaesenc		Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1.
														
66 0F 38 DD /r	AESENCLAST xmm1, xmm2/m128	RM	RW, R						V	V	AES	aesenclast		Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
VEX.NDS.128.66.0F38.WIG DD /r	VAESENCLAST xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AES AVX	vaesenclast		Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1.
														
66 0F 38 DB /r	AESIMC xmm1, xmm2/m128	RM	W, R						V	V	AES	aesimc		Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.
VEX.128.66.0F38.WIG DB /r	VAESIMC xmm1, xmm2/m128	RM	Z, R						V	V	AES AVX	vaesimc		Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.
														
66 0F 3A DF /r ib	AESKEYGENASSIST xmm1, xmm2/m128, imm8	RMI	W, R, R						V	V	AES	aeskeygenassist		Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
VEX.128.66.0F3A.WIG DF /r ib	VAESKEYGENASSIST xmm1, xmm2/m128, imm8	RMI	Z, R, R						V	V	AES AVX	vaeskeygenassist		Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
														
24 ib	AND AL, imm8	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andb		AL AND imm8.
25 iw	AND AX, imm16	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andw		AX AND imm16.
25 id	AND EAX, imm32	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andl		EAX AND imm32.
REX.W+ 25 id	AND RAX, imm32	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andq		RAX AND imm32 sign-extended to 64-bits.
80 /4 ib	AND r/m8, imm8	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andb		r/m8 AND imm8.
REX+ 80 /4 ib	AND r/m8, imm8	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andb		r/m8 AND imm8.
81 /4 iw	AND r/m16, imm16	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andw		r/m16 AND imm16.
81 /4 id	AND r/m32, imm32	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andl		r/m32 AND imm32.
REX.W+ 81 /4 id	AND r/m64, imm32	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andq		r/m64 AND imm32 sign extended to 64-bits.
83 /4 ib	AND r/m16, imm8	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andw	YES	r/m16 AND imm8 (sign-extended).
83 /4 ib	AND r/m32, imm8	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andl	YES	r/m32 AND imm8 (sign-extended).
REX.W+ 83 /4 ib	AND r/m64, imm8	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andq	YES	r/m64 AND imm8 (sign-extended).
20 /r	AND r/m8, r8	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andb	YES	r/m8 AND r8.
REX+ 20 /r	AND r/m8, r8	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andb	YES	r/m64 AND r8 (sign-extended).
21 /r	AND r/m16, r16	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andw	YES	r/m16 AND r16.
21 /r	AND r/m32, r32	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andl	YES	r/m32 AND r32.
REX.W+ 21 /r	AND r/m64, r64	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andq	YES	r/m64 AND r32.
22 /r	AND r8, r/m8	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andb		r8 AND r/m8.
REX+ 22 /r	AND r8, r/m8	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andb		r/m64 AND r8 (sign-extended).
23 /r	AND r16, r/m16	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andw		r16 AND r/m16.
23 /r	AND r32, r/m32	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		andl		r32 AND r/m32.
REX.W+ 23 /r	AND r64, r/m64	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		andq		r64 AND r/m64.
														
VEX.NDS.LZ.0F38.W0 F2 /r	ANDN r32a, r32b, r/m32	RVM	W, R, R		E.SF E.ZF E.OF E.CF	E.AF E.PF			V	V	BMI1	andnl		Bitwise AND of inverted r32b with r/m32, store result in r32a
VEX.NDS.LZ.0F38.W1 F2 /r	ANDN r64a, r64b, r/m64	RVM	W, R, R		E.SF E.ZF E.OF E.CF	E.AF E.PF			V	NE	BMI1	andnq		Bitwise AND of inverted r64b with r/m64, store result in r64a
														
66 0F 54 /r	ANDPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	andpd		Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.
VEX.NDS.128.66.0F.WIG 54 /r	VANDPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vandpd		Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 54 /r	VANDPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vandpd		Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem.
														
0F 54 /r	ANDPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	andps		Bitwise logical AND of xmm2/m128 and xmm1.
VEX.NDS.128.0F.WIG 54 /r	VANDPS xmm1,xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vandps		Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.0F.WIG 54 /r	VANDPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vandps		Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem.
														
66 0F 55 /r	ANDNPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	andnpd		Bitwise logical AND NOT of xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG 55 /r	VANDNPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vandnpd		Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 55 /r	VANDNPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vandnpd		Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem.
														
0F 55 /r	ANDNPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	andnps		Bitwise logical AND NOT of xmm2/m128 and xmm1.
VEX.NDS.128.0F.WIG 55 /r	VANDNPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vandnps		Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.0F.WIG 55 /r	VANDNPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vandnps		Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem.
														
63 /r	ARPL r/m16, r16						YES	NO	NE	V				Adjust RPL of r/m16 to not less than RPL of r16.
														
66 0F 3A 0D /r ib	BLENDPD xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE4_1	blendpd		Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
VEX.NDS.128.66.0F3A.WIG 0D /r ib	VBLENDPD xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vblendpd		Select packed double-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1. 
VEX.NDS.256.66.0F3A.WIG 0D /r ib	VBLENDPD ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vblendpd		Select packed double-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.
														
VEX.NDS.LZ.0F38.W0 F7 /r	BEXTR r32a, r/m32, r32b	RMV	W, R, R		E.ZF E.OF E.CF	E.AF E.SF E.PF			V	V	BMI1	bextrl		Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a.
VEX.NDS.LZ.0F38.W1 F7 /r	BEXTR r64a, r/m64, r64b	RMV	W, R, R		E.ZF E.OF E.CF	E.AF E.SF E.PF			V	NE	BMI1	bextrq		Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a
														
66 0F 3A 0C /r ib	BLENDPS xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE4_1	blendps		Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
VEX.NDS.128.66.0F3A.WIG 0C /r ib	VBLENDPS xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vblendps		Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.
VEX.NDS.256.66.0F3A.WIG 0C /r ib	VBLENDPS ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vblendps		Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.
														
66 0F 38 15 /r	BLENDVPD xmm1, xmm2/m128, <XMM0>	RM0	RW, R, R						V	V	SSE4_1	blendvpd		Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.
VEX.NDS.128.66.0F3A.W0 4B /r /is4	VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4	RVMR	Z, R, R, R						V	V	AVX	vblendvpd		Conditionally copy double-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4.
VEX.NDS.256.66.0F3A.W0 4B /r /is4	VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4	RVMR	W, R, R, R						V	V	AVX	vblendvpd		Conditionally copy double-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4.
														
66 0F 38 14 /r	BLENDVPS xmm1, xmm2/m128, <XMM0>	RM0	RW, R, R						V	V	SSE4_1	blendvps		Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
VEX.NDS.128.66.0F3A.W0 4A /r /is4	VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4	RVMR	Z, R, R, R						V	V	AVX	vblendvps		Conditionally copy single-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4.
VEX.NDS.256.66.0F3A.W0 4A /r /is4	VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4	RVMR	W, R, R, R						V	V	AVX	vblendvps		Conditionally copy single-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4.
														
VEX.NDD.LZ.0F38.W0 F3 /3	BLSI r32, r/m32	VM	RW, R		E.ZF E.SF E.OF E.CF	E.AF E.PF			V	V	BMI1	blsil		Extract lowest set bit from r/m32 and set that bit in r32.
VEX.NDD.LZ.0F38.W1 F3 /3	BLSI r64, r/m64	VM	RW, R		E.ZF E.SF E.OF E.CF	E.AF E.PF			V	NE	BMI1	blsiq		Extract lowest set bit from r/m64, and set that bit in r64.
														
VEX.NDD.LZ.0F38.W0 F3 /2	BLSMSK r32, r/m32	VM	RW, R		E.ZF E.SF E.OF E.CF	E.AF E.PF			V	V	BMI1	blsmskl		Set all lower bits in r32 to "1" starting from bit 0 to lowest set bit in r/m32
VEX.NDD.LZ.0F38.W1 F3 /2	BLSMSK r64, r/m64	VM	RW, R		E.ZF E.SF E.OF E.CF	E.AF E.PF			V	NE	BMI1	blsmskq		Set all lower bits in r64 to "1" starting from bit 0 to lowest set bit in r/m64
														
VEX.NDD.LZ.0F38.W0 F3 /1	BLSR r32, r/m32	VM	W, R		E.ZF E.SF E.OF E.CF	E.AF E.PF			V	V	BMI1	blsrl		Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32.
VEX.NDD.LZ.0F38.W1 F3 /1	BLSR r64, r/m64	VM	W, R		E.ZF E.SF E.OF E.CF	E.AF E.PF			V	NE	BMI1	blsrq		Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64.
														
62 /r	BOUND r16, m16&16								I	V				Check if r16 (array index) is within bounds specified by m16&16.
62 /r	BOUND r32, m32&32								I	V				Check if r32 (array index) is within bounds specified by m16&16.
														
0F BC /r	BSF r16, r/m16	RM	uw, R		E.ZF	E.CF E.OF E.SF E.AF E.PF			V	V		bsfw		Bit scan forward on r/m16.
0F BC /r	BSF r32, r/m32	RM	uz, R		E.ZF	E.CF E.OF E.SF E.AF E.PF			V	V		bsfl		Bit scan forward on r/m32.
REX.W+ 0F BC	BSF r64, r/m64	RM	uw, R		E.ZF	E.CF E.OF E.SF E.AF E.PF			V	NE		bsfq		Bit scan forward on r/m64.
														
0F BD /r	BSR r16, r/m16	RM	uw, R		E.ZF	E.CF E.OF E.SF E.AF E.PF			V	V		bsrw		Bit scan reverse on r/m16.
0F BD /r	BSR r32, r/m32	RM	uz, R		E.ZF	E.CF E.OF E.SF E.AF E.PF			V	V		bsrl		Bit scan reverse on r/m32.
REX.W+ 0F BD	BSR r64, r/m64	RM	uw, R		E.ZF	E.CF E.OF E.SF E.AF E.PF			V	NE		bsrq		Bit scan reverse on r/m64.
														
0F C8 +rd	BSWAP r32	O	RW						V	V		bswap		Reverses the byte order of a 32-bit register.
REX.W+ 0F C8 +rd	BSWAP r64	O	RW						V	NE		bswap		Reverses the byte order of a 64-bit register.
														
0F A3	BT r/m16, r16	MR	R, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btw		Store selected bit in CF flag.
0F A3	BT r/m32, r32	MR	R, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btl		Store selected bit in CF flag.
REX.W+ 0F A3	BT r/m64, r64	MR	R, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btq		Store selected bit in CF flag.
0F BA /4 ib	BT r/m16, imm8	MI	R, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btw		Store selected bit in CF flag.
0F BA /4 ib	BT r/m32, imm8	MI	R, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btl		Store selected bit in CF flag.
REX.W+ 0F BA /4 ib	BT r/m64, imm8	MI	R, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btq		Store selected bit in CF flag.
														
0F BB	BTC r/m16, r16	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btcw		Store selected bit in CF flag and complement.
0F BB	BTC r/m32, r32	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btcl		Store selected bit in CF flag and complement.
REX.W+ 0F BB	BTC r/m64, r64	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btcq		Store selected bit in CF flag and complement.
0F BA /7 ib	BTC r/m16, imm8	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btcw		Store selected bit in CF flag and complement.
0F BA /7 ib	BTC r/m32, imm8	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btcl		Store selected bit in CF flag and complement.
REX.W+ 0F BA /7 ib	BTC r/m64, imm8	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btcq		Store selected bit in CF flag and complement.
														
0F B3	BTR r/m16, r16	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btrw		Store selected bit in CF flag and clear.
0F B3	BTR r/m32, r32 	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btrl		Store selected bit in CF flag and clear.
REX.W+ 0F B3	BTR r/m64, r64 	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btrq		Store selected bit in CF flag and clear.
0F BA /6 ib	BTR r/m16, imm8 	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btrw		Store selected bit in CF flag and clear.
0F BA /6 ib	BTR r/m32, imm8 	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btrl		Store selected bit in CF flag and clear.
REX.W+ 0F BA /6 ib	BTR r/m64, imm8	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btrq		Store selected bit in CF flag and clear.
														
0F AB	BTS r/m16, r16 	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btsw		Store selected bit in CF flag and set.
0F AB	BTS r/m32, r32 	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btsl		Store selected bit in CF flag and set.
REX.W+ 0F AB	BTS r/m64, r64 	MR	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btsq		Store selected bit in CF flag and set.
0F BA /5 ib	BTS r/m16, imm8 	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btsw		Store selected bit in CF flag and set.
0F BA /5 ib	BTS r/m32, imm8 	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	V		btsl		Store selected bit in CF flag and set.
REX.W+ 0F BA /5 ib	BTS r/m64, imm8	MI	RW, R		E.CF	E.OF E.SF E.AF E.PF			V	NE		btsq		Store selected bit in CF flag and set.
														
VEX.NDS.LZ.0F38.W0 F5 /r	BZHI r32a, r/m32, r32b	RMV	W, R, R		E.ZF E.CF E.SF E.OF	E.AF E.PF			V	V	BMI2	bzhil		Zero bits in r/m32 starting with the position in r32b, write result to r32a.
VEX.NDS.LZ.0F38.W1 F5 /r	BZHI r64a, r/m64, r64b	RMV	W, R, R		E.ZF E.CF E.SF E.OF	E.AF E.PF			V	NE	BMI2	bzhiq		Zero bits in r/m64 starting with the position in r64b, write result to r64a.
														
E8 cw 	CALL rel16 			rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			NS	V				Call near, relative, displacement relative to next instruction.
E8 cd	CALL rel32	D	R	rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			V	V		callq		Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.
FF /2	CALL r/m16			rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			NE	V				Call near, absolute indirect, address given in r/m16.
FF /2	CALL r/m32			rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			NE	V				Call near, absolute indirect, address given in r/m32.
FF /2	CALL r/m64	M	R	rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			V	NE		callq		Call near, absolute indirect, address given in r/m64.
9A cd 	CALL ptr16:16 			rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			I	V				Call far, absolute, address given in operand.
9A cp 	CALL ptr16:32 			rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			I	V				Call far, absolute, address given in operand.
FF /3	CALL m16:16	M	R	rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			V	V		callq		Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16- bit offset from far pointer referenced in the instruction.
FF /3	CALL m16:32	M	R	rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			V	V		callq		In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction.
REX.W+ FF /3	CALL m16:64	M	R	rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7	RAX RDX XMM0 XMM1	RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15			V	NE		callq		In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction.
														
PREF.66+ 98	CBW	NP		AL	AX				V	V		cbtw		AX = sign-extend of AL.
98	CWDE	NP		AX	RAX				V	V		cwtl		EAX = sign-extend of AX.
REX.W+ 98	CDQE	NP		EAX	RAX				V	NE		cltq		RAX = sign-extend of EAX.
														
F8	CLC	NP			E.CF				V	V		clc		Clear CF flag.
														
FC	CLD	NP			E.DF				V	V		cld		Clear DF flag.
														
0F AE /7	CLFLUSH m8	M	I						V	V	CLFLUSH	clflush		Flushes cache line containing m8.
														
FA	CLI	NP		E.VM E.IOPL E.VIP	e.if e.vif				V	V		cli		Clear interrupt flag; interrupts disabled when interrupt flag cleared.
														
0F 06	CLTS						NO	YES	V	V				Clears TS flag in CR0.
														
F5	CMC	NP		E.CF	E.CF				V	V		cmc		Complement CF flag.
														
0F 47 /r	CMOVA r16, r/m16 	RM	w, R	E.CF E.ZF					V	V	CMOV	cmovaw		Move if above (CF=0 and ZF=0).
0F 47 /r 	CMOVA r32, r/m32 	RM	z, R	E.CF E.ZF					V	V	CMOV	cmoval		Move if above (CF=0 and ZF=0).
REX.W+ 0F 47 /r 	CMOVA r64, r/m64 	RM	w, R	E.CF E.ZF					V	NE	CMOV	cmovaq		Move if above (CF=0 and ZF=0).
0F 43 /r	CMOVAE r16, r/m16 	RM	w, R	E.CF					V	V	CMOV	cmovaew		Move if above or equal (CF=0).
0F 43 /r 	CMOVAE r32, r/m32 	RM	z, R	E.CF					V	V	CMOV	cmovael		Move if above or equal (CF=0).
REX.W+ 0F 43 /r 	CMOVAE r64, r/m64 	RM	w, R	E.CF					V	NE	CMOV	cmovaeq		Move if above or equal (CF=0).
0F 42 /r	CMOVB r16, r/m16 	RM	w, R	E.CF					V	V	CMOV	cmovbw		Move if below (CF=1).
0F 42 /r 	CMOVB r32, r/m32 	RM	z, R	E.CF					V	V	CMOV	cmovbl		Move if below (CF=1).
REX.W+ 0F 42 /r 	CMOVB r64, r/m64 	RM	w, R	E.CF					V	NE	CMOV	cmovbq		Move if below (CF=1).
0F 46 /r	CMOVBE r16, r/m16 	RM	w, R	E.CF E.ZF					V	V	CMOV	cmovbew		Move if below or equal (CF=1 or ZF=1).
0F 46 /r 	CMOVBE r32, r/m32 	RM	z, R	E.CF E.ZF					V	V	CMOV	cmovbel		Move if below or equal (CF=1 or ZF=1).
REX.W+ 0F 46 /r 	CMOVBE r64, r/m64	RM	w, R	E.CF E.ZF					V	NE	CMOV	cmovbeq		Move if below or equal (CF=1 or ZF=1).
0F 42 /r	CMOVC r16, r/m16 	RM	w, R	E.CF					V	V	CMOV	cmovcw		Move if carry (CF=1).
0F 42 /r 	CMOVC r32, r/m32 	RM	z, R	E.CF					V	V	CMOV	cmovcl		Move if carry (CF=1).
REX.W+ 0F 42 /r 	CMOVC r64, r/m64 	RM	w, R	E.CF					V	NE	CMOV	cmovcq		Move if carry (CF=1).
0F 44 /r	CMOVE r16, r/m16 	RM	w, R	E.ZF					V	V	CMOV	cmovew		Move if equal (ZF=1).
0F 44 /r 	CMOVE r32, r/m32 	RM	z, R	E.ZF					V	V	CMOV	cmovel		Move if equal (ZF=1).
REX.W+ 0F 44 /r 	CMOVE r64, r/m64 	RM	w, R	E.ZF					V	NE	CMOV	cmoveq		Move if equal (ZF=1).
0F 4F /r	CMOVG r16, r/m16 	RM	w, R	E.ZF E.SF E.OF					V	V	CMOV	cmovgw		Move if greater (ZF=0 and SF=OF).
0F 4F /r 	CMOVG r32, r/m32 	RM	z, R	E.ZF E.SF E.OF					V	V	CMOV	cmovgl		Move if greater (ZF=0 and SF=OF).
REX.W+ 0F 4F /r 	CMOVG r64, r/m64 	RM	w, R	E.ZF E.SF E.OF					V	NE	CMOV	cmovgq		Move if greater (ZF=0 and SF=OF).
0F 4D /r	CMOVGE r16, r/m16 	RM	w, R	E.SF E.OF					V	V	CMOV	cmovgew		Move if greater or equal (SF=OF).
0F 4D /r 	CMOVGE r32, r/m32 	RM	z, R	E.SF E.OF					V	V	CMOV	cmovgel		Move if greater or equal (SF=OF).
REX.W+ 0F 4D /r 	CMOVGE r64, r/m64 	RM	w, R	E.SF E.OF					V	NE	CMOV	cmovgeq		Move if greater or equal (SF=OF).
0F 4C /r	CMOVL r16, r/m16 	RM	w, R	E.SF E.OF					V	V	CMOV	cmovlw		Move if less (SF !!= OF).
0F 4C /r 	CMOVL r32, r/m32 	RM	z, R	E.SF E.OF					V	V	CMOV	cmovll		Move if less (SF!!= OF).
REX.W+ 0F 4C /r 	CMOVL r64, r/m64 	RM	w, R	E.SF E.OF					V	NE	CMOV	cmovlq		Move if less (SF!!= OF).
0F 4E /r	CMOVLE r16, r/m16 	RM	w, R	E.ZF E.SF E.OF					V	V	CMOV	cmovlew		Move if less or equal (ZF=1 or SF!!= OF).
0F 4E /r 	CMOVLE r32, r/m32 	RM	z, R	E.ZF E.SF E.OF					V	V	CMOV	cmovlel		Move if less or equal (ZF=1 or SF!!= OF).
REX.W+ 0F 4E /r 	CMOVLE r64, r/m64 	RM	w, R	E.ZF E.SF E.OF					V	NE	CMOV	cmovleq		Move if less or equal (ZF=1 or SF!!= OF).
0F 46 /r	CMOVNA r16, r/m16 	RM	w, R	E.CF E.ZF					V	V	CMOV	cmovnaw		Move if not above (CF=1 or ZF=1).
0F 46 /r 	CMOVNA r32, r/m32 	RM	z, R	E.CF E.ZF					V	V	CMOV	cmovnal		Move if not above (CF=1 or ZF=1).
REX.W+ 0F 46 /r	CMOVNA r64, r/m64 	RM	w, R	E.CF E.ZF					V	NE	CMOV	cmovnaq		Move if not above (CF=1 or ZF=1).
0F 42 /r	CMOVNAE r16, r/m16 	RM	w, R	E.CF					V	V	CMOV	cmovnaew		Move if not above or equal (CF=1).
0F 42 /r 	CMOVNAE r32, r/m32 	RM	z, R	E.CF					V	V	CMOV	cmovnael		Move if not above or equal (CF=1).
REX.W+ 0F 42 /r 	CMOVNAE r64, r/m64 	RM	w, R	E.CF					V	NE	CMOV	cmovnaeq		Move if not above or equal (CF=1).
0F 43 /r	CMOVNB r16, r/m16 	RM	w, R	E.CF					V	V	CMOV	cmovnbw		Move if not below (CF=0).
0F 43 /r 	CMOVNB r32, r/m32 	RM	z, R	E.CF					V	V	CMOV	cmovnbl		Move if not below (CF=0).
REX.W+ 0F 43 /r 	CMOVNB r64, r/m64 	RM	w, R	E.CF					V	NE	CMOV	cmovnbq		Move if not below (CF=0).
0F 47 /r	CMOVNBE r16, r/m16	RM	w, R	E.CF E.ZF					V	V	CMOV	cmovnbew		Move if not below or equal (CF=0 and ZF=0).
0F 47 /r 	CMOVNBE r32, r/m32 	RM	z, R	E.CF E.ZF					V	V	CMOV	cmovnbel		Move if not below or equal (CF=0 and ZF=0).
REX.W+ 0F 47 /r 	CMOVNBE r64, r/m64 	RM	w, R	E.CF E.ZF					V	NE	CMOV	cmovnbeq		Move if not below or equal (CF=0 and ZF=0).
0F 43 /r	CMOVNC r16, r/m16 	RM	w, R	E.CF					V	V	CMOV	cmovncw		Move if not carry (CF=0).
0F 43 /r 	CMOVNC r32, r/m32 	RM	z, R	E.CF					V	V	CMOV	cmovncl		Move if not carry (CF=0).
REX.W+ 0F 43 /r 	CMOVNC r64, r/m64 	RM	w, R	E.CF					V	NE	CMOV	cmovncq		Move if not carry (CF=0).
0F 45 /r	CMOVNE r16, r/m16 	RM	w, R	E.ZF					V	V	CMOV	cmovnew		Move if not equal (ZF=0).
0F 45 /r 	CMOVNE r32, r/m32 	RM	z, R	E.ZF					V	V	CMOV	cmovnel		Move if not equal (ZF=0).
REX.W+ 0F 45 /r 	CMOVNE r64, r/m64 	RM	w, R	E.ZF					V	NE	CMOV	cmovneq		Move if not equal (ZF=0).
0F 4E /r	CMOVNG r16, r/m16 	RM	w, R	E.ZF E.SF E.OF					V	V	CMOV	cmovngw		Move if not greater (ZF=1 or SF!!= OF).
0F 4E /r 	CMOVNG r32, r/m32 	RM	z, R	E.ZF E.SF E.OF					V	V	CMOV	cmovngl		Move if not greater (ZF=1 or SF!!= OF).
REX.W+ 0F 4E /r 	CMOVNG r64, r/m64 	RM	w, R	E.ZF E.SF E.OF					V	NE	CMOV	cmovngq		Move if not greater (ZF=1 or SF!!= OF).
0F 4C /r	CMOVNGE r16, r/m16 	RM	w, R	E.SF E.OF					V	V	CMOV	cmovngew		Move if not greater or equal (SF!!= OF).
0F 4C /r 	CMOVNGE r32, r/m32 	RM	z, R	E.SF E.OF					V	V	CMOV	cmovngel		Move if not greater or equal (SF!!= OF).
REX.W+ 0F 4C /r 	CMOVNGE r64, r/m64 	RM	w, R	E.SF E.OF					V	NE	CMOV	cmovngeq		Move if not greater or equal (SF!!= OF).
0F 4D /r	CMOVNL r16, r/m16 	RM	w, R	E.SF E.OF					V	V	CMOV	cmovnlw		Move if not less (SF=OF).
0F 4D /r 	CMOVNL r32, r/m32 	RM	z, R	E.SF E.OF					V	V	CMOV	cmovnll		Move if not less (SF=OF).
REX.W+ 0F 4D /r 	CMOVNL r64, r/m64 	RM	w, R	E.SF E.OF					V	NE	CMOV	cmovnlq		Move if not less (SF=OF).
0F 4F /r	CMOVNLE r16, r/m16 	RM	w, R	E.ZF E.SF E.OF					V	V	CMOV	cmovnlew		Move if not less or equal (ZF=0 and SF=OF).
0F 4F /r 	CMOVNLE r32, r/m32 	RM	z, R	E.ZF E.SF E.OF					V	V	CMOV	cmovnlel		Move if not less or equal (ZF=0 and SF=OF).
REX.W+ 0F 4F /r 	CMOVNLE r64, r/m64 	RM	w, R	E.ZF E.SF E.OF					V	NE	CMOV	cmovnleq		Move if not less or equal (ZF=0 and SF=OF).
0F 41 /r	CMOVNO r16, r/m16 	RM	w, R	E.OF					V	V	CMOV	cmovnow		Move if not overflow (OF=0).
0F 41 /r 	CMOVNO r32, r/m32 	RM	z, R	E.OF					V	V	CMOV	cmovnol		Move if not overflow (OF=0).
REX.W+ 0F 41 /r 	CMOVNO r64, r/m64 	RM	w, R	E.OF					V	NE	CMOV	cmovnoq		Move if not overflow (OF=0).
0F 4B /r	CMOVNP r16, r/m16 	RM	w, R	E.PF					V	V	CMOV	cmovnpw		Move if not parity (PF=0).
0F 4B /r 	CMOVNP r32, r/m32 	RM	z, R	E.PF					V	V	CMOV	cmovnpl		Move if not parity (PF=0).
REX.W+ 0F 4B /r 	CMOVNP r64, r/m64 	RM	w, R	E.PF					V	NE	CMOV	cmovnpq		Move if not parity (PF=0).
0F 49 /r	CMOVNS r16, r/m16 	RM	w, R	E.SF					V	V	CMOV	cmovnsw		Move if not sign (SF=0).
0F 49 /r 	CMOVNS r32, r/m32 	RM	z, R	E.SF					V	V	CMOV	cmovnsl		Move if not sign (SF=0).
REX.W+ 0F 49 /r 	CMOVNS r64, r/m64 	RM	w, R	E.SF					V	NE	CMOV	cmovnsq		Move if not sign (SF=0).
0F 45 /r	CMOVNZ r16, r/m16 	RM	w, R	E.ZF					V	V	CMOV	cmovnzw		Move if not zero (ZF=0).
0F 45 /r 	CMOVNZ r32, r/m32 	RM	z, R	E.ZF					V	V	CMOV	cmovnzl		Move if not zero (ZF=0).
REX.W+ 0F 45 /r 	CMOVNZ r64, r/m64 	RM	w, R	E.ZF					V	NE	CMOV	cmovnzq		Move if not zero (ZF=0).
0F 40 /r	CMOVO r16, r/m16 	RM	w, R	E.OF					V	V	CMOV	cmovow		Move if overflow (OF=1).
0F 40 /r 	CMOVO r32, r/m32 	RM	z, R	E.OF					V	V	CMOV	cmovol		Move if overflow (OF=1).
REX.W+ 0F 40 /r 	CMOVO r64, r/m64 	RM	w, R	E.OF					V	NE	CMOV	cmovoq		Move if overflow (OF=1).
0F 4A /r	CMOVP r16, r/m16 	RM	w, R	E.PF					V	V	CMOV	cmovpw		Move if parity (PF=1).
0F 4A /r 	CMOVP r32, r/m32 	RM	z, R	E.PF					V	V	CMOV	cmovpl		Move if parity (PF=1).
REX.W+ 0F 4A /r 	CMOVP r64, r/m64 	RM	w, R	E.PF					V	NE	CMOV	cmovpq		Move if parity (PF=1).
0F 4A /r	CMOVPE r16, r/m16 	RM	w, R	E.PF					V	V	CMOV	cmovpew		Move if parity even (PF=1).
0F 4A /r 	CMOVPE r32, r/m32 	RM	z, R	E.PF					V	V	CMOV	cmovpel		Move if parity even (PF=1).
REX.W+ 0F 4A /r	CMOVPE r64, r/m64	RM	w, R	E.PF					V	NE	CMOV	cmovpeq		Move if parity even (PF=1).
0F 4B /r	CMOVPO r16, r/m16 	RM	w, R	E.PF					V	V	CMOV	cmovpow		Move if parity odd (PF=0).
0F 4B /r	CMOVPO r32, r/m32 	RM	z, R	E.PF					V	V	CMOV	cmovpol		Move if parity odd (PF=0).
REX.W+ 0F 4B /r 	CMOVPO r64, r/m64 	RM	w, R	E.PF					V	NE	CMOV	cmovpoq		Move if parity odd (PF=0).
0F 48 /r	CMOVS r16, r/m16 	RM	w, R	E.SF					V	V	CMOV	cmovsw		Move if sign (SF=1).
0F 48 /r	CMOVS r32, r/m32 	RM	z, R	E.SF					V	V	CMOV	cmovsl		Move if sign (SF=1).
REX.W+ 0F 48 /r 	CMOVS r64, r/m64 	RM	w, R	E.SF					V	NE	CMOV	cmovsq		Move if sign (SF=1).
0F 44 /r	CMOVZ r16, r/m16 	RM	w, R	E.ZF					V	V	CMOV	cmovzw		Move if zero (ZF=1).
0F 44 /r	CMOVZ r32, r/m32 	RM	z, R	E.ZF					V	V	CMOV	cmovzl		Move if zero (ZF=1).
REX.W+ 0F 44 /r	CMOVZ r64, r/m64	RM	w, R	E.ZF					V	NE	CMOV	cmovzq		Move if zero (ZF=1).
														
3C ib	CMP AL, imm8 	I	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpb		Compare imm8 with AL.
3D iw	CMP AX, imm16	I	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpw		Compare imm16 with AX.
3D id	CMP EAX, imm32 	I	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpl		Compare imm32 with EAX.
REX.W+ 3D id	CMP RAX, imm32	I	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpq		Compare imm32 sign-extended to 64-bits with RAX.
80 /7 ib	CMP r/m8, imm8 	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpb		Compare imm8 with r/m8.
REX+ 80 /7 ib	CMP r/m8, imm8	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpb		Compare imm8 with r/m8.
81 /7 iw	CMP r/m16, imm16 	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpw		Compare imm16 with r/m16.
81 /7 id	CMP r/m32, imm32 	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpl		Compare imm32 with r/m32.
REX.W+ 81 /7 id	CMP r/m64, imm32	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpq		Compare imm32 sign-extended to 64-bits with r/m64.
83 /7 ib	CMP r/m16, imm8 	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpw	YES	Compare imm8 with r/m16.
83 /7 ib	CMP r/m32, imm8 	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpl	YES	Compare imm8 with r/m32.
REX.W+ 83 /7 ib	CMP r/m64, imm8 	MI	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpq	YES	Compare imm8 with r/m64.
38 /r	CMP r/m8, r8 	MR	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpb	YES	Compare r8 with r/m8.
REX+ 38 /r	CMP r/m8, r8	MR	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpb	YES	Compare r8 with r/m8.
39 /r	CMP r/m16, r16 	MR	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpw	YES	Compare r16 with r/m16.
39 /r	CMP r/m32, r32 	MR	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpl	YES	Compare r32 with r/m32.
REX.W+ 39 /r	CMP r/m64, r64 	MR	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpq	YES	Compare r64 with r/m64.
3A /r	CMP r8, r/m8 	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpb		Compare r/m8 with r8.
REX+ 3A /r	CMP r8, r/m8	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpb		Compare r/m8 with r8.
3B /r	CMP r16, r/m16 	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpw		Compare r/m16 with r16.
3B /r	CMP r32, r/m32 	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpl		Compare r/m32 with r32.
REX.W+ 3B /r	CMP r64, r/m64	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpq		Compare r/m64 with r64.
														
66 0F C2 /r ib	CMPPD xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE2	cmppd		Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.
VEX.NDS.128.66.0F.WIG C2 /r ib	VCMPPD xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vcmppd		Compare packed double-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.
VEX.NDS.256.66.0F.WIG C2 /r ib	VCMPPD ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vcmppd		Compare packed double-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.
														
0F C2 /r ib	CMPPS xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE	cmpps		Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.
VEX.NDS.128.0F.WIG C2 /r ib	VCMPPS xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vcmpps		Compare packed single-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.
VEX.NDS.256.0F.WIG C2 /r ib	VCMPPS ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vcmpps		Compare packed single-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.
														
A6	CMPS m8, m8	NP	I, I	E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmps		For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly.
A7	CMPS m16, m16	NP	I, I	E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmps		For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.
A7	CMPS m32, m32	NP	I, I	E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmps		For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly.
REX.W+ A7 	CMPS m64, m64 	NP	I, I	E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmps		Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.
A6	CMPSB	NP		E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpsb		For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64- bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly.
PREF.66+ A7	CMPSW	NP		E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpsw		For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64- bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.
A7	CMPSD	NP		E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		cmpsl		For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.
REX.W+ A7	CMPSQ	NP		E.DF ESI rsi EDI rdi	E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		cmpsq		Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.
														
F2 0F C2 /r ib	CMPSD xmm1, xmm2/m64, imm8	RMI	RW, R, R						V	V	SSE2	cmpsd		Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.
VEX.NDS.LIG.F2.0F.WIG C2 /r ib	VCMPSD xmm1, xmm2, xmm3/m64, imm8	RVMI	Z, R, R, R						V	V	AVX	vcmpsd		Compare low double precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate.
														
F3 0F C2 /r ib	CMPSS xmm1, xmm2/m32, imm8	RMI	RW, R, R						V	V	SSE	cmpss		Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.
VEX.NDS.LIG.F3.0F.WIG C2 /r ib	VCMPSS xmm1, xmm2, xmm3/m32, imm8	RVMI	Z, R, R, R						V	V	AVX	vcmpss		Compare low single precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate.
														
0F B0 /r	CMPXCHG r/m8, r8	MR	Rw, R	AL	al E.ZF E.CF E.PF E.AF E.SF E.OF				V	V		cmpxchgb		Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
REX+ 0F B0 /r	CMPXCHG r/m8,r8	MR	Rw, R	AL	al E.ZF E.CF E.PF E.AF E.SF E.OF				V	NE		cmpxchgb		Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
0F B1 /r	CMPXCHG r/m16, r16	MR	Rw, R	AX	ax E.ZF E.CF E.PF E.AF E.SF E.OF				V	V		cmpxchgw		Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.
0F B1 /r	CMPXCHG r/m32, r32	MR	Rz, R	EAX	rax E.ZF E.CF E.PF E.AF E.SF E.OF				V	V		cmpxchgl		Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.
REX.W+ 0F B1 /r	CMPXCHG r/m64, r64	MR	Rw, R	RAX	Rax E.ZF E.CF E.PF E.AF E.SF E.OF				V	NE		cmpxchgq		Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.
														
0F C7 /1	CMPXCHG8B m64	M	Rw	EAX EDX	rax rbx rcx rdx E.ZF				V	V	CX8	cmpxchg8b		Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX.
REX.W+ 0F C7 /1	CMPXCHG16B m128	M	Rw	RAX RDX	rax rbx rcx rdx E.ZF				V	NE	CX16	cmpxchg16b		Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX.
														
66 0F 2F /r	COMISD xmm1, xmm2/m64	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V	SSE2	comisd		Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
VEX.LIG.66.0F.WIG 2F /r	VCOMISD xmm1, xmm2/m64	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V	AVX	vcomisd		Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
														
0F 2F /r	COMISS xmm1, xmm2/m32	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V	SSE	comiss		Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
VEX.LIG.0F.WIG 2F /r	VCOMISS xmm1, xmm2/m32	RM	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V	AVX	vcomiss		Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
														
0F A2	CPUID	NP		EAX ecx	RAX RBX RCX RDX				V	V		cpuid		Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
														
F2 0F 38 F0 /r	CRC32 r32, r/m8	RM	RW, R						V	V		crc32b		Accumulate CRC32 on r/m8.
F2 REX+ 0F 38 F0 /r	CRC32 r32, r/m8	RM	RW, R						V	NE		crc32b		Accumulate CRC32 on r/m8.
F2 0F 38 F1 /r	CRC32 r32, r/m16	RM	RW, R						V	V		crc32w		Accumulate CRC32 on r/m16.
F2 0F 38 F1 /r	CRC32 r32, r/m32	RM	RW, R						V	V		crc32l		Accumulate CRC32 on r/m32.
F2 REX.W+ 0F 38 F0 /r	CRC32 r64, r/m8	RM	RW, R						V	NE		crc32b		Accumulate CRC32 on r/m8.
F2 REX.W+ 0F 38 F1 /r	CRC32 r64, r/m64	RM	RW, R						V	NE		crc32q		Accumulate CRC32 on r/m64.
														
F3 0F E6	CVTDQ2PD xmm1, xmm2/m64	RM	W, R						V	V	SSE2	cvtdq2pd		Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.
VEX.128.F3.0F.WIG E6 /r	VCVTDQ2PD xmm1, xmm2/m64	RM	Z, R						V	V	AVX	vcvtdq2pd		Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1.
VEX.256.F3.0F.WIG E6 /r	VCVTDQ2PD ymm1, xmm2/m128	RM	W, R						V	V	AVX	vcvtdq2pd		Convert four packed signed doubleword integers from ymm2/mem to four packed double-precision floating-point values in ymm1.
														
0F 5B /r	CVTDQ2PS xmm1, xmm2/m128	RM	W, R						V	V	SSE2	cvtdq2ps		Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.
VEX.128.0F.WIG 5B /r	VCVTDQ2PS xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vcvtdq2ps		Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1.
VEX.256.0F.WIG 5B /r	VCVTDQ2PS ymm1, ymm2/m256	RM	W, R						V	V	AVX	vcvtdq2ps		Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1.
														
F2 0F E6	CVTPD2DQ xmm1, xmm2/m128	RM	W, R	M.RC					V	V	SSE2	cvtpd2dq		Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.
VEX.128.F2.0F.WIG E6 /r	VCVTPD2DQ xmm1, xmm2/m128	RM	Z, R	M.RC					V	V	AVX	vcvtpd2dq		Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1.
VEX.256.F2.0F.WIG E6 /r	VCVTPD2DQ xmm1, ymm2/m256	RM	Z, R	M.RC					V	V	AVX	vcvtpd2dq		Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1.
														
66 0F 2D /r	CVTPD2PI mm, xmm/m128	RM	W, R	M.RC					V	V		cvtpd2pi		Convert two packed double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm.
														
66 0F 5A /r	CVTPD2PS xmm1, xmm2/m128	RM	W, R	M.RC					V	V	SSE2	cvtpd2ps		Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.
VEX.128.66.0F.WIG 5A /r	VCVTPD2PS xmm1, xmm2/m128	RM	Z, R	M.RC					V	V	AVX	vcvtpd2ps		Convert two packed double-precision floating- point values in xmm2/mem to two single- precision floating-point values in xmm1.
VEX.256.66.0F.WIG 5A /r	VCVTPD2PS xmm1, ymm2/m256	RM	Z, R	M.RC					V	V	AVX	vcvtpd2ps		Convert four packed double-precision floating- point values in ymm2/mem to four single- precision floating-point values in xmm1.
														
66 0F 2A /r	CVTPI2PD xmm, mm/m64	RM	W, R	M.RC					V	V		cvtpi2pd		Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.
														
0F 2A /r	CVTPI2PS xmm, mm/m64	RM	RW, R	M.RC					V	V		cvtpi2ps		Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.
														
66 0F 5B /r	CVTPS2DQ xmm1, xmm2/m128	RM	W, R	M.RC					V	V	SSE2	cvtps2dq		Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.
VEX.128.66.0F.WIG 5B /r	VCVTPS2DQ xmm1, xmm2/m128	RM	Z, R	M.RC					V	V	AVX	vcvtps2dq		Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1.
VEX.256.66.0F.WIG 5B /r	VCVTPS2DQ ymm1, ymm2/m256	RM	W, R	M.RC					V	V	AVX	vcvtps2dq		Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1.
														
0F 5A /r	CVTPS2PD xmm1, xmm2/m64	RM	W, R	M.RC					V	V	SSE2	cvtps2pd		Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.
VEX.128.0F.WIG 5A /r	VCVTPS2PD xmm1, xmm2/m64	RM	Z, R	M.RC					V	V	AVX	vcvtps2pd		Convert two packed single-precision floating- point values in xmm2/mem to two packed double-precision floating-point values in xmm1.
VEX.256.0F.WIG 5A /r	VCVTPS2PD ymm1, xmm2/m128	RM	W, R	M.RC					V	V	AVX	vcvtps2pd		Convert four packed single-precision floating- point values in xmm2/mem to four packed double-precision floating-point values in ymm1.
														
0F 2D /r	CVTPS2PI mm, xmm/m64	RM	W, R	M.RC					V	V		cvtps2pi		Convert two packed single-precision floating- point values from xmm/m64 to two packed signed doubleword integers in mm.
														
F2 0F 2D /r	CVTSD2SI r32, xmm/m64	RM	W, R	M.RC					V	V	SSE2	cvtsd2si		Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.
F2 REX.W+ 0F 2D /r	CVTSD2SI r64, xmm/m64	RM	W, R	M.RC					V	NE	SSE2	cvtsd2si		Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.
VEX.LIG.F2.0F.W0 2D /r	VCVTSD2SI r32, xmm1/m64	RM	W, R	M.RC					V	V	AVX	vcvtsd2si		Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32.
VEX.LIG.F2.0F.W1 2D /r	VCVTSD2SI r64, xmm1/m64	RM	W, R	M.RC					V	NE	AVX	vcvtsd2si		Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.
														
F2 0F 5A /r	CVTSD2SS xmm1, xmm2/m64	RM	RW, R	M.RC					V	V	SSE2	cvtsd2ss		Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.
VEX.NDS.LIG.F2.0F.WIG 5A /r	VCVTSD2SS xmm1,xmm2, xmm3/m64	RVM	Z, R, R	M.RC					V	V	AVX	vcvtsd2ss		Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2.
														
F2 0F 2A /r	CVTSI2SD xmm, r/m32	RM	RW, R	M.RC					V	V	SSE2	cvtsi2sdl		Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.
F2 REX.W+ 0F 2A /r	CVTSI2SD xmm, r/m64	RM	RW, R	M.RC					V	NE	SSE2	cvtsi2sdq		Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.
VEX.NDS.LIG.F2.0F.W0 2A /r	VCVTSI2SD xmm1, xmm2, r/m32	RVM	Z, R, R	M.RC					V	V	AVX	vcvtsi2sdl		Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1.
VEX.NDS.LIG.F2.0F.W1 2A /r	VCVTSI2SD xmm1, xmm2, r/m64	RVM	Z, R, R	M.RC					V	NE	AVX	vcvtsi2sdq		Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1.
														
F3 0F 2A /r	CVTSI2SS xmm, r/m32	RM	RW, R	M.RC					V	V	SSE	cvtsi2ssl		Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.
F3 REX.W+ 0F 2A /r	CVTSI2SS xmm, r/m64	RM	RW, R	M.RC					V	NE	SSE	cvtsi2ssq		Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.
VEX.NDS.LIG.F3.0F.W0 2A /r	VCVTSI2SS xmm1, xmm2, r/m32	RVM	Z, R, R	M.RC					V	V	AVX	vcvtsi2ssl		Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1.
VEX.NDS.LIG.F3.0F.W1 2A /r	VCVTSI2SS xmm1, xmm2, r/m64	RVM	Z, R, R	M.RC					V	NE	AVX	vcvtsi2ssq		Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1.
														
F3 0F 5A /r	CVTSS2SD xmm1, xmm2/m32	RM	RW, R	M.RC					V	V	SSE2	cvtss2sd		Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.
VEX.NDS.LIG.F3.0F.WIG 5A /r	VCVTSS2SD xmm1, xmm2, xmm3/m32	RVM	Z, R, R	M.RC					V	V	AVX	vcvtss2sd		Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2.
														
F3 0F 2D /r	CVTSS2SI r32, xmm/m32	RM	W, R						V	V	SSE	cvtss2si		Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.
F3 REX.W+ 0F 2D /r	CVTSS2SI r64, xmm/m32	RM	W, R						V	NE	SSE	cvtss2si		Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.
VEX.LIG.F3.0F.W0 2D /r	VCVTSS2SI r32, xmm1/m32	RM	W, R						V	V	AVX	vcvtss2si		Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.
VEX.LIG.F3.0F.W1 2D /r	VCVTSS2SI r64, xmm1/m32	RM	W, R						V	NE	AVX	vcvtss2si		Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64.
														
66 0F E6	CVTTPD2DQ xmm1, xmm2/m128	RM	W, R						V	V	SSE2	cvttpd2dq		Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.
VEX.128.66.0F.WIG E6 /r	VCVTTPD2DQ xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vcvttpd2dq		Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation.
VEX.256.66.0F.WIG E6 /r	VCVTTPD2DQ xmm1, ymm2/m256	RM	Z, R						V	V	AVX	vcvttpd2dq		Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation.
														
66 0F 2C /r	CVTTPD2PI mm, xmm/m128	RM	W, R						V	V		cvttpd2pi		Convert two packer double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.
														
F3 0F 5B /r	CVTTPS2DQ xmm1, xmm2/m128	RM	W, R						V	V	SSE2	cvttps2dq		Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.
VEX.128.F3.0F.WIG 5B /r	VCVTTPS2DQ xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vcvttps2dq		Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation.
VEX.256.F3.0F.WIG 5B /r	VCVTTPS2DQ ymm1, ymm2/m256	RM	W, R						V	V	AVX	vcvttps2dq		Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation.
														
0F 2C /r	CVTTPS2PI mm, xmm/m64	RM	W, R						V	V		cvttps2pi		Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.
														
F2 0F 2C /r	CVTTSD2SI r32, xmm/m64	RM	W, R						V	V	SSE2	cvttsd2si		Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.
F2 REX.W+ 0F 2C /r	CVTTSD2SI r64, xmm/m64	RM	W, R						V	NE	SSE2	cvttsd2si		Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.
VEX.LIG.F2.0F.W0 2C /r	VCVTTSD2SI r32, xmm1/m64	RM	W, R						V	V	AVX	vcvttsd2si		Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.
VEX.LIG.F2.0F.W1 2C /r	VCVTTSD2SI r64, xmm1/m64	RM	W, R						V	NE	AVX	vcvttsd2si		Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.
														
F3 0F 2C /r	CVTTSS2SI r32, xmm/m32	RM	W, R						V	V	SSE	cvttss2si		Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.
F3 REX.W+ 0F 2C /r	CVTTSS2SI r64, xmm/m32	RM	W, R						V	NE	SSE	cvttss2si		Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.
VEX.LIG.F3.0F.W0 2C /r	VCVTTSS2SI r32, xmm1/m32	RM	W, R						V	V	AVX	vcvttss2si		Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.
VEX.LIG.F3.0F.W1 2C /r	VCVTTSS2SI r64, xmm1/m32	RM	W, R						V	NE	AVX	vcvttss2si		Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.
														
PREF.66+ 99	CWD	NP		AX	DX				V	V		cwtd		DX:AX = sign-extend of AX.
99	CDQ	NP		EAX	RDX				V	V		cltd		EDX:EAX = sign-extend of EAX.
REX.W+ 99	CQO	NP		RAX	RDX				V	NE		cqto		RDX:RAX = sign-extend of RAX.
														
27	DAA								I	V				Decimal adjust AL after addition.
														
2F	DAS								I	V				Decimal adjust AL after subtraction.
														
FE /1	DEC r/m8 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	V		decb		Decrement r/m8 by 1.
REX+ FE /1	DEC r/m8	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	NE		decb		Decrement r/m8 by 1.
FF /1	DEC r/m16 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	V		decw		Decrement r/m16 by 1.
FF /1	DEC r/m32 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	V		decl		Decrement r/m32 by 1.
REX.W+ FF /1	DEC r/m64 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	NE		decq		Decrement r/m64 by 1.
48 +rw	DEC r16 								NE	V				Decrement r16 by 1.
48 +rd	DEC r32								NE	V				Decrement r32 by 1.
														
F6 /6	DIV r/m8	M	R	AX	AX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	V		divb		Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
REX+ F6 /6	DIV r/m8	M	R	AX	AX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	NE		divb		Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
F7 /6	DIV r/m16 	M	R	AX DX	AX DX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	V		divw		Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
F7 /6	DIV r/m32	M	R	EAX EDX	RAX RDX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	V		divl		Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
REX.W+ F7 /6	DIV r/m64	M	R	RAX RDX	RAX RDX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	NE		divq		Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
														
66 0F 5E /r	DIVPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	divpd		Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.
VEX.NDS.128.66.0F.WIG 5E /r	VDIVPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vdivpd		Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.
VEX.NDS.256.66.0F.WIG 5E /r	VDIVPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vdivpd		Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.
														
0F 5E /r	DIVPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	divps		Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.
VEX.NDS.128.0F.WIG 5E /r	VDIVPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vdivps		Divide packed single-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.
VEX.NDS.256.0F.WIG 5E /r	VDIVPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vdivps		Divide packed single-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.
														
F2 0F 5E /r	DIVSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	divsd		Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.
VEX.NDS.LIG.F2.0F.WIG 5E /r	VDIVSD xmm1, xmm2, xmm3/m64	RVM	Z, R, R						V	V	AVX	vdivsd		Divide low double-precision floating point values in xmm2 by low double precision floating-point value in xmm3/mem64.
														
F3 0F 5E /r	DIVSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	divss		Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.
VEX.NDS.LIG.F3.0F.WIG 5E /r	VDIVSS xmm1, xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vdivss		Divide low single-precision floating point value in xmm2 by low single precision floating-point value in xmm3/m32.
														
66 0F 3A 41 /r ib	DPPD xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE4_1	dppd		Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.
VEX.NDS.128.66.0F3A.WIG 41 /r ib	VDPPD xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vdppd		Selectively multiply packed DP floating-point values from xmm2 with packed DP floating- point values from xmm3, add and selectively store the packed DP floating-point values to xmm1.
														
66 0F 3A 40 /r ib	DPPS xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE4_1	dpps		Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.
VEX.NDS.128.66.0F3A.WIG 40 /r ib	VDPPS xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vdpps		Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1.
VEX.NDS.256.66.0F3A.WIG 40 /r ib	VDPPS ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vdpps		Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1.
														
0F 77	EMMS	NP			TAG(*)				V	V		emms		Set the x87 FPU tag word to empty.
														
C8 ib iw 	ENTER 0, imm16	II	R, R	???	???	???			V	V		enterq		Create a stack frame for a procedure.
C8 ib iw	ENTER 1, imm16	II	R, R	???	???	???			V	V		enterq		Create a nested stack frame for a procedure.
C8 ib iw	ENTER imm8, imm16	II	R, R	???	???	???			V	V		enterq		Create a nested stack frame for a procedure.
														
66 0F 3A 17 /r ib	EXTRACTPS reg/m32, xmm2, imm8	MRI	W, R, R						V	V	SSE4_1	extractps		Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.
VEX.128.66.0F3A.WIG 17 /r ib	VEXTRACTPS r/m32, xmm1, imm8	MRI	W, R, R						V	V	AVX	vextractps		Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable.
														
D9 F0	F2XM1			ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	f2xm1		Replace ST(0) with (2^(ST(0)) - 1).
														
D9 E1	FABS			ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fabs		Replace ST with its absolute value.
														
D8 /0	FADD m32fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fadds		Add m32fp to ST(0) and store result in ST(0).
DC /0	FADD m64fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	faddl		Add m64fp to ST(0) and store result in ST(0).
D8 C0 +i	FADD ST(0), ST(i) 	TO	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fadd		Add ST(0) to ST(i) and store result in ST(0).
DC C0 +i	FADD ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fadd		Add ST(i) to ST(0) and store result in ST(i).
DE C0 +i	FADDP ST(i), ST(0)	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	faddp		Add ST(0) to ST(i), store result in ST(i), and pop the register stack.
DE C1	FADDP			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	faddp		Add ST(0) to ST(1), store result in ST(1), and pop the register stack.
DA /0	FIADD m32int	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fiaddl		Add m32int to ST(0) and store result in ST(0).
DE /0	FIADD m16int	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fiadd		Add m16int to ST(0) and store result in ST(0).
														
DF /4	FBLD m80bcd	M	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fbld		Convert BCD value to floating-point and push onto the FPU stack.
														
DF /6	FBSTP m80bcd	M	R	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fbstp		Store ST(0) in m80bcd and pop ST(0).
														
D9 E0	FCHS			ST(0)	ST(0)				V	V	FPU	fchs		Complements sign of ST(0).
														
9B DB E2	FCLEX				S.PE S.UE S.OE S.ZE S.DE S.IE S.ES S.SF S.B	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fclex		Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.
DB E2	FNCLEX				S.PE S.UE S.OE S.ZE S.DE S.IE S.ES S.SF S.B	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fnclex		Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.
														
DA C0 +i 	FCMOVB ST(0), ST(i) 	TO	w, R	E.CF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmovb		Move if below (CF=1).
DA C8 +i 	FCMOVE ST(0), ST(i) 	TO	w, R	E.ZF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmove		Move if equal (ZF=1).
DA D0 +i 	FCMOVBE ST(0), ST(i) 	TO	w, R	E.CF E.ZF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmovbe		Move if below or equal (CF=1 or ZF=1).
DA D8 +i 	FCMOVU ST(0), ST(i) 	TO	w, R	E.PF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmovu		Move if unordered (PF=1).
DB C0 +i 	FCMOVNB ST(0), ST(i) 	TO	w, R	E.CF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmovnb		Move if not below (CF=0).
DB C8 +i 	FCMOVNE ST(0), ST(i) 	TO	w, R	E.ZF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmovne		Move if not equal (ZF=0).
DB D0 +i 	FCMOVNBE ST(0), ST(i) 	TO	w, R	E.CF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmovnbe		Move if not below or equal (CF=0 and ZF=0).
DB D8 +i	FCMOVNU ST(0), ST(i)	TO	w, R	E.PF	S.C1	S.C0 S.C2 S.C3			V	V	FPU CMOV	fcmovnu		Move if not unordered (PF=0).
														
D8 /2 	FCOM m32fp 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcoms		Compare ST(0) with m32fp.
DC /2 	FCOM m64fp 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcoml		Compare ST(0) with m64fp.
D8 D0 +i 	FCOM ST(i) 	O	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcom		Compare ST(0) with ST(i).
D8 D1 	FCOM			ST(0) ST(1)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcom		Compare ST(0) with ST(1).
D8 /3 	FCOMP m32fp 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcomps		Compare ST(0) with m32fp and pop register stack.
DC /3 	FCOMP m64fp 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcompl		Compare ST(0) with m64fp and pop register stack.
D8 D8 +i 	FCOMP ST(i) 	O	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcomp		Compare ST(0) with ST(i) and pop register stack.
D8 D9 	FCOMP 			ST(0) ST(1)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcomp		Compare ST(0) with ST(1) and pop register stack.
DE D9	FCOMPP			ST(0) ST(1)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fcompp		Compare ST(0) with ST(1) and pop register stack twice.
														
DB F0 +i 	FCOMI ST, ST(i) 	TO	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF S.C1				V	V	FPU	fcomi		Compare ST(0) with ST(i) and set status flags accordingly.
DF F0 +i	FCOMIP ST, ST(i) 	TO	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF S.C1				V	V	FPU	fcomip		Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.
DB E8 +i 	FUCOMI ST, ST(i) 	TO	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF S.C1				V	V	FPU	fucomi		Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.
DF E8 +i	FUCOMIP ST, ST(i) 	TO	R, R		E.CF E.OF E.SF E.ZF E.AF E.PF S.C1				V	V	FPU	fucomip		Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.
														
D9 FF 	FCOS 			ST(0)	ST(0) s.c1 S.C2	s.c1 S.C0 S.C3			V	V	FPU	fcos		Replace ST(0) with its cosine.
														
D9 F6 	FDECSTP 			S.TOP	S.TOP S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdecstp		Decrement TOP field in FPU status word.
														
D8 /6 	FDIV m32fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivs		Divide ST(0) by m32fp and store result in ST(0).
DC /6 	FDIV m64fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivl		Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.
D8 F0 +i 	FDIV ST(0), ST(i) 	TO	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdiv		Divide ST(0) by ST(i) and store result in ST(0).
DC F0 +i 	FDIV ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdiv		Divide ST(i) by ST(0) and store result in ST(i).
DE F0 +i 	FDIVP ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivp		Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.
DE F1 	FDIVP 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivp		Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.
DA /6 	FIDIV m32int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fidivl		Divide ST(0) by m32int and store result in ST(0).
DE /6 	FIDIV m16int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fidiv		Divide ST(0) by m64int and store result in ST(0).
														
D8 /7 	FDIVR m32fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivrs		Divide m32fp by ST(0) and store result in ST(0).
DC /7 	FDIVR m64fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivrl		Divide m64fp by ST(0) and store result in ST(0).
D8 F8 +i 	FDIVR ST(0), ST(i) 	TO	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivr		Divide ST(i) by ST(0) and store result in ST(0).
DC F8 +i 	FDIVR ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivr		Divide ST(0) by ST(i) and store result in ST(i).
DE F8 +i 	FDIVRP ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivrp		Divide ST(0) by ST(i), store result in ST(i), and pop the register stack.
DE F9	FDIVRP 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fdivrp		Divide ST(0) by ST(1), store result in ST(1), and pop the register stack.
DA /7 	FIDIVR m32int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fidivrl		Divide m32int by ST(0) and store result in ST(0).
DE /7 	FIDIVR m16int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fidivr		Divide m16int by ST(0) and store result in ST(0).
														
DD C0 +i 	FFREE ST(i) 	O	I			S.C0 S.C1 s.c2 S.C3			V	V	FPU	ffreep		Sets tag for ST(i) to empty.
														
DE /2 	FICOM m16int 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	ficom		Compare ST(0) with m16int.
DA /2 	FICOM m32int 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	ficoml		Compare ST(0) with m32int.
DE /3 	FICOMP m16int 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	ficomp		Compare ST(0) with m16int and pop stack register.
DA /3 	FICOMP m32int 	M	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	ficompl		Compare ST(0) with m32int and pop stack register.
														
DF /0 	FILD m16int 	M	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fild		Push m16int onto the FPU register stack.
DB /0 	FILD m32int 	M	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fildl		Push m32int onto the FPU register stack.
DF /5 	FILD m64int 	M	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fildll		Push m64int onto the FPU register stack.
														
D9 F7 	FINCSTP 			S.TOP	S.TOP S.C1	S.C0 S.C2 S.C3			V	V	FPU	fincstp		Increment the TOP field in the FPU status register.
														
9B DB E3 	FINIT 				S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE				V	V	FPU	finit		Initialize FPU after checking for pending unmasked floating-point exceptions.
DB E3 	FNINIT				S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE				V	V	FPU	fninit		Initialize FPU without checking for pending unmasked floating-point exceptions.
														
DF /2 	FIST m16int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fist		Store ST(0) in m16int.
DB /2 	FIST m32int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fistl		Store ST(0) in m32int.
DF /3 	FISTP m16int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fistp		Store ST(0) in m16int and pop register stack.
DB /3 	FISTP m32int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fistpl		Store ST(0) in m32int and pop register stack.
DF /7 	FISTP m64int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fistpll		Store ST(0) in m64int and pop register stack.
														
DF /1 	FISTTP m16int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fisttp		Store ST(0) in m16int with truncation.
DB /1 	FISTTP m32int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fisttpl		Store ST(0) in m32int with truncation.
DD /1 	FISTTP m64int 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fisttpll		Store ST(0) in m64int with truncation.
														
D9 /0 	FLD m32fp 	M	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	flds		Push m32fp onto the FPU register stack.
DD /0 	FLD m64fp 	M	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldl		Push m64fp onto the FPU register stack.
DB /5 	FLD m80fp 	M	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldt		Push m80fp onto the FPU register stack.
D9 C0 +i 	FLD ST(i) 	O	R		ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fld		Push ST(i) onto the FPU register stack.
														
D9 E8 	FLD1 				ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fld1		Push +1.0 onto the FPU register stack.
D9 E9 	FLDL2T 				ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldl2t		Push log210 onto the FPU register stack.
D9 EA 	FLDL2E 				ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldl2e		Push log2e onto the FPU register stack.
D9 EB 	FLDPI 				ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldpi		Push pi onto the FPU register stack.
D9 EC 	FLDLG2 				ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldlg2		Push log102 onto the FPU register stack.
D9 ED 	FLDLN2 				ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldln2		Push loge2 onto the FPU register stack.
D9 EE 	FLDZ 				ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fldz		Push +0.0 onto the FPU register stack.
														
D9 /5 	FLDCW m2byte 	M	R			S.C0 S.C1 S.C2 S.C3			V	V	FPU	fldcw		Load FPU control word from m2byte.
														
D9 /4 	FLDENV m28byte 	M	R		S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE				V	V	FPU	fldenvl		Load FPU environment from m14byte or m28byte.
														
D8 /1 	FMUL m32fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fmuls		Multiply ST(0) by m32fp and store result in ST(0).
DC /1 	FMUL m64fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fmull		Multiply ST(0) by m64fp and store result in ST(0).
D8 C8 +i 	FMUL ST(0), ST(i) 	TO	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fmul		Multiply ST(0) by ST(i) and store result in ST(0).
DC C8 +i 	FMUL ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fmul		Multiply ST(i) by ST(0) and store result in ST(i).
DE C8 +i 	FMULP ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fmulp		Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack.
DE C9 	FMULP 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fmulp		Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack.
DA /1 	FIMUL m32int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fimull		Multiply ST(0) by m32int and store result in ST(0).
DE /1 	FIMUL m16int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fimul		Multiply ST(0) by m16int and store result in ST(0).
														
D9 D0 	FNOP 					S.C0 S.C1 S.C2 S.C3			V	V	FPU	fnop		No operation is performed.
														
D9 F3 	FPATAN 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fpatan		Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.
														
D9 F8 	FPREM 			ST(0) ST(1)	ST(0) S.C0 S.C1 S.C2 S.C3				V	V	FPU	fprem		Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).
														
D9 F5 	FPREM1 			ST(0) ST(1)	ST(0) S.C0 S.C1 S.C2 S.C3				V	V	FPU	fprem1		Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).
														
D9 F2 	FPTAN 			ST(0)	ST(0) S.C1 S.C2	S.C0 S.C3			V	V	FPU	fptan		Replace ST(0) with its tangent and push 1 onto the FPU stack.
														
D9 FC 	FRNDINT 			ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	frndint		Round ST(0) to an integer.
														
DD /4 	FRSTOR m108byte 	M	R		ST(*) TAG(*) FPUDATA FPUINSTR S.* M.*				V	V	FPU	frstor		Load FPU state from m94byte or m108byte.
														
9B DD /6 	FSAVE m108byte 	M	W	ST(*) S.* FPUDATA FPUINSTR FPUOPCODE	ST(*) TAG(*) S.* FPUDATA FPUINSTR FPUOPCODE				V	V	FPU	fsave		Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.
DD /6 	FNSAVE m108byte 	M	W	ST(*) S.* FPUDATA FPUINSTR FPUOPCODE	ST(*) TAG(*) S.* FPUDATA FPUINSTR FPUOPCODE				V	V	FPU	fnsave		Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.
														
D9 FD 	FSCALE 			ST(0) ST(1)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fscale		Scale ST(0) by ST(1).
														
D9 FE 	FSIN 			ST(0)	ST(0) S.C1 S.C2	S.C0 S.C3			V	V	FPU	fsin		Replace ST(0) with its sine.
														
D9 FB 	FSINCOS 			ST(0)	ST(0) S.C1 S.C2	S.C0 S.C3			V	V	FPU	fsincos		Compute the sine and cosine of ST(0); replace ST(0) with the sine, and push the cosine onto the register stack.
														
D9 FA 	FSQRT 			ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsqrt		Computes square root of ST(0) and stores the result in ST(0).
														
D9 /2 	FST m32fp 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsts		Copy ST(0) to m32fp.
DD /2 	FST m64fp 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fstl		Copy ST(0) to m64fp.
DD D0 +i 	FST ST(i) 	O	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fst		Copy ST(0) to ST(i).
D9 /3 	FSTP m32fp 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fstps		Copy ST(0) to m32fp and pop register stack.
DD /3 	FSTP m64fp 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fstpl		Copy ST(0) to m64fp and pop register stack.
DB /7 	FSTP m80fp 	M	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fstpt		Copy ST(0) to m80fp and pop register stack.
DD D8 +i 	FSTP ST(i) 	O	W	ST(0)	S.C1	S.C0 S.C2 S.C3			V	V	FPU	fstp		Copy ST(0) to ST(i) and pop register stack.
														
9B D9 /7 	FSTCW m2byte 	M	W			S.C0 S.C1 S.C2 S.C3			V	V	FPU	fstcw		Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.
D9 /7 	FNSTCW m2byte 	M	W			S.C0 S.C1 S.C2 S.C3			V	V	FPU	fnstcw		Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.
														
9B D9 /6 	FSTENV m28byte 	M	W		S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fstenvl		Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.
D9 /6 	FNSTENV m28byte 	M	W		S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fnstenvl		Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.
														
9B DD /7 	FSTSW m2byte 	M	W		S.*	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fstsw		Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.
9B DF E0 	FSTSW AX 		W		S.*	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fstsw		Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.
DD /7 	FNSTSW m2byte 	M	W		S.*	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fnstsw		Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.
DF E0 	FNSTSW AX 		W		S.*	S.C0 S.C1 S.C2 S.C3			V	V	FPU	fnstsw		Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.
														
D8 /4 	FSUB m32fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubs		Subtract m32fp from ST(0) and store result in ST(0).
DC /4 	FSUB m64fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubl		Subtract m64fp from ST(0) and store result in ST(0).
D8 E0 +i 	FSUB ST(0), ST(i) 	TO	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsub		Subtract ST(i) from ST(0) and store result in ST(0).
DC E0 +i 	FSUB ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsub		Subtract ST(0) from ST(i) and store result in ST(i).
DE E0 +i 	FSUBP ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubp		Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.
DE E1 	FSUBP 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubp		Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.
DA /4 	FISUB m32int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fisubl		Subtract m32int from ST(0) and store result in ST(0).
DE /4 	FISUB m16int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fisub		Subtract m16int from ST(0) and store result in ST(0).
														
D8 /5 	FSUBR m32fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubrs		Subtract ST(0) from m32fp and store result in ST(0).
DC /5 	FSUBR m64fp 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubrl		Subtract ST(0) from m64fp and store result in ST(0).
D8 E8 +i 	FSUBR ST(0), ST(i) 	TO	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubr		Subtract ST(0) from ST(i) and store result in ST(0).
DC E8 +i 	FSUBR ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubr		Subtract ST(i) from ST(0) and store result in ST(i).
DE E8 +i 	FSUBRP ST(i), ST(0) 	OT	RW, R		S.C1	S.C0 S.C2 S.C3			V	V		fsubrp		Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.
DE E9	FSUBRP 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fsubrp		Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.
DA /5 	FISUBR m32int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fisubrl		Subtract ST(0) from m32int and store result in ST(0).
DE /5 	FISUBR m16int 	M	R	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fisubr		Subtract ST(0) from m16int and store result in ST(0).
														
D9 E4 	FTST 			ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	ftst		Compare ST(0) with 0.0.
														
DD E0 +i 	FUCOM ST(i) 	O	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fucom		Compare ST(0) with ST(i).
DD E1 	FUCOM 			ST(0) ST(1)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fucom		Compare ST(0) with ST(1).
DD E8 +i 	FUCOMP ST(i) 	O	R	ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fucomp		Compare ST(0) with ST(i) and pop register stack.
DD E9 	FUCOMP 			ST(0) ST(1)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fucomp		Compare ST(0) with ST(1) and pop register stack.
DA E9 	FUCOMPP 			ST(0) ST(1)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fucompp		Compare ST(0) with ST(1) and pop register stack twice.
														
D9 E5 	FXAM 			ST(0)	S.C0 S.C1 S.C2 S.C3				V	V	FPU	fxam		Classify value or number in ST(0).
														
D9 C8 +i 	FXCH ST(i) 	O	RW	ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fxch		Exchange the contents of ST(0) and ST(i).
D9 C9 	FXCH 			ST(0) ST(1)	ST(0) ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fxch		Exchange the contents of ST(0) and ST(1).
														
0F AE /1 	FXRSTOR m512byte	M	R		ST(*) MM* XMM* CS DS				V	V	FPU FXSR	fxrstor		Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.
REX.W+ 0F AE /1	FXRSTOR64 m512byte	M	R		ST(*) MM* XMM*				V	NE	FPU FXSR	fxrstor64		Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.
														
0F AE /0 	FXSAVE m512byte	M	W	ST(*) MM* XMM* M.* CS DS					V	V	FPU FXSR	fxsave		Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.
REX.W+ 0F AE /0	FXSAVE64 m512byte	M	W	ST(*) MM* XMM* M.*					V	NE	FPU FXSR	fxsave64		Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.
														
D9 F4 	FXTRACT			ST(0)	ST(0) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fxtract		Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.
														
D9 F1 	FYL2X 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fyl2x		Replace ST(1) with (ST(1) * log2ST(0)) and pop the register stack.
														
D9 F9 	FYL2XP1 			ST(0) ST(1)	ST(1) S.C1	S.C0 S.C2 S.C3			V	V	FPU	fyl2xp1		Replace ST(1) with ST(1) * log2(ST(0) + 1.0) and pop the register stack.
														
66 0F 7C /r 	HADDPD xmm1, xmm2/m128	RM	RW, R						V	V	PNI	haddpd		Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1.
VEX.NDS.128.66.0F.WIG 7C /r	VHADDPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vhaddpd		Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 7C /r	VHADDPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vhaddpd		Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem.
														
F2 0F 7C /r 	HADDPS xmm1, xmm2/m128	RM	RW, R						V	V	PNI	haddps		Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1.
VEX.NDS.128.F2.0F.WIG 7C /r	VHADDPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vhaddps		Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem.
VEX.NDS.256.F2.0F.WIG 7C /r	VHADDPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vhaddps		Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem.
														
F4 	HLT 						NO	YES	V	V				Halt
														
66 0F 7D /r 	HSUBPD xmm1, xmm2/m128	RM	RW, R						V	V	PNI	hsubpd		Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1.
VEX.NDS.128.66.0F.WIG 7D /r 	VHSUBPD xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vhsubpd		Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 7D /r 	VHSUBPD ymm1, ymm2, ymm3/m256 	RVM	W, R, R						V	V	AVX	vhsubpd		Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem.
														
F2 0F 7D /r 	HSUBPS xmm1, xmm2/m128	RM	RW, R						V	V	PNI	hsubps		Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1.
VEX.NDS.128.F2.0F.WIG 7D /r	VHSUBPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vhsubps		Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem.
VEX.NDS.256.F2.0F.WIG 7D /r	VHSUBPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vhsubps		Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem.
														
F6 /7 	IDIV r/m8 	M	R	AX	AX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	V		idivb		Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
REX+ F6 /7 	IDIV r/m8	M	R	AX	AX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	NE		idivb		Signed divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
F7 /7 	IDIV r/m16 	M	R	AX DX	AX DX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	V		idivw		Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
F7 /7 	IDIV r/m32 	M	R	EAX EDX	RAX RDX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	V		idivl		Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
REX.W+ F7 /7 	IDIV r/m64 	M	R	RAX RDX	RAX RDX	E.CF E.OF E.SF E.ZF E.AF E.PF			V	NE		idivq		Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
														
F6 /5	IMUL r/m8	M	R	AL	AX E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imulb		AX= AL * r/m byte.
REX+ F6 /5	IMUL r/m8	M	R	AL	AX E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imulb		AX= AL * r/m byte.
F7 /5 	IMUL r/m16 	M	R	AX	AX DX E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imulw		DX:AX = AX * r/m word.
F7 /5 	IMUL r/m32 	M	R	EAX	RAX RDX E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imull		EDX:EAX = EAX * r/m32.
REX.W+ F7 /5 	IMUL r/m64 	M	R	RAX	RAX RDX E.CF E.OF	E.SF E.ZF E.AF E.PF			V	NE		imulq		RDX:RAX = RAX * r/m64.
0F AF /r 	IMUL r16, r/m16 	RM	RW, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imulw		word register = word register * r/m16.
0F AF /r 	IMUL r32, r/m32 	RM	RW, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imull		doubleword register = doubleword register *  r/m32.
REX.W+ 0F AF /r 	IMUL r64, r/m64 	RM	RW, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	NE		imulq		Quadword register = Quadword register *  r/m64.
6B /r ib 	IMUL r16, r/m16, imm8 	RMI	W, R, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imulw		word register = r/m16 * sign-extended immediate byte.
6B /r ib 	IMUL r32, r/m32, imm8 	RMI	W, R, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imull		doubleword register = r/m32 * sign- extended immediate byte.
REX.W+ 6B /r ib 	IMUL r64, r/m64, imm8 	RMI	W, R, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	NE		imulq		Quadword register = r/m64 * sign-extended  immediate byte.
69 /r iw 	IMUL r16, r/m16, imm16 	RMI	W, R, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imulw		word register = r/m16 * immediate word.
69 /r id 	IMUL r32, r/m32, imm32 	RMI	W, R, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	V		imull		doubleword register = r/m32 * immediate doubleword.
REX.W+ 69 /r id 	IMUL r64, r/m64, imm32 	RMI	W, R, R		E.CF E.OF	E.SF E.ZF E.AF E.PF			V	NE		imulq		Quadword register = r/m64 * immediate doubleword.
														
E4 ib 	IN AL, imm8 	I	W, R	E.IOPL E.VM					V	V		inb		Input byte from imm8 I/O port address into AL.
E5 ib 	IN AX, imm8 	I	W, R	E.IOPL E.VM					V	V		inw		Input word from imm8 I/O port address into AX.
E5 ib 	IN EAX, imm8 	I	W, R	E.IOPL E.VM					V	V		inl		Input dword from imm8 I/O port address into EAX.
EC 	IN AL,DX 	NP	W, R	E.IOPL E.VM					V	V		inb		Input byte from I/O port in DX into AL.
ED 	IN AX,DX 	NP	W, R	E.IOPL E.VM					V	V		inw		Input word from I/O port in DX into AX.
ED 	IN EAX,DX 	NP	W, R	E.IOPL E.VM					V	V		inl		Input doubleword from I/O port in DX into EAX.
														
FE /0 	INC r/m8 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	V		incb		Increment r/m byte by 1.
REX+ FE /0 	INC r/m8	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	NE		incb		Increment r/m byte by 1.
FF /0 	INC r/m16 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	V		incw		Increment r/m word by 1.
FF /0 	INC r/m32 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	V		incl		Increment r/m doubleword by 1.
REX.W+ FF /0	INC r/m64 	M	RW		E.OF E.SF E.ZF E.AF E.PF				V	NE		incq		Increment r/m quadword by 1.
40 +rw 	INC r16 								NE	V				Increment word register by 1.
40 +rd 	INC r32 								NE	V				Increment doubleword register by 1.
														
6C 	INS m8, DX 	NP	I, R	E.IOPL E.VM E.DF RDI					V	V		ins		Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
6D 	INS m16, DX 	NP	I, R	E.IOPL E.VM E.DF RDI					V	V		ins		Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
6D 	INS m32, DX 	NP	I, R	E.IOPL E.VM E.DF RDI					V	V		ins		Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
6C 	INSB 	NP		E.IOPL E.VM E.DF DX RDI					V	V		insb		Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.
PREF.66+ 6D 	INSW 	NP		E.IOPL E.VM E.DF DX RDI					V	V		insw		Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
6D 	INSD 	NP		E.IOPL E.VM E.DF DX RDI					V	V		insl		Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
														
66 0F 3A 21 /r ib 	INSERTPS xmm1, xmm2/m32, imm8	RMI	RW, R, R						V	V	SSE4_1	insertps		Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
VEX.NDS.128.66.0F3A.WIG 21 /r ib	VINSERTPS xmm1, xmm2, xmm3/m32, imm8	RVMI	RZ, RW, R, R						V	V	AVX	vinsertps		Insert a single precision floating point value selected by imm8 from xmm3/m32 and merge into xmm2 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
														
CC 	INT 3 	NP	R	???	???	???			V	V		int		Interrupt 3-trap to debugger.
CD ib 	INT imm8 	I	R	???	???	???			V	V		int		Interrupt vector number specified by immediate byte.
CE 	INTO 								I	V				Interrupt 4-if overflow flag is 1.
														
0F 08 	INVD 						NO	YES	V	V				Flush internal caches; initiate flushing of external caches.
														
0F 01 /7 	INVLPG m 						NO	YES	V	V				Invalidate TLB Entry for page that contains m.
														
66 0F 38 82 /r 	INVPCID r32, m128								NE	V	INVPCID			Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r32 and descriptor in m128.
66 0F 38 82 /r	INVPCID r64, m128	RM	R, R						V	NE	INVPCID	invpcid		Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128.
														
PREF.66+ CF 	IRET 	NP		???	???	???			V	V		iretw		Interrupt return (16-bit operand size).
CF 	IRETD 	NP		???	???	???			V	V		iretl		Interrupt return (32-bit operand size).
REX.W+ CF 	IRETQ 	NP		???	???	???			V	NE		iretq		Interrupt return (64-bit operand size).
														
77 cb 	JA rel8 	D	R	E.CF E.ZF					V	V		ja		Jump short if above (CF=0 and ZF=0).
73 cb 	JAE rel8 	D	R	E.CF					V	V		jae		Jump short if above or equal (CF=0).
72 cb 	JB rel8 	D	R	E.CF					V	V		jb		Jump short if below (CF=1).
76 cb 	JBE rel8 	D	R	E.CF E.ZF					V	V		jbe		Jump short if below or equal (CF=1 or ZF=1).
72 cb 	JC rel8 	D	R	E.CF					V	V		jc		Jump short if carry (CF=1).
E3 cb 	JCXZ rel8 								NE	V				Jump short if CX register is 0.
E3 cb 	JECXZ rel8 	D	R	ECX					V	V		jecxz		Jump short if ECX register is 0.
E3 cb 	JRCXZ rel8 	D	R	RCX					V	NE		jrcxz		Jump short if RCX register is 0.
74 cb 	JE rel8 	D	R	E.ZF					V	V		je		Jump short if equal (ZF=1).
7F cb 	JG rel8 	D	R	E.ZF E.SF E.OF					V	V		jg		Jump short if greater (ZF=0 and SF=OF).
7D cb 	JGE rel8 	D	R	E.SF E.OF					V	V		jge		Jump short if greater or equal (SF=OF).
7C cb 	JL rel8 	D	R	E.SF E.OF					V	V		jl		Jump short if less (SF!!= OF).
7E cb 	JLE rel8 	D	R	E.ZF E.SF E.OF					V	V		jle		Jump short if less or equal (ZF=1 or SF!!= OF).
76 cb 	JNA rel8 	D	R	E.CF E.ZF					V	V		jna		Jump short if not above (CF=1 or ZF=1).
72 cb 	JNAE rel8 	D	R	E.CF					V	V		jnae		Jump short if not above or equal (CF=1).
73 cb 	JNB rel8 	D	R	E.CF					V	V		jnb		Jump short if not below (CF=0).
77 cb 	JNBE rel8 	D	R	E.CF E.ZF					V	V		jnbe		Jump short if not below or equal (CF=0 and ZF=0).
73 cb 	JNC rel8 	D	R	E.CF					V	V		jnc		Jump short if not carry (CF=0).
75 cb 	JNE rel8 	D	R	E.ZF					V	V		jne		Jump short if not equal (ZF=0).
7E cb 	JNG rel8 	D	R	E.ZF E.SF E.OF					V	V		jng		Jump short if not greater (ZF=1 or SF!!= OF).
7C cb 	JNGE rel8 	D	R	E.SF E.OF					V	V		jnge		Jump short if not greater or equal (SF!!= OF).
7D cb 	JNL rel8 	D	R	E.SF E.OF					V	V		jnl		Jump short if not less (SF=OF).
7F cb 	JNLE rel8 	D	R	E.ZF E.SF E.OF					V	V		jnle		Jump short if not less or equal (ZF=0 and SF=OF).
71 cb 	JNO rel8 	D	R	E.OF					V	V		jno		Jump short if not overflow (OF=0).
7B cb 	JNP rel8 	D	R	E.PF					V	V		jnp		Jump short if not parity (PF=0).
79 cb 	JNS rel8 	D	R	E.SF					V	V		jns		Jump short if not sign (SF=0).
75 cb 	JNZ rel8 	D	R	E.ZF					V	V		jnz		Jump short if not zero (ZF=0).
70 cb 	JO rel8 	D	R	E.OF					V	V		jo		Jump short if overflow (OF=1).
7A cb 	JP rel8 	D	R	E.PF					V	V		jp		Jump short if parity (PF=1).
7A cb 	JPE rel8 	D	R	E.PF					V	V		jpe		Jump short if parity even (PF=1).
7B cb 	JPO rel8 	D	R	E.PF					V	V		jpo		Jump short if parity odd (PF=0).
78 cb 	JS rel8 	D	R	E.SF					V	V		js		Jump short if sign (SF=1).
74 cb 	JZ rel8 	D	R	E.ZF					V	V		jz		Jump short if zero (ZF = 1).
0F 87 cw 	JA rel16 								NS	V				Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode.
0F 87 cd 	JA rel32 	D	R	E.CF E.ZF					V	V		ja		Jump near if above (CF=0 and ZF=0).
0F 83 cw 	JAE rel16 								NS	V				Jump near if above or equal (CF=0). Not supported in 64-bit mode.
0F 83 cd 	JAE rel32 	D	R	E.CF					V	V		jae		Jump near if above or equal (CF=0).
0F 82 cw 	JB rel16 								NS	V				Jump near if below (CF=1). Not supported in 64-bit mode.
0F 82 cd 	JB rel32 	D	R	E.CF					V	V		jb		Jump near if below (CF=1).
0F 86 cw 	JBE rel16 								NS	V				Jump near if below or equal (CF=1 or ZF=1). Not supported in 64-bit mode.
0F 86 cd 	JBE rel32 	D	R	E.CF E.ZF					V	V		jbe		Jump near if below or equal (CF=1 or ZF=1).
0F 82 cw 	JC rel16 								NS	V				Jump near if carry (CF=1). Not supported in 64-bit mode.
0F 82 cd 	JC rel32 	D	R	E.CF					V	V		jc		Jump near if carry (CF=1).
0F 84 cw 	JE rel16 								NS	V				Jump near if equal (ZF=1). Not supported in 64-bit mode.
0F 84 cd 	JE rel32 	D	R	E.ZF					V	V		je		Jump near if 0 (ZF=1).
0F 8F cw 	JG rel16 								NS	V				Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode.
0F 8F cd 	JG rel32 	D	R	E.ZF E.SF E.OF					V	V		jg		Jump near if greater (ZF=0 and SF=OF).
0F 8D cw 	JGE rel16 								NS	V				Jump near if greater or equal (SF=OF). Not supported in 64-bit mode.
0F 8D cd 	JGE rel32 	D	R	E.SF E.OF					V	V		jge		Jump near if greater or equal (SF=OF).
0F 8C cw 	JL rel16 								NS	V				Jump near if less (SF!!= OF). Not supported in  64-bit mode.
0F 8C cd 	JL rel32 	D	R	E.SF E.OF					V	V		jl		Jump near if less (SF!!= OF).
0F 8E cw 	JLE rel16 								NS	V				Jump near if less or equal (ZF=1 or SF!!= OF).  Not supported in 64-bit mode.
0F 8E cd 	JLE rel32 	D	R	E.ZF E.SF E.OF					V	V		jle		Jump near if less or equal (ZF=1 or SF!!= OF).
0F 86 cw 	JNA rel16 								NS	V				Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode.
0F 86 cd 	JNA rel32 	D	R	E.CF E.ZF					V	V		jna		Jump near if not above (CF=1 or ZF=1).
0F 82 cw 	JNAE rel16 								NS	V				Jump near if not above or equal (CF=1). Not supported in 64-bit mode.
0F 82 cd 	JNAE rel32 	D	R	E.CF					V	V		jnae		Jump near if not above or equal (CF=1).
0F 83 cw 	JNB rel16 								NS	V				Jump near if not below (CF=0). Not supported in 64-bit mode.
0F 83 cd 	JNB rel32 	D	R	E.CF					V	V		jnb		Jump near if not below (CF=0).
0F 87 cw 	JNBE rel16 								NS	V				Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode.
0F 87 cd 	JNBE rel32 	D	R	E.CF E.ZF					V	V		jnbe		Jump near if not below or equal (CF=0 and ZF=0). 
0F 83 cw 	JNC rel16 								NS	V				Jump near if not carry (CF=0). Not supported in 64-bit mode.
0F 83 cd 	JNC rel32 	D	R	E.CF					V	V		jnc		Jump near if not carry (CF=0).
0F 85 cw 	JNE rel16 								NS	V				Jump near if not equal (ZF=0). Not supported in 64-bit mode.
0F 85 cd 	JNE rel32 	D	R	E.ZF					V	V		jne		Jump near if not equal (ZF=0).
0F 8E cw 	JNG rel16 								NS	V				Jump near if not greater (ZF=1 or SF !!= OF). Not supported in 64-bit mode.
0F 8E cd 	JNG rel32 	D	R	E.ZF E.SF E.OF					V	V		jng		Jump near if not greater (ZF=1 or SF !!= OF).
0F 8C cw 	JNGE rel16 								NS	V				Jump near if not greater or equal (SF !!= OF). Not supported in 64-bit mode.
0F 8C cd 	JNGE rel32 	D	R	E.SF E.OF					V	V		jnge		Jump near if not greater or equal (SF !!= OF).
0F 8D cw 	JNL rel16 								NS	V				Jump near if not less (SF=OF). Not supported in 64-bit mode.
0F 8D cd 	JNL rel32 	D	R	E.SF E.OF					V	V		jnl		Jump near if not less (SF=OF).
0F 8F cw 	JNLE rel16 								NS	V				Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode.
0F 8F cd 	JNLE rel32 	D	R	E.ZF E.SF E.OF					V	V		jnle		Jump near if not less or equal (ZF=0 and SF=OF).
0F 81 cw 	JNO rel16 								NS	V				Jump near if not overflow (OF=0). Not supported in 64-bit mode.
0F 81 cd 	JNO rel32 	D	R	E.OF					V	V		jno		Jump near if not overflow (OF=0).
0F 8B cw 	JNP rel16 								NS	V				Jump near if not parity (PF=0). Not supported in 64-bit mode.
0F 8B cd 	JNP rel32 	D	R	E.PF					V	V		jnp		Jump near if not parity (PF=0).
0F 89 cw 	JNS rel16 								NS	V				Jump near if not sign (SF=0). Not supported in 64-bit mode.
0F 89 cd 	JNS rel32 	D	R	E.SF					V	V		jns		Jump near if not sign (SF=0).
0F 85 cw 	JNZ rel16 								NS	V				Jump near if not zero (ZF=0). Not supported in 64-bit mode.
0F 85 cd 	JNZ rel32 	D	R	E.ZF					V	V		jnz		Jump near if not zero (ZF=0).
0F 80 cw 	JO rel16 								NS	V				Jump near if overflow (OF=1). Not supported in 64-bit mode.
0F 80 cd 	JO rel32 	D	R	E.OF					V	V		jo		Jump near if overflow (OF=1).
0F 8A cw 	JP rel16 								NS	V				Jump near if parity (PF=1). Not supported in 64-bit mode.
0F 8A cd 	JP rel32 	D	R	E.PF					V	V		jp		Jump near if parity (PF=1).
0F 8A cw 	JPE rel16								NS	V				Jump near if parity even (PF=1). Not supported in 64-bit mode.
0F 8A cd 	JPE rel32 	D	R	E.PF					V	V		jpe		Jump near if parity even (PF=1).
0F 8B cw 	JPO rel16 								NS	V				Jump near if parity odd (PF=0). Not supported in 64-bit mode.
0F 8B cd 	JPO rel32 	D	R	E.PF					V	V		jpo		Jump near if parity odd (PF=0).
0F 88 cw 	JS rel16 								NS	V				Jump near if sign (SF=1). Not supported in 64-bit mode.
0F 88 cd 	JS rel32 	D	R	E.SF					V	V		js		Jump near if sign (SF=1).
0F 84 cw 	JZ rel16 								NS	V				Jump near if 0 (ZF=1). Not supported in 64-bit mode.
0F 84 cd 	JZ rel32 	D	R	E.ZF					V	V		jz		Jump near if 0 (ZF=1).
														
EB cb 	JMP rel8 	D	R		RIP				V	V		jmpq		Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits
E9 cw 	JMP rel16 								NS	V				Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode.
E9 cd 	JMP rel32 	D	R		RIP				V	V		jmpq		Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits
FF /4 	JMP r/m16 								NS	V				Jump near, absolute indirect, address = zero-extended r/m16. Not supported in 64-bit mode.
FF /4 	JMP r/m32 								NS	V				Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode.
FF /4 	JMP r/m64 	M	R		RIP				V	NE		jmpq		Jump near, absolute indirect, RIP = 64-Bit offset from register or memory
EA cd 	JMP ptr16:16 								I	V				Jump far, absolute, address given in operand
EA cp 	JMP ptr16:32 								I	V				Jump far, absolute, address given in operand
FF /5 	JMP m16:16 	D	R	???	???	???			V	V		jmpq		Jump far, absolute indirect, address given in m16:16
FF /5 	JMP m16:32 	D	R	???	???	???			V	V		jmpq		Jump far, absolute indirect, address given in m16:32.
REX.W+ FF /5 	JMP m16:64 	D	R	???	???	???			V	NE		jmpq		Jump far, absolute indirect, address given in m16:64.
														
9F 	LAHF 	NP		E.SF E.ZF E.PF E.AF E.CF	AH				V	V	LAHF_LM	lahf		Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF).
														
0F 02 /r 	LAR r16, r16/m16 	RM	W, R		E.ZF		YES	NO	V	V		larw		r16 = access rights referenced by r16/m16
0F 02 /r 	LAR r32, r32/m16	RM	W, R		E.ZF		YES	NO	V	V		lar		reg = access rights referenced by r32/m16
REX.W+ 0F 02 /r 	LAR r64, r32/m16	RM	W, R		E.ZF		YES	NO	V	V		lar		reg = access rights referenced by r32/m16
														
F2 0F F0 /r 	LDDQU xmm1, m128	RM	W, R						V	V	PNI	lddqu		Load unaligned data from mem and return double quadword in xmm1.
VEX.128.F2.0F.WIG F0 /r	VLDDQU xmm1, m128	RM	Z, R						V	V	AVX	vlddqu		Load unaligned packed integer values from mem to xmm1.
VEX.256.F2.0F.WIG F0 /r	VLDDQU ymm1, m256	RM	W, R						V	V	AVX	vlddqu		Load unaligned packed integer values from mem to ymm1.
														
0F AE /2 	LDMXCSR m32	M	R		M.*				V	V	SSE	ldmxcsr		Load MXCSR register from m32.
VEX.LZ.0F.WIG AE /2	VLDMXCSR m32	M	R		M.*				V	V	AVX	vldmxcsr		Load MXCSR register from m32.
														
C5 /r 	LDS r16, m16:16 								I	V				Load DS:r16 with far pointer from memory.
C5 /r 	LDS r32, m16:32 								I	V				Load DS:r32 with far pointer from memory.
0F B2 /r 	LSS r16, m16:16 	RM	W, R		SS				V	V		lssw		Load SS:r16 with far pointer from memory.
0F B2 /r 	LSS r32, m16:32 	RM	W, R		SS				V	V		lssl		Load SS:r32 with far pointer from memory.
REX.W+ 0F B2 /r 	LSS r64, m16:64 	RM	W, R		SS				V	NE		lss		Load SS:r64 with far pointer from memory.
C4 /r 	LES r16, m16:16 								I	V				Load ES:r16 with far pointer from memory.
C4 /r 	LES r32, m16:32 								I	V				Load ES:r32 with far pointer from memory.
0F B4 /r 	LFS r16, m16:16 	RM	W, R		FS				V	V		lfsw		Load FS:r16 with far pointer from memory.
0F B4 /r 	LFS r32, m16:32 	RM	W, R		FS				V	V		lfsl		Load FS:r32 with far pointer from memory.
REX.W+ 0F B4 /r 	LFS r64, m16:64 	RM	W, R		FS				V	NE		lfs		Load FS:r64 with far pointer from memory.
0F B5 /r 	LGS r16, m16:16 	RM	W, R		GS				V	V		lgsw		Load GS:r16 with far pointer from memory.
0F B5 /r 	LGS r32, m16:32 	RM	W, R		GS				V	V		lgsl		Load GS:r32 with far pointer from memory.
REX.W+ 0F B5 /r 	LGS r64, m16:64 	RM	W, R		GS				V	NE		lgs		Load GS:r64 with far pointer from memory.
														
8D /r 	LEA r16, m 	RM	W, I						V	V		leaw		Store effective address for m in register r16.
8D /r 	LEA r32, m 	RM	W, I						V	V		leal		Store effective address for m in register r32.
REX.W+ 8D /r 	LEA r64, m 	RM	W, I						V	NE		leaq		Store effective address for m in register r64.
														
PREF.66+ C9 	LEAVE p66	NP	I						V	V		leavew		Set SP to BP, then pop BP.
C9 	LEAVE 								NE	V				Set ESP to EBP, then pop EBP.
C9 	LEAVE 	NP							V	NE		leaveq		Set RSP to RBP, then pop RBP.
														
0F AE E8	LFENCE 	NP							V	V		lfence		Serializes load operations.
														
0F 01 /2 	LGDT m16&32 						NO	YES	NE	V				Load m into GDTR.
0F 01 /3 	LIDT m16&32 						NO	YES	NE	V				Load m into IDTR.
0F 01 /2 	LGDT m16&64 						NO	YES	V	NE				Load m into GDTR.
0F 01 /3 	LIDT m16&64 						NO	YES	V	NE				Load m into IDTR.
														
0F 00 /2 	LLDT r/m16 						NO	YES	V	V				Load segment selector r/m16 into LDTR.
														
0F 01 /6 	LMSW r/m16 						NO	YES	V	V				Loads r/m16 in machine status word of CR0.
														
F0 	LOCK 	NP					YES	NO	V	V		lock		Asserts LOCK# signal for duration of the accompanying instruction.
														
AC 	LODS m8 	NP	I	E.DF SI rsi	AL				V	V		lods		For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.
AD 	LODS m16 	NP	I	E.DF SI rsi	AX				V	V		lods		For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.
AD 	LODS m32 	NP	I	E.DF SI rsi	EAX				V	V		lods		For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.
REX.W+ AD 	LODS m64 	NP	I	E.DF SI rsi	RAX				V	NE		lods		Load qword at address (R)SI into RAX.
AC 	LODSB 	NP		E.DF SI rsi	AL				V	V		lodsb		For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.
PREF.66+ AD 	LODSW 	NP		E.DF SI rsi	AX				V	V		lodsw		For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.
AD 	LODSD 	NP		E.DF SI rsi	EAX				V	V		lodsl		For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.
REX.W+ AD 	LODSQ 	NP		E.DF SI rsi	RAX				V	NE		lodsq		Load qword at address (R)SI into RAX.
														
E2 cb 	LOOP rel8 	D	R	RCX E.ZF					V	V		loop		Decrement count; jump short if count !!= 0.
E0 cb 	LOOPE rel8 	D	R	RCX E.ZF					V	V		loope		Decrement count; jump short if count !!= 0 and  ZF = 1.
E0 cb 	LOOPNE rel8 	D	R	RCX E.ZF					V	V		loopne		Decrement count; jump short if count !!= 0 and  ZF = 0.
														
0F 03 /r 	LSL r16, r16/m16 	RM	W, R		E.ZF		YES	NO	V	V		lslw		Load: r16 = segment limit, selector r16/m16.
0F 03 /r 	LSL r32, r32/m16	RM	W, R		E.ZF		YES	NO	V	V		lsl		Load: r32 = segment limit, selector r32/m16.
REX.W+ 0F 03 /r	LSL r64, r32/m16	RM	W, R		E.ZF		YES	NO	V	V		lsl		Load: r64 = segment limit, selector r32/m16
														
0F 00 /3 	LTR r/m16 						NO	YES	V	V				Load r/m16 into task register.
														
F3 0F BD /r	LZCNT r16, r/m16	RM	W, R		E.ZF E.CF	E.AF E.PF E.SF E.OF			V	V	BMI1	lzcntw		Count the number of leading zero bits in r/m16, return result in r16
F3 0F BD /r	LZCNT r32, r/m32	RM	W, R		E.ZF E.CF	E.AF E.PF E.SF E.OF			V	V	BMI1	lzcntl		Count the number of leading zero bits in r/m32, return result in r32
REX.W+ F3 0F BD /r	LZCNT r64, r/m64	RM	W, R		E.ZF E.CF	E.AF E.PF E.SF E.OF			V	NE	BMI1	lzcntq		Count the number of leading zero bits in r/m64, return result in r64
														
66 0F F7 /r 	MASKMOVDQU xmm1, xmm2	RM	R, R						V	V	SSE2	maskmovdqu		Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.
VEX.128.66.0F.WIG F7 /r	VMASKMOVDQU xmm1, xmm2	RM	R, R						V	V	AVX	vmaskmovdqu		Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.
														
0F F7 /r 	MASKMOVQ mm1, mm2	RM	R, R						V	V		maskmovq		Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI.
														
66 0F 5F /r 	MAXPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	maxpd		Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG 5F /r	VMAXPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vmaxpd		Return the maximum double-precision floating-point values between xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 5F /r	VMAXPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vmaxpd		Return the maximum packed double-precision floating-point values between ymm2 and ymm3/mem.
														
0F 5F /r 	MAXPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	maxps		Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.
VEX.NDS.128.0F.WIG 5F /r	VMAXPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vmaxps		Return the maximum single-precision floating-point values between xmm2 and xmm3/mem.
VEX.NDS.256.0F.WIG 5F /r	VMAXPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vmaxps		Return the maximum single double-precision floating-point values between ymm2 and ymm3/mem.
														
F2 0F 5F /r 	MAXSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	maxsd		Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
VEX.NDS.LIG.F2.0F.WIG 5F /r	VMAXSD xmm1, xmm2, xmm3/m64	RVM	Z, R, R						V	V	AVX	vmaxsd		Return the maximum scalar double-precision floating-point value between xmm3/mem64 and xmm2.
														
F3 0F 5F /r 	MAXSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	maxss		Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
VEX.NDS.LIG.F3.0F.WIG 5F /r	VMAXSS xmm1, xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vmaxss		Return the maximum scalar single-precision floating-point value between xmm3/mem32 and xmm2.
														
0F AE F0	MFENCE 	NP							V	V		mfence		Serializes load and store operations.
														
66 0F 5D /r 	MINPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	minpd		Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG 5D /r	VMINPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vminpd		Return the minimum double-precision floating-point values between xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 5D /r	VMINPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vminpd		Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem.
														
0F 5D /r 	MINPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	minps		Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.
VEX.NDS.128.0F.WIG 5D /r	VMINPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vminps		Return the minimum single-precision floating-point values between xmm2 and xmm3/mem.
VEX.NDS.256.0F.WIG 5D /r	VMINPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vminps		Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem.
														
F2 0F 5D /r 	MINSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	minsd		Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
VEX.NDS.LIG.F2.0F.WIG 5D /r	VMINSD xmm1, xmm2, xmm3/m64	RVM	Z, R, R						V	V	AVX	vminsd		Return the minimum scalar double precision floating-point value between xmm3/mem64 and xmm2.
														
F3 0F 5D /r 	MINSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	minss		Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
VEX.NDS.LIG.F3.0F.WIG 5D /r	VMINSS xmm1,xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vminss		Return the minimum scalar single precision floating-point value between xmm3/mem32 and xmm2.
														
0F 01 C8 	MONITOR 	NP							V	V	MONITOR	monitor		Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is DS:EAX (DS:RAX in 64-bit mode).
														
88 /r 	MOV r/m8, r8 	MR	W, R						V	V		movb	YES	Move r8 to r/m8.
REX+ 88 /r 	MOV r/m8, r8	MR	W, R						V	NE		movb	YES	Move r8 to r/m8.
89 /r 	MOV r/m16, r16 	MR	W, R						V	V		movw	YES	Move r16 to r/m16.
89 /r 	MOV r/m32, r32 	MR	W, R						V	V		movl	YES	Move r32 to r/m32.
REX.W+ 89 /r 	MOV r/m64, r64 	MR	W, R						V	NE		movq	YES	Move r64 to r/m64.
8A /r 	MOV r8, r/m8 	RM	W, R						V	V		movb		Move r/m8 to r8.
REX+ 8A /r 	MOV r8, r/m8	RM	W, R						V	NE		movb		Move r/m8 to r8.
8B /r 	MOV r16, r/m16 	RM	W, R						V	V		movw		Move r/m16 to r16.
8B /r 	MOV r32, r/m32 	RM	W, R						V	V		movl		Move r/m32 to r32.
REX.W+ 8B /r 	MOV r64, r/m64 	RM	W, R						V	NE		movq		Move r/m64 to r64.
8C /r 	MOV r/m16, Sreg	MR	W, R						V	V		movw		Move segment register to r/m16.
REX.W+ 8C /r 	MOV r/m64, Sreg	MR	W, R						V	V		movq		Move zero extended 16-bit segment register to r/m64.
8E /r 	MOV Sreg, r/m16	RM	W, R						V	V		mov		Move r/m16 to segment register.
REX.W+ 8E /r 	MOV Sreg, r/m64	RM	W, R						V	V		mov		Move lower 16 bits of r/m64 to segment register.
A0 	MOV AL, moffs8	FD	W, R						V	V		movabsb		Move byte at (seg:offset) to AL.
REX.W+ A0 	MOV AL, moffs8, pw	FD	W, R, I						V	NE		movabsb		Move byte at (offset) to AL.
A1 	MOV AX, moffs16	FD	W, R						V	V		movabsw		Move word at (seg:offset) to AX.
A1 	MOV EAX, moffs32	FD	W, R						V	V		movabsl		Move doubleword at (seg:offset) to EAX.
REX.W+ A1 	MOV RAX, moffs64	FD	W, R						V	NE		movabsq		Move quadword at (offset) to RAX.
A2 	MOV moffs8, AL 	TD	W, R						V	V		movabsb		Move AL to (seg:offset).
REX.W+ A2 	MOV moffs8, AL, pw 	TD	W, R, I						V	NE		movabsb		Move AL to (offset).
A3 	MOV moffs16, AX 	TD	W, R						V	V		movabsw		Move AX to (seg:offset).
A3 	MOV moffs32, EAX 	TD	W, R						V	V		movabsl		Move EAX to (seg:offset).
REX.W+ A3 	MOV moffs64, RAX 	TD	W, R						V	NE		movabsq		Move RAX to (offset).
B0 +rb 	MOV r8, imm8 	OI	W, R						V	V		movb	YES	Move imm8 to r8.
REX+ B0 +rb	MOV r8, imm8 	OI	W, R						V	NE		movb	YES	Move imm8 to r8.
B8 +rw 	MOV r16, imm16 	OI	W, R						V	V		movw	YES	Move imm16 to r16.
B8 +rd 	MOV r32, imm32 	OI	W, R						V	V		movl	YES	Move imm32 to r32.
REX.W+ B8 +rd 	MOV r64, imm64 	OI	W, R						V	NE		movq		Move imm64 to r64.
C6 /0 	MOV r/m8, imm8 	MI	W, R						V	V		movb		Move imm8 to r/m8.
REX+ C6 /0 	MOV r/m8, imm8 	MI	W, R						V	NE		movb		Move imm8 to r/m8.
C7 /0 	MOV r/m16, imm16 	MI	W, R						V	V		movw		Move imm16 to r/m16.
C7 /0 	MOV r/m32, imm32 	MI	W, R						V	V		movl		Move imm32 to r/m32.
REX.W+ C7 /0 	MOV r/m64, imm32 	MI	W, R						V	NE		movq	YES	Move imm32 sign extended to 64-bits to r/m64.
														
0F 20 /r 	MOV r32, CR0-CR7						NO	YES	NE	V				Move control register to r32.
0F 20 /r	MOV r64, CR0-CR7						NO	YES	V	NE				Move extended control register to r64.
REX.R+ 0F 20	MOV r64, CR8						NO	YES	V	NE				Move extended CR8 to r64.1
0F 22 /r	MOV CR0-CR7, r32						NO	YES	NE	V				Move r32 to control register.
0F 22 /r	MOV CR0-CR7, r64						NO	YES	V	NE				Move r64 to extended control register.
REX.R+ 0F 22	MOV CR8, r64						NO	YES	V	NE				Move r64 to extended CR8.1
														
0F 21 /r 	MOV r32, DR0-DR7						NO	YES	NE	V				Move debug register to r32.
0F 21 /r	MOV r64, DR0-DR7						NO	YES	V	NE				Move extended debug register to r64.
0F 23 /r	MOV DR0-DR7, r32						NO	YES	NE	V				Move r32 to debug register.
0F 23 /r	MOV DR0-DR7, r64						NO	YES	V	NE				Move r64 to extended debug register.
														
66 0F 28 /r 	MOVAPD xmm1, xmm2/m128	RM	W, R						V	V	SSE2	movapd		Move packed double-precision floating-point values from xmm2/m128 to xmm1.
66 0F 29 /r	MOVAPD xmm2/m128, xmm1	MR	W, R						V	V	SSE2	movapd	YES	Move packed double-precision floating-point values from xmm1 to xmm2/m128.
VEX.128.66.0F.WIG 28 /r	VMOVAPD xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovapd	YES	Move aligned packed double-precision floating-point values from xmm2/mem to xmm1.
VEX.128.66.0F.WIG 29 /r	VMOVAPD xmm2/m128, xmm1	MR	Z, R						V	V	AVX	vmovapd		Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem.
VEX.256.66.0F.WIG 28 /r	VMOVAPD ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovapd	YES	Move aligned packed double-precision floating-point values from ymm2/mem to ymm1.
VEX.256.66.0F.WIG 29 /r	VMOVAPD ymm2/m256, ymm1	MR	W, R						V	V	AVX	vmovapd		Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem.
														
0F 28 /r 	MOVAPS xmm1, xmm2/m128	RM	W, R						V	V	SSE	movaps		Move packed single-precision floating-point values from xmm2/m128 to xmm1.
0F 29 /r	MOVAPS xmm2/m128, xmm1	MR	W, R						V	V	SSE	movaps	YES	Move packed single-precision floating-point values from xmm1 to xmm2/m128.
VEX.128.0F.WIG 28 /r	VMOVAPS xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovaps	YES	Move aligned packed single-precision floating-point values from xmm2/mem to xmm1.
VEX.128.0F.WIG 29 /r	VMOVAPS xmm2/m128, xmm1	MR	Z, R						V	V	AVX	vmovaps		Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem.
VEX.256.0F.WIG 28 /r	VMOVAPS ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovaps	YES	Move aligned packed single-precision floating-point values from ymm2/mem to ymm1.
VEX.256.0F.WIG 29 /r	VMOVAPS ymm2/m256, ymm1	MR	W, R						V	V	AVX	vmovaps		Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem.
														
0F 38 F0 /r 	MOVBE r16, m16 	RM	W, R						V	V	MOVBE	movbew		Reverse byte order in m16 and move to r16
0F 38 F0 /r 	MOVBE r32, m32 	RM	W, R						V	V	MOVBE	movbel		Reverse byte order in m32 and move to r32
REX.W+ 0F 38 F0 /r 	MOVBE r64, m64 	RM	W, R						V	NE	MOVBE	movbeq		Reverse byte order in m64 and move to r64.
0F 38 F1 /r 	MOVBE m16, r16 	MR	W, R						V	V	MOVBE	movbew		Reverse byte order in r16 and move to m16
0F 38 F1 /r 	MOVBE m32, r32 	MR	W, R						V	V	MOVBE	movbel		Reverse byte order in r32 and move to m32
REX.W+ 0F 38 F1 /r 	MOVBE m64, r64 	MR	W, R						V	NE	MOVBE	movbeq		Reverse byte order in r64 and move to m64.
														
0F 6E /r 	MOVD mm, r/m32	RM	W, R						V	V	MMX	movd		Move doubleword from r/m32 to mm.
REX.W+ 0F 6E /r	MOVQ mm, r/m64	RM	W, R						V	NE	MMX	movq	YES	Move quadword from r/m64 to mm.
0F 7E /r	MOVD r/m32, mm	MR	W, R						V	V	MMX	movd		Move doubleword from mm to r/m32.
REX.W+ 0F 7E /r	MOVQ r/m64, mm	MR	W, R						V	NE	MMX	movq	YES	Move quadword from mm to r/m64.
VEX.128.66.0F.W0 6E /r	VMOVD xmm1, r32/m32	RM	Z, R						V	V	AVX	vmovd		Move doubleword from r/m32 to xmm1.
VEX.128.66.0F.W1 6E /r	VMOVQ xmm1, r64/m64	RM	Z, R						V	NE	AVX	vmovq	YES	Move quadword from r/m64 to xmm1.
66 0F 6E /r	MOVD xmm, r/m32	RM	W, R						V	V	SSE2	movd		Move doubleword from r/m32 to xmm.
66 REX.W+ 0F 6E /r	MOVQ xmm, r/m64	RM	W, R						V	NE	SSE2	movq	YES	Move quadword from r/m64 to xmm.
66 0F 7E /r	MOVD r/m32, xmm	MR	W, R						V	V	SSE2	movd		Move doubleword from xmm register to r/m32.
66 REX.W+ 0F 7E /r	MOVQ r/m64, xmm	MR	W, R						V	NE	SSE2	movq	YES	Move quadword from xmm register to r/m64.
VEX.128.66.0F.W0 7E /r	VMOVD r32/m32, xmm1	MR	W, R						V	V	AVX	vmovd		Move doubleword from xmm1 register to r/m32.
VEX.128.66.0F.W1 7E /r	VMOVQ r64/m64, xmm1	MR	W, R						V	NE	AVX	vmovq	YES	Move quadword from xmm1 register to r/m64.
														
F2 0F 12 /r 	MOVDDUP xmm1, xmm2/m64	RM	W, R						V	V	PNI	movddup		Move one double-precision floating-point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate.
VEX.128.F2.0F.WIG 12 /r	VMOVDDUP xmm1, xmm2/m64	RM	Z, R						V	V	AVX	vmovddup		Move double-precision floating-point values from xmm2/mem and duplicate into xmm1.
VEX.256.F2.0F.WIG 12 /r	VMOVDDUP ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovddup		Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
														
66 0F 6F /r 	MOVDQA xmm1, xmm2/m128	RM	W, R						V	V	SSE2	movdqa	YES	Move aligned double quadword from xmm2/m128 to xmm1.
66 0F 7F /r	MOVDQA xmm2/m128, xmm1	MR	W, R						V	V	SSE2	movdqa		Move aligned double quadword from xmm1 to xmm2/m128.
VEX.128.66.0F.WIG 6F /r	VMOVDQA xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovdqa	YES	Move aligned packed integer values from xmm2/mem to xmm1.
VEX.128.66.0F.WIG 7F /r	VMOVDQA xmm2/m128, xmm1	MR	Z, R						V	V	AVX	vmovdqa		Move aligned packed integer values from xmm1 to xmm2/mem.
VEX.256.66.0F.WIG 6F /r	VMOVDQA ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovdqa	YES	Move aligned packed integer values from ymm2/mem to ymm1.
VEX.256.66.0F.WIG 7F /r	VMOVDQA ymm2/m256, ymm1	MR	W, R						V	V	AVX	vmovdqa		Move aligned packed integer values from ymm1 to ymm2/mem.
														
F3 0F 6F /r 	MOVDQU xmm1, xmm2/m128	RM	W, R						V	V	SSE2	movdqu	YES	Move unaligned double quadword from xmm2/m128 to xmm1.
F3 0F 7F /r	MOVDQU xmm2/m128, xmm1	MR	W, R						V	V	SSE2	movdqu		Move unaligned double quadword from xmm1 to xmm2/m128.
VEX.128.F3.0F.WIG 6F /r	VMOVDQU xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovdqu	YES	Move unaligned packed integer values from xmm2/mem to xmm1.
VEX.128.F3.0F.WIG 7F /r	VMOVDQU xmm2/m128, xmm1	MR	Z, R						V	V	AVX	vmovdqu		Move unaligned packed integer values from xmm1 to xmm2/mem.
VEX.256.F3.0F.WIG 6F /r	VMOVDQU ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovdqu	YES	Move unaligned packed integer values from ymm2/mem to ymm1.
VEX.256.F3.0F.WIG 7F /r	VMOVDQU ymm2/m256, ymm1	MR	W, R						V	V	AVX	vmovdqu		Move unaligned packed integer values from ymm1 to ymm2/mem.
														
F2 0F D6 	MOVDQ2Q mm, xmm 	RM	W, R						V	V	MMX	movdq2q		Move low quadword from xmm to mmx register.
														
0F 12 /r 	MOVHLPS xmm1, xmm2	RM	RW, R						V	V	SSE	movhlps		Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1.
VEX.NDS.128.0F.WIG 12 /r	VMOVHLPS xmm1, xmm2, xmm3	RVM	Z, R, R						V	V	AVX	vmovhlps		Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2.
														
66 0F 16 /r 	MOVHPD xmm, m64	RM	RW, R						V	V	SSE2	movhpd		Move double-precision floating-point value from m64 to high quadword of xmm.
66 0F 17 /r	MOVHPD m64, xmm	MR	W, R						V	V	SSE2	movhpd		Move double-precision floating-point value from high quadword of xmm to m64.
VEX.NDS.128.66.0F.WIG 16 /r	VMOVHPD xmm2, xmm1, m64	RVM	Z, R, R						V	V	AVX	vmovhpd		Merge double-precision floating-point value from m64 and the low quadword of xmm1.
VEX128.66.0F.WIG 17 /r	VMOVHPD m64, xmm1	MR	W, R						V	V	AVX	vmovhpd		Move double-precision floating-point values from high quadword of xmm1 to m64.
														
0F 16 /r 	MOVHPS xmm, m64	RM	RW, R						V	V	SSE	movhps		Move two packed single-precision floating-point values from m64 to high quadword of xmm.
0F 17 /r	MOVHPS m64, xmm	MR	W, R						V	V	SSE	movhps		Move two packed single-precision floating-point values from high quadword of xmm to m64.
VEX.NDS.128.0F.WIG 16 /r	VMOVHPS xmm2, xmm1, m64	RVM	Z, R, R						V	V	AVX	vmovhps		Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1.
VEX.128.0F.WIG 17 /r	VMOVHPS m64, xmm1	MR	W, R						V	V	AVX	vmovhps		Move two packed single-precision floating-point values from high quadword of xmm1to m64.
														
0F 16 /r 	MOVLHPS xmm1, xmm2	RM	RW, R						V	V	SSE	movlhps		Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1.
VEX.NDS.128.0F.WIG 16 /r	VMOVLHPS xmm1, xmm2, xmm3	RVM	Z, R, R						V	V	AVX	vmovlhps		Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2.
														
66 0F 12 /r 	MOVLPD xmm, m64	RM	RW, R						V	V	SSE2	movlpd		Move double-precision floating-point value from m64 to low quadword of xmm register.
66 0F 13 /r	MOVLPD m64, xmm	MR	W, R						V	V	SSE2	movlpd		Move double-precision floating-point nvalue from low quadword of xmm register to m64.
VEX.NDS.128.66.0F.WIG 12 /r	VMOVLPD xmm2, xmm1, m64	RVM	Z, R, R						V	V	AVX	vmovlpd		Merge double-precision floating-point value from m64 and the high quadword of xmm1.
VEX.128.66.0F.WIG 13 /r	VMOVLPD m64, xmm1	MR	W, R						V	V	AVX	vmovlpd		Move double-precision floating-point values from low quadword of xmm1 to m64.
														
0F 12 /r 	MOVLPS xmm, m64	RM	RW, R						V	V	SSE	movlps		Move two packed single-precision floating-point values from m64 to low quadword of xmm.
0F 13 /r	MOVLPS m64, xmm	MR	W, R						V	V	SSE	movlps		Move two packed single-precision floating-point values from low quadword of xmm to m64.
VEX.NDS.128.0F.WIG 12 /r	VMOVLPS xmm2, xmm1, m64	RVM	Z, R, R						V	V	AVX	vmovlps		Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1.
VEX.128.0F.WIG 13 /r	VMOVLPS m64, xmm1	MR	W, R						V	V	AVX	vmovlps		Move two packed single-precision floating-point values from low quadword of xmm1 to m64.
														
66 0F 50 /r 	MOVMSKPD reg, xmm	RM	W, R						V	V	SSE2	movmskpd		Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.
VEX.128.66.0F.WIG 50 /r	VMOVMSKPD reg, xmm2	RM	W, R						V	V	AVX	vmovmskpd		Extract 2-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed.
VEX.256.66.0F.WIG 50 /r	VMOVMSKPD reg, ymm2	RM	W, R						V	V	AVX	vmovmskpd		Extract 4-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed.
														
0F 50 /r 	MOVMSKPS reg, xmm	RM	W, R						V	V	SSE	movmskps		Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.
VEX.128.0F.WIG 50 /r	VMOVMSKPS reg, xmm2	RM	W, R						V	V	AVX	vmovmskps		Extract 4-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed.
VEX.256.0F.WIG 50 /r	VMOVMSKPS reg, ymm2	RM	W, R						V	V	AVX	vmovmskps		Extract 8-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed.
														
66 0F 38 2A /r 	MOVNTDQA xmm1, m128	RM	W, R						V	V	SSE4_1	movntdqa		Move double quadword from m128 to xmm using non-temporal hint if WC memory type.
VEX.128.66.0F38.WIG 2A /r	VMOVNTDQA xmm1, m128	RM	Z, R						V	V	AVX	vmovntdqa		Move double quadword from m128 to xmm using non-temporal hint if WC memory type.
VEX.256.66.0F38.WIG 2A /r	VMOVNTDQA ymm1, m256	RM	W, R						V	V	AVX2	vmovntdqa		Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type.
														
66 0F E7 /r 	MOVNTDQ m128, xmm	MR	W, R						V	V	SSE2	movntdq		Move double quadword from xmm to m128 using non-temporal hint.
VEX.128.66.0F.WIG E7 /r	VMOVNTDQ m128, xmm1	MR	W, R						V	V	AVX	vmovntdq		Move packed integer values in xmm1 to m128 using non-temporal hint.
VEX.256.66.0F.WIG E7 /r	VMOVNTDQ m256, ymm1	MR	W, R						V	V	AVX	vmovntdq		Move packed integer values in ymm1 to m256 using non-temporal hint.
														
0F C3 /r 	MOVNTI m32, r32 	MR	W, R						V	V		movnti		Move doubleword from r32 to m32 using non-temporal hint.
REX.W+ 0F C3 /r 	MOVNTI m64, r64 	MR	W, R						V	NE		movnti		Move quadword from r64 to m64 using non-temporal hint.
														
66 0F 2B /r 	MOVNTPD m128, xmm	MR	W, R						V	V	SSE2	movntpd		Move packed double-precision floating-point values from xmm to m128 using non-temporal hint.
VEX.128.66.0F.WIG 2B /r	VMOVNTPD m128, xmm1	MR	W, R						V	V	AVX	vmovntpd		Move packed double-precision values in xmm1 to m128 using non-temporal hint.
VEX.256.66.0F.WIG 2B /r	VMOVNTPD m256, ymm1	MR	W, R						V	V	AVX	vmovntpd		Move packed double-precision values in ymm1 to m256 using non-temporal hint.
														
0F 2B /r 	MOVNTPS m128, xmm	MR	W, R						V	V	SSE	movntps		Move packed single-precision floating-point values from xmm to m128 using non-temporal hint.
VEX.128.0F.WIG 2B /r	VMOVNTPS m128, xmm1	MR	W, R						V	V	AVX	vmovntps		Move packed single-precision values xmm1 to mem using non-temporal hint.
VEX.256.0F.WIG 2B /r	VMOVNTPS m256, ymm1	MR	W, R						V	V	AVX	vmovntps		Move packed single-precision values ymm1 to mem using non-temporal hint.
														
0F E7 /r 	MOVNTQ m64, mm 	MR	W, R						V	V		movntq		Move quadword from mm to m64 using non-temporal hint.
														
0F 6F /r 	MOVQ mm, mm/m64	RM	W, R						V	V	MMX	movq	YES	Move quadword from mm/m64 to mm.
0F 7F /r	MOVQ mm/m64, mm	MR	W, R						V	V	MMX	movq		Move quadword from mm to mm/m64.
F3 0F 7E	MOVQ xmm1, xmm2/m64	RM	W, R						V	V	SSE2	movq	YES	Move quadword from xmm2/mem64 to xmm1.
VEX.128.F3.0F.WIG 7E /r	VMOVQ xmm1, xmm2	RM	Z, R						V	V	AVX	vmovq		Move quadword from xmm2 to xmm1.
VEX.128.F3.0F.WIG 7E /r	VMOVQ xmm1, m64	RM	Z, R						V	V	AVX	vmovq		Load quadword from m64 to xmm1.
66 0F D6	MOVQ xmm2/m64, xmm1	MR	W, R						V	V	SSE2	movq		Move quadword from xmm1 to xmm2/mem64.
VEX.128.66.0F.WIG D6 /r	VMOVQ xmm1/m64, xmm2	MR	Z, R						V	V	AVX	vmovq	YES	Move quadword from xmm2 register to xmm1/m64.
														
F3 0F D6 	MOVQ2DQ xmm, mm 	RM	W, R						V	V	MMX	movq2dq		Move quadword from mmx to low quadword of xmm.
														
A4 	MOVS m8, m8 	NP	I, I	E.DF ESI rsi EDI rdi					V	V		movs		For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.
A5 	MOVS m16, m16 	NP	I, I	E.DF ESI rsi EDI rdi					V	V		movs		For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.
A5 	MOVS m32, m32 	NP	I, I	E.DF ESI rsi EDI rdi					V	V		movs		For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
REX.W+ A5 	MOVS m64, m64 	NP	I, I	E.DF ESI rsi EDI rdi					V	NE		movs		Move qword from address (R|E)SI to (R|E)DI.
A4 	MOVSB 	NP		E.DF ESI rsi EDI rdi					V	V		movsb		For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.
PREF.66+ A5 	MOVSW 	NP		E.DF ESI rsi EDI rdi					V	V		movsw		For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.
A5 	MOVSD 	NP		E.DF ESI rsi EDI rdi					V	V		movsl		For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
REX.W+ A5 	MOVSQ 	NP		E.DF ESI rsi EDI rdi					V	NE		movsq		Move qword from address (R|E)SI to (R|E)DI.
														
F2 0F 10 /r 	MOVSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	movsd	YES	Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.
VEX.NDS.LIG.F2.0F.WIG 10 /r	VMOVSD xmm1, xmm2, xmm3	RVM	Z, R, R						V	V	AVX	vmovsd		Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register.
VEX.LIG.F2.0F.WIG 10 /r	VMOVSD xmm1, m64	XM	Z, R						V	V	AVX	vmovsd		Load scalar double-precision floating-point value from m64 to xmm1 register.
F2 0F 11 /r	MOVSD xmm2/m64, xmm1	MR	QW, R						V	V	SSE2	movsd		Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.
VEX.NDS.LIG.F2.0F.WIG 11 /r	VMOVSD xmm1, xmm2, xmm3	MVR	Z, R, R						V	V	AVX	vmovsd	YES	Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1.
VEX.LIG.F2.0F.WIG 11 /r	VMOVSD m64, xmm1	MR	W, R						V	V	AVX	vmovsd		Move scalar double-precision floating-point value from xmm1 register to m64.
														
F3 0F 16 /r 	MOVSHDUP xmm1, xmm2/m128	RM	W, R						V	V	PNI	movshdup		Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.
VEX.128.F3.0F.WIG 16 /r	VMOVSHDUP xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovshdup		Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.
VEX.256.F3.0F.WIG 16 /r	VMOVSHDUP ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovshdup		Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
														
F3 0F 12 /r 	MOVSLDUP xmm1, xmm2/m128	RM	W, R						V	V	PNI	movsldup		Move two single-precision floating-point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword.
VEX.128.F3.0F.WIG 12 /r	VMOVSLDUP xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovsldup		Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.
VEX.256.F3.0F.WIG 12 /r	VMOVSLDUP ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovsldup		Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
														
F3 0F 10 /r 	MOVSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	movss	YES	Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.
VEX.NDS.LIG.F3.0F.WIG 10 /r	VMOVSS xmm1, xmm2, xmm3	RVM	Z, R, R						V	V	AVX	vmovss		Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register.
VEX.LIG.F3.0F.WIG 10 /r	VMOVSS xmm1, m32	XM	Z, R						V	V	AVX	vmovss		Load scalar single-precision floating-point value from m32 to xmm1 register.
F3 0F 11 /r	MOVSS xmm2/m32, xmm	MR	QW, R						V	V	SSE	movss		Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.
VEX.NDS.LIG.F3.0F.WIG 11 /r	VMOVSS xmm1, xmm2, xmm3	MVR	Z, R, R						V	V	AVX	vmovss	YES	Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register.
VEX.LIG.F3.0F.WIG 11 /r	VMOVSS m32, xmm1	MR	W, R						V	V	AVX	vmovss		Move scalar single-precision floating-point value from xmm1 register to m32.
														
0F BE /r 	MOVSX r16, r/m8 	RM	W, R						V	V		movsbw		Move byte to word with sign-extension.
REX+ 0F BE /r 	MOVSX r16, r/m8 	RM	W, R						V	V		movsbw		Move byte to word with sign-extension.
0F BE /r 	MOVSX r32, r/m8 	RM	W, R						V	V		movsbl		Move byte to doubleword with sign-extension.
REX+ 0F BE /r 	MOVSX r32, r/m8 	RM	W, R						V	V		movsbl		Move byte to doubleword with sign-extension.
REX.W+ 0F BE /r 	MOVSX r64, r/m8	RM	W, R						V	NE		movsbq		Move byte to quadword with sign-extension.
0F BF /r 	MOVSX r32, r/m16 	RM	W, R						V	V		movswl		Move word to doubleword, with sign-extension.
REX.W+ 0F BF /r 	MOVSX r64, r/m16 	RM	W, R						V	NE		movswq		Move word to quadword with sign-extension.
REX.W+ 63 /r 	MOVSXD r64, r/m32 	RM	W, R						V	NE		movslq		Move doubleword to quadword with sign-extension.
														
66 0F 10 /r 	MOVUPD xmm1, xmm2/m128	RM	W, R						V	V	SSE2	movupd	YES	Move packed double-precision floating-point values from xmm2/m128 to xmm1.
VEX.128.66.0F.WIG 10 /r	VMOVUPD xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovupd		Move unaligned packed double-precision floating-point from xmm2/mem to xmm1.
VEX.256.66.0F.WIG 10 /r	VMOVUPD ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovupd		Move unaligned packed double-precision floating-point from ymm2/mem to ymm1.
66 0F 11 /r	MOVUPD xmm2/m128, xmm	MR	W, R						V	V	SSE2	movupd		Move packed double-precision floating-point values from xmm1 to xmm2/m128.
VEX.128.66.0F.WIG 11 /r	VMOVUPD xmm2/m128, xmm1	MR	Z, R						V	V	AVX	vmovupd	YES	Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem.
VEX.256.66.0F.WIG 11 /r	VMOVUPD ymm2/m256, ymm1	MR	W, R						V	V	AVX	vmovupd	YES	Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem.
														
0F 10 /r 	MOVUPS xmm1, xmm2/m128	RM	W, R						V	V	SSE	movups	YES	Move packed single-precision floating-point values from xmm2/m128 to xmm1.
VEX.128.0F.WIG 10 /r	VMOVUPS xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vmovups		Move unaligned packed single-precision floating-point from xmm2/mem to xmm1.
VEX.256.0F.WIG 10 /r	VMOVUPS ymm1, ymm2/m256	RM	W, R						V	V	AVX	vmovups		Move unaligned packed single-precision floating-point from ymm2/mem to ymm1.
0F 11 /r	MOVUPS xmm2/m128, xmm1	MR	W, R						V	V	SSE	movups		Move packed single-precision floating-point values from xmm1 to xmm2/m128.
VEX.128.0F.WIG 11 /r	VMOVUPS xmm2/m128, xmm1	MR	Z, R						V	V	AVX	vmovups	YES	Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem.
VEX.256.0F.WIG 11 /r	VMOVUPS ymm2/m256, ymm1	MR	W, R						V	V	AVX	vmovups	YES	Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem.
														
0F B6 /r 	MOVZX r16, r/m8 	RM	W, R						V	V		movzbw		Move byte to word with zero-extension.
REX+ 0F B6 /r 	MOVZX r16, r/m8 	RM	W, R						V	V		movzbw		Move byte to word with zero-extension.
0F B6 /r 	MOVZX r32, r/m8 	RM	W, R						V	V		movzbl		Move byte to doubleword, zero-extension.
REX+ 0F B6 /r 	MOVZX r32, r/m8 	RM	W, R						V	V		movzbl		Move byte to doubleword, zero-extension.
REX.W+ 0F B6 /r 	MOVZX r64, r/m8	RM	W, R						V	NE		movzbq		Move byte to quadword, zero-extension.
0F B7 /r 	MOVZX r32, r/m16 	RM	W, R						V	V		movzwl		Move word to doubleword, zero-extension.
REX.W+ 0F B7 /r 	MOVZX r64, r/m16 	RM	W, R						V	NE		movzwq		Move word to quadword, zero-extension.
														
66 0F 3A 42 /r ib 	MPSADBW xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE4_1	mpsadbw		Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.
VEX.NDS.128.66.0F3A.WIG 42 /r ib	VMPSADBW xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vmpsadbw		Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8.
VEX.NDS.256.66.0F3A.WIG 42 /r ib	VMPSADBW ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX2	vmpsadbw		Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by imm8.
														
F6 /4 	MUL r/m8 	M	R	AL	AX E.OF E.CF	E.SF E.ZF E.AF E.PF			V	V		mulb		Unsigned multiply (AX = AL * r/m8).
REX+ F6 /4 	MUL r/m8	M	R	AL	AX E.OF E.CF	E.SF E.ZF E.AF E.PF			V	NE		mulb		Unsigned multiply (AX = AL * r/m8).
F7 /4 	MUL r/m16 	M	R	AX	AX DX E.OF E.CF	E.SF E.ZF E.AF E.PF			V	V		mulw		Unsigned multiply (DX:AX = AX * r/m16).
F7 /4 	MUL r/m32 	M	R	EAX	RAX RDX E.OF E.CF	E.SF E.ZF E.AF E.PF			V	V		mull		Unsigned multiply (EDX:EAX = EAX * r/m32).
REX.W+ F7 /4 	MUL r/m64 	M	R	RAX	RAX RDX E.OF E.CF	E.SF E.ZF E.AF E.PF			V	NE		mulq		Unsigned multiply (RDX:RAX = RAX * r/m64.
														
66 0F 59 /r 	MULPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	mulpd		Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.
VEX.NDS.128.66.0F.WIG 59 /r	VMULPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vmulpd		Multiply packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
VEX.NDS.256.66.0F.WIG 59 /r	VMULPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vmulpd		Multiply packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
														
0F 59 /r 	MULPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	mulps		Multiply packed single-precision floating-point values in xmm2/mem by xmm1.
VEX.NDS.128.0F.WIG 59 /r	VMULPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vmulps		Multiply packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
VEX.NDS.256.0F.WIG 59 /r	VMULPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vmulps		Multiply packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
														
F2 0F 59 /r 	MULSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	mulsd		Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.
VEX.NDS.LIG.F2.0F.WIG 59 /r	VMULSD xmm1,xmm2, xmm3/m64	RVM	Z, R, R						V	V	AVX	vmulsd		Multiply the low double-precision floating-point value in xmm3/mem64 by low double precision floating-point value in xmm2.
														
F3 0F 59 /r 	MULSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	mulss		Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.
VEX.NDS.LIG.F3.0F.WIG 59 /r	VMULSS xmm1,xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vmulss		Multiply the low single-precision floating-point value in xmm3/mem by the low single-precision floating-point value in xmm2.
														
VEX.NDD.LZ.F2.0F38.W0 F6 /r	MULX r32a, r32b, r/m32	RVM	W, W, R	EDX					V	V	BMI2	mulxl		Unsigned multiply of r/m32 with EDX without affecting arithmetic flags
VEX.NDD.LZ.F2.0F38.W1 F6 /r	MULX r64a, r64b, r/m64	RVM	W, W, R	RDX					V	NE	BMI2	mulxq		Unsigned multiply of r/m64 with RDX without affecting arithmetic flags
														
0F 01 C9 	MWAIT 	NP		EAX ECX					V	V	MONITOR	mwait		A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.
														
F6 /3 	NEG r/m8 	M	RW		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		negb		Two''s complement negate r/m8.
REX+ F6 /3 	NEG r/m8	M	RW		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		negb		Two''s complement negate r/m8.
F7 /3 	NEG r/m16 	M	RW		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		negw		Two''s complement negate r/m16.
F7 /3 	NEG r/m32 	M	RW		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V		negl		Two''s complement negate r/m32.
REX.W+ F7 /3 	NEG r/m64 	M	RW		E.CF E.OF E.SF E.ZF E.AF E.PF				V	NE		negq		Two''s complement negate r/m64.
														
90	NOP 	NP							V	V		nop		One byte no-operation instruction.
0F 1F /0 	NOP r/m16 	M	I						V	V	NOPL	nopw		Multi-byte no-operation instruction.
0F 1F /0 	NOP r/m32 	M	I						V	V	NOPL	nopl		Multi-byte no-operation instruction.
														
F6 /2 	NOT r/m8 	M	RW						V	V		notb		Reverse each bit of r/m8.
REX+ F6 /2 	NOT r/m8	M	RW						V	NE		notb		Reverse each bit of r/m8.
F7 /2 	NOT r/m16 	M	RW						V	V		notw		Reverse each bit of r/m16.
F7 /2 	NOT r/m32 	M	RW						V	V		notl		Reverse each bit of r/m32.
REX.W+ F7 /2 	NOT r/m64 	M	RW						V	NE		notq		Reverse each bit of r/m64.
														
0C ib 	OR AL, imm8 	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orb		AL OR imm8.
0D iw 	OR AX, imm16 	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orw		AX OR imm16.
0D id 	OR EAX, imm32 	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orl		EAX OR imm32.
REX.W+ 0D id 	OR RAX, imm32 	I	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orq		RAX OR imm32 (sign-extended).
80 /1 ib 	OR r/m8, imm8 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orb		r/m8 OR imm8.
REX+ 80 /1 ib 	OR r/m8, imm8 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orb		r/m8 OR imm8.
81 /1 iw 	OR r/m16, imm16 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orw		r/m16 OR imm16.
81 /1 id 	OR r/m32, imm32 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orl		r/m32 OR imm32.
REX.W+ 81 /1 id 	OR r/m64, imm32 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orq		r/m64 OR imm32 (sign-extended).
83 /1 ib 	OR r/m16, imm8 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orw	YES	r/m16 OR imm8 (sign-extended).
83 /1 ib 	OR r/m32, imm8 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orl	YES	r/m32 OR imm8 (sign-extended).
REX.W+ 83 /1 ib 	OR r/m64, imm8 	MI	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orq	YES	r/m64 OR imm8 (sign-extended).
08 /r 	OR r/m8, r8 	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orb	YES	r/m8 OR r8.
REX+ 08 /r 	OR r/m8, r8	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orb	YES	r/m8 OR r8.
09 /r 	OR r/m16, r16 	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orw	YES	r/m16 OR r16.
09 /r 	OR r/m32, r32 	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orl	YES	r/m32 OR r32.
REX.W+ 09 /r 	OR r/m64, r64 	MR	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orq	YES	r/m64 OR r64.
0A /r 	OR r8, r/m8 	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orb		r8 OR r/m8.
REX+ 0A /r 	OR r8, r/m8	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orb		r8 OR r/m8.
0B /r 	OR r16, r/m16 	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orw		r16 OR r/m16.
0B /r 	OR r32, r/m32 	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	V		orl		r32 OR r/m32.
REX.W+ 0B /r 	OR r64, r/m64 	RM	RW, R		E.OF E.CF E.SF E.ZF E.PF	E.AF			V	NE		orq		r64 OR r/m64.
														
66 0F 56 /r 	ORPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	orpd		Bitwise OR of xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG 56 /r 	VORPD xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vorpd		Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 56 /r 	VORPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vorpd		Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem.
														
0F 56 /r 	ORPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	orps		Bitwise OR of xmm1 and xmm2/m128.
VEX.NDS.128.0F.WIG 56 /r	VORPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vorps		Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.0F.WIG 56 /r	VORPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vorps		Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem.
														
E6 ib 	OUT imm8, AL 	I	R, R	E.IOPL E.VM					V	V		outb		Output byte in AL to I/O port address imm8.
E7 ib 	OUT imm8, AX 	I	R, R	E.IOPL E.VM					V	V		outw		Output word in AX to I/O port address imm8.
E7 ib 	OUT imm8, EAX 	I	R, R	E.IOPL E.VM					V	V		outl		Output doubleword in EAX to I/O port address imm8.
EE 	OUT DX, AL 	NP	R, R	E.IOPL E.VM					V	V		outb		Output byte in AL to I/O port address in DX.
EF 	OUT DX, AX 	NP	R, R	E.IOPL E.VM					V	V		outw		Output word in AX to I/O port address in DX.
EF 	OUT DX, EAX 	NP	R, R	E.IOPL E.VM					V	V		outl		Output doubleword in EAX to I/O port address in DX.
														
6E 	OUTS DX, m8 	NP	R, I	E.IOPL E.VM E.DF RSI					V	V		outs		Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
6F 	OUTS DX, m16 	NP	R, I	E.IOPL E.VM E.DF RSI					V	V		outs		Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
6F 	OUTS DX, m32 	NP	R, I	E.IOPL E.VM E.DF RSI					V	V		outs		Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
6E 	OUTSB 	NP		E.IOPL E.VM E.DF DX RSI					V	V		outsb		Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
PREF.66+ 6F 	OUTSW 	NP		E.IOPL E.VM E.DF DX RSI					V	V		outsw		Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
6F 	OUTSD 	NP		E.IOPL E.VM E.DF DX RSI					V	V		outsl		Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
														
0F 38 1C /r 	PABSB mm1, mm2/m64	RM	W, R						V	V	SSSE3	pabsb		Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.
66 0F 38 1C /r	PABSB xmm1, xmm2/m128	RM	W, R						V	V	SSSE3	pabsb		Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.
0F 38 1D /r	PABSW mm1, mm2/m64	RM	W, R						V	V	SSSE3	pabsw		Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.
66 0F 38 1D /r	PABSW xmm1, xmm2/m128	RM	W, R						V	V	SSSE3	pabsw		Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
0F 38 1E /r	PABSD mm1, mm2/m64	RM	W, R						V	V	SSSE3	pabsd		Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.
66 0F 38 1E /r	PABSD xmm1, xmm2/m128	RM	W, R						V	V	SSSE3	pabsd		Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
VEX.128.66.0F38.WIG 1C /r	VPABSB xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vpabsb		Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.
VEX.128.66.0F38.WIG 1D /r	VPABSW xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vpabsw		Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
VEX.128.66.0F38.WIG 1E /r	VPABSD xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vpabsd		Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
VEX.256.66.0F38.WIG 1C /r	VPABSB ymm1, ymm2/m256	RM	W, R						V	V	AVX2	vpabsb		Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1.
VEX.256.66.0F38.WIG 1D /r	VPABSW ymm1, ymm2/m256	RM	W, R						V	V	AVX2	vpabsw		Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1
VEX.256.66.0F38.WIG 1E /r	VPABSD ymm1, ymm2/m256	RM	W, R						V	V	AVX2	vpabsd		Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.
														
0F 63 /r 	PACKSSWB mm1, mm2/m64	RM	RW, R						V	V	MMX	packsswb		Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.
66 0F 63 /r	PACKSSWB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	packsswb		Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.
0F 6B /r	PACKSSDW mm1, mm2/m64	RM	RW, R						V	V	MMX	packssdw		Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.
66 0F 6B /r	PACKSSDW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	packssdw		Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.
VEX.NDS.128.66.0F.WIG 63 /r	VPACKSSWB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpacksswb		Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation.
VEX.NDS.128.66.0F.WIG 6B /r	VPACKSSDW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpackssdw		Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation.
VEX.NDS.256.66.0F.WIG 63 /r	VPACKSSWB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpacksswb		Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation.
VEX.NDS.256.66.0F.WIG 6B /r	VPACKSSDW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpackssdw		Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation.
														
66 0F 38 2B /r 	PACKUSDW xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	packusdw		Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
VEX.NDS.128.66.0F38.WIG 2B /r 	VPACKUSDW xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpackusdw		Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
VEX.NDS.256.66.0F38.WIG 2B /r	VPACKUSDW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpackusdw		Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m128 into 16 packed unsigned word integers in ymm1 using unsigned saturation.
														
0F 67 /r 	PACKUSWB mm, mm/m64	RM	RW, R						V	V	MMX	packuswb		Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.
66 0F 67 /r	PACKUSWB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	packuswb		Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
VEX.NDS.128.66.0F.WIG 67 /r	VPACKUSWB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpackuswb		Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
VEX.NDS.256.66.0F.WIG 67 /r	VPACKUSWB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpackuswb		Converts 16 signed word integers from ymm2 And 16 signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation.
														
0F FC /r 	PADDB mm, mm/m64	RM	RW, R						V	V	MMX	paddb		Add packed byte integers from mm/m64 and mm.
66 0F FC /r	PADDB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddb		Add packed byte integers from xmm2/m128 and xmm1.
0F FD /r	PADDW mm, mm/m64	RM	RW, R						V	V	MMX	paddw		Add packed word integers from mm/m64 and mm.
66 0F FD /r	PADDW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddw		Add packed word integers from xmm2/m128 and xmm1.
0F FE /r	PADDD mm, mm/m64	RM	RW, R						V	V	MMX	paddd		Add packed doubleword integers from mm/m64 and mm.
66 0F FE /r	PADDD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddd		Add packed doubleword integers from xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG FC /r	VPADDB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpaddb		Add packed byte integers from xmm3/m128 and xmm2.
VEX.NDS.128.66.0F.WIG FD /r	VPADDW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpaddw		Add packed word integers from xmm3/m128 and xmm2.
VEX.NDS.128.66.0F.WIG FE /r	VPADDD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpaddd		Add packed doubleword integers from xmm3/m128 and xmm2.
VEX.NDS.256.66.0F.WIG FC /r	VPADDB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddb		Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1.
VEX.NDS.256.66.0F.WIG FD /r	VPADDW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddw		Add packed word integers from ymm2, ymm3/m256 and store in ymm1.
VEX.NDS.256.66.0F.WIG FE /r	VPADDD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddd		Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1.
														
0F D4 /r 	PADDQ mm1, mm2/m64	RM	RW, R						V	V	SSE2	paddq		Add quadword integer mm2/m64 to mm1.
66 0F D4 /r	PADDQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddq		Add packed quadword integers xmm2/m128 to xmm1.
VEX.NDS.128.66.0F.WIG D4 /r	VPADDQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpaddq		Add packed quadword integers xmm3/m128 and xmm2.
VEX.NDS.256.66.0F.WIG D4 /r	VPADDQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddq		Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1.
														
0F EC /r 	PADDSB mm, mm/m64	RM	RW, R						V	V	MMX	paddsb		Add packed signed byte integers from mm/m64 and mm and saturate the results.
66 0F EC /r	PADDSB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddsb		Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.
0F ED /r	PADDSW mm, mm/m64	RM	RW, R						V	V	MMX	paddsw		Add packed signed word integers from mm/m64 and mm and saturate the results.
66 0F ED /r	PADDSW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddsw		Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.
VEX.NDS.128.66.0F.WIG EC /r 	VPADDSB xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpaddsb		Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results.
VEX.NDS.128.66.0F.WIG ED /r 	VPADDSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpaddsw		Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results.
VEX.NDS.256.66.0F.WIG EC /r	VPADDSB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddsb		Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
VEX.NDS.256.66.0F.WIG ED /r	VPADDSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddsw		Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
														
0F DC /r 	PADDUSB mm, mm/m64	RM	RW, R						V	V	MMX	paddusb		Add packed unsigned byte integers from mm/m64 and mm and saturate the results.
66 0F DC /r	PADDUSB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddusb		Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.
0F DD /r	PADDUSW mm, mm/m64	RM	RW, R						V	V	MMX	paddusw		Add packed unsigned word integers from mm/m64 and mm and saturate the results.
66 0F DD /r	PADDUSW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	paddusw		Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.
VEX.NDS.128.66.0F.WIG DC /r	VPADDUSB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpaddusb		Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results.
VEX.NDS.128.66.0F.WIG DD /r	VPADDUSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpaddusw		Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results.
VEX.NDS.256.66.0F.WIG DC /r	VPADDUSB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddusb		Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
VEX.NDS.256.66.0F.WIG DD /r	VPADDUSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpaddusw		Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
														
0F 3A 0F 	PALIGNR mm1, mm2/m64, imm8	RMI	RW, R, R						V	V	SSSE3	palignr		Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1.
66 0F 3A 0F	PALIGNR xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSSE3	palignr		Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1
VEX.NDS.128.66.0F3A.WIG 0F /r ib	VPALIGNR xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vpalignr		Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1.
VEX.NDS.256.66.0F3A.WIG 0F /r ib	VPALIGNR ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX2	vpalignr		Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1.
														
0F DB /r 	PAND mm, mm/m64	RM	RW, R						V	V	MMX	pand		Bitwise AND mm/m64 and mm.
66 0F DB /r	PAND xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pand		Bitwise AND of xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG DB /r	VPAND xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpand		Bitwise AND of xmm3/m128 and xmm.
VEX.NDS.256.66.0F.WIG DB /r	VPAND ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpand		Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1.
														
0F DF /r 	PANDN mm, mm/m64	RM	RW, R						V	V	MMX	pandn		Bitwise AND NOT of mm/m64 and mm.
66 0F DF /r	PANDN xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pandn		Bitwise AND NOT of xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG DF /r	VPANDN xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpandn		Bitwise AND NOT of xmm3/m128 and xmm2.
VEX.NDS.256.66.0F.WIG DF /r	VPANDN ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpandn		Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1.
														
F3 90 	PAUSE 	NP							V	V		pause		Gives hint to processor that improves performance of spin-wait loops.
														
0F E0 /r 	PAVGB mm1, mm2/m64	RM	RW, R						V	V	SSE	pavgb		Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.
66 0F E0 /r	PAVGB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pavgb		Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.
0F E3 /r	PAVGW mm1, mm2/m64	RM	RW, R						V	V	SSE	pavgw		Average packed unsigned word integers from mm2/m64 and mm1 with rounding.
66 0F E3 /r	PAVGW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pavgw		Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.
VEX.NDS.128.66.0F.WIG E0 /r	VPAVGB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpavgb		Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding.
VEX.NDS.128.66.0F.WIG E3 /r	VPAVGW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpavgw		Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding.
VEX.NDS.256.66.0F.WIG E0 /r	VPAVGB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpavgb		Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1.
VEX.NDS.256.66.0F.WIG E3 /r	VPAVGW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpavgw		Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1.
														
66 0F 38 10 /r 	PBLENDVB xmm1, xmm2/m128, <XMM0> 	RM	RW, R, R						V	V	SSE4_1	pblendvb		Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.
VEX.NDS.128.66.0F3A.W0 4C /r /is4 	VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4 	RVMR	Z, R, R, R						V	V	AVX	vpblendvb		Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1.
VEX.NDS.256.66.0F3A.W0 4C /r /is4	VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4	RVMR	W, R, R, R						V	V	AVX2	vpblendvb		Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1.
														
66 0F 3A 0E /r ib 	PBLENDW xmm1, xmm2/m128, imm8 	RMI	RW, R, R						V	V	SSE4_1	pblendw		Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
VEX.NDS.128.66.0F3A.WIG 0E /r ib 	VPBLENDW xmm1, xmm2, xmm3/m128, imm8 	RVMI	Z, R, R, R						V	V	AVX	vpblendw		Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.
VEX.NDS.256.66.0F3A.WIG 0E /r ib	VPBLENDW ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX2	vpblendw		Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.
														
66 0F 3A 44 /r ib 	PCLMULQDQ xmm1, xmm2/m128, imm8 	RMI	RW, R, R						V	V	PCLMULQDQ	pclmulqdq		Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.
VEX.NDS.128.66.0F3A.WIG 44 /r ib 	VPCLMULQDQ xmm1, xmm2, xmm3/m128, imm8 	RVMI	Z, R, R, R						V	V	PCLMULQDQ AVX	vpclmulqdq		Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.
														
0F 74 /r 	PCMPEQB mm, mm/m64	RM	RW, R						V	V	MMX	pcmpeqb		Compare packed bytes in mm/m64 and mm for equality.
66 0F 74 /r	PCMPEQB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pcmpeqb		Compare packed bytes in xmm2/m128 and xmm1 for equality.
0F 75 /r	PCMPEQW mm, mm/m64	RM	RW, R						V	V	MMX	pcmpeqw		Compare packed words in mm/m64 and mm for equality.
66 0F 75 /r	PCMPEQW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pcmpeqw		Compare packed words in xmm2/m128 and xmm1 for equality.
0F 76 /r	PCMPEQD mm, mm/m64	RM	RW, R						V	V	MMX	pcmpeqd		Compare packed doublewords in mm/m64 and mm for equality.
66 0F 76 /r	PCMPEQD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pcmpeqd		Compare packed doublewords in xmm2/m128 and xmm1 for equality.
VEX.NDS.128.66.0F.WIG 74 /r	VPCMPEQB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpcmpeqb		Compare packed bytes in xmm3/m128 and xmm2 for equality.
VEX.NDS.128.66.0F.WIG 75 /r	VPCMPEQW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpcmpeqw		Compare packed words in xmm3/m128 and xmm2 for equality.
VEX.NDS.128.66.0F.WIG 76 /r	VPCMPEQD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpcmpeqd		Compare packed doublewords in xmm3/m128 and xmm2 for equality.
VEX.NDS.256.66.0F.WIG 74 /r	VPCMPEQB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpeqb		Compare packed bytes in ymm3/m256 and ymm2 for equality.
VEX.NDS.256.66.0F.WIG 75 /r	VPCMPEQW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpeqw		Compare packed words in ymm3/m256 and ymm2 for equality.
VEX.NDS.256.66.0F.WIG 76 /r	VPCMPEQD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpeqd		Compare packed doublewords in ymm3/m256 and ymm2 for equality.
														
66 0F 38 29 /r 	PCMPEQQ xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pcmpeqq		Compare packed qwords in xmm2/m128 and xmm1 for equality.
VEX.NDS.128.66.0F38.WIG 29 /r 	VPCMPEQQ xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpcmpeqq		Compare packed quadwords in xmm3/m128 and xmm2 for equality.
VEX.NDS.256.66.0F38.WIG 29 /r	VPCMPEQQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpeqq		Compare packed quadwords in ymm3/m256 and ymm2 for equality.
														
66 0F 3A 61 /r	PCMPESTRI xmm1, xmm2/m128, imm8 	RMI	R, R, R	EAX EDX	RCX E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	SSE4_2	pcmpestri		Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
VEX.128.66.0F3A.WIG 61 /r ib 	VPCMPESTRI xmm1, xmm2/m128, imm8 	RMI	R, R, R	EAX EDX	RCX E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	AVX	vpcmpestri		Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
														
66 0F 3A 60 /r	PCMPESTRM xmm1, xmm2/m128, imm8 	RMI	R, R, R	EAX EDX	XMM0 E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	SSE4_2	pcmpestrm		Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0
VEX.128.66.0F3A.WIG 60 /r ib 	VPCMPESTRM xmm1, xmm2/m128, imm8 	RMI	R, R, R	EAX EDX	YMM0 E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	AVX	vpcmpestrm		Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.
														
0F 64 /r 	PCMPGTB mm, mm/m64	RM	RW, R						V	V	MMX	pcmpgtb		Compare packed signed byte integers in mm and mm/m64 for greater than.
66 0F 64 /r	PCMPGTB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pcmpgtb		Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.
0F 65 /r	PCMPGTW mm, mm/m64	RM	RW, R						V	V	MMX	pcmpgtw		Compare packed signed word integers in mm and mm/m64 for greater than.
66 0F 65 /r	PCMPGTW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pcmpgtw		Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.
0F 66 /r	PCMPGTD mm, mm/m64	RM	RW, R						V	V	MMX	pcmpgtd		Compare packed signed doubleword integers in mm and mm/m64 for greater than.
66 0F 66 /r	PCMPGTD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pcmpgtd		Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.
VEX.NDS.128.66.0F.WIG 64 /r	VPCMPGTB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpcmpgtb		Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than.
VEX.NDS.128.66.0F.WIG 65 /r	VPCMPGTW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpcmpgtw		Compare packed signed word integers in xmm2 and xmm3/m128 for greater than.
VEX.NDS.128.66.0F.WIG 66 /r	VPCMPGTD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpcmpgtd		Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than.
VEX.NDS.256.66.0F.WIG 64 /r	VPCMPGTB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpgtb		Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than.
VEX.NDS.256.66.0F.WIG 65 /r	VPCMPGTW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpgtw		Compare packed signed word integers in ymm2 and ymm3/m256 for greater than.
VEX.NDS.256.66.0F.WIG 66 /r	VPCMPGTD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpgtd		Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than.
														
66 0F 38 37 /r 	PCMPGTQ xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_2	pcmpgtq		Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.
VEX.NDS.128.66.0F38.WIG 37 /r 	VPCMPGTQ xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpcmpgtq		Compare packed signed qwords in xmm2 and xmm3/m128 for greater than.
VEX.NDS.256.66.0F38.WIG 37 /r	VPCMPGTQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpcmpgtq		Compare packed signed qwords in ymm2 and ymm3/m256 for greater than.
														
66 0F 3A 63 /r	PCMPISTRI xmm1, xmm2/m128, imm8 	RM	R, R, R		RCX E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	SSE4_2	pcmpistri		Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
VEX.128.66.0F3A.WIG 63 /r ib 	VPCMPISTRI xmm1, xmm2/m128, imm8 	RM	R, R, R		RCX E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	AVX	vpcmpistri		Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
														
66 0F 3A 62 /r	PCMPISTRM xmm1, xmm2/m128, imm8 	RM	R, R, R		XMM0 E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	SSE4_2	pcmpistrm		Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
VEX.128.66.0F3A.WIG 62 /r ib 	VPCMPISTRM xmm1, xmm2/m128, imm8 	RM	R, R, R		YMM0 E.CF E.ZF E.SF E.OF E.AF E.PF				V	V	AVX	vpcmpistrm		Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.
														
VEX.NDS.LZ.F2.0F38.W0 F5 /r	PDEP r32a, r32b, r/m32	RVM	W, R, R						V	V	BMI2	pdepl		Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a.
VEX.NDS.LZ.F2.0F38.W1 F5 /r	PDEP r64a, r64b, r/m64	RVM	W, R, R						V	NE	BMI2	pdepq		Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a.
														
VEX.NDS.LZ.F3.0F38.W0 F5 /r	PEXT r32a, r32b, r/m32	RVM	W, R, R						V	V	BMI2	pextl		Parallel extract of bits from r32b using mask in r/m32, result is written to r32a.
VEX.NDS.LZ.F3.0F38.W1 F5 /r	PEXT r64a, r64b, r/m64	RVM	W, R, R						V	NE	BMI2	pextq		Parallel extract of bits from r64b using mask in r/m64, result is written to r64a.
														
66 0F 3A 14 /r ib 	PEXTRB reg/m8, xmm2, imm8 	MRI	W, R, R						V	V	SSE4_1	pextrb		Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.
66 0F 3A 16 /r ib 	PEXTRD r/m32, xmm2, imm8 	MRI	W, R, R						V	V	SSE4_1	pextrd		Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.
66 REX.W+ 0F 3A 16 /r ib 	PEXTRQ r/m64, xmm2, imm8 	MRI	W, R, R						V	NE	SSE4_1	pextrq		Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.
VEX.128.66.0F3A.W0 14 /r ib 	VPEXTRB reg/m8, xmm2, imm8 	MRI	W, R, R						V	V	AVX	vpextrb		Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with
VEX.128.66.0F3A.W0 16 /r ib 	VPEXTRD r32/m32, xmm2, imm8 	MRI	W, R, R						V	V	AVX	vpextrd		Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32.
VEX.128.66.0F3A.W1 16 /r ib 	VPEXTRQ r64/m64, xmm2, imm8 	MRI	W, R, R						V	I	AVX	vpextrq		Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64.
														
0F C5 /r ib 	PEXTRW reg, mm, imm8	RMI	W, R, R						V	V	SSE	pextrw		Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.
66 0F C5 /r ib	PEXTRW reg, xmm, imm8	RMI	W, R, R						V	V	SSE2	pextrw	YES	Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.
66 0F 3A 15 /r ib 	PEXTRW reg/m16, xmm, imm8 	MRI	W, R, R						V	V	SSE4_1	pextrw		Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.
VEX.128.66.0F.W0 C5 /r ib 	VPEXTRW reg, xmm1, imm8 	RMI	W, R, R						V	V	AVX	vpextrw	YES	Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros.
VEX.128.66.0F3A.W0 15 /r ib 	VPEXTRW reg/m16, xmm2, imm8 	MRI	W, R, R						V	V	AVX	vpextrw		Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros.
														
0F 38 01 /r 	PHADDW mm1, mm2/m64	RM	RW, R						V	V	SSSE3	phaddw		Add 16-bit integers horizontally, pack to MM1.
66 0F 38 01 /r	PHADDW xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	phaddw		Add 16-bit integers horizontally, pack to XMM1.
0F 38 02 /r	PHADDD mm1, mm2/m64	RM	RW, R						V	V	SSSE3	phaddd		Add 32-bit integers horizontally, pack to MM1.
66 0F 38 02 /r	PHADDD xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	phaddd		Add 32-bit integers horizontally, pack to XMM1.
VEX.NDS.128.66.0F38.WIG 01 /r	VPHADDW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vphaddw		Add 16-bit integers horizontally, pack to xmm1.
VEX.NDS.128.66.0F38.WIG 02 /r	VPHADDD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vphaddd		Add 32-bit integers horizontally, pack to xmm1.
VEX.NDS.256.66.0F38.WIG 01 /r	VPHADDW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vphaddw		Add 16-bit signed integers horizontally, pack to ymm1.
VEX.NDS.256.66.0F38.WIG 02 /r	VPHADDD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vphaddd		Add 32-bit signed integers horizontally, pack to ymm1.
														
0F 38 03 /r 	PHADDSW mm1, mm2/m64	RM	RW, R						V	V	SSSE3	phaddsw		Add 16-bit signed integers horizontally, pack saturated integers to MM1.
66 0F 38 03 /r	PHADDSW xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	phaddsw		Add 16-bit signed integers horizontally, pack saturated integers to XMM1.
VEX.NDS.128.66.0F38.WIG 03 /r	VPHADDSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vphaddsw		Add 16-bit signed integers horizontally, pack saturated integers to xmm1.
VEX.NDS.256.66.0F38.WIG 03 /r	VPHADDSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vphaddsw		Add 16-bit signed integers horizontally, pack saturated integers to ymm1.
														
66 0F 38 41 /r 	PHMINPOSUW xmm1, xmm2/m128 	RM	W, R						V	V	SSE4_1	phminposuw		Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
VEX.128.66.0F38.WIG 41 /r 	VPHMINPOSUW xmm1, xmm2/m128 	RM	Z, R						V	V	AVX	vphminposuw		Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
														
0F 38 05 /r 	PHSUBW mm1, mm2/m64	RM	RW, R						V	V	SSSE3	phsubw		Subtract 16-bit signed integers horizontally, pack to MM1.
66 0F 38 05 /r	PHSUBW xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	phsubw		Subtract 16-bit signed integers horizontally, pack to XMM1.
0F 38 06 /r	PHSUBD mm1, mm2/m64	RM	RW, R						V	V	SSSE3	phsubd		Subtract 32-bit signed integers horizontally, pack to MM1.
66 0F 38 06 /r	PHSUBD xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	phsubd		Subtract 32-bit signed integers horizontally, pack to XMM1
VEX.NDS.128.66.0F38.WIG 05 /r	VPHSUBW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vphsubw		Subtract 16-bit signed integers horizontally, pack to xmm1.
VEX.NDS.128.66.0F38.WIG 06 /r	VPHSUBD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vphsubd		Subtract 32-bit signed integers horizontally, pack to xmm1.
VEX.NDS.256.66.0F38.WIG 05 /r	VPHSUBW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vphsubw		Subtract 16-bit signed integers horizontally, pack to ymm1.
VEX.NDS.256.66.0F38.WIG 06 /r	VPHSUBD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vphsubd		Subtract 32-bit signed integers horizontally, pack to ymm1.
														
0F 38 07 /r 	PHSUBSW mm1, mm2/m64	RM	RW, R						V	V	SSSE3	phsubsw		Subtract 16-bit signed integer horizontally, pack saturated integers to MM1.
66 0F 38 07 /r	PHSUBSW xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	phsubsw		Subtract 16-bit signed integer horizontally, pack saturated integers to XMM1
VEX.NDS.128.66.0F38.WIG 07 /r	VPHSUBSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vphsubsw		Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.
VEX.NDS.256.66.0F38.WIG 07 /r	VPHSUBSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vphsubsw		Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1.
														
66 0F 3A 20 /r ib 	PINSRB xmm1, r32/m8, imm8 	RMI	RW, R, R						V	V	SSE4_1	pinsrb		Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.
66 0F 3A 22 /r ib 	PINSRD xmm1, r/m32, imm8 	RMI	RW, R, R						V	V	SSE4_1	pinsrd		Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.
66 REX.W+ 0F 3A 22 /r ib 	PINSRQ xmm1, r/m64, imm8 								NE	V	SSE4_1	pinsrq		Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8.
VEX.NDS.128.66.0F3A.W0 20 /r ib 	VPINSRB xmm1, xmm2, r32/m8, imm8 	RVMI	Z, R, R, R						V	V	AVX	vpinsrb		Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8.
VEX.NDS.128.66.0F3A.W0 22 /r ib 	VPINSRD xmm1, xmm2, r32/m32, imm8 	RVMI	Z, R, R, R						V	V	AVX	vpinsrd		Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8.
VEX.NDS.128.66.0F3A.W1 22 /r ib 	VPINSRQ xmm1, xmm2, r64/m64, imm8 	RVMI	Z, R, R, R						V	I	AVX	vpinsrq		Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8.
														
0F C4 /r ib 	PINSRW mm, r32/m16, imm8	RMI	RW, R, R						V	V	SSE	pinsrw		Insert the low word from r32 or from m16 into mm at the word position specified by imm8
66 0F C4 /r ib	PINSRW xmm, r32/m16, imm8	RMI	RW, R, R						V	V	SSE2	pinsrw		Move the low word of r32 or from m16 into xmm at the word position specified by imm8.
VEX.NDS.128.66.0F.W0 C4 /r ib	VPINSRW xmm1, xmm2, r32/m16, imm8	RVMI	Z, R, R, R						V	V	AVX	vpinsrw		Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8.
														
0F 38 04 /r 	PMADDUBSW mm1, mm2/m64	RM	RW, R						V	V	MMX SSSE3	pmaddubsw		Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to MM1.
66 0F 38 04 /r	PMADDUBSW xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	pmaddubsw		Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to XMM1.
VEX.NDS.128.66.0F38.WIG 04 /r	VPMADDUBSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmaddubsw		Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.
VEX.NDS.256.66.0F38.WIG 04 /r	VPMADDUBSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaddubsw		Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1.
														
0F F5 /r 	PMADDWD mm, mm/m64	RM	RW, R						V	V	MMX	pmaddwd		Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.
66 0F F5 /r	PMADDWD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pmaddwd		Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.
VEX.NDS.128.66.0F.WIG F5 /r	VPMADDWD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmaddwd		Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1.
VEX.NDS.256.66.0F.WIG F5 /r	VPMADDWD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaddwd		Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1.
														
66 0F 38 3C /r 	PMAXSB xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pmaxsb		Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
VEX.NDS.128.66.0F38.WIG 3C /r 	VPMAXSB xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpmaxsb		Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
VEX.NDS.256.66.0F38.WIG 3C /r	VPMAXSB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaxsb		Compare packed signed byte integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.
														
66 0F 38 3D /r 	PMAXSD xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pmaxsd		Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
VEX.NDS.128.66.0F38.WIG 3D /r 	VPMAXSD xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpmaxsd		Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
VEX.NDS.256.66.0F38.WIG 3D /r	VPMAXSD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaxsd		Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.
														
0F EE /r 	PMAXSW mm1, mm2/m64	RM	RW, R						V	V	SSE	pmaxsw		Compare signed word integers in mm2/m64 and mm1 and return maximum values.
66 0F EE /r	PMAXSW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pmaxsw		Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.
VEX.NDS.128.66.0F.WIG EE /r	VPMAXSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmaxsw		Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1.
VEX.NDS.256.66.0F.WIG EE /r	VPMAXSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaxsw		Compare packed signed word integers in ymm3/m128 and ymm2 and store packed maximum values in ymm1.
														
0F DE /r 	PMAXUB mm1, mm2/m64	RM	RW, R						V	V	SSE	pmaxub		Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.
66 0F DE /r	PMAXUB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pmaxub		Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.
VEX.NDS.128.66.0F.WIG DE /r	VPMAXUB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmaxub		Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
VEX.NDS.256.66.0F.WIG DE /r	VPMAXUB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaxub		Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.
														
66 0F 38 3F /r 	PMAXUD xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pmaxud		Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
VEX.NDS.128.66.0F38.WIG 3F /r 	VPMAXUD xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpmaxud		Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
VEX.NDS.256.66.0F38.WIG 3F /r	VPMAXUD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaxud		Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.
														
66 0F 38 3E /r 	PMAXUW xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pmaxuw		Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
VEX.NDS.128.66.0F38.WIG 3E /r 	VPMAXUW xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpmaxuw		Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1.
VEX.NDS.256.66.0F38.WIG 3E /r	VPMAXUW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmaxuw		Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1.
														
66 0F 38 38 /r 	PMINSB xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pminsb		Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
VEX.NDS.128.66.0F38.WIG 38 /r 	VPMINSB xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpminsb		Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
VEX.NDS.256.66.0F38.WIG 38 /r	VPMINSB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpminsb		Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
														
66 0F 38 39 /r 	PMINSD xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pminsd		Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
VEX.NDS.128.66.0F38.WIG 39 /r 	VPMINSD xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpminsd		Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
VEX.NDS.256.66.0F38.WIG 39 /r	VPMINSD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpminsd		Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1.
														
0F EA /r 	PMINSW mm1, mm2/m64	RM	RW, R						V	V	SSE	pminsw		Compare signed word integers in mm2/m64 and mm1 and return minimum values.
66 0F EA /r	PMINSW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pminsw		Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.
VEX.NDS.128.66.0F.WIG EA /r	VPMINSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpminsw		Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.
														
0F DA /r 	PMINUB mm1, mm2/m64	RM	RW, R						V	V	SSE	pminub		Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.
66 0F DA /r	PMINUB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pminub		Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.
VEX.NDS.128.66.0F.WIG DA /r	VPMINUB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpminub		Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
VEX.NDS.256.66.0F.WIG DA /r	VPMINUB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpminub		Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
														
66 0F 38 3B /r 	PMINUD xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pminud		Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
VEX.NDS.128.66.0F38.WIG 3B /r 	VPMINUD xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpminud		Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
VEX.NDS.256.66.0F38.WIG 3B /r	VPMINUD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpminud		Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
														
66 0F 38 3A /r 	PMINUW xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pminuw		Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
VEX.NDS.128.66.0F38.WIG 3A /r 	VPMINUW xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpminuw		Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.
VEX.NDS.256.66.0F38.WIG 3A /r	VPMINUW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpminuw		Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1.
														
0F D7 /r 	PMOVMSKB reg, mm	RM	W, R						V	V	SSE	pmovmskb		Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed
66 0F D7 /r	PMOVMSKB reg, xmm	RM	W, R						V	V	SSE2	pmovmskb		Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed
VEX.128.66.0F.WIG D7 /r	VPMOVMSKB reg, xmm1	RM	W, R						V	V	AVX	vpmovmskb		Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros.
VEX.256.66.0F.WIG D7 /r	VPMOVMSKB reg, ymm1	RM	W, R						V	V	AVX2	vpmovmskb		Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros.
														
66 0f 38 20 /r 	PMOVSXBW xmm1, xmm2/m64 	RM	W, R						V	V	SSE4_1	pmovsxbw		Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.
66 0f 38 21 /r 	PMOVSXBD xmm1, xmm2/m32 	RM	W, R						V	V	SSE4_1	pmovsxbd		Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.
66 0f 38 22 /r 	PMOVSXBQ xmm1, xmm2/m16	RM	W, R						V	V	SSE4_1	pmovsxbq		Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.
66 0f 38 23 /r 	PMOVSXWD xmm1, xmm2/m64 	RM	W, R						V	V	SSE4_1	pmovsxwd		Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.
66 0f 38 24 /r 	PMOVSXWQ xmm1, xmm2/m32 	RM	W, R						V	V	SSE4_1	pmovsxwq		Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.
66 0f 38 25 /r 	PMOVSXDQ xmm1, xmm2/m64 	RM	W, R						V	V	SSE4_1	pmovsxdq		Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.
VEX.128.66.0F38.WIG 20 /r 	VPMOVSXBW xmm1, xmm2/m64 	RM	Z, R						V	V	AVX	vpmovsxbw		Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
VEX.128.66.0F38.WIG 21 /r 	VPMOVSXBD xmm1, xmm2/m32 	RM	Z, R						V	V	AVX	vpmovsxbd		Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
VEX.128.66.0F38.WIG 22 /r 	VPMOVSXBQ xmm1, xmm2/m16 	RM	Z, R						V	V	AVX	vpmovsxbq		Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
VEX.128.66.0F38.WIG 23 /r 	VPMOVSXWD xmm1, xmm2/m64 	RM	Z, R						V	V	AVX	vpmovsxwd		Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
VEX.128.66.0F38.WIG 24 /r 	VPMOVSXWQ xmm1, xmm2/m32 	RM	Z, R						V	V	AVX	vpmovsxwq		Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
VEX.128.66.0F38.WIG 25 /r 	VPMOVSXDQ xmm1, xmm2/m64 	RM	Z, R						V	V	AVX	vpmovsxdq		Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1
VEX.256.66.0F38.WIG 20 /r	VPMOVSXBW ymm1, xmm2/m128	RM	W, R						V	V	AVX2	vpmovsxbw		Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.
VEX.256.66.0F38.WIG 21 /r	VPMOVSXBD ymm1, xmm2/m64	RM	W, R						V	V	AVX2	vpmovsxbd		Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.
VEX.256.66.0F38.WIG 22 /r	VPMOVSXBQ ymm1, xmm2/m32	RM	W, R						V	V	AVX2	vpmovsxbq		Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.
VEX.256.66.0F38.WIG 23 /r	VPMOVSXWD ymm1, xmm2/m128	RM	W, R						V	V	AVX2	vpmovsxwd		Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1.
VEX.256.66.0F38.WIG 24 /r	VPMOVSXWQ ymm1, xmm2/m64	RM	W, R						V	V	AVX2	vpmovsxwq		Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1.
VEX.256.66.0F38.WIG 25 /r	VPMOVSXDQ ymm1, xmm2/m128	RM	W, R						V	V	AVX2	vpmovsxdq		Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1.
														
66 0f 38 30 /r 	PMOVZXBW xmm1, xmm2/m64 	RM	W, R						V	V	SSE4_1	pmovzxbw		Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
66 0f 38 31 /r 	PMOVZXBD xmm1, xmm2/m32 	RM	W, R						V	V	SSE4_1	pmovzxbd		Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
66 0f 38 32 /r 	PMOVZXBQ xmm1, xmm2/m16 	RM	W, R						V	V	SSE4_1	pmovzxbq		Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
66 0f 38 33 /r 	PMOVZXWD xmm1, xmm2/m64 	RM	W, R						V	V	SSE4_1	pmovzxwd		Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
66 0f 38 34 /r 	PMOVZXWQ xmm1, xmm2/m32 	RM	W, R						V	V	SSE4_1	pmovzxwq		Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
66 0f 38 35 /r 	PMOVZXDQ xmm1, xmm2/m64 	RM	W, R						V	V	SSE4_1	pmovzxdq		Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
VEX.128.66.0F38.WIG 30 /r 	VPMOVZXBW xmm1, xmm2/m64 	RM	Z, R						V	V	AVX	vpmovzxbw		Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
VEX.128.66.0F38.WIG 31 /r 	VPMOVZXBD xmm1, xmm2/m32 	RM	Z, R						V	V	AVX	vpmovzxbd		Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
VEX.128.66.0F38.WIG 32 /r 	VPMOVZXBQ xmm1, xmm2/m16 	RM	Z, R						V	V	AVX	vpmovzxbq		Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
VEX.128.66.0F38.WIG 33 /r 	VPMOVZXWD xmm1, xmm2/m64 	RM	Z, R						V	V	AVX	vpmovzxwd		Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
VEX.128.66.0F38.WIG 34 /r 	VPMOVZXWQ xmm1, xmm2/m32 	RM	Z, R						V	V	AVX	vpmovzxwq		Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
VEX.128.66.0F38.WIG 35 /r 	VPMOVZXDQ xmm1, xmm2/m64 	RM	Z, R						V	V	AVX	vpmovzxdq		Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
VEX.256.66.0F38.WIG 30 /r	VPMOVZXBW ymm1, xmm2/m128	RM	W, R						V	V	AVX2	vpmovzxbw		Zero extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 16-bit integers in ymm1.
VEX.256.66.0F38.WIG 31 /r	VPMOVZXBD ymm1, xmm2/m64	RM	W, R						V	V	AVX2	vpmovzxbd		Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.
VEX.256.66.0F38.WIG 32 /r	VPMOVZXBQ ymm1, xmm2/m32	RM	W, R						V	V	AVX2	vpmovzxbq		Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.
VEX.256.66.0F38.WIG 33 /r	VPMOVZXWD ymm1, xmm2/m128	RM	W, R						V	V	AVX2	vpmovzxwd		Zero extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1
VEX.256.66.0F38.WIG 34 /r	VPMOVZXWQ ymm1, xmm2/m64	RM	W, R						V	V	AVX2	vpmovzxwq		Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1.
VEX.256.66.0F38.WIG 35 /r	VPMOVZXDQ ymm1, xmm2/m128	RM	W, R						V	V	AVX2	vpmovzxdq		Zero extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1.
														
66 0F 38 28 /r 	PMULDQ xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pmuldq		Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.
VEX.NDS.128.66.0F38.WIG 28 /r 	VPMULDQ xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpmuldq		Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1.
VEX.NDS.256.66.0F38.WIG 28 /r	VPMULDQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmuldq		Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1.
														
0F 38 0B /r 	PMULHRSW mm1, mm2/m64	RM	RW, R						V	V	SSSE3	pmulhrsw		Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to MM1.
66 0F 38 0B /r	PMULHRSW xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	pmulhrsw		Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to XMM1.
VEX.NDS.128.66.0F38.WIG 0B /r	VPMULHRSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmulhrsw		Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.
VEX.NDS.256.66.0F38.WIG 0B /r	VPMULHRSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmulhrsw		Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1.
														
0F E4 /r 	PMULHUW mm1, mm2/m64	RM	RW, R						V	V	SSE	pmulhuw		Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.
66 0F E4 /r	PMULHUW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pmulhuw		Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
VEX.NDS.128.66.0F.WIG E4 /r	VPMULHUW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmulhuw		Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.
VEX.NDS.256.66.0F.WIG E4 /r	VPMULHUW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmulhuw		Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.
														
0F E5 /r 	PMULHW mm, mm/m64	RM	RW, R						V	V	MMX	pmulhw		Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.
66 0F E5 /r	PMULHW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pmulhw		Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
VEX.NDS.128.66.0F.WIG E5 /r	VPMULHW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmulhw		Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.
VEX.NDS.256.66.0F.WIG E5 /r	VPMULHW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmulhw		Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.
														
66 0F 38 40 /r 	PMULLD xmm1, xmm2/m128 	RM	RW, R						V	V	SSE4_1	pmulld		Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.
VEX.NDS.128.66.0F38.WIG 40 /r 	VPMULLD xmm1, xmm2, xmm3/m128 	RVM	Z, R, R						V	V	AVX	vpmulld		Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.
VEX.NDS.256.66.0F38.WIG 40 /r	VPMULLD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmulld		Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1.
														
0F D5 /r 	PMULLW mm, mm/m64	RM	RW, R						V	V	MMX	pmullw		Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.
66 0F D5 /r	PMULLW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pmullw		Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.
VEX.NDS.128.66.0F.WIG D5 /r	VPMULLW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmullw		Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.
VEX.NDS.256.66.0F.WIG D5 /r	VPMULLW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmullw		Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1.
														
0F F4 /r 	PMULUDQ mm1, mm2/m64	RM	RW, R						V	V	SSE2	pmuludq		Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.
66 0F F4 /r	PMULUDQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pmuludq		Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.
VEX.NDS.128.66.0F.WIG F4 /r	VPMULUDQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpmuludq		Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1.
VEX.NDS.256.66.0F.WIG F4 /r	VPMULUDQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpmuludq		Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1.
														
8F /0 	POP r/m16 	M	W	RSP	RSP				V	V		popw		Pop top of stack into m16; increment stack pointer.
8F /0 	POP r/m32 			RSP	RSP				NE	V				Pop top of stack into m32; increment stack pointer.
8F /0 	POP r/m64 	M	W	RSP	RSP				V	NE		popq		Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size.
58 +rw 	POP r16 	O	W	RSP	RSP				V	V		popw	YES	Pop top of stack into r16; increment stack pointer.
58 +rd 	POP r32 			RSP	RSP				NE	V				Pop top of stack into r32; increment stack pointer.
58 +rd 	POP r64 	O	W	RSP	RSP				V	NE		popq	YES	Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size.
1F 	POP DS 			RSP	RSP				I	V				Pop top of stack into DS; increment stack pointer.
07	POP ES 			RSP	RSP				I	V				Pop top of stack into ES; increment stack pointer.
17	POP SS 			RSP	RSP				I	V				Pop top of stack into SS; increment stack pointer.
PREF.66+ 0F A1 	POP FS, p66	NP	W, I	RSP	RSP				V	V		popq		Pop top of stack into FS; increment stack pointer by 16 bits.
0F A1 	POP FS 			RSP	RSP				NE	V				Pop top of stack into FS; increment stack pointer by 32 bits.
0F A1 	POP FS 	NP	W	RSP	RSP				V	NE		popq		Pop top of stack into FS; increment stack pointer by 64 bits.
PREF.66+ 0F A9 	POP GS, p66	NP	W, I	RSP	RSP				V	V		popq		Pop top of stack into GS; increment stack pointer by 16 bits.
0F A9 	POP GS 			RSP	RSP				NE	V				Pop top of stack into GS; increment stack pointer by 32 bits.
0F A9 	POP GS 	NP	W	RSP	RSP				V	NE		popq		Pop top of stack into GS; increment stack pointer by 64 bits.
														
61	POPA 			RSP	RSP				I	V				Pop DI, SI, BP, BX, DX, CX, and AX.
61	POPAD 			RSP	RSP				I	V				Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.
														
F3 0F B8 /r 	POPCNT r16, r/m16 	RM	W, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	POPCNT	popcntw		POPCNT on r/m16
F3 0F B8 /r 	POPCNT r32, r/m32 	RM	W, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	POPCNT	popcntl		POPCNT on r/m32
F3 REX.W+ 0F B8 /r 	POPCNT r64, r/m64 	RM	W, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE	POPCNT	popcntq		POPCNT on r/m64
														
66 9D 	POPF 	NP		RSP	E.* RSP				V	V		popfw		Pop top of stack into lower 16 bits of EFLAGS.
9D 	POPFD 								NE	V				Pop top of stack into EFLAGS.
9D 	POPFQ 	NP		RSP	E.* RSP				V	NE		popfq		Pop top of stack and zero-extend into RFLAGS.
														
0F EB /r 	POR mm, mm/m64	RM	RW, R						V	V	MMX	por		Bitwise OR of mm/m64 and mm.
66 0F EB /r	POR xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	por		Bitwise OR of xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG EB /r	VPOR xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpor		Bitwise OR of xmm2/m128 and xmm3.
VEX.NDS.256.66.0F.WIG EB /r	VPOR ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpor		Bitwise OR of ymm2/m256 and ymm3
														
0F 18 /1 	PREFETCHT0 m8 	M	I						V	V		prefetcht0		Move data from m8 closer to the processor using T0 hint.
0F 18 /2 	PREFETCHT1 m8 	M	I						V	V		prefetcht1		Move data from m8 closer to the processor using T1 hint.
0F 18 /3 	PREFETCHT2 m8 	M	I						V	V		prefetcht2		Move data from m8 closer to the processor using T2 hint.
0F 18 /0 	PREFETCHNTA m8 	M	I						V	V		prefetchnta		Move data from m8 closer to the processor using NTA hint.
														
0F F6 /r 	PSADBW mm1, mm2/m64	RM	RW, R						V	V	SSE	psadbw		Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.
66 0F F6 /r	PSADBW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psadbw		Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
VEX.NDS.128.66.0F.WIG F6 /r	VPSADBW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsadbw		Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
VEX.NDS.256.66.0F.WIG F6 /r	VPSADBW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsadbw		Computes the absolute differences of the packed unsigned byte integers from ymm3/m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results.
														
0F 38 00 /r 	PSHUFB mm1, mm2/m64	RM	RW, R						V	V	SSSE3	pshufb		Shuffle bytes in mm1 according to contents of mm2/m64.
66 0F 38 00 /r	PSHUFB xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	pshufb		Shuffle bytes in xmm1 according to contents of xmm2/m128.
VEX.NDS.128.66.0F38.WIG 00 /r	VPSHUFB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpshufb		Shuffle bytes in xmm2 according to contents of xmm3/m128.
VEX.NDS.256.66.0F38.WIG 00 /r	VPSHUFB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpshufb		Shuffle bytes in ymm2 according to contents of ymm3/m256.
														
66 0F 70 /r ib 	PSHUFD xmm1, xmm2/m128, imm8	RMI	W, R, R						V	V	SSE2	pshufd		Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
VEX.128.66.0F.WIG 70 /r ib	VPSHUFD xmm1, xmm2/m128, imm8	RMI	Z, R, R						V	V	AVX	vpshufd		Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
VEX.256.66.0F.WIG 70 /r ib	VPSHUFD ymm1, ymm2/m256, imm8	RMI	W, R, R						V	V	AVX2	vpshufd		Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
														
F3 0F 70 /r ib 	PSHUFHW xmm1, xmm2/m128, imm8	RMI	W, R, R						V	V	SSE2	pshufhw		Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
VEX.128.F3.0F.WIG 70 /r ib	VPSHUFHW xmm1, xmm2/m128, imm8	RMI	Z, R, R						V	V	AVX	vpshufhw		Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
VEX.256.F3.0F.WIG 70 /r ib	VPSHUFHW ymm1, ymm2/m256, imm8	RMI	W, R, R						V	V	AVX2	vpshufhw		Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
														
F2 0F 70 /r ib 	PSHUFLW xmm1, xmm2/m128, imm8	RMI	W, R, R						V	V	SSE2	pshuflw		Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
VEX.128.F2.0F.WIG 70 /r ib	VPSHUFLW xmm1, xmm2/m128, imm8	RMI	Z, R, R						V	V	AVX	vpshuflw		Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
VEX.256.F2.0F.WIG 70 /r ib	VPSHUFLW ymm1, ymm2/m256, imm8	RMI	W, R, R						V	V	AVX2	vpshuflw		Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
														
0F 70 /r ib 	PSHUFW mm1, mm2/m64, imm8	RMI	W, R, R						V	V		pshufw		Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.
														
0F 38 08 /r 	PSIGNB mm1, mm2/m64	RM	RW, R						V	V	SSSE3	psignb		Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64
66 0F 38 08 /r	PSIGNB xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	psignb		Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128.
0F 38 09 /r	PSIGNW mm1, mm2/m64	RM	RW, R						V	V	SSSE3	psignw		Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128.
66 0F 38 09 /r	PSIGNW xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	psignw		Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128.
0F 38 0A /r	PSIGND mm1, mm2/m64	RM	RW, R						V	V	SSSE3	psignd		Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128.
66 0F 38 0A /r	PSIGND xmm1, xmm2/m128	RM	RW, R						V	V	SSSE3	psignd		Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128.
VEX.NDS.128.66.0F38.WIG 08 /r	VPSIGNB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsignb		Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128.
VEX.NDS.128.66.0F38.WIG 09 /r	VPSIGNW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsignw		Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128.
VEX.NDS.128.66.0F38.WIG 0A /r	VPSIGND xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsignd		Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128.
														
66 0F 73 /7 ib 	PSLLDQ xmm1, imm8	MI	RW, R						V	V	SSE2	pslldq		Shift xmm1 left by imm8 bytes while shifting in 0s.
VEX.NDD.128.66.0F.WIG 73 /7 ib	VPSLLDQ xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpslldq		Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1.
VEX.NDD.256.66.0F.WIG 73 /7 ib	VPSLLDQ ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpslldq		Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1.
														
0F F1 /r	PSLLW mm, mm/m64	RM	RW, R						V	V	MMX	psllw		Shift words in mm left mm/m64 while shifting in 0s.
66 0F F1 /r	PSLLW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psllw		Shift words in xmm1 left by xmm2/m128 while shifting in 0s.
0F 71 /6 ib	PSLLW mm1, imm8	MI	RW, R						V	V	MMX	psllw		Shift words in mm left by imm8 while shifting in 0s.
66 0F 71 /6 ib	PSLLW xmm1, imm8	MI	RW, R						V	V	SSE2	psllw	YES	Shift words in xmm1 left by imm8 while shifting in 0s.
0F F2 /r	PSLLD mm, mm/m64	RM	RW, R						V	V	MMX	pslld		Shift doublewords in mm left by mm/m64 while shifting in 0s.
66 0F F2 /r	PSLLD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pslld		Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.
0F 72 /6 ib	PSLLD mm, imm8	MI	RW, R						V	V	MMX	pslld		Shift doublewords in mm left by imm8 while shifting in 0s.
66 0F 72 /6 ib	PSLLD xmm1, imm8	MI	RW, R						V	V	SSE2	pslld		Shift doublewords in xmm1 left by imm8 while shifting in 0s.
0F F3 /r	PSLLQ mm, mm/m64	RM	RW, R						V	V	MMX	psllq		Shift quadword in mm left by mm/m64 while shifting in 0s.
66 0F F3 /r	PSLLQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psllq		Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.
0F 73 /6 ib	PSLLQ mm, imm8	MI	RW, R						V	V	MMX	psllq		Shift quadword in mm left by imm8 while shifting in 0s.
66 0F 73 /6 ib	PSLLQ xmm1, imm8	MI	RW, R						V	V	SSE2	psllq		Shift quadwords in xmm1 left by imm8 while shifting in 0s.
VEX.NDS.128.66.0F.WIG F1 /r	VPSLLW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsllw		Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.128.66.0F.WIG 71 /6 ib	VPSLLW xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsllw		Shift words in xmm2 left by imm8 while shifting in 0s.
VEX.NDS.128.66.0F.WIG F2 /r	VPSLLD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpslld		Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.128.66.0F.WIG 72 /6 ib	VPSLLD xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpslld		Shift doublewords in xmm2 left by imm8 while shifting in 0s.
VEX.NDS.128.66.0F.WIG F3 /r	VPSLLQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsllq		Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.128.66.0F.WIG 73 /6 ib	VPSLLQ xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsllq		Shift quadwords in xmm2 left by imm8 while shifting in 0s.
VEX.NDS.256.66.0F.WIG F1 /r	VPSLLW ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpsllw		Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.256.66.0F.WIG 71 /6 ib	VPSLLW ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsllw		Shift words in ymm2 left by imm8 while shifting in 0s.
VEX.NDS.256.66.0F.WIG F2 /r	VPSLLD ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpslld		Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s
VEX.NDD.256.66.0F.WIG 72 /6 ib	VPSLLD ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpslld		Shift doublewords in ymm2 left by imm8 while shifting in 0s.
VEX.NDS.256.66.0F.WIG F3 /r	VPSLLQ ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpsllq		Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.256.66.0F.WIG 73 /6 ib	VPSLLQ ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsllq		Shift quadwords in ymm2 left by imm8 while shifting in 0s.
														
0F E1 /r	PSRAW mm, mm/m64	RM	RW, R						V	V	MMX	psraw		Shift words in mm right by mm/m64 while shifting in sign bits.
66 0F E1 /r	PSRAW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psraw		Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.
0F 71 /4 ib	PSRAW mm, imm8	MI	RW, R						V	V	MMX	psraw		Shift words in mm right by imm8 while shifting in sign bits
66 0F 71 /4 ib	PSRAW xmm1, imm8	MI	RW, R						V	V	SSE2	psraw		Shift words in xmm1 right by imm8 while shifting in sign bits
0F E2 /r	PSRAD mm, mm/m64	RM	RW, R						V	V	MMX	psrad		Shift doublewords in mm right by mm/m64 while shifting in sign bits.
66 0F E2 /r	PSRAD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psrad		Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.
0F 72 /4 ib	PSRAD mm, imm8	MI	RW, R						V	V	MMX	psrad		Shift doublewords in mm right by imm8 while shifting in sign bits.
66 0F 72 /4 ib	PSRAD xmm1, imm8	MI	RW, R						V	V	SSE2	psrad		Shift doublewords in xmm1 right by imm8 while shifting in sign bits.
VEX.NDS.128.66.0F.WIG E1 /r	VPSRAW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsraw		Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.
VEX.NDD.128.66.0F.WIG 71 /4 ib	VPSRAW xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsraw		Shift words in xmm2 right by imm8 while shifting in sign bits.
VEX.NDS.128.66.0F.WIG E2 /r	VPSRAD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsrad		Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.
VEX.NDD.128.66.0F.WIG 72 /4 ib	VPSRAD xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsrad		Shift doublewords in xmm2 right by imm8 while shifting in sign bits.
VEX.NDS.256.66.0F.WIG E1 /r	VPSRAW ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpsraw		Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.
VEX.NDD.256.66.0F.WIG 71 /4 ib	VPSRAW ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsraw		Shift words in ymm2 right by imm8 while shifting in sign bits.
VEX.NDS.256.66.0F.WIG E2 /r	VPSRAD ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpsrad		Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.
VEX.NDD.256.66.0F.WIG 72 /4 ib	VPSRAD ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsrad		Shift doublewords in ymm2 right by imm8 while shifting in sign bits.
														
66 0F 73 /3 ib	PSRLDQ xmm1, imm8	MI	RW, R						V	V	SSE2	psrldq		Shift xmm1 right by imm8 while shifting in 0s.
VEX.NDD.128.66.0F.WIG 73 /3 ib	VPSRLDQ xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsrldq		Shift xmm2 right by imm8 bytes while shifting in 0s.
VEX.NDD.256.66.0F.WIG 73 /3 ib	VPSRLDQ ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsrldq		Shift ymm1 right by imm8 bytes while shifting in 0s.
														
0F D1 /r	PSRLW mm, mm/m64	RM	RW, R						V	V	MMX	psrlw		Shift words in mm right by amount specified in mm/m64 while shifting in 0s.
66 0F D1 /r	PSRLW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psrlw		Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
0F 71 /2 ib	PSRLW mm, imm8	MI	RW, R						V	V	MMX	psrlw		Shift words in mm right by imm8 while shifting in 0s.
66 0F 71 /2 ib	PSRLW xmm1, imm8	MI	RW, R						V	V	SSE2	psrlw		Shift words in xmm1 right by imm8 while shifting in 0s.
0F D2 /r	PSRLD mm, mm/m64	RM	RW, R						V	V	MMX	psrld		Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.
66 0F D2 /r	PSRLD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psrld		Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.
0F 72 /2 ib	PSRLD mm, imm8	MI	RW, R						V	V	MMX	psrld		Shift doublewords in mm right by imm8 while shifting in 0s.
66 0F 72 /2 ib	PSRLD xmm1, imm8	MI	RW, R						V	V	SSE2	psrld		Shift doublewords in xmm1 right by imm8 while shifting in 0s.
0F D3 /r	PSRLQ mm, mm/m64	RM	RW, R						V	V	MMX	psrlq		Shift mm right by amount specified in mm/m64 while shifting in 0s.
66 0F D3 /r	PSRLQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psrlq		Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
0F 73 /2 ib	PSRLQ mm, imm8	MI	RW, R						V	V	MMX	psrlq		Shift mm right by imm8 while shifting in 0s. 
66 0F 73 /2 ib	PSRLQ xmm1, imm8	MI	RW, R						V	V	SSE2	psrlq		Shift quadwords in xmm1 right by imm8 while shifting in 0s.
VEX.NDS.128.66.0F.WIG D1 /r	VPSRLW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsrlw		Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.128.66.0F.WIG 71 /2 ib	VPSRLW xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsrlw		Shift words in xmm2 right by imm8 while shifting in 0s.
VEX.NDS.128.66.0F.WIG D2 /r	VPSRLD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsrld		Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.128.66.0F.WIG 72 /2 ib	VPSRLD xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsrld		Shift doublewords in xmm2 right by imm8 while shifting in 0s.
VEX.NDS.128.66.0F.WIG D3 /r	VPSRLQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsrlq		Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.128.66.0F.WIG 73 /2 ib	VPSRLQ xmm1, xmm2, imm8	VMI	Z, R, R						V	V	AVX	vpsrlq		Shift quadwords in xmm2 right by imm8 while shifting in 0s.
VEX.NDS.256.66.0F.WIG D1 /r	VPSRLW ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpsrlw		Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.256.66.0F.WIG 71 /2 ib	VPSRLW ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsrlw		Shift words in ymm2 right by imm8 while shifting in 0s.
VEX.NDS.256.66.0F.WIG D2 /r	VPSRLD ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpsrld		Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.256.66.0F.WIG 72 /2 ib	VPSRLD ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsrld		Shift doublewords in ymm2 right by imm8 while shifting in 0s.
VEX.NDS.256.66.0F.WIG D3 /r	VPSRLQ ymm1, ymm2, xmm3/m128	RVM	W, R, R						V	V	AVX2	vpsrlq		Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
VEX.NDD.256.66.0F.WIG 73 /2 ib	VPSRLQ ymm1, ymm2, imm8	VMI	W, R, R						V	V	AVX2	vpsrlq		Shift quadwords in ymm2 right by imm8 while shifting in 0s.
														
0F F8 /r	PSUBB mm, mm/m64	RM	RW, R						V	V	MMX	psubb		Subtract packed byte integers in mm/m64 from packed byte integers in mm.
66 0F F8 /r	PSUBB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubb		Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.
0F F9 /r	PSUBW mm, mm/m64	RM	RW, R						V	V	MMX	psubw		Subtract packed word integers in mm/m64 from packed word integers in mm.
66 0F F9 /r	PSUBW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubw		Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.
0F FA /r	PSUBD mm, mm/m64	RM	RW, R						V	V	MMX	psubd		Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.
66 0F FA /r	PSUBD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubd		Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.
VEX.NDS.128.66.0F.WIG F8 /r	VPSUBB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubb		Subtract packed byte integers in xmm3/m128 from xmm2.
VEX.NDS.128.66.0F.WIG F9 /r	VPSUBW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubw		Subtract packed word integers in xmm3/m128 from xmm2.
VEX.NDS.128.66.0F.WIG FA /r	VPSUBD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubd		Subtract packed doubleword integers in xmm3/m128 from xmm2.
VEX.NDS.256.66.0F.WIG F8 /r	VPSUBB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubb		Subtract packed byte integers in ymm3/m256 from ymm2.
VEX.NDS.256.66.0F.WIG F9 /r	VPSUBW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubw		Subtract packed word integers in ymm3/m256 from ymm2.
VEX.NDS.256.66.0F.WIG FA /r	VPSUBD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubd		Subtract packed doubleword integers in ymm3/m256 from ymm2.
														
0F FB /r	PSUBQ mm1, mm2/m64	RM	RW, R						V	V	SSE2	psubq		Subtract quadword integer in mm1 from mm2 /m64.
66 0F FB /r	PSUBQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubq		Subtract packed quadword integers in xmm1 from xmm2 /m128.
VEX.NDS.128.66.0F.WIG FB /r	VPSUBQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubq		Subtract packed quadword integers in xmm3/m128 from xmm2.
VEX.NDS.256.66.0F.WIG FB /r	VPSUBQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubq		Subtract packed quadword integers in ymm3/m256 from ymm2.
														
0F E8 /r	PSUBSB mm, mm/m64	RM	RW, R						V	V	MMX	psubsb		Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.
66 0F E8 /r	PSUBSB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubsb		Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.
0F E9 /r	PSUBSW mm, mm/m64	RM	RW, R						V	V	MMX	psubsw		Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.
66 0F E9 /r	PSUBSW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubsw		Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.
VEX.NDS.128.66.0F.WIG E8 /r	VPSUBSB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubsb		Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results.
VEX.NDS.128.66.0F.WIG E9 /r	VPSUBSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubsw		Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results.
VEX.NDS.256.66.0F.WIG E8 /r	VPSUBSB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubsb		Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results.
VEX.NDS.256.66.0F.WIG E9 /r	VPSUBSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubsw		Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results.
														
0F D8 /r	PSUBUSB mm, mm/m64	RM	RW, R						V	V	MMX	psubusb		Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.
66 0F D8 /r	PSUBUSB xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubusb		Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.
0F D9 /r	PSUBUSW mm, mm/m64	RM	RW, R						V	V	MMX	psubusw		Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.
66 0F D9 /r	PSUBUSW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	psubusw		Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.
VEX.NDS.128.66.0F.WIG D8 /r	VPSUBUSB xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubusb		Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result.
VEX.NDS.128.66.0F.WIG D9 /r	VPSUBUSW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpsubusw		Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result.
VEX.NDS.256.66.0F.WIG D8 /r	VPSUBUSB ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubusb		Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result.
VEX.NDS.256.66.0F.WIG D9 /r	VPSUBUSW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsubusw		Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result.
														
66 0F 38 17 /r	PTEST xmm1, xmm2/m128	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	SSE4_1	ptest		Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.
VEX.128.66.0F38.WIG 17 /r	VPTEST xmm1, xmm2/m128	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vptest		Set ZF and CF depending on bitwise AND and ANDN of sources.
VEX.256.66.0F38.WIG 17 /r	VPTEST ymm1, ymm2/m256	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vptest		Set ZF and CF depending on bitwise AND and ANDN of sources.
														
0F 68 /r	PUNPCKHBW mm, mm/m64	RM	RW, R						V	V	MMX	punpckhbw		Unpack and interleave high-order bytes from mm and mm/m64 into mm.
66 0F 68 /r	PUNPCKHBW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpckhbw		Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.
0F 69 /r	PUNPCKHWD mm, mm/m64	RM	RW, R						V	V	MMX	punpckhwd		Unpack and interleave high-order words from mm and mm/m64 into mm.
66 0F 69 /r	PUNPCKHWD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpckhwd		Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.
0F 6A /r	PUNPCKHDQ mm, mm/m64	RM	RW, R						V	V	MMX	punpckhdq		Unpack and interleave high-order doublewords from mm and mm/m64 into mm.
66 0F 6A /r	PUNPCKHDQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpckhdq		Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.
66 0F 6D /r	PUNPCKHQDQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpckhqdq		Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.
VEX.NDS.128.66.0F.WIG 68 /r	VPUNPCKHBW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpckhbw		Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1.
VEX.NDS.128.66.0F.WIG 69 /r	VPUNPCKHWD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpckhwd		Interleave high-order words from xmm2 and xmm3/m128 into xmm1.
VEX.NDS.128.66.0F.WIG 6A /r	VPUNPCKHDQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpckhdq		Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1.
VEX.NDS.128.66.0F.WIG 6D /r 	VPUNPCKHQDQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpckhqdq		Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register.
VEX.NDS.256.66.0F.WIG 68 /r	VPUNPCKHBW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpckhbw		Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register.
VEX.NDS.256.66.0F.WIG 69 /r	VPUNPCKHWD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpckhwd		Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register.
VEX.NDS.256.66.0F.WIG 6A /r	VPUNPCKHDQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpckhdq		Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register.
VEX.NDS.256.66.0F.WIG 6D /r	VPUNPCKHQDQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpckhqdq		Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register.
														
0F 60 /r	PUNPCKLBW mm, mm/m32	RM	RW, R						V	V	MMX	punpcklbw		Interleave low-order bytes from mm and mm/m32 into mm.
66 0F 60 /r	PUNPCKLBW xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpcklbw		Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.
0F 61 /r	PUNPCKLWD mm, mm/m32	RM	RW, R						V	V	MMX	punpcklwd		Interleave low-order words from mm and mm/m32 into mm.
66 0F 61 /r	PUNPCKLWD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpcklwd		Interleave low-order words from xmm1 and xmm2/m128 into xmm1.
0F 62 /r	PUNPCKLDQ mm, mm/m32	RM	RW, R						V	V	MMX	punpckldq		Interleave low-order doublewords from mm and mm/m32 into mm.
66 0F 62 /r	PUNPCKLDQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpckldq		Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.
66 0F 6C /r	PUNPCKLQDQ xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	punpcklqdq		Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.
VEX.NDS.128.66.0F.WIG 60 /r	VPUNPCKLBW xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpcklbw		Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1.
VEX.NDS.128.66.0F.WIG 61 /r	VPUNPCKLWD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpcklwd		Interleave low-order words from xmm2 and xmm3/m128 into xmm1.
VEX.NDS.128.66.0F.WIG 62 /r	VPUNPCKLDQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpckldq		Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1.
VEX.NDS.128.66.0F.WIG 6C /r	VPUNPCKLQDQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpunpcklqdq		Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register.
VEX.NDS.256.66.0F.WIG 60 /r	VPUNPCKLBW ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpcklbw		Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register.
VEX.NDS.256.66.0F.WIG 61 /r	VPUNPCKLWD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpcklwd		Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register.
VEX.NDS.256.66.0F.WIG 62 /r	VPUNPCKLDQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpckldq		Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register.
VEX.NDS.256.66.0F.WIG 6C /r	VPUNPCKLQDQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpunpcklqdq		Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register.
														
FF /6	PUSH r/m16 	M	R	RSP	RSP				V	V		pushw		Push r/m16.
FF /6	PUSH r/m32			RSP	RSP				NE	V				Push r/m32.
FF /6	PUSH r/m64	M	R	RSP	RSP				V	NE		pushq		Push r/m64.
50 +rw	PUSH r16	O	R	RSP	RSP				V	V		pushw	YES	Push r16.
50 +rd	PUSH r32			RSP	RSP				NE	V				Push r32.
50 +rd	PUSH r64	O	R	RSP	RSP				V	NE		pushq	YES	Push r64.
6A	PUSHQ imm8	I	R	RSP	RSP				V	V		pushq		Push imm8 (sign-extended to 64-bits).
66 6A	PUSHW imm8	I	R	RSP	RSP				V	V		pushw		Push imm8 (sign-extended to 16-bits).
68	PUSHQ imm16	I	R	RSP	RSP				V	V		pushq		Push imm16 (sign-extended to 64-bits).
66 68	PUSHW imm16	I	R	RSP	RSP				V	V		pushw		Push imm16 (sign-extended to 16-bits).
68	PUSHQ imm32	I	R	RSP	RSP				V	V		pushq		Push imm32 (sign-extended to 64-bits).
0E	PUSH CS			RSP	RSP				I	V				Push CS.
16	PUSH SS			RSP	RSP				I	V				Push SS.
1E	PUSH DS			RSP	RSP				I	V				Push DS.
06	PUSH ES			RSP	RSP				I	V				Push ES.
0F A0	PUSH FS	NP	R	RSP	RSP				V	V		pushq		Push FS.
0F A8	PUSH GS	NP	R	RSP	RSP				V	V		pushq		Push GS.
														
60	PUSHA			RSP	RSP				I	V				Push AX, CX, DX, BX, original SP, BP, SI, and DI.
60	PUSHAD			RSP	RSP				I	V				Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.
														
66 9C	PUSHF	NP		E.* RSP	RSP				V	V		pushfw		Push lower 16 bits of EFLAGS.
9C	PUSHFD								NE	V				Push EFLAGS.
9C	PUSHFQ	NP		E.* RSP	RSP				V	NE		pushfq		Push RFLAGS.
														
0F EF /r	PXOR mm, mm/m64	RM	RW, R						V	V	MMX	pxor		Bitwise XOR of mm/m64 and mm.
66 0F EF /r	PXOR xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	pxor		Bitwise XOR of xmm2/m128 and xmm1. 
VEX.NDS.128.66.0F.WIG EF /r	VPXOR xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpxor		Bitwise XOR of xmm3/m128 and xmm2.
VEX.NDS.256.66.0F.WIG EF /r	VPXOR ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpxor		Bitwise XOR of ymm3/m256 and ymm2.
														
D0 /2	RCL r/m8, 1	M1	RW, R	E.CF	E.CF E.OF				V	V		rclb		Rotate 9 bits (CF, r/m8) left once.
REX+ D0 /2	RCL r/m8, 1	M1	RW, R	E.CF	E.CF E.OF				V	NE		rclb		Rotate 9 bits (CF, r/m8) left once.
D2 /2	RCL r/m8, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	V		rclb		Rotate 9 bits (CF, r/m8) left CL times.
REX+ D2 /2	RCL r/m8, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	NE		rclb		Rotate 9 bits (CF, r/m8) left CL times.
C0 /2 ib	RCL r/m8, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	V		rclb		Rotate 9 bits (CF, r/m8) left imm8 times.
REX+ C0 /2 ib	RCL r/m8, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	NE		rclb		Rotate 9 bits (CF, r/m8) left imm8 times.
D1 /2	RCL r/m16, 1	M1	RW, R	E.CF	E.CF E.OF				V	V		rclw		Rotate 17 bits (CF, r/m16) left once.
D3 /2	RCL r/m16, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	V		rclw		Rotate 17 bits (CF, r/m16) left CL times.
C1 /2 ib	RCL r/m16, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	V		rclw		Rotate 17 bits (CF, r/m16) left imm8 times.
D1 /2	RCL r/m32, 1	M1	RW, R	E.CF	E.CF E.OF				V	V		rcll		Rotate 33 bits (CF, r/m32) left once.
REX.W+ D1 /2	RCL r/m64, 1	M1	RW, R	E.CF	E.CF E.OF				V	NE		rclq		Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.
D3 /2	RCL r/m32, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	V		rcll		Rotate 33 bits (CF, r/m32) left CL times.
REX.W+ D3 /2	RCL r/m64, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	NE		rclq		Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.
C1 /2 ib	RCL r/m32, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	V		rcll		Rotate 33 bits (CF, r/m32) left imm8 times.
REX.W+ C1 /2 ib	RCL r/m64, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	NE		rclq		Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.
D0 /3	RCR r/m8, 1	M1	RW, R	E.CF	E.CF E.OF				V	V		rcrb		Rotate 9 bits (CF, r/m8) right once.
REX+ D0 /3	RCR r/m8, 1	M1	RW, R	E.CF	E.CF E.OF				V	NE		rcrb		Rotate 9 bits (CF, r/m8) right once.
D2 /3	RCR r/m8, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	V		rcrb		Rotate 9 bits (CF, r/m8) right CL times.
REX+ D2 /3	RCR r/m8, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	NE		rcrb		Rotate 9 bits (CF, r/m8) right CL times.
C0 /3 ib	RCR r/m8, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	V		rcrb		Rotate 9 bits (CF, r/m8) right imm8 times.
REX+ C0 /3 ib	RCR r/m8, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	NE		rcrb		Rotate 9 bits (CF, r/m8) right imm8 times.
D1 /3	RCR r/m16, 1	M1	RW, R	E.CF	E.CF E.OF				V	V		rcrw		Rotate 17 bits (CF, r/m16) right once.
D3 /3	RCR r/m16, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	V		rcrw		Rotate 17 bits (CF, r/m16) right CL times.
C1 /3 ib	RCR r/m16, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	V		rcrw		Rotate 17 bits (CF, r/m16) right imm8 times.
D1 /3	RCR r/m32, 1	M1	RW, R	E.CF	E.CF E.OF				V	V		rcrl		Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.
REX.W+ D1 /3	RCR r/m64, 1	M1	RW, R	E.CF	E.CF E.OF				V	NE		rcrq		Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.
D3 /3	RCR r/m32, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	V		rcrl		Rotate 33 bits (CF, r/m32) right CL times.
REX.W+ D3 /3	RCR r/m64, CL	MC	RW, R	E.CF	e.cf e.of	e.of			V	NE		rcrq		Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.
C1 /3 ib	RCR r/m32, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	V		rcrl		Rotate 33 bits (CF, r/m32) right imm8 times.
REX.W+ C1 /3 ib	RCR r/m64, imm8	MI	RW, R	E.CF	e.cf e.of	e.of			V	NE		rcrq		Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.
D0 /0	ROL r/m8, 1	M1	RW, R		E.CF E.OF				V	V		rolb		Rotate 8 bits r/m8 left once.
REX+ D0 /0	ROL r/m8, 1	M1	RW, R		E.CF E.OF				V	NE		rolb		Rotate 8 bits r/m8 left once.
D2 /0	ROL r/m8, CL	MC	RW, R		e.cf e.of	e.of			V	V		rolb		Rotate 8 bits r/m8 left CL times.
REX+ D2 /0	ROL r/m8, CL	MC	RW, R		e.cf e.of	e.of			V	NE		rolb		Rotate 8 bits r/m8 left CL times.
C0 /0 ib	ROL r/m8, imm8	MI	RW, R		e.cf e.of	e.of			V	V		rolb		Rotate 8 bits r/m8 left imm8 times.
REX+ C0 /0 ib	ROL r/m8, imm8	MI	RW, R		e.cf e.of	e.of			V	NE		rolb		Rotate 8 bits r/m8 left imm8 times.
D1 /0	ROL r/m16, 1	M1	RW, R		E.CF E.OF				V	V		rolw		Rotate 16 bits r/m16 left once.
D3 /0	ROL r/m16, CL	MC	RW, R		e.cf e.of	e.of			V	V		rolw		Rotate 16 bits r/m16 left CL times.
C1 /0 ib	ROL r/m16, imm8	MI	RW, R		e.cf e.of	e.of			V	V		rolw		Rotate 16 bits r/m16 left imm8 times.
D1 /0	ROL r/m32, 1	M1	RW, R		E.CF E.OF				V	V		roll		Rotate 32 bits r/m32 left once.
REX.W+ D1 /0	ROL r/m64, 1	M1	RW, R		E.CF E.OF				V	NE		rolq		Rotate 64 bits r/m64 left once. Uses a 6 bit count.
D3 /0	ROL r/m32, CL	MC	RW, R		e.cf e.of	e.of			V	V		roll		Rotate 32 bits r/m32 left CL times.
REX.W+ D3 /0	ROL r/m64, CL	MC	RW, R		e.cf e.of	e.of			V	NE		rolq		Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.
C1 /0 ib	ROL r/m32, imm8	MI	RW, R		e.cf e.of	e.of			V	V		roll		Rotate 32 bits r/m32 left imm8 times.
REX.W+ C1 /0 ib	ROL r/m64, imm8	MI	RW, R		e.cf e.of	e.of			V	NE		rolq		Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.
D0 /1	ROR r/m8, 1	M1	RW, R		E.CF E.OF				V	V		rorb		Rotate 8 bits r/m8 right once.
REX+ D0 /1	ROR r/m8, 1	M1	RW, R		E.CF E.OF				V	NE		rorb		Rotate 8 bits r/m8 right once.
D2 /1	ROR r/m8, CL	MC	RW, R		e.cf e.of	e.of			V	V		rorb		Rotate 8 bits r/m8 right CL times.
REX+ D2 /1	ROR r/m8, CL	MC	RW, R		e.cf e.of	e.of			V	NE		rorb		Rotate 8 bits r/m8 right CL times.
C0 /1 ib	ROR r/m8, imm8	MI	RW, R		e.cf e.of	e.of			V	V		rorb		Rotate 8 bits r/m16 right imm8 times.
REX+ C0 /1 ib	ROR r/m8, imm8	MI	RW, R		e.cf e.of	e.of			V	NE		rorb		Rotate 8 bits r/m16 right imm8 times.
D1 /1	ROR r/m16, 1	M1	RW, R		E.CF E.OF				V	V		rorw		Rotate 16 bits r/m16 right once.
D3 /1	ROR r/m16, CL	MC	RW, R		e.cf e.of	e.of			V	V		rorw		Rotate 16 bits r/m16 right CL times.
C1 /1 ib	ROR r/m16, imm8	MI	RW, R		e.cf e.of	e.of			V	V		rorw		Rotate 16 bits r/m16 right imm8 times.
D1 /1	ROR r/m32, 1	M1	RW, R		E.CF E.OF				V	V		rorl		Rotate 32 bits r/m32 right once.
REX.W+ D1 /1	ROR r/m64, 1	M1	RW, R		E.CF E.OF				V	NE		rorq		Rotate 64 bits r/m64 right once. Uses a 6 bit count.
D3 /1	ROR r/m32, CL	MC	RW, R		e.cf e.of	e.of			V	V		rorl		Rotate 32 bits r/m32 right CL times.
REX.W+ D3 /1	ROR r/m64, CL	MC	RW, R		e.cf e.of	e.of			V	NE		rorq		Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.
C1 /1 ib	ROR r/m32, imm8	MI	RW, R		e.cf e.of	e.of			V	V		rorl		Rotate 32 bits r/m32 right imm8 times.
REX.W+ C1 /1 ib	ROR r/m64, imm8	MI	RW, R		e.cf e.of	e.of			V	NE		rorq		Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.
														
0F 53 /r	RCPPS xmm1, xmm2/m128	RM	W, R						V	V	SSE	rcpps		Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
VEX.128.0F.WIG 53 /r	VRCPPS xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vrcpps		Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1.
VEX.256.0F.WIG 53 /r	VRCPPS ymm1, ymm2/m256	RM	W, R						V	V	AVX	vrcpps		Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1.
														
F3 0F 53 /r	RCPSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	rcpss		Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.
VEX.NDS.LIG.F3.0F.WIG 53 /r	VRCPSS xmm1, xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vrcpss		Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
														
F3 0F AE /0	RDFSBASE r32	M	W						V	I	FSGSBASE	rdfsbase		Load the 32-bit destination register with the FS base address.
REX.W+ F3 0F AE /0	RDFSBASE r64	M	W						V	I	FSGSBASE	rdfsbase		Load the 64-bit destination register with the FS base address.
F3 0F AE /1	RDGSBASE r32	M	W						V	I	FSGSBASE	rdgsbase		Load the 32-bit destination register with the GS base address.
REX.W+ F3 0F AE /1	RDGSBASE r64	M	W						V	I	FSGSBASE	rdgsbase		Load the 64-bit destination register with the GS base address.
														
0F 32	RDMSR						NO	YES	V	V	MSR			Read MSR specified by ECX into EDX:EAX.
														
0F 33	RDPMC						YES	YES*	V	V	MSR			Read performance-monitoring counter specified by ECX into EDX:EAX.
														
0F C7 /6	RDRAND r16	M	W		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V	RDRAND	rdrand		Read a 16-bit random number and store in the destination register.
0F C7 /6	RDRAND r32	M	W		E.CF E.OF E.SF E.ZF E.AF E.PF				V	V	RDRAND	rdrand		Read a 32-bit random number and store in the destination register.
REX.W+ 0F C7 /6	RDRAND r64	M	W		E.CF E.OF E.SF E.ZF E.AF E.PF				V	I	RDRAND	rdrand		Read a 64-bit random number and store in the destination register.
														
0F 31	RDTSC						YES	YES*	V	V	TSC			Read time-stamp counter into EDX:EAX.
														
0F 01 F9	RDTSCP						YES	YES*	V	V	RDTSCP			Read 64-bit time-stamp counter and 32-bit IA32_TSC_AUX value into EDX:EAX and ECX.
														
F3 6C	REP_INS m8, DX 	NP	I, R	ECX E.IOPL E.VM E.DF RDI					V	V	REP_GOOD	rep insb	YES	Input (E)CX bytes from port DX into ES:[(E)DI].
F3 REX.W+ 6C	REP_INS m8, DX	NP	I, R	RCX E.IOPL E.VM E.DF RDI					V	NE	REP_GOOD	rep insb		Input RCX bytes from port DX into [RDI].
F3 6D	REP_INS m16, DX	NP	I, R	ECX E.IOPL E.VM E.DF RDI					V	V	REP_GOOD	rep insw	YES	Input (E)CX words from port DX into ES:[(E)DI.]
F3 6D	REP_INS m32, DX	NP	I, R	ECX E.IOPL E.VM E.DF RDI					V	V	REP_GOOD	rep insl	YES	Input (E)CX doublewords from port DX into ES:[(E)DI].
F3 REX.W+ 6D	REP_INS m64, DX	NP	I, R	RCX E.IOPL E.VM E.DF RDI					V	NE	REP_GOOD	rep insq		Input RCX default size from port DX into [RDI].
F3 A4	REP_MOVS m8, m8	NP	I, I	ECX E.DF ESI rsi EDI rdi					V	V	REP_GOOD	rep movsb	YES	Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI].
F3 REX.W+ A4	REP_MOVS m8, m8	NP	I, I	RCX E.DF ESI rsi EDI rdi					V	NE	REP_GOOD	rep movsb		Move RCX bytes from [RSI] to [RDI].
F3 A5	REP_MOVS m16, m16	NP	I, I	ECX E.DF ESI rsi EDI rdi					V	V	REP_GOOD	rep movsw	YES	Move (E)CX words from DS:[(E)SI] to ES:[(E)DI].
F3 A5	REP_MOVS m32, m32	NP	I, I	ECX E.DF ESI rsi EDI rdi					V	V	REP_GOOD	rep movsl	YES	Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI].
F3 REX.W+ A5	REP_MOVS m64, m64	NP	I, I	RCX E.DF ESI rsi EDI rdi					V	NE	REP_GOOD	rep movsq		Move RCX quadwords from [RSI] to [RDI].
F3 6E	REP_OUTS DX, m8	NP	R, I	ECX E.IOPL E.VM E.DF RSI					V	V	REP_GOOD	rep outsb	YES	Output (E)CX bytes from DS:[(E)SI] to port DX.
F3 REX.W+ 6E	REP_OUTS DX, m8	NP	R, I	RCX E.IOPL E.VM E.DF RSI					V	NE	REP_GOOD	rep outsb		Output RCX bytes from [RSI] to port DX.
F3 6F	REP_OUTS DX, m16	NP	R, I	ECX E.IOPL E.VM E.DF RSI					V	V	REP_GOOD	rep outsw	YES	Output (E)CX words from DS:[(E)SI] to port DX.
F3 6F	REP_OUTS DX, m32	NP	R, I	ECX E.IOPL E.VM E.DF RSI					V	V	REP_GOOD	rep outsl	YES	Output (E)CX doublewords from DS:[(E)SI] to port DX.
F3 REX.W+ 6F	REP_OUTS DX, m64	NP	R, I	RCX E.IOPL E.VM E.DF RSI					V	NE	REP_GOOD	rep outsq		Output RCX default size from [RSI] to port DX.
F3 AC	REP_LODS AL	NP	W	ECX E.DF SI rsi					V	V	REP_GOOD	rep lodsb	YES	Load (E)CX bytes from DS:[(E)SI] to AL.
F3 REX.W+ AC	REP_LODS AL	NP	W	RCX E.DF SI rsi					V	NE	REP_GOOD	rep lodsb		Load RCX bytes from [RSI] to AL.
F3 AD	REP_LODS AX	NP	W	ECX E.DF SI rsi					V	V	REP_GOOD	rep lodsw	YES	Load (E)CX words from DS:[(E)SI] to AX.
F3 AD	REP_LODS EAX	NP	W	ECX E.DF SI rsi					V	V	REP_GOOD	rep lodsl	YES	Load (E)CX doublewords from DS:[(E)SI] to EAX.
F3 REX.W+ AD	REP_LODS RAX	NP	W	RCX E.DF SI rsi					V	NE	REP_GOOD	rep lodsq		Load RCX quadwords from [RSI] to RAX.
F3 AA	REP_STOS m8	NP	I	ECX E.DF RDI AL					V	V	REP_GOOD	rep stosb	YES	Fill (E)CX bytes at ES:[(E)DI] with AL.
F3 REX.W+ AA	REP_STOS m8	NP	I	RCX E.DF RDI AL					V	NE	REP_GOOD	rep stosb		Fill RCX bytes at [RDI] with AL.
F3 AB	REP_STOS m16	NP	I	ECX E.DF RDI AL					V	V	REP_GOOD	rep stosw	YES	Fill (E)CX words at ES:[(E)DI] with AX.
F3 AB	REP_STOS m32	NP	I	ECX E.DF RDI AL					V	V	REP_GOOD	rep stosl	YES	Fill (E)CX doublewords at ES:[(E)DI] with EAX.
F3 REX.W+ AB	REP_STOS m64	NP	I	RCX E.DF RDI AL					V	NE	REP_GOOD	rep stosq		Fill RCX quadwords at [RDI] with RAX.
F3 A6	REPE_CMPS m8, m8	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	V	REP_GOOD	repz cmpsb	YES	Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI].
F3 REX.W+ A6	REPE_CMPS m8, m8	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	NE	REP_GOOD	repz cmpsb		Find non-matching bytes in [RDI] and [RSI].
F3 A7	REPE_CMPS m16, m16	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	V	REP_GOOD	repz cmpsw	YES	Find nonmatching words in ES:[(E)DI] and DS:[(E)SI].
F3 A7	REPE_CMPS m32, m32	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	V	REP_GOOD	repz cmpsl	YES	Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI].
F3 REX.W+ A7	REPE_CMPS m64, m64	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	NE	REP_GOOD	repz cmpsq		Find non-matching quadwords in [RDI] and [RSI].
F3 AE	REPE_SCAS m8	NP	I	E.ZF E.DF RDI AL					V	V	REP_GOOD	repz scasb	YES	Find non-AL byte starting at ES:[(E)DI].
F3 REX.W+ AE	REPE_SCAS m8	NP	I	E.ZF E.DF RDI AL					V	NE	REP_GOOD	repz scasb		Find non-AL byte starting at [RDI].
F3 AF	REPE_SCAS m16	NP	I	E.ZF E.DF RDI AX					V	V	REP_GOOD	repz scasw	YES	Find non-AX word starting at ES:[(E)DI].
F3 AF	REPE_SCAS m32	NP	I	E.ZF E.DF RDI EAX					V	V	REP_GOOD	repz scasl	YES	Find non-EAX doubleword starting at ES:[(E)DI].
F3 REX.W+ AF	REPE_SCAS m64	NP	I	E.ZF E.DF RDI RAX					V	NE	REP_GOOD	repz scasq		Find non-RAX quadword starting at [RDI].
F2 A6	REPNE_CMPS m8, m8	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	V	REP_GOOD	repnz cmpsb	YES	Find matching bytes in ES:[(E)DI] and DS:[(E)SI].
F2 REX.W+ A6	REPNE_CMPS m8, m8	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	NE	REP_GOOD	repnz cmpsb		Find matching bytes in [RDI] and [RSI].
F2 A7	REPNE_CMPS m16, m16	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	V	REP_GOOD	repnz cmpsw	YES	Find matching words in ES:[(E)DI] and DS:[(E)SI].
F2 A7	REPNE_CMPS m32, m32	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	V	REP_GOOD	repnz cmpsl	YES	Find matching doublewords in ES:[(E)DI] and DS:[(E)SI].
F2 REX.W+ A7	REPNE_CMPS m64, m64	NP	I, I	E.ZF E.DF ESI rsi EDI rdi					V	NE	REP_GOOD	repnz cmpsq		Find matching doublewords in [RDI] and [RSI].
F2 AE	REPNE_SCAS m8	NP	I	E.ZF E.DF RDI AL					V	V	REP_GOOD	repnz scasb	YES	Find AL, starting at ES:[(E)DI].
F2 REX.W+ AE	REPNE_SCAS m8	NP	I	E.ZF E.DF RDI AL					V	NE	REP_GOOD	repnz scasb		Find AL, starting at [RDI].
F2 AF	REPNE_SCAS m16	NP	I	E.ZF E.DF RDI AX					V	V	REP_GOOD	repnz scasw	YES	Find AX, starting at ES:[(E)DI].
F2 AF	REPNE_SCAS m32	NP	I	E.ZF E.DF RDI EAX					V	V	REP_GOOD	repnz scasl	YES	Find EAX, starting at ES:[(E)DI].
F2 REX.W+ AF	REPNE_SCAS m64	NP	I	E.ZF E.DF RDI RAX					V	NE	REP_GOOD	repnz scasq		Find RAX, starting at [RDI].
														
C3	RET	NP			RIP				V	V		retq		Near return to calling procedure.
CB	RET far	NP	I	???	???	???			V	V		lretl		Far return to calling procedure.
C2 iw	RET imm16	I	R		RIP RSP				V	V		retq		Near return to calling procedure and pop imm16 bytes from stack.
CA iw	RET imm16, far	I	R, I	???	???	???			V	V		retq		Far return to calling procedure and pop imm16 bytes from stack.
														
VEX.LZ.F2.0F3A.W0 F0 /r ib	RORX r32, r/m32, imm8	RMI	W, R, R						V	V	BMI2	rorxl		Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags.
VEX.LZ.F2.0F3A.W1 F0 /r ib	RORX r64, r/m64, imm8	RMI	W, R, R						V	NE	BMI2	rorxq		Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags.
														
66 0F 3A 09 /r ib	ROUNDPD xmm1, xmm2/m128, imm8	RMI	W, R, R	M.RC					V	V	SSE4_1	roundpd		Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
VEX.128.66.0F3A.WIG 09 /r ib	VROUNDPD xmm1, xmm2/m128, imm8	RMI	Z, R, R	M.RC					V	V	AVX	vroundpd		Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
VEX.256.66.0F3A.WIG 09 /r ib	VROUNDPD ymm1, ymm2/m256, imm8	RMI	W, R, R	M.RC					V	V	AVX	vroundpd		Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.
														
66 0F 3A 08 /r ib	ROUNDPS xmm1, xmm2/m128, imm8	RMI	W, R, R	M.RC					V	V	SSE4_1	roundps		Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
VEX.128.66.0F3A.WIG 08 /r ib	VROUNDPS xmm1, xmm2/m128, imm8	RMI	Z, R, R	M.RC					V	V	AVX	vroundps		Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
VEX.256.66.0F3A.WIG 08 /r ib	VROUNDPS ymm1, ymm2/m256, imm8	RMI	W, R, R	M.RC					V	V	AVX	vroundps		Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.
														
66 0F 3A 0B /r ib	ROUNDSD xmm1, xmm2/m64, imm8	RMI	RW, R, R	M.RC					V	V	SSE4_1	roundsd		Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.
VEX.NDS.LIG.66.0F3A.WIG 0B /r ib	VROUNDSD xmm1, xmm2, xmm3/m64, imm8	RVMI	Z, R, R, R	M.RC					V	V	AVX	vroundsd		Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by imm8. Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].
														
66 0F 3A 0A /r ib	ROUNDSS xmm1, xmm2/m32, imm8	RMI	RW, R, R	M.RC					V	V	SSE4_1	roundss		Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.
VEX.NDS.LIG.66.0F3A.WIG 0A ib	VROUNDSS xmm1, xmm2, xmm3/m32, imm8	RVMI	Z, R, R, R	M.RC					V	V	AVX	vroundss		Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by imm8. Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
														
0F AA	RSM						NO	YES	I	V				Resume operation of interrupted program.
														
0F 52 /r	RSQRTPS xmm1, xmm2/m128	RM	W, R						V	V	SSE	rsqrtps		Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
VEX.128.0F.WIG 52 /r	VRSQRTPS xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vrsqrtps		Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1.
VEX.256.0F.WIG 52 /r	VRSQRTPS ymm1, ymm2/m256	RM	W, R						V	V	AVX	vrsqrtps		Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1.
														
F3 0F 52 /r	RSQRTSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	rsqrtss		Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.
VEX.NDS.LIG.F3.0F.WIG 52 /r	VRSQRTSS xmm1, xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vrsqrtss		Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
														
9E	SAHF	NP		AH	E.SF E.ZF E.AF E.PF E.CF				V	V	LAHF_LM	sahf		Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register.
														
D0 /4	SAL r/m8, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		salb		Multiply r/m8 by 2, once.
REX+ D0 /4	SAL r/m8, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		salb		Multiply r/m8 by 2, once.
D2 /4	SAL r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	V		salb		Multiply r/m8 by 2, CL times.
REX+ D2 /4	SAL r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	NE		salb		Multiply r/m8 by 2, CL times.
C0 /4 ib	SAL r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	V		salb		Multiply r/m8 by 2, imm8 times.
REX+ C0 /4 ib	SAL r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	NE		salb		Multiply r/m8 by 2, imm8 times.
D1 /4	SAL r/m16, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		salw		Multiply r/m16 by 2, once.
D3 /4	SAL r/m16, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	V		salw		Multiply r/m16 by 2, CL times.
C1 /4 ib	SAL r/m16, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	V		salw		Multiply r/m16 by 2, imm8 times.
D1 /4	SAL r/m32, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		sall		Multiply r/m32 by 2, once.
REX.W+ D1 /4	SAL r/m64, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		salq		Multiply r/m64 by 2, once.
D3 /4	SAL r/m32, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	V		sall		Multiply r/m32 by 2, CL times.
REX.W+ D3 /4	SAL r/m64, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	NE		salq		Multiply r/m64 by 2, CL times.
C1 /4 ib	SAL r/m32, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	V		sall		Multiply r/m32 by 2, imm8 times.
REX.W+ C1 /4 ib	SAL r/m64, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af e.cf			V	NE		salq		Multiply r/m64 by 2, imm8 times.
D0 /7	SAR r/m8, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		sarb		Signed divide r/m8 by 2, once.
REX+ D0 /7	SAR r/m8, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		sarb		Signed divide r/m8 by 2, once.
D2 /7	SAR r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	V		sarb		Signed divide r/m8 by 2, CL times.
REX+ D2 /7	SAR r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	NE		sarb		Signed divide r/m8 by 2, CL times.
C0 /7 ib	SAR r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	V		sarb		Signed divide r/m8 by 2, imm8 time.
REX+ C0 /7 ib	SAR r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	NE		sarb		Signed divide r/m8 by 2, imm8 time.
D1 /7	SAR r/m16,1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		sarw		Signed divide r/m16 by 2, once.
D3 /7	SAR r/m16, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	V		sarw		Signed divide r/m16 by 2, CL times.
C1 /7 ib	SAR r/m16, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	V		sarw		Signed divide r/m16 by 2, imm8 times.
D1 /7	SAR r/m32, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		sarl		Signed divide r/m32 by 2, once.
REX.W+ D1 /7	SAR r/m64, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		sarq		Signed divide r/m32 by 2, once.
D3 /7	SAR r/m32, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	V		sarl		Signed divide r/m32 by 2, CL times.
REX.W+ D3 /7	SAR r/m64, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	NE		sarq		Signed divide r/m32 by 2, CL times.
C1 /7 ib	SAR r/m32, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	V		sarl		Signed divide r/m32 by 2, imm8 times.
REX.W+ C1 /7 ib	SAR r/m64, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.of e.af			V	NE		sarq		Signed divide r/m32 by 2, imm8 times.
D0 /4	SHL r/m8, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		shlb		Multiply r/m8 by 2, once.
REX+ D0 /4	SHL r/m8, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		shlb		Multiply r/m8 by 2, once.
D2 /4	SHL r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shlb		Multiply r/m8 by 2, CL times.
REX+ D2 /4	SHL r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shlb		Multiply r/m8 by 2, CL times.
C0 /4 ib	SHL r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shlb		Multiply r/m8 by 2, imm8 times.
REX+ C0 /4 ib	SHL r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shlb		Multiply r/m8 by 2, imm8 times.
D1 /4	SHL r/m16,1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		shlw		Multiply r/m16 by 2, once.
D3 /4	SHL r/m16, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shlw		Multiply r/m16 by 2, CL times.
C1 /4 ib	SHL r/m16, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shlw		Multiply r/m16 by 2, imm8 times.
D1 /4	SHL r/m32,1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		shll		Multiply r/m32 by 2, once.
REX.W+ D1 /4	SHL r/m64,1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		shlq		Multiply r/m64 by 2, once.
D3 /4	SHL r/m32, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shll		Multiply r/m32 by 2, CL times.
REX.W+ D3 /4	SHL r/m64, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shlq		Multiply r/m32 by 2, CL times.
C1 /4 ib	SHL r/m32, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shll		Multiply r/m32 by 2, imm8 times.
REX.W+ C1 /4 ib	SHL r/m64, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shlq		Multiply r/m32 by 2, imm8 times.
D0 /5	SHR r/m8,1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		shrb		Unsigned divide r/m8 by 2, once.
REX+ D0 /5	SHR r/m8, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		shrb		Unsigned divide r/m8 by 2, once.
D2 /5	SHR r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shrb		Unsigned divide r/m8 by 2, CL times.
REX+ D2 /5	SHR r/m8, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shrb		Unsigned divide r/m8 by 2, CL times.
C0 /5 ib	SHR r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shrb		Unsigned divide r/m8 by 2, imm8 times.
REX+ C0 /5 ib	SHR r/m8, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shrb		Unsigned divide r/m8 by 2, imm8 times.
D1 /5	SHR r/m16, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		shrw		Unsigned divide r/m16 by 2, once.
D3 /5	SHR r/m16, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shrw		Unsigned divide r/m16 by 2, CL times
C1 /5 ib	SHR r/m16, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shrw		Unsigned divide r/m16 by 2, imm8 times.
D1 /5	SHR r/m32, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	V		shrl		Unsigned divide r/m32 by 2, once.
REX.W+ D1 /5	SHR r/m64, 1	M1	RW, R		E.CF E.OF E.PF E.SF E.ZF	E.AF			V	NE		shrq		Unsigned divide r/m32 by 2, once.
D3 /5	SHR r/m32, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shrl		Unsigned divide r/m32 by 2, CL times.
REX.W+ D3 /5	SHR r/m64, CL	MC	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shrq		Unsigned divide r/m32 by 2, CL times.
C1 /5 ib	SHR r/m32, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	V		shrl		Unsigned divide r/m32 by 2, imm8 times.
REX.W+ C1 /5 ib	SHR r/m64, imm8	MI	RW, R		e.cf e.of e.pf e.sf e.zf	e.cf e.of e.af			V	NE		shrq		Unsigned divide r/m32 by 2, imm8 times.
														
VEX.NDS.LZ.F3.0F38.W0 F7 /r	SARX r32a, r/m32, r32b	RMV	W, R, R						V	V	BMI2	sarxl		Shift r/m32 arithmetically right with count specified in r32b
VEX.NDS.LZ.66.0F38.W0 F7 /r	SHLX r32a, r/m32, r32b	RMV	W, R, R						V	V	BMI2	shlxl		Shift r/m32 logically left with count specified in r32b
VEX.NDS.LZ.F2.0F38.W0 F7 /r	SHRX r32a, r/m32, r32b	RMV	W, R, R						V	V	BMI2	shrxl		Shift r/m32 logically right with count specified in r32b
VEX.NDS.LZ.F3.0F38.W1 F7 /r	SARX r64a, r/m64, r64b	RMV	W, R, R						V	NE	BMI2	sarxq		Shift r/m64 arithmetically right with count specified in r64b
VEX.NDS.LZ.66.0F38.W1 F7 /r	SHLX r64a, r/m64, r64b	RMV	W, R, R						V	NE	BMI2	shlxq		Shift r/m64 logically left with count specified in r64b.
VEX.NDS.LZ.F2.0F38.W1 F7 /r	SHRX r64a, r/m64, r64b	RMV	W, R, R						V	NE	BMI2	shrxq		Shift r/m64 logically right with count specified in r64b
														
1C ib	SBB AL, imm8	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbb		Subtract with borrow imm8 from AL.
1D iw	SBB AX, imm16	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbw		Subtract with borrow imm16 from AX.
1D id	SBB EAX, imm32	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbl		Subtract with borrow imm32 from EAX.
REX.W+ 1D id	SBB RAX, imm32	I	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbq		Subtract with borrow sign-extended imm.32 to 64-bits from RAX.
80 /3 ib	SBB r/m8, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbb		Subtract with borrow imm8 from r/m8.
REX+ 80 /3 ib	SBB r/m8, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbb		Subtract with borrow imm8 from r/m8.
81 /3 iw	SBB r/m16, imm16	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbw		Subtract with borrow imm16 from r/m16.
81 /3 id	SBB r/m32, imm32	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbl		Subtract with borrow imm32 from r/m32.
REX.W+ 81 /3 id	SBB r/m64, imm32	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbq		Subtract with borrow sign-extended imm32 to 64-bits from r/m64.
83 /3 ib	SBB r/m16, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbw	YES	Subtract with borrow sign-extended imm8 from r/m16.
83 /3 ib	SBB r/m32, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbl	YES	Subtract with borrow sign-extended imm8 from r/m32.
REX.W+ 83 /3 ib	SBB r/m64, imm8	MI	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbq	YES	Subtract with borrow sign-extended imm8 from r/m64.
18 /r	SBB r/m8, r8	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbb	YES	Subtract with borrow r8 from r/m8.
REX+ 18 /r	SBB r/m8, r8	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbb	YES	Subtract with borrow r8 from r/m8.
19 /r	SBB r/m16, r16	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbw	YES	Subtract with borrow r16 from r/m16.
19 /r	SBB r/m32, r32	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbl	YES	Subtract with borrow r32 from r/m32.
REX.W+ 19 /r	SBB r/m64, r64	MR	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbq	YES	Subtract with borrow r64 from r/m64.
1A /r	SBB r8, r/m8	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbb		Subtract with borrow r/m8 from r8.
REX+ 1A /r	SBB r8, r/m8	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbb		Subtract with borrow r/m8 from r8.
1B /r	SBB r16, r/m16	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbw		Subtract with borrow r/m16 from r16.
1B /r	SBB r32, r/m32	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	V		sbbl		Subtract with borrow r/m32 from r32.
REX.W+ 1B /r	SBB r64, r/m64	RM	RW, R	E.CF	E.OF E.SF E.ZF E.AF E.PF E.CF				V	NE		sbbq		Subtract with borrow r/m64 from r64.
														
AE	SCAS m8	NP	I	E.DF RDI AL					V	V		scas		Compare AL with byte at ES:(E)DI or RDI, then set status flags.
AF	SCAS m16	NP	I	E.DF RDI AX					V	V		scas		Compare AX with word at ES:(E)DI or RDI, then set status flags.
AF	SCAS m32	NP	I	E.DF RDI EAX					V	V		scas		Compare EAX with doubleword at ES(E)DI or RDI then set status flags.
REX.W+ AF	SCAS m64	NP	I	E.DF RDI RAX					V	NE		scas		Compare RAX with quadword at RDI or EDI then set status flags.
AE	SCASB	NP		E.DF RDI AL					V	V		scasb		Compare AL with byte at ES:(E)DI or RDI then set status flags.
PREF.66+ AF	SCASW	NP		E.DF RDI AX					V	V		scasw		Compare AX with word at ES:(E)DI or RDI then set status flags.
AF	SCASD	NP		E.DF RDI EAX					V	V		scasl		Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.
REX.W+ AF	SCASQ	NP		E.DF RDI RAX					V	NE		scasq		Compare RAX with quadword at RDI or EDI then set status flags.
														
0F 97 /0	SETA r/m8	M	W	E.CF E.ZF					V	V		seta		Set byte if above (CF=0 and ZF=0).
REX+ 0F 97 /0 	SETA r/m8	M	W	E.CF E.ZF					V	NE		seta		Set byte if above (CF=0 and ZF=0).
0F 93 /0	SETAE r/m8	M	W	E.CF					V	V		setae		Set byte if above or equal (CF=0).
REX+ 0F 93 /0	SETAE r/m8	M	W	E.CF					V	NE		setae		Set byte if above or equal (CF=0).
0F 92 /0	SETB r/m8	M	W	E.CF					V	V		setb		Set byte if below (CF=1).
REX+ 0F 92 /0	SETB r/m8	M	W	E.CF					V	NE		setb		Set byte if below (CF=1).
0F 96 /0	SETBE r/m8	M	W	E.CF E.ZF					V	V		setbe		Set byte if below or equal (CF=1 or ZF=1).
REX+ 0F 96 /0	SETBE r/m8	M	W	E.CF E.ZF					V	NE		setbe		Set byte if below or equal (CF=1 or ZF=1).
0F 92 /0	SETC r/m8	M	W	E.CF					V	V		setc		Set byte if carry (CF=1).
REX+ 0F 92 /0	SETC r/m8	M	W	E.CF					V	NE		setc		Set byte if carry (CF=1).
0F 94 /0	SETE r/m8	M	W	E.ZF					V	V		sete		Set byte if equal (ZF=1).
REX+ 0F 94 /0	SETE r/m8	M	W	E.ZF					V	NE		sete		Set byte if equal (ZF=1).
0F 9F /0	SETG r/m8	M	W	E.ZF E.SF E.OF					V	V		setg		Set byte if greater (ZF=0 and SF=OF).
REX+ 0F 9F /0	SETG r/m8	M	W	E.ZF E.SF E.OF					V	NE		setg		Set byte if greater (ZF=0 and SF=OF).
0F 9D /0	SETGE r/m8	M	W	E.SF E.OF					V	V		setge		Set byte if greater or equal (SF=OF).
REX+ 0F 9D /0	SETGE r/m8	M	W	E.SF E.OF					V	NE		setge		Set byte if greater or equal (SF=OF).
0F 9C /0	SETL r/m8	M	W	E.SF E.OF					V	V		setl		Set byte if less (SF!!= OF).
REX+ 0F 9C /0	SETL r/m8	M	W	E.SF E.OF					V	NE		setl		Set byte if less (SF!!= OF).
0F 9E /0	SETLE r/m8	M	W	E.ZF E.SF E.OF					V	V		setle		Set byte if less or equal (ZF=1 or SF!!= OF).
REX+ 0F 9E /0	SETLE r/m8	M	W	E.ZF E.SF E.OF					V	NE		setle		Set byte if less or equal (ZF=1 or SF!!= OF).
0F 96 /0	SETNA r/m8	M	W	E.CF E.ZF					V	V		setna		Set byte if not above (CF=1 or ZF=1).
REX+ 0F 96 /0	SETNA r/m8	M	W	E.CF E.ZF					V	NE		setna		Set byte if not above (CF=1 or ZF=1).
0F 92 /0	SETNAE r/m8	M	W	E.CF					V	V		setnae		Set byte if not above or equal (CF=1).
REX+ 0F 92 /0	SETNAE r/m8	M	W	E.CF					V	NE		setnae		Set byte if not above or equal (CF=1).
0F 93 /0	SETNB r/m8	M	W	E.CF					V	V		setnb		Set byte if not below (CF=0).
REX+ 0F 93 /0	SETNB r/m8	M	W	E.CF					V	NE		setnb		Set byte if not below (CF=0).
0F 97 /0	SETNBE r/m8	M	W	E.CF E.ZF					V	V		setnbe		Set byte if not below or equal (CF=0 and ZF=0).
REX+ 0F 97 /0	SETNBE r/m8	M	W	E.CF E.ZF					V	NE		setnbe		Set byte if not below or equal (CF=0 and ZF=0).
0F 93 /0	SETNC r/m8	M	W	E.CF					V	V		setnc		Set byte if not carry (CF=0).
REX+ 0F 93 /0	SETNC r/m8	M	W	E.CF					V	NE		setnc		Set byte if not carry (CF=0).
0F 95 /0	SETNE r/m8	M	W	E.ZF					V	V		setne		Set byte if not equal (ZF=0).
REX+ 0F 95 /0	SETNE r/m8	M	W	E.ZF					V	NE		setne		Set byte if not equal (ZF=0).
0F 9E /0	SETNG r/m8	M	W	E.ZF E.SF E.OF					V	V		setng		Set byte if not greater (ZF=1 or SF!!= OF)
REX+ 0F 9E /0	SETNG r/m8	M	W	E.ZF E.SF E.OF					V	NE		setng		Set byte if not greater (ZF=1 or SF!!= OF)
0F 9C /0	SETNGE r/m8	M	W	E.SF E.OF					V	V		setnge		Set byte if not greater or equal (SF!!= OF).
REX+ 0F 9C /0	SETNGE r/m8	M	W	E.SF E.OF					V	NE		setnge		Set byte if not greater or equal (SF!!= OF).
0F 9D /0	SETNL r/m8	M	W	E.SF E.OF					V	V		setnl		Set byte if not less (SF=OF).
REX+ 0F 9D /0	SETNL r/m8	M	W	E.SF E.OF					V	NE		setnl		Set byte if not less (SF=OF).
0F 9F /0	SETNLE r/m8	M	W	E.ZF E.SF E.OF					V	V		setnle		Set byte if not less or equal (ZF=0 and SF=OF).
REX+ 0F 9F /0	SETNLE r/m8	M	W	E.ZF E.SF E.OF					V	NE		setnle		Set byte if not less or equal (ZF=0 and SF=OF).
0F 91 /0	SETNO r/m8	M	W	E.OF					V	V		setno		Set byte if not overflow (OF=0).
REX+ 0F 91 /0	SETNO r/m8	M	W	E.OF					V	NE		setno		Set byte if not overflow (OF=0).
0F 9B /0	SETNP r/m8	M	W	E.PF					V	V		setnp		Set byte if not parity (PF=0).
REX+ 0F 9B /0	SETNP r/m8	M	W	E.PF					V	NE		setnp		Set byte if not parity (PF=0).
0F 99 /0	SETNS r/m8	M	W	E.SF					V	V		setns		Set byte if not sign (SF=0).
REX+ 0F 99 /0	SETNS r/m8	M	W	E.SF					V	NE		setns		Set byte if not sign (SF=0).
0F 95 /0	SETNZ r/m8	M	W	E.ZF					V	V		setnz		Set byte if not zero (ZF=0).
REX+ 0F 95 /0	SETNZ r/m8	M	W	E.ZF					V	NE		setnz		Set byte if not zero (ZF=0).
0F 90 /0	SETO r/m8	M	W	E.OF					V	V		seto		Set byte if overflow (OF=1)
REX+ 0F 90 /0	SETO r/m8	M	W	E.OF					V	NE		seto		Set byte if overflow (OF=1)
0F 9A /0	SETP r/m8	M	W	E.PF					V	V		setp		Set byte if parity (PF=1).
REX+ 0F 9A /0	SETP r/m8	M	W	E.PF					V	NE		setp		Set byte if parity (PF=1).
0F 9A /0	SETPE r/m8	M	W	E.PF					V	V		setpe		Set byte if parity even (PF=1).
REX+ 0F 9A /0	SETPE r/m8	M	W	E.PF					V	NE		setpe		Set byte if parity even (PF=1).
0F 9B /0	SETPO r/m8	M	W	E.PF					V	V		setpo		Set byte if parity odd (PF=0).
REX+ 0F 9B /0	SETPO r/m8	M	W	E.PF					V	NE		setpo		Set byte if parity odd (PF=0).
0F 98 /0	SETS r/m8	M	W	E.SF					V	V		sets		Set byte if sign (SF=1).
REX+ 0F 98 /0	SETS r/m8	M	W	E.SF					V	NE		sets		Set byte if sign (SF=1).
0F 94 /0	SETZ r/m8	M	W	E.ZF					V	V		setz		Set byte if zero (ZF=1).
REX+ 0F 94 /0	SETZ r/m8	M	W	E.ZF					V	NE		setz		Set byte if zero (ZF=1).
														
0F AE F8	SFENCE	NP							V	V		sfence		Serializes store operations.
														
0F 01 /0	SGDT m						NO	NO	V	V				Store GDTR to m.
														
0F A4	SHLD r/m16, r16, imm8	MRI	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shldw		Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
0F A5	SHLD r/m16, r16, CL	MRC	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shldw		Shift r/m16 to left CL places while shifting bits from r16 in from the right.
0F A4	SHLD r/m32, r32, imm8	MRI	Rzu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shldl		Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.
REX.W+ 0F A4 	SHLD r/m64, r64, imm8	MRI	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	NE		shldq		Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.
0F A5	SHLD r/m32, r32, CL	MRC	Rzu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shldl		Shift r/m32 to left CL places while shifting bits from r32 in from the right.
REX.W+ 0F A5	SHLD r/m64, r64, CL	MRC	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	NE		shldq		Shift r/m64 to left CL places while shifting bits from r64 in from the right.
														
0F AC	SHRD r/m16, r16, imm8	MRI	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shrdw		Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
0F AD	SHRD r/m16, r16, CL	MRC	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shrdw		Shift r/m16 to right CL places while shifting bits from r16 in from the left.
0F AC	SHRD r/m32, r32, imm8	MRI	Rzu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shrdl		Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.
REX.W+ 0F AC	SHRD r/m64, r64, imm8	MRI	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	NE		shrdq		Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.
0F AD	SHRD r/m32, r32, CL	MRC	Rzu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	V		shrdl		Shift r/m32 to right CL places while shifting bits from r32 in from the left.
REX.W+ 0F AD	SHRD r/m64, r64, CL	MRC	Rwu, R, R		e.cf e.sf e.zf e.pf	e.of e.sf e.zf e.af e.cf e.pf			V	NE		shrdq		Shift r/m64 to right CL places while shifting bits from r64 in from the left.
														
66 0F C6 /r ib	SHUFPD xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE2	shufpd		Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.
VEX.NDS.128.66.0F.WIG C6 /r ib	VSHUFPD xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vshufpd		Shuffle Packed double-precision floating- point values selected by imm8 from xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG C6 /r ib	VSHUFPD ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vshufpd		Shuffle Packed double-precision floating- point values selected by imm8 from ymm2 and ymm3/mem.
														
0F C6 /r ib	SHUFPS xmm1, xmm2/m128, imm8	RMI	RW, R, R						V	V	SSE	shufps		Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.
VEX.NDS.128.0F.WIG C6 /r ib	VSHUFPS xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX	vshufps		Shuffle Packed single-precision floating-point values selected by imm8 from xmm2 and xmm3/mem.
VEX.NDS.256.0F.WIG C6 /r ib	VSHUFPS ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vshufps		Shuffle Packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/mem.
														
0F 01 /1	SIDT m						NO	NO	V	V				Store IDTR to m.
														
0F 00 /0	SLDT r/m16						NO	NO	V	V				Stores segment selector from LDTR in r/m16.
REX.W+ 0F 00 /0	SLDT r64/m16						NO	NO	V	V				Stores segment selector from LDTR in r64/m16.
														
0F 01 /4	SMSW r/m16						NO*	NO	V	V				Store machine status word to r/m16.
0F 01 /4	SMSW r32/m16						NO*	NO	V	V				Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined.
REX.W+ 0F 01 /4	SMSW r64/m16						NO*	NO	V	V				Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined.
														
66 0F 51 /r	SQRTPD xmm1, xmm2/m128	RM	W, R						V	V	SSE2	sqrtpd		Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.
VEX.128.66.0F.WIG 51 /r	VSQRTPD xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vsqrtpd		Computes Square Roots of the packed double- precision floating-point values in xmm2/m128 and stores the result in xmm1.
VEX.256.66.0F.WIG 51 /r	VSQRTPD ymm1, ymm2/m256	RM	W, R						V	V	AVX	vsqrtpd		Computes Square Roots of the packed double- precision floating-point values in ymm2/m256 and stores the result in ymm1
														
0F 51 /r	SQRTPS xmm1, xmm2/m128	RM	W, R						V	V	SSE	sqrtps		Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.
VEX.128.0F.WIG 51 /r	VSQRTPS xmm1, xmm2/m128	RM	Z, R						V	V	AVX	vsqrtps		Computes Square Roots of the packed single- precision floating-point values in xmm2/m128 and stores the result in xmm1.
VEX.256.0F.WIG 51 /r	VSQRTPS ymm1, ymm2/m256	RM	W, R						V	V	AVX	vsqrtps		Computes Square Roots of the packed single- precision floating-point values in ymm2/m256 and stores the result in ymm1.
														
F2 0F 51 /r	SQRTSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	sqrtsd		Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.
VEX.NDS.LIG.F2.0F.WIG 51 /r	VSQRTSD xmm1,xmm2, xmm3/m64	RVM	Z, R, R						V	V	AVX	vsqrtsd		Computes square root of the low double- precision floating point value in xmm3/m64 and stores the results in xmm2. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].
														
F3 0F 51 /r	SQRTSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	sqrtss		Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.
VEX.NDS.LIG.F3.0F.WIG 51	VSQRTSS xmm1, xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vsqrtss		Computes square root of the low single- precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
														
F9	STC	NP			E.CF				V	V		stc		Set CF flag.
														
FD	STD	NP			E.DF				V	V		std		Set DF flag.
														
FB	STI	NP		E.VM E.IOPL E.VIP	e.if e.vif				V	V		sti		Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.
														
0F AE /3	STMXCSR m32	M	W	M.*					V	V	SSE	stmxcsr		Store contents of MXCSR register to m32. 
VEX.LZ.0F.WIG AE /3	VSTMXCSR m32	M	W	M.*					V	V	AVX	vstmxcsr		Store contents of MXCSR register to m32.
														
AA	STOS m8	NP	I	E.DF RDI AL					V	V		stosb		For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
AB	STOS m16	NP	I	E.DF RDI AX					V	V		stosw		For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.
AB	STOS m32	NP	I	E.DF RDI EAX					V	V		stosl		For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
REX.W+ AB	STOS m64	NP	I	E.DF RDI RAX					V	NE		stosq		Store RAX at address RDI or EDI.
AA	STOSB	NP		E.DF RDI AL					V	V		stosb		For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
PREF.66+ AB	STOSW	NP		E.DF RDI AX					V	V		stosw		For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.
AB	STOSD	NP		E.DF RDI EAX					V	V		stosl		For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
REX.W+ AB	STOSQ	NP		E.DF RDI RAX					V	NE		stosq		Store RAX at address RDI or EDI.
														
0F 00 /1	STR r/m16						NO	NO	V	V				Stores segment selector from TR in r/m16.
														
2C ib	SUB AL, imm8	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subb		Subtract imm8 from AL.
2D iw	SUB AX, imm16	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subw		Subtract imm16 from AX.
2D id	SUB EAX, imm32	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subl		Subtract imm32 from EAX.
REX.W+ 2D id	SUB RAX, imm32	I	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subq		Subtract imm32 sign-extended to 64-bits from RAX.
80 /5 ib	SUB r/m8, imm8	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subb		Subtract imm8 from r/m8.
REX+ 80 /5 ib	SUB r/m8, imm8	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subb		Subtract imm8 from r/m8.
81 /5 iw	SUB r/m16, imm16	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subw		Subtract imm16 from r/m16.
81 /5 id	SUB r/m32, imm32	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subl		Subtract imm32 from r/m32.
REX.W+ 81 /5 id	SUB r/m64, imm32	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subq		Subtract imm32 sign-extended to 64-bits from r/m64.
83 /5 ib	SUB r/m16, imm8	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subw	YES	Subtract sign-extended imm8 from r/m16.
83 /5 ib	SUB r/m32, imm8	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subl	YES	Subtract sign-extended imm8 from r/m32.
REX.W+ 83 /5 ib	SUB r/m64, imm8	MI	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subq	YES	Subtract sign-extended imm8 from r/m64.
28 /r	SUB r/m8, r8	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subb	YES	Subtract r8 from r/m8.
REX+ 28 /r	SUB r/m8, r8	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subb	YES	Subtract r8 from r/m8.
29 /r	SUB r/m16, r16	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subw	YES	Subtract r16 from r/m16.
29 /r	SUB r/m32, r32	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subl	YES	Subtract r32 from r/m32.
REX.W+ 29 /r	SUB r/m64, r64	MR	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subq	YES	Subtract r64 from r/m64.
2A /r	SUB r8, r/m8	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subb		Subtract r/m8 from r8.
REX+ 2A /r	SUB r8, r/m8	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subb		Subtract r/m8 from r8.
2B /r	SUB r16, r/m16	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subw		Subtract r/m16 from r16.
2B /r	SUB r32, r/m32	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		subl		Subtract r/m32 from r32.
REX.W+ 2B /r	SUB r64, r/m64	RM	RW, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		subq		Subtract r/m64 from r64.
														
66 0F 5C /r	SUBPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	subpd		Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.
VEX.NDS.128.66.0F.WIG 5C /r	VSUBPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vsubpd		Subtract packed double-precision floating- point values in xmm3/mem from xmm2 and stores result in xmm1.
VEX.NDS.256.66.0F.WIG 5C /r	VSUBPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vsubpd		Subtract packed double-precision floating- point values in ymm3/mem from ymm2 and stores result in ymm1.
														
0F 5C /r	SUBPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	subps		Subtract packed single-precision floating-point values in xmm2/mem from xmm1.
VEX.NDS.128.0F.WIG 5C /r	VSUBPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vsubps		Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1.
VEX.NDS.256.0F.WIG 5C /r	VSUBPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vsubps		Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1.
														
F2 0F 5C /r	SUBSD xmm1, xmm2/m64	RM	RW, R						V	V	SSE2	subsd		Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.
VEX.NDS.LIG.F2.0F.WIG 5C /r	VSUBSD xmm1, xmm2, xmm3/m64	RVM	Z, R, R						V	V	AVX	vsubsd		Subtract the low double-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1.
														
F3 0F 5C /r	SUBSS xmm1, xmm2/m32	RM	RW, R						V	V	SSE	subss		Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.
VEX.NDS.LIG.F3.0F.WIG 5C /r	VSUBSS xmm1, xmm2, xmm3/m32	RVM	Z, R, R						V	V	AVX	vsubss		Subtract the low single-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1.
														
0F 01 F8	SWAPGS	NP							V	I		swapgs		Exchanges the current GS base register value with the value contained in MSR address C0000102H.
														
0F 05	SYSCALL	NP		???	???	???			V	I	SYSCALL	syscall		Fast call to privilege level 0 system procedures.
														
0F 34	SYSENTER	NP		???	???	???			V	V	SEP	sysenter		Fast call to privilege level 0 system procedures.
														
0F 35	SYSEXIT	NP		???	???	???			V	V	SEP	sysexit		Fast return to privilege level 3 user code.
REX.W+ 0F 35	SYSEXIT pw	NP	I	???	???	???			V	V	SEP	sysexit		Fast return to 64-bit mode privilege level 3 user code.
														
0F 07	SYSRET	NP		???	???	???			V	I	SYSCALL	sysret		Return to compatibility mode from fast system call
REX.W+ 0F 07	SYSRET pw	NP	I						V	I	SYSCALL	sysret		Return to 64-bit mode from fast system call
														
A8 ib	TEST AL, imm8	I	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testb		AND imm8 with AL; set SF, ZF, PF according to result.
A9 iw	TEST AX, imm16	I	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testw		AND imm16 with AX; set SF, ZF, PF according to result.
A9 id	TEST EAX, imm32	I	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testl		AND imm32 with EAX; set SF, ZF, PF according to result.
REX.W+ A9 id	TEST RAX, imm32	I	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		testq		AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.
F6 /0 ib	TEST r/m8, imm8	MI	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testb		AND imm8 with r/m8; set SF, ZF, PF according to result.
REX+ F6 /0 ib	TEST r/m8, imm8	MI	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		testb		AND imm8 with r/m8; set SF, ZF, PF according to result.
F7 /0 iw	TEST r/m16, imm16	MI	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testw		AND imm16 with r/m16; set SF, ZF, PF according to result.
F7 /0 id	TEST r/m32, imm32	MI	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testl		AND imm32 with r/m32; set SF, ZF, PF according to result.
REX.W+ F7 /0 id	TEST r/m64, imm32	MI	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		testq		AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.
84 /r	TEST r/m8, r8	MR	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testb		AND r8 with r/m8; set SF, ZF, PF according to result.
REX+ 84 /r	TEST r/m8, r8	MR	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		testb		AND r8 with r/m8; set SF, ZF, PF according to result.
85 /r	TEST r/m16, r16	MR	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testw		AND r16 with r/m16; set SF, ZF, PF according to result.
85 /r	TEST r/m32, r32	MR	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		testl		AND r32 with r/m32; set SF, ZF, PF according to result.
REX.W+ 85 /r	TEST r/m64, r64	MR	R, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		testq		AND r64 with r/m64; set SF, ZF, PF according to result.
														
F3 0F BC /r	TZCNT r16, r/m16	RM	W, R		E.ZF E.CF	E.AF E.PF E.OF E.SF			V	V	BMI1	tzcntw		Count the number of trailing zero bits in r/m16, return result in r16.
F3 0F BC /r	TZCNT r32, r/m32	RM	W, R		E.ZF E.CF	E.AF E.PF E.OF E.SF			V	V	BMI1	tzcntl		Count the number of trailing zero bits in r/m32, return result in r32.
REX.W+ F3 0F BC /r	TZCNT r64, r/m64	RM	W, R		E.ZF E.CF	E.AF E.PF E.OF E.SF			V	NE	BMI1	tzcntq		Count the number of trailing zero bits in r/m64, return result in r64.
														
66 0F 2E /r	UCOMISD xmm1, xmm2/m64	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	SSE2	ucomisd		Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.
VEX.LIG.66.0F.WIG 2E /r	VUCOMISD xmm1, xmm2/m64	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vucomisd		Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
														
0F 2E /r	UCOMISS xmm1, xmm2/m32	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	SSE	ucomiss		Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.
VEX.LIG.0F.WIG 2E /r	VUCOMISS xmm1, xmm2/m32	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vucomiss		Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
														
0F 0B	UD2	NP							V	V		ud2		Raise invalid opcode exception.
														
66 0F 15 /r	UNPCKHPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	unpckhpd		Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.
VEX.NDS.128.66.0F.WIG 15 /r	VUNPCKHPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vunpckhpd		Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128.
VEX.NDS.256.66.0F.WIG 15 /r	VUNPCKHPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vunpckhpd		Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256.
														
0F 15 /r	UNPCKHPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	unpckhps		Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.
VEX.NDS.128.0F.WIG 15 /r	VUNPCKHPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vunpckhps		Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128.
VEX.NDS.256.0F.WIG 15 /r	VUNPCKHPS ymm1, ymm2,ymm3/m256	RVM	W, R, R						V	V	AVX	vunpckhps		Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256.
														
66 0F 14 /r	UNPCKLPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	unpcklpd		Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.
VEX.NDS.128.66.0F.WIG 14 /r	VUNPCKLPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vunpcklpd		Unpacks and Interleaves double precision floating-point values low high quadwords of xmm2 and xmm3/m128.
VEX.NDS.256.66.0F.WIG 14 /r	VUNPCKLPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vunpcklpd		Unpacks and Interleaves double precision floating-point values low high quadwords of ymm2 and ymm3/m256.
														
0F 14 /r	UNPCKLPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	unpcklps		Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.
VEX.NDS.128.0F.WIG 14 /r	VUNPCKLPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vunpcklps		Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128.
VEX.NDS.256.0F.WIG 14 /r	VUNPCKLPS ymm1, ymm2,ymm3/m256	RVM	W, R, R						V	V	AVX	vunpcklps		Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256.
														
VEX.128.66.0F38.W0 18 /r	VBROADCASTSS xmm1, m32	RM	Z, R						V	V	AVX	vbroadcastss		Broadcast single-precision floating-point element in mem to four locations in xmm1.
VEX.256.66.0F38.W0 18 /r	VBROADCASTSS ymm1, m32	RM	W, R						V	V	AVX	vbroadcastss		Broadcast single-precision floating-point element in mem to eight locations in ymm1.
VEX.256.66.0F38.W0 19 /r	VBROADCASTSD ymm1, m64	RM	W, R						V	V	AVX	vbroadcastsd		Broadcast double-precision floating-point element in mem to four locations in ymm1.
VEX.256.66.0F38.W0 1A /r	VBROADCASTF128 ymm1, m128	RM	W, R						V	V	AVX	vbroadcastf128		Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1.
VEX.128.66.0F38.W0 18 /r	VBROADCASTSS xmm1, xmm2	RM	Z, R						V	V	AVX2	vbroadcastss		Broadcast the low single-precision floating- point element in the source operand to four locations in xmm1.
VEX.256.66.0F38.W0 18 /r	VBROADCASTSS ymm1, xmm2	RM	W, R						V	V	AVX2	vbroadcastss		Broadcast low single-precision floating-point element in the source operand to eight locations in ymm1.
VEX.256.66.0F38.W0 19 /r	VBROADCASTSD ymm1, xmm2	RM	W, R						V	V	AVX2	vbroadcastsd		Broadcast low double-precision floating-point element in the source operand to four locations in ymm1.
														
VEX.256.66.0F38.W0 13 /r	VCVTPH2PS ymm1, xmm2/m128	RM	W, R	M.RC					V	V	F16C	vcvtph2ps		Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1.
VEX.128.66.0F38.W0 13 /r	VCVTPH2PS xmm1, xmm2/m64	RM	Z, R	M.RC					V	V	F16C	vcvtph2ps		Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1.
														
VEX.256.66.0F3A.W0 1D /r ib	VCVTPS2PH xmm1/m128, ymm2, imm8	MR	Z, R, R	M.RC					V	V	F16C	vcvtps2ph		Convert eight packed single-precision floating-point value in ymm2 to packed half-precision (16-bit) floating-point value in xmm1/mem. Imm8 provides rounding controls.
VEX.128.66.0F3A.W0 1D /r ib	VCVTPS2PH xmm1/m64, xmm2, imm8	MR	Z, R, R	M.RC					V	V	F16C	vcvtps2ph		Convert four packed single-precision float- ing-point value in xmm2 to packed half- precision (16-bit) floating-point value in xmm1/mem. Imm8 provides rounding con- trols.
														
0F 00 /4	VERR r/m16	M	R		E.ZF		YES	NO	V	V		verr		Set ZF=1 if segment specified with r/m16 can be read.
0F 00 /5	VERW r/m16	M	R		E.ZF		YES	NO	V	V		verw		Set ZF=1 if segment specified with r/m16 can be written.
														
VEX.256.66.0F3A.W0 19 /r ib	VEXTRACTF128 xmm1/m128, ymm2, imm8	MR	QZ, R, R						V	V	AVX	vextractf128		Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/mem.
														
VEX.256.66.0F3A.W0 39 /r ib	VEXTRACTI128 xmm1/m128, ymm2, imm8	MRI	RZ, R, R						V	V	AVX2	vextracti128		Extract 128 bits of integer data from ymm2 and store results in xmm1/mem.
														
VEX.DDS.128.66.0F38.W1 98 /r	VFMADD132PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmadd132pd		Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W1 A8 /r	VFMADD213PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmadd213pd		Multiply packed double-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W1 B8 /r	VFMADD231PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmadd231pd		Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W1 98 /r	VFMADD132PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmadd132pd		Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W1 A8 /r	VFMADD213PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmadd213pd		Multiply packed double-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.W1 B8 /r 	VFMADD231PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmadd231pd		Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W0 98 /r 	VFMADD132PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmadd132ps		Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0
VEX.DDS.128.66.0F38.W0 A8 /r	VFMADD213PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmadd213ps		Multiply packed single-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W0 B8 /r	VFMADD231PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmadd231ps		Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W0 98 /r	VFMADD132PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmadd132ps		Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W0 A8 /r 	VFMADD213PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmadd213ps		Multiply packed single-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.W0 B8 /r	VFMADD231PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmadd231ps		Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.
														
VEX.DDS.LIG.128.66.0F38.W1 99 /r	VFMADD132SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfmadd132sd		Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0
VEX.DDS.LIG.128.66.0F38.W1 A9 /r	VFMADD213SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfmadd213sd		Multiply scalar double-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W1 B9 /r	VFMADD231SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfmadd231sd		Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
														
VEX.DDS.LIG.128.66.0F38.W0 99 /r	VFMADD132SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfmadd132ss		Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0
VEX.DDS.LIG.128.66.0F38.W0 A9 /r	VFMADD213SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfmadd213ss		Multiply scalar single-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W0 B9 /r	VFMADD231SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfmadd231ss		Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
														
VEX.DDS.128.66.0F38.W1 96 /r	VFMADDSUB132PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmaddsub132pd		Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W1 A6 /r	VFMADDSUB213PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmaddsub213pd		Multiply packed double-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W1 B6 /r	VFMADDSUB231PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmaddsub231pd		Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W1 96 /r	VFMADDSUB132PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmaddsub132pd		Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W1 A6 /r	VFMADDSUB213PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmaddsub213pd		Multiply packed double-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.W1 B6 /r	VFMADDSUB231PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmaddsub231pd		Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W0 96 /r	VFMADDSUB132PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmaddsub132ps		Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W0 A6 /r	VFMADDSUB213PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmaddsub213ps		Multiply packed single-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W0 B6 /r	VFMADDSUB231PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmaddsub231ps		Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W0 96 /r	VFMADDSUB132PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmaddsub132ps		Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W0 A6 /r	VFMADDSUB213PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmaddsub213ps		Multiply packed single-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.W0 B6 /r	VFMADDSUB231PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmaddsub231ps		Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W1 97 /r 	VFMSUBADD132PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsubadd132pd		Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W1 A7 /r	VFMSUBADD213PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsubadd213pd		Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W1 B7 /r	VFMSUBADD231PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsubadd231pd		Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W1 97 /r	VFMSUBADD132PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsubadd132pd		Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W1 A7 /r	VFMSUBADD213PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsubadd213pd		Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.W1 B7 /r	VFMSUBADD231PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsubadd231pd		Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W0 97 /r	VFMSUBADD132PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsubadd132ps		Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W0 A7 /r	VFMSUBADD213PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsubadd213ps		Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W0 B7 /r	VFMSUBADD231PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsubadd231ps		Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W0 97 /r	VFMSUBADD132PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsubadd132ps		Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W0 A7 /r	VFMSUBADD213PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsubadd213ps		Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.W0 B7 /r	VFMSUBADD231PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsubadd231ps		Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W1 9A /r	VFMSUB132PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsub132pd		Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W1 AA /r	VFMSUB213PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsub213pd		Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W1 BA /r	VFMSUB231PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsub231pd		Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W1 9A /r 	VFMSUB132PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsub132pd		Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W1 AA /r	VFMSUB213PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsub213pd		Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0
VEX.DDS.256.66.0F38.W1 BA /r	VFMSUB231PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsub231pd		Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W0 9A /r	VFMSUB132PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsub132ps		Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W0 AA /r	VFMSUB213PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsub213ps		Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W0 BA /r	VFMSUB231PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfmsub231ps		Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W0 9A /r	VFMSUB132PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsub132ps		Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W0 AA /r	VFMSUB213PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsub213ps		Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0
VEX.DDS.256.66.0F38.W0 BA /r	VFMSUB231PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfmsub231ps		Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.
														
VEX.DDS.LIG.128.66.0F38.W1 9B /r	VFMSUB132SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfmsub132sd		Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W1 AB /r	VFMSUB213SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfmsub213sd		Multiply scalar double-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W1 BB /r	VFMSUB231SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfmsub231sd		Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
														
VEX.DDS.LIG.128.66.0F38.W0 9B /r	VFMSUB132SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfmsub132ss		Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W0 AB /r	VFMSUB213SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfmsub213ss		Multiply scalar single-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W0 BB /r 	VFMSUB231SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfmsub231ss		Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
														
VEX.DDS.128.66.0F38.W1 9C /r	VFNMADD132PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmadd132pd		Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W1 AC /r	VFNMADD213PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmadd213pd		Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W1 BC /r	VFNMADD231PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmadd231pd		Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0
VEX.DDS.256.66.0F38.W1 9C /r	VFNMADD132PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmadd132pd		Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W1 AC /r	VFNMADD213PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmadd213pd		Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0
VEX.DDS.256.66.0F38.W1 BC /r	VFNMADD231PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmadd231pd		Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W0 9C /r	VFNMADD132PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmadd132ps		Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W0 AC /r	VFNMADD213PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmadd213ps		Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W0 BC /r	VFNMADD231PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmadd231ps		Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W0 9C /r 	VFNMADD132PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmadd132ps		Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W0 AC /r	VFNMADD213PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmadd213ps		Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.0 BC /r	VFNMADD231PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmadd231ps		Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.
														
VEX.DDS.LIG.128.66.0F38.W1 9D /r	VFNMADD132SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfnmadd132sd		Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0
VEX.DDS.LIG.128.66.0F38.W1 AD /r 	VFNMADD213SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfnmadd213sd		Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W1 BD /r 	VFNMADD231SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfnmadd231sd		Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
														
VEX.DDS.LIG.128.66.0F38.W0 9D /r	VFNMADD132SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfnmadd132ss		Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0
VEX.DDS.LIG.128.66.0F38.W0 AD /r	VFNMADD213SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfnmadd213ss		Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W0 BD /r	VFNMADD231SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfnmadd231ss		Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
														
VEX.DDS.128.66.0F38.W1 9E /r	VFNMSUB132PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmsub132pd		Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W1 AE /r	VFNMSUB213PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmsub213pd		Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0
VEX.DDS.128.66.0F38.W1 BE /r	VFNMSUB231PD xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmsub231pd		Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W1 9E /r	VFNMSUB132PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmsub132pd		Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W1 AE /r	VFNMSUB213PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmsub213pd		Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.W1 BE /r	VFNMSUB231PD ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmsub231pd		Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.
														
VEX.DDS.128.66.0F38.W0 9E /r	VFNMSUB132PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmsub132ps		Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
VEX.DDS.128.66.0F38.W0 AE /r	VFNMSUB213PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmsub213ps		Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
VEX.DDS.128.66.0F38.W0 BE /r	VFNMSUB231PS xmm0, xmm1, xmm2/m128	RVM	RZ, R, R						V	V	FMA	vfnmsub231ps		Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
VEX.DDS.256.66.0F38.W0 9E /r	VFNMSUB132PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmsub132ps		Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.
VEX.DDS.256.66.0F38.W0 AE /r	VFNMSUB213PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmsub213ps		Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.
VEX.DDS.256.66.0F38.0 BE /r	VFNMSUB231PS ymm0, ymm1, ymm2/m256	RVM	RW, R, R						V	V	FMA	vfnmsub231ps		Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.
														
VEX.DDS.LIG.128.66.0F38.W1 9F /r	VFNMSUB132SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfnmsub132sd		Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W1 AF /r	VFNMSUB213SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfnmsub213sd		Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W1 BF /r	VFNMSUB231SD xmm0, xmm1, xmm2/m64	RVM	RZ, R, R						V	V	FMA	vfnmsub231sd		Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
														
VEX.DDS.LIG.128.66.0F38.W0 9F /r	VFNMSUB132SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfnmsub132ss		Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W0 AF /r	VFNMSUB213SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfnmsub213ss		Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
VEX.DDS.LIG.128.66.0F38.W0 BF /r	VFNMSUB231SS xmm0, xmm1, xmm2/m32	RVM	RZ, R, R						V	V	FMA	vfnmsub231ss		Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
														
VEX.DDS.128.66.0F38.W1 92 /r	VGATHERDPD xmm1, vm32x, xmm2	RMV	Z, R, R						V	V	AVX2	vgatherdpd		Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.128.66.0F38.W1 93 /r	VGATHERQPD xmm1, vm64x, xmm2	RMV	Z, R, R						V	V	AVX2	vgatherqpd		Using qword indices specified in vm64x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.256.66.0F38.W1 92 /r	VGATHERDPD ymm1, vm32x, ymm2	RMV	W, R, R						V	V	AVX2	vgatherdpd		Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.
VEX.DDS.256.66.0F38.W1 93 /r	VGATHERQPD ymm1, vm64y, ymm2	RMV	W, R, R						V	V	AVX2	vgatherqpd		Using qword indices specified in vm64y, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.
														
VEX.DDS.128.66.0F38.W0 92 /r	VGATHERDPS xmm1, vm32x, xmm2	RMV	Z, R, R						V	V	AVX2	vgatherdps		Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.128.66.0F38.W0 93 /r	VGATHERQPS xmm1, vm64x, xmm2	RMV	Z, R, R						V	V	AVX2	vgatherqps		Using qword indices specified in vm64x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.256.66.0F38.W0 92 /r	VGATHERDPS ymm1, vm32y, ymm2	RMV	W, R, R						V	V	AVX2	vgatherdps		Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.
VEX.DDS.256.66.0F38.W0 93 /r	VGATHERQPS xmm1, vm64y, xmm2	RMV	Z, R, R						V	V	AVX2	vgatherqps		Using qword indices specified in vm64y, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.
														
VEX.DDS.128.66.0F38.W0 90 /r	VPGATHERDD xmm1, vm32x, xmm2	RMV	Z, R, R						V	V	AVX2	vpgatherdd		Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.128.66.0F38.W0 91 /r	VPGATHERQD xmm1, vm64x, xmm2	RMV	Z, R, R						V	V	AVX2	vpgatherqd		Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.256.66.0F38.W0 90 /r	VPGATHERDD ymm1, vm32y, ymm2	RMV	W, R, R						V	V	AVX2	vpgatherdd		Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.
VEX.DDS.256.66.0F38.W0 91 /r	VPGATHERQD xmm1, vm64y, xmm2	RMV	Z, R, R						V	V	AVX2	vpgatherqd		Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
														
VEX.DDS.128.66.0F38.W1 90 /r	VPGATHERDQ xmm1, vm32x, xmm2	RMV	Z, R, R						V	V	AVX2	vpgatherdq		Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.128.66.0F38.W1 91 /r	VPGATHERQQ xmm1, vm64x, xmm2	RMV	Z, R, R						V	V	AVX2	vpgatherqq		Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.
VEX.DDS.256.66.0F38.W1 90 /r	VPGATHERDQ ymm1, vm32x, ymm2	RMV	W, R, R						V	V	AVX2	vpgatherdq		Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.
VEX.DDS.256.66.0F38.W1 91 /r	VPGATHERQQ ymm1, vm64y, ymm2	RMV	W, R, R						V	V	AVX2	vpgatherqq		Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.
														
VEX.NDS.256.66.0F3A.W0 18 /r ib	VINSERTF128 ymm1, ymm2, xmm3/m128, imm8	RVMI	W, R, R, R						V	V	AVX	vinsertf128		Insert a single precision floating-point value selected by imm8 from xmm3/m128 into ymm2 at the specified destination element specified by imm8 and zero out destination elements in ymm1 as indicated in imm8.
														
VEX.NDS.256.66.0F3A.W0 38 /r ib	VINSERTI128 ymm1, ymm2, xmm3/m128, imm8	RVMI	W, R, R, R						V	V	AVX2	vinserti128		Insert 128-bits of integer data from xmm3/mem and the remaining values from ymm2 into ymm1.
														
VEX.NDS.128.66.0F38.W0 2C /r	VMASKMOVPS xmm1, xmm2, m128	RVM	Z, R, R						V	V	AVX	vmaskmovps		Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1.
VEX.NDS.256.66.0F38.W0 2C /r	VMASKMOVPS ymm1, ymm2, m256	RVM	W, R, R						V	V	AVX	vmaskmovps		Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1.
VEX.NDS.128.66.0F38.W0 2D /r	VMASKMOVPD xmm1, xmm2, m128	RVM	Z, R, R						V	V	AVX	vmaskmovpd		Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1.
VEX.NDS.256.66.0F38.W0 2D /r	VMASKMOVPD ymm1, ymm2, m256	RVM	W, R, R						V	V	AVX	vmaskmovpd		Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1.
VEX.NDS.128.66.0F38.W0 2E /r	VMASKMOVPS m128, xmm1, xmm2	MVR	W, R, R						V	V	AVX	vmaskmovps		Conditionally store packed single-precision values from xmm2 using mask in xmm1.
VEX.NDS.256.66.0F38.W0 2E /r	VMASKMOVPS m256, ymm1, ymm2	MVR	W, R, R						V	V	AVX	vmaskmovps		Conditionally store packed single-precision values from ymm2 using mask in ymm1.
VEX.NDS.128.66.0F38.W0 2F /r	VMASKMOVPD m128, xmm1, xmm2	MVR	W, R, R						V	V	AVX	vmaskmovpd		Conditionally store packed double-precision values from xmm2 using mask in xmm1.
VEX.NDS.256.66.0F38.W0 2F /r	VMASKMOVPD m256, ymm1, ymm2	MVR	W, R, R						V	V	AVX	vmaskmovpd		Conditionally store packed double-precision values from ymm2 using mask in ymm1.
														
VEX.NDS.128.66.0F3A.W0 02 /r ib	VPBLENDD xmm1, xmm2, xmm3/m128, imm8	RVMI	Z, R, R, R						V	V	AVX2	vpblendd		Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.
VEX.NDS.256.66.0F3A.W0 02 /r ib	VPBLENDD ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX2	vpblendd		Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.
														
VEX.128.66.0F38.W0 78 /r	VPBROADCASTB xmm1, xmm2/m8	RM	Z, R						V	V	AVX2	vpbroadcastb		Broadcast a byte integer in the source operand to sixteen locations in xmm1.
VEX.256.66.0F38.W0 78 /r	VPBROADCASTB ymm1, xmm2/m8	RM	W, R						V	V	AVX2	vpbroadcastb		Broadcast a byte integer in the source operand to thirty two locations in ymm1.
VEX.128.66.0F38.W0 79 /r	VPBROADCASTW xmm1, xmm2/m16	RM	Z, R						V	V	AVX2	vpbroadcastw		Broadcast a word integer in the source operand to eight locations in xmm1.
VEX.256.66.0F38.W0 79 /r	VPBROADCASTW ymm1, xmm2/m16	RM	W, R						V	V	AVX2	vpbroadcastw		Broadcast a word integer in the source operand to sixteen locations in ymm1.
VEX.128.66.0F38.W0 58 /r	VPBROADCASTD xmm1, xmm2/m32	RM	Z, R						V	V	AVX2	vpbroadcastd		Broadcast a dword integer in the source operand to four locations in xmm1.
VEX.256.66.0F38.W0 58 /r	VPBROADCASTD ymm1, xmm2/m32	RM	W, R						V	V	AVX2	vpbroadcastd		Broadcast a dword integer in the source operand to eight locations in ymm1.
VEX.128.66.0F38.W0 59 /r	VPBROADCASTQ xmm1, xmm2/m64	RM	Z, R						V	V	AVX2	vpbroadcastq		Broadcast a qword element in mem to two locations in xmm1
VEX.256.66.0F38.W0 59 /r	VPBROADCASTQ ymm1, xmm2/m64	RM	W, R						V	V	AVX2	vpbroadcastq		Broadcast a qword element in mem to four locations in ymm1
VEX.256.66.0F38.W0 5A /r	VBROADCASTI128 ymm1, m128	RM	W, R						V	V	AVX2	vbroadcasti128		Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1.
														
VEX.NDS.256.66.0F38.W0 36 /r	VPERMD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpermd		Permute doublewords in ymm3/m256 using indexes in ymm2 and store the result in ymm1.
														
VEX.256.66.0F3A.W1 01 /r ib	VPERMPD ymm1, ymm2/m256, imm8	RMI	W, R, R						V	V	AVX2	vpermpd		Permute double-precision floating-point elements in ymm2/m256 using indexes in imm8 and store the result in ymm1.
														
VEX.NDS.256.66.0F38.W0 16 /r	VPERMPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpermps		Permute single-precision floating-point elements in ymm3/m256 using indexes in ymm2 and store the result in ymm1.
														
VEX.256.66.0F3A.W1 00 /r ib	VPERMQ ymm1, ymm2/m256, imm8	RMI	W, R, R						V	V	AVX2	vpermq		Permute qwords in ymm2/m256 using indexes in imm8 and store the result in ymm1.
														
VEX.NDS.256.66.0F3A.W0 46 /r ib	VPERM2I128 ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX2	vperm2i128		Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.
														
VEX.NDS.128.66.0F38.W0 0D /r	VPERMILPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpermilpd		Permute double-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.
VEX.NDS.256.66.0F38.W0 0D /r	VPERMILPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vpermilpd		Permute double-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.
VEX.128.66.0F3A.W0 05 /r ib	VPERMILPD xmm1, xmm2/m128, imm8	RMI	Z, R, R						V	V	AVX	vpermilpd		Permute double-precision floating-point values in xmm2/mem using controls from imm8.
VEX.256.66.0F3A.W0 05 /r ib	VPERMILPD ymm1, ymm2/m256, imm8	RMI	W, R, R						V	V	AVX	vpermilpd		Permute double-precision floating-point values in ymm2/mem using controls from imm8.
														
VEX.NDS.128.66.0F38.W0 0C /r	VPERMILPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vpermilps		Permute single-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.
VEX.128.66.0F3A.W0 04 /r ib	VPERMILPS xmm1, xmm2/m128, imm8	RMI	Z, R, R						V	V	AVX	vpermilps		Permute single-precision floating-point values in xmm2/mem using controls from imm8 and store result in xmm1.
VEX.NDS.256.66.0F38.W0 0C /r	VPERMILPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vpermilps		Permute single-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.
VEX.256.66.0F3A.W0 04 /r ib	VPERMILPS ymm1, ymm2/m256, imm8	RMI	W, R, R						V	V	AVX	vpermilps		Permute single-precision floating-point values in ymm2/mem using controls from imm8 and store result in ymm1.
														
VEX.NDS.256.66.0F3A.W0 06 /r ib	VPERM2F128 ymm1, ymm2, ymm3/m256, imm8	RVMI	W, R, R, R						V	V	AVX	vperm2f128		Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.
														
VEX.NDS.128.66.0F38.W0 8C /r	VPMASKMOVD xmm1, xmm2, m128	RVM	Z, R, R						V	V	AVX2	vpmaskmovd		Conditionally load dword values from m128 using mask in xmm2 and store in xmm1.
VEX.NDS.256.66.0F38.W0 8C /r	VPMASKMOVD ymm1, ymm2, m256	RVM	W, R, R						V	V	AVX2	vpmaskmovd		Conditionally load dword values from m256 using mask in ymm2 and store in ymm1.
VEX.NDS.128.66.0F38.W1 8C /r	VPMASKMOVQ xmm1, xmm2, m128	RVM	Z, R, R						V	V	AVX2	vpmaskmovq		Conditionally load qword values from m128 using mask in xmm2 and store in xmm1.
VEX.NDS.256.66.0F38.W1 8C /r	VPMASKMOVQ ymm1, ymm2, m256	RVM	W, R, R						V	V	AVX2	vpmaskmovq		Conditionally load qword values from m256 using mask in ymm2 and store in ymm1.
VEX.NDS.128.66.0F38.W0 8E /r	VPMASKMOVD m128, xmm1, xmm2	MVR	W, R, R						V	V	AVX2	vpmaskmovd		Conditionally store dword values from xmm2 using mask in xmm1.
VEX.NDS.256.66.0F38.W0 8E /r	VPMASKMOVD m256, ymm1, ymm2	MVR	W, R, R						V	V	AVX2	vpmaskmovd		Conditionally store dword values from ymm2 using mask in ymm1.
VEX.NDS.128.66.0F38.W1 8E /r	VPMASKMOVQ m128, xmm1, xmm2	MVR	W, R, R						V	V	AVX2	vpmaskmovq		Conditionally store qword values from xmm2 using mask in xmm1.
VEX.NDS.256.66.0F38.W1 8E /r	VPMASKMOVQ m256, ymm1, ymm2	MVR	W, R, R						V	V	AVX2	vpmaskmovq		Conditionally store qword values from ymm2 using mask in ymm1.
														
VEX.NDS.128.66.0F38.W0 47 /r	VPSLLVD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX2	vpsllvd		Shift bits in doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
VEX.NDS.128.66.0F38.W1 47 /r	VPSLLVQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX2	vpsllvq		Shift bits in quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
VEX.NDS.256.66.0F38.W0 47 /r	VPSLLVD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsllvd		Shift bits in doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
VEX.NDS.256.66.0F38.W1 47 /r	VPSLLVQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsllvq		Shift bits in quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
														
VEX.NDS.128.66.0F38.W0 46 /r	VPSRAVD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX2	vpsravd		Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in the sign bits.
VEX.NDS.256.66.0F38.W0 46 /r	VPSRAVD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsravd		Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in the sign bits.
														
VEX.NDS.128.66.0F38.W0 45 /r	VPSRLVD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX2	vpsrlvd		Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
VEX.NDS.128.66.0F38.W1 45 /r	VPSRLVQ xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX2	vpsrlvq		Shift bits in quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
VEX.NDS.256.66.0F38.W0 45 /r	VPSRLVD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsrlvd		Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
VEX.NDS.256.66.0F38.W1 45 /r	VPSRLVQ ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX2	vpsrlvq		Shift bits in quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
														
VEX.128.66.0F38.W0 0E /r	VTESTPS xmm1, xmm2/m128	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vtestps		Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources.
VEX.256.66.0F38.W0 0E /r	VTESTPS ymm1, ymm2/m256	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vtestps		Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources.
VEX.128.66.0F38.W0 0F /r	VTESTPD xmm1, xmm2/m128	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vtestpd		Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources.
VEX.256.66.0F38.W0 0F /r	VTESTPD ymm1, ymm2/m256	RM	R, R		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V	AVX	vtestpd		Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources.
														
VEX.256.0F.WIG 77	VZEROALL	NP			YMM*				V	V	AVX	vzeroall		Zero all YMM registers.
														
VEX.128.0F.WIG 77	VZEROUPPER	NP		XMM*	YMM*				V	V	AVX	vzeroupper		Zero upper 128 bits of all YMM registers.
														
9B	WAIT	NP				S.C0 S.C1 S.C2 S.C3			V	V	FPU	wait		Check pending unmasked floating-point exceptions.
9B	FWAIT	NP				S.C0 S.C1 S.C2 S.C3			V	V	FPU	fwait		Check pending unmasked floating-point exceptions.
														
0F 09	WBINVD						NO	YES	V	V				Write back and flush Internal caches; initiate writing-back and flushing of external caches.
														
F3 0F AE /2	WRFSBASE r32	M	R						V	I	FSGSBASE	wrfsbase		Load the FS base address with the 32-bit value in the source register.
REX.W+ F3 0F AE /2	WRFSBASE r64	M	R						V	I	FSGSBASE	wrfsbase		Load the FS base address with the 64-bit value in the source register.
F3 0F AE /3	WRGSBASE r32	M	R						V	I	FSGSBASE	wrgsbase		Load the GS base address with the 32-bit value in the source register.
REX.W+ F3 0F AE /3	WRGSBASE r64	M	R						V	I	FSGSBASE	wrgsbase		Load the GS base address with the 64-bit value in the source register.
														
0F 30	WRMSR						NO	YES	V	V				Write the value in EDX:EAX to MSR specified by ECX.
														
F2	XACQUIRE	NP							V	V	HLE	xacquire		A hint used with an "XACQUIRE-enabled" instruction to start lock elision on the instruction memory operand address.
F3	XRELEASE	NP							V	V	HLE	xrelease		A hint used with an "XRELEASE-enabled" instruction to end lock elision on the instruction memory operand address.
														
C6 F8 ib	XABORT imm8	I	R						V	V	RTM	xabort		Causes an RTM abort if in RTM execution
														
0F C0 /r	XADD r/m8, r8	MR	RW, RW		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		xaddb		Exchange r8 and r/m8; load sum into r/m8.
REX+ 0F C0 /r	XADD r/m8, r8	MR	RW, RW		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		xaddb		Exchange r8 and r/m8; load sum into r/m8.
0F C1 /r	XADD r/m16, r16	MR	RW, RW		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		xaddw		Exchange r16 and r/m16; load sum into r/m16.
0F C1 /r	XADD r/m32, r32	MR	RW, RW		E.OF E.SF E.ZF E.AF E.CF E.PF				V	V		xaddl		Exchange r32 and r/m32; load sum into r/m32.
REX.W+ 0F C1 /r	XADD r/m64, r64	MR	RW, RW		E.OF E.SF E.ZF E.AF E.CF E.PF				V	NE		xaddq		Exchange r64 and r/m64; load sum into r/m64.
														
C7 F8	XBEGIN rel16	A	R						NS	V	RTM	xbegin		Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.
C7 F8	XBEGIN rel32	A	R						V	V	RTM	xbegin		Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.
														
90 +rw	XCHG AX, r16	 O	RW, RW						V	V		xchgw		Exchange r16 with AX.
90 +rw	XCHG r16, AX	O	RW, RW						V	V		xchgw		Exchange AX with r16.
90 +rd	XCHG EAX, r32	 O	RW, RW						V	V		xchgl		Exchange r32 with EAX.
REX.W+ 90 +rd	XCHG RAX, r64	 O	RW, RW						V	NE		xchgq		Exchange r64 with RAX.
90 +rd	XCHG r32, EAX	O	RW, RW						V	V		xchgl		Exchange EAX with r32.
REX.W+ 90 +rd	XCHG r64, RAX	O	RW, RW						V	NE		xchgq		Exchange RAX with r64.
86 /r	XCHG r/m8, r8	MR	RW, RW						V	V		xchgb	YES	Exchange r8 (byte register) with byte from r/m8.
REX+ 86 /r	XCHG r/m8, r8	MR	RW, RW						V	NE		xchgb		Exchange r8 (byte register) with byte from r/m8.
86 /r	XCHG r8, r/m8	RM	RW, RW						V	V		xchgb		Exchange byte from r/m8 with r8 (byte register).
REX+ 86 /r	XCHG r8, r/m8	RM	RW, RW						V	NE		xchgb		Exchange byte from r/m8 with r8 (byte register).
87 /r	XCHG r/m16, r16	MR	RW, RW						V	V		xchgw	YES	Exchange r16 with word from r/m16.
87 /r	XCHG r16, r/m16	RM	RW, RW						V	V		xchgw		Exchange word from r/m16 with r16.
87 /r	XCHG r/m32, r32	MR	RW, RW						V	V		xchgl	YES	Exchange r32 with doubleword from r/m32.
REX.W+ 87 /r	XCHG r/m64, r64	MR	RW, RW						V	NE		xchgq	YES	Exchange r64 with quadword from r/m64.
87 /r	XCHG r32, r/m32	RM	RW, RW						V	V		xchgl		Exchange doubleword from r/m32 with r32.
REX.W+ 87 /r	XCHG r64, r/m64	RM	RW, RW						V	NE		xchgq		Exchange quadword from r/m64 with r64.
														
0F 01 D5	XEND	NP							V	V	RTM	xend		Specifies the end of an RTM code region.
														
0F 01 D0	XGETBV	NP		ECX	EAX EDX		YES	NO	V	V	XSAVE	xgetbv		Reads an XCR specified by ECX into EDX:EAX.
														
D7	XLAT m8	NP	I	AL DS BX ebx	AL				V	V		xlat		Set AL to memory byte DS:[(E)BX + unsigned AL].
D7	XLATB	NP		AL DS BX ebx	AL				V	V		xlatb	YES	Set AL to memory byte DS:[(E)BX + unsigned AL].
REX.W+ D7	XLATB	NP		AL RBX	AL				V	NE		xlatb		Set AL to memory byte [RBX + unsigned AL].
														
34 ib	XOR AL, imm8	I	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorb		AL XOR imm8.
35 iw	XOR AX, imm16	I	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorw		AX XOR imm16.
35 id	XOR EAX, imm32	I	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorl		EAX XOR imm32.
REX.W+ 35 id	XOR RAX, imm32	I	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorq		RAX XOR imm32 (sign-extended).
80 /6 ib	XOR r/m8, imm8	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorb		r/m8 XOR imm8.
REX+ 80 /6 ib	XOR r/m8, imm8	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorb		r/m8 XOR imm8.
81 /6 iw	XOR r/m16, imm16	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorw		r/m16 XOR imm16.
81 /6 id	XOR r/m32, imm32	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorl		r/m32 XOR imm32.
REX.W+ 81 /6 id	XOR r/m64, imm32	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorq		r/m64 XOR imm32 (sign-extended).
83 /6 ib	XOR r/m16, imm8	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorw	YES	r/m16 XOR imm8 (sign-extended).
83 /6 ib	XOR r/m32, imm8	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorl	YES	r/m32 XOR imm8 (sign-extended).
REX.W+ 83 /6 ib	XOR r/m64, imm8	MI	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorq	YES	r/m64 XOR imm8 (sign-extended).
30 /r	XOR r/m8, r8	MR	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorb	YES	r/m8 XOR r8.
REX+ 30 /r	XOR r/m8, r8	MR	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorb	YES	r/m8 XOR r8.
31 /r	XOR r/m16, r16	MR	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorw	YES	r/m16 XOR r16.
31 /r	XOR r/m32, r32	MR	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorl	YES	r/m32 XOR r32.
REX.W+ 31 /r	XOR r/m64, r64	MR	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorq	YES	r/m64 XOR r64.
32 /r	XOR r8, r/m8	RM	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorb		r8 XOR r/m8.
REX+ 32 /r	XOR r8, r/m8	RM	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorb		r8 XOR r/m8.
33 /r	XOR r16, r/m16	RM	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorw		r16 XOR r/m16.
33 /r	XOR r32, r/m32	RM	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	V		xorl		r32 XOR r/m32.
REX.W+ 33 /r	XOR r64, r/m64	RM	RW, R		E.OF E.SF E.ZF E.CF E.PF	E.AF			V	NE		xorq		r64 XOR r/m64.
														
66 0F 57 /r	XORPD xmm1, xmm2/m128	RM	RW, R						V	V	SSE2	xorpd		Bitwise exclusive-OR of xmm2/m128 and xmm1.
VEX.NDS.128.66.0F.WIG 57 /r	VXORPD xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vxorpd		Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.66.0F.WIG 57 /r	VXORPD ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vxorpd		Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem.
														
0F 57 /r	XORPS xmm1, xmm2/m128	RM	RW, R						V	V	SSE	xorps		Bitwise exclusive-OR of xmm2/m128 and xmm1.
VEX.NDS.128.0F.WIG 57 /r	VXORPS xmm1, xmm2, xmm3/m128	RVM	Z, R, R						V	V	AVX	vxorps		Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem.
VEX.NDS.256.0F.WIG 57 /r	VXORPS ymm1, ymm2, ymm3/m256	RVM	W, R, R						V	V	AVX	vxorps		Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem.
														
0F AE /5	XRSTOR mem	M	R	???	???	???			V	V	XSAVE	xrstor		Restore processor extended states from memory. The states are specified by EDX:EAX
REX.W+ 0F AE /5	XRSTOR64 mem	M	R	???	???	???			V	NE	XSAVE	xrstor64		Restore processor extended states from memory. The states are specified by EDX:EAX
														
0F AE /4	XSAVE mem	M	W	???	???	???			V	V	XSAVE	xsave		Save processor extended states to memory. The states are specified by EDX:EAX
REX.W+ 0F AE /4	XSAVE64 mem	M	W	???	???	???			V	NE	XSAVE	xsave64		Save processor extended states to memory. The states are specified by EDX:EAX
														
0F AE /6	XSAVEOPT mem	M	W	???	???	???			V	V	XSAVEOPT	xsaveopt		Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.
REX.W+ 0F AE /6	XSAVEOPT64 mem	M	W	???	???	???			V	V	XSAVEOPT	xsaveopt64		Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.
														
0F 01 D1	XSETBV						NO*	YES	V	V				Write the value in EDX:EAX to the XCR specified by ECX.
														
0F 01 D6	XTEST	NP							V	V	RTM	xtest		Test if executing in a transactional region
'
! !

!OperandEncoding methodsFor: 'services' stamp: 'KenD 11/22/2023 13:56:04'!
bytesFor: integer length: n
	| bytes v |
	bytes := ByteArray new: n.
	v := integer.
	v < 0 ifTrue: [v := v + (1 bitShift: n * 8)].
	1 to: n do: [:i | | b |
		b := v bitAnd: 16rFF.
		bytes at: i put: b.
		v := v bitShift: -8].
	^bytes
! !

!OperandEncoding methodsFor: 'services' stamp: 'KenD 11/22/2023 13:56:04'!
encodeOperand: i of: instruction
	| selector |
	selector := selectors at: i.
	self perform: selector with: instruction
! !

!OperandEncoding methodsFor: 'services' stamp: 'KenD 11/22/2023 13:56:04'!
encodeOperands: instruction
	1 to: instruction arity do: [:i | self encodeOperand: i of: instruction]
! !

!OperandEncoding methodsFor: 'services' stamp: 'KenD 11/22/2023 13:56:04'!
immediateOperand
	^descriptions findFirst: [:d | d includesString: 'imm']
! !

!OperandEncoding methodsFor: 'services' stamp: 'KenD 11/22/2023 13:56:04'!
operand: index of: instruction
	| d |
	d := descriptions at: index.
	(d includesString: 'reg') ifTrue: [^instruction regOperand: index].
	(d includesString: 'r/m') ifTrue: [^instruction rmOperand: index].
	(d includesString: 'vvvv') ifTrue: [^instruction vvvvOperand: index].
	(self isImmediate1Operand: index) ifTrue: [^instruction immediateOperand].
	(self isImmediate2Operand: index) ifTrue: [^instruction immediateOperand2].
	(instruction spec operands at: index) isImmediate
		ifTrue: [^instruction immediateOperand].
	((d beginsWith: 'opcode') and: [index = 1])
		ifTrue: [^instruction opcodeOperand].
	self ASSERT: false
! !

!OperandEncoding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:04'!
descriptions
	^descriptions
! !

!OperandEncoding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:04'!
descriptions: aCollection
	descriptions := aCollection.
	modrm := immediate := false.
	(selectors conform: [:s | s beginsWith: 'encodeNP']) ifTrue: [^self].
	descriptions do: [:d | 
		(d includesString: 'ModRM') ifTrue: [modrm := true].
		(d includesString: 'offs') ifTrue: [immediate := true].
		(d includesString: 'imm') ifTrue: [immediate := true]]
! !

!OperandEncoding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:04'!
name
	^name
! !

!OperandEncoding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:04'!
name: aString
	name := aString
! !

!OperandEncoding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:04'!
selectors
	^selectors
! !

!OperandEncoding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:04'!
selectors: aCollection
	selectors := aCollection
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeAOperand1: operand
	"
	imm8
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeDOperand1: instruction
	"
	offset
	"
	| op bytes |
	op := instruction spec operands at: 1.
	bytes := self bytesFor: instruction operand1 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFDOperand1: instruction
	"
	AL/AX/EAX/RAX
	Moffs
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFDOperand2: operand
	"
	AL/AX/EAX/RAX
	Moffs
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFVOperand1: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFVOperand2: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFVOperand3: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFVRVMOperand1: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFVRVMOperand2: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeFVRVMOperand3: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeIIOperand1: instruction
	"
	iw
	imm8
	"
	| op bytes |
	op := instruction spec operands at: 1.
	bytes := self bytesFor: instruction operand1 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeIIOperand2: instruction
	"
	iw
	imm8
	"
	| op bytes |
	op := instruction spec operands at: 2.
	bytes := self bytesFor: instruction operand2 value length: op length // 8.
	instruction immediate2: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeIOperand1: instruction
	"
	AL/AX/EAX/RAX
	imm8
	"
	"
	do nothing
	"
	instruction arity = 1 ifTrue: [| op bytes |
		op := instruction spec operands at: 1.
		bytes := self bytesFor: instruction operand1 value length: op length // 8.
		instruction immediate: bytes]
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeIOperand2: instruction
	"
	AL/AX/EAX/RAX
	imm8
	"
	| op bytes |
	op := instruction spec operands at: 2.
	bytes := self bytesFor: instruction operand2 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeM1Operand1: instruction
	"
	ModRM:r/m (w)
	1
	"
	instruction rm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeM1Operand2: instruction
	"
	ModRM:r/m (w)
	1
	"
	"
	do nothing
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMCOperand1: instruction
	"
	ModRM:r/m (w)
	CL
	"
	instruction rm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMCOperand2: operand
	"
	ModRM:r/m (w)
	CL
	"
	"
	do nothing
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMIOperand1: instruction
	"
	ModRM:r/m (r, w)
	imm8
	"
	instruction rm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMIOperand2: instruction
	"
	ModRM:r/m (r, w)
	imm8
	"
	| op bytes |
	op := instruction spec operands at: 2.
	bytes := self bytesFor: instruction operand2 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMOperand1: instruction
	"
	ModRM:r/m (r)
	"
	instruction rm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMRCOperand1: instruction
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	CL
	"
	instruction rm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMRCOperand2: instruction
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	CL
	"
	instruction reg: instruction operand2
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMRCOperand3: instruction
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	CL
	"
	"
	do nothing
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMRIOperand1: instruction
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	imm8
	"
	instruction rm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMRIOperand2: instruction
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	imm8
	"
	instruction reg: instruction operand2
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMRIOperand3: instruction
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	imm8
	"
	| op bytes |
	op := instruction spec operands at: 3.
	bytes := self bytesFor: instruction operand3 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMROperand1: instruction
	"
	ModRM:r/m (r, w)
	ModRM:reg (r)
	"
	instruction rm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMROperand2: instruction
	"
	ModRM:r/m (r, w)
	ModRM:reg (r)
	"
	instruction reg: instruction operand2
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMVROperand1: instruction
	"
	ModRM:r/m (w)
	VEX.vvvv (r)
	ModRM:reg (r)
	"
	instruction vrm: instruction operand1 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMVROperand2: instruction
	"
	ModRM:r/m (w)
	VEX.vvvv (r)
	ModRM:reg (r)
	"
	instruction vvvv: instruction operand2 index
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeMVROperand3: instruction
	"
	ModRM:r/m (w)
	VEX.vvvv (r)
	ModRM:reg (r)
	"
	instruction vreg: instruction operand3
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeNPOperand1: instruction
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	"
	self ASSERT: instruction operand1 isImmediate
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeNPOperand2: operand
	"
	ModRM:r/m (w)
	ModRM:reg (r)
	"
	self ASSERT: false
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeOIOperand1: instruction
	"
	opcode + rd (w)
	imm8/16/32/64
	"
	self encodeOOperand1: instruction
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeOIOperand2: instruction
	"
	opcode + rd (w)
	imm8/16/32/64
	"
	instruction operand2 length: instruction operand1 length.
	instruction immediate: instruction operand2 bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeOOperand1: instruction
	"
	opcode + rd (r, w)
	"
	| index i opcode |
	index := instruction operand1 index.
	i := index bitAnd: 2r111.
	opcode := instruction spec primaryOpcode copy.
	opcode at: opcode size put: opcode last + i.
	index > 7
		ifTrue: [instruction rexB: true opcode: opcode]
		ifFalse: [instruction opcode: opcode]
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRM0Operand1: instruction
	"
	ModRM:reg (r, w)
	ModRM:r/m (r)
	"
	instruction vreg: instruction operand1
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRM0Operand2: instruction
	"
	ModRM:reg (r, w)
	ModRM:r/m (r)
	"
	instruction vrm: instruction operand2 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMIOperand1: instruction
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	imm8
	"
	instruction reg: instruction operand1
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMIOperand2: instruction
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	imm8
	"
	instruction rm: instruction operand2 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMIOperand3: instruction
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	imm8
	"
	| op bytes |
	op := instruction spec operands at: 3.
	bytes := self bytesFor: instruction operand3 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMOperand1: instruction
	"
	ModRM:reg (r, w)
	ModRM:r/m (r)
	"
	instruction reg: instruction operand1
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMOperand2: instruction
	"
	ModRM:reg (r, w)
	ModRM:r/m (r)
	"
	instruction rm: instruction operand2 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMVOperand1: instruction
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	VEX.vvvv (r)
	"
	instruction vreg: instruction operand1
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMVOperand2: instruction
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	VEX.vvvv (r)
	"
	instruction vrm: instruction operand2 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRMVOperand3: instruction
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	VEX.vvvv (r)
	"
	instruction vvvv: instruction operand3 index
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMIOperand1: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[3:0]
	"
	instruction vreg: instruction operand1
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMIOperand2: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[3:0]
	"
	instruction vvvv: instruction operand2 index
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMIOperand3: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[3:0]
	"
	instruction vrm: instruction operand3 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMIOperand4: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[3:0]
	"
	| op bytes |
	op := instruction spec operands at: 4.
	bytes := self bytesFor: instruction operand4 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMOperand1: instruction
	"
	ModRM:reg (w)
	VEX.vvvv
	ModRM:r/m (r)
	"
	instruction vreg: instruction operand1
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMOperand2: instruction
	"
	ModRM:reg (w)
	VEX.vvvv
	ModRM:r/m (r)
	"
	instruction vvvv: instruction operand2 index
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMOperand3: instruction
	"
	ModRM:reg (w)
	VEX.vvvv
	ModRM:r/m (r)
	"
	instruction vrm: instruction operand3 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMROperand1: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[7:4]
	"
	instruction vreg: instruction operand1
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMROperand2: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[7:4]
	"
	instruction vvvv: instruction operand2 index
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMROperand3: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[7:4]
	"
	instruction vrm: instruction operand3 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeRVMROperand4: instruction
	"
	ModRM:reg (w)
	VEX.vvvv (r)
	ModRM:r/m (r)
	imm8[7:4]
	"
	| imm |
	imm := instruction operand4 index bitShift: 4.
	instruction immediate: imm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeT1SOperand1: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeT1SOperand2: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeT1SOperand3: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeT1SRVMOperand1: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeT1SRVMOperand2: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeT1SRVMOperand3: instruction
	"
	ModRM:reg (w)
	EVEX.vvvv
	ModRM:r/m (r)
	"
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeTDOperand1: operand
	"
	Moffs (w)
	AL/AX/EAX/RAX
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeTDOperand2: operand
	"
	Moffs (w)
	AL/AX/EAX/RAX
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeTOOperand1: operand
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeTOOperand2: operand
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeVMIOperand1: instruction
	"
	VEX.vvvv (w)
	ModRM:r/m (r)
	imm8
	"
	instruction vvvv: instruction operand1 index
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeVMIOperand2: instruction
	"
	VEX.vvvv (w)
	ModRM:r/m (r)
	imm8
	"
	instruction vrm: instruction operand2 rm
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeVMIOperand3: instruction
	"
	VEX.vvvv (w)
	ModRM:r/m (r)
	imm8
	"
	| op bytes |
	op := instruction spec operands at: 3.
	bytes := self bytesFor: instruction operand3 value length: op length // 8.
	instruction immediate: bytes
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeVMOperand1: operand
	"
	VEX.vvvv (w)
	ModRM:r/m (r)
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeVMOperand2: operand
	"
	VEX.vvvv (w)
	ModRM:r/m (r)
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeXMOperand1: operand
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	"
	
! !

!OperandEncoding methodsFor: 'private' stamp: 'KenD 11/22/2023 13:56:04'!
encodeXMOperand2: operand
	"
	ModRM:reg (w)
	ModRM:r/m (r)
	"
	
! !

!OperandEncoding methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:04'!
isImmediate1Operand: index
	^(self isImmediateOperand: index)
		and: [(1 to: index - 1) noneSatisfy: [:i | self isImmediateOperand: i]]
! !

!OperandEncoding methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:04'!
isImmediate2Operand: index
	^(self isImmediateOperand: index)
		and: [(1 to: index - 1) anySatisfy: [:i | self isImmediateOperand: i]]
! !

!OperandEncoding methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:04'!
isImmediateOperand: index
	| d |
	d := descriptions at: index.
	^(d includesString: 'imm') or: [d includesString: 'offs'] or: [d = 'iw']
! !

!OperandEncoding methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:04'!
isVvvvOperand: index
	^(descriptions at: index) includesString: 'vvvv'
! !

!OperandEncoding methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:04'!
usesImmediate
	^immediate
! !

!OperandEncoding methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:04'!
usesImmediate2
	^immediate and: [selectors anySatisfy: [:s | s includesString: 'II']]
! !

!OperandEncoding methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:56:04'!
usesModRM
	^modrm
! !

!OperandEncoding methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:56:04'!
printOn: aStream
	name isNil ifTrue: [^super printOn: aStream].
	aStream nextPutAll: name
! !

!OperandEncoding class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:04'!
commentEncodingMethods
	"
	StChangesetBrowser new
		label: 'OperandEncoding comments';
		setModel: (ChangesetBrowserModel on: OperandEncoding commentEncodingMethods);
		openInWindow
	"
	| changes |
	changes := OrderedCollection new.
	Encodings collect: [:oe | | comment |
		comment := String streamContents: [:strm | 
			strm crtab; nextPut: $"; crtab.
			oe descriptions do: [:d | strm nextPutAll: d; crtab].
			strm nextPut: $"; cr].
		oe selectors do: [:s | | cm reader source change |
			cm := self >> s.
			reader := cm sourceCode readStream.
			source := String streamContents: [:strm | 
				strm
					nextPutAll: reader nextLine;
					nextPutAll: comment;
					nextPutAll: reader upToEnd].
			change := self project changes
				methodDefinitionClass: self
				sourceCode: source.
			changes add: change]].
	^changes
! !

!OperandEncoding class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:04'!
defs
	^#(
		#('A' 'imm8')
		#('D' 'offset')
		#('FD' 'AL/AX/EAX/RAX' 'Moffs')
		#('FV' 'ModRM:reg (w)' 'EVEX.vvvv' 'ModRM:r/m (r)')
		#('FV-RVM' 'ModRM:reg (w)' 'EVEX.vvvv' 'ModRM:r/m (r)')
		#('I' 'AL/AX/EAX/RAX' 'imm8')
		#('II' 'iw' 'imm8')
		#('M' 'ModRM:r/m (r)')
		#('M1' 'ModRM:r/m (w)' '1')
		#('MC' 'ModRM:r/m (w)' 'CL')
		#('MI' 'ModRM:r/m (r, w)' 'imm8')
		#('MR' 'ModRM:r/m (r, w)' 'ModRM:reg (r)')
		#('MRC' 'ModRM:r/m (w)' 'ModRM:reg (r)' 'CL')
		#('MRI' 'ModRM:r/m (w)' 'ModRM:reg (r)' 'imm8')
		#('MVR' 'ModRM:r/m (w)' 'VEX.vvvv (r)' 'ModRM:reg (r)')
		#('NP' 'ModRM:r/m (w)' 'ModRM:reg (r)')
		#('O' 'opcode + rd (r, w)')
		#('OI' 'opcode + rd (w)' 'imm8/16/32/64')
		#('RM' 'ModRM:reg (r, w)' 'ModRM:r/m (r)')
		#('RM0' 'ModRM:reg (r, w)' 'ModRM:r/m (r)')
		#('RMI' 'ModRM:reg (w)' 'ModRM:r/m (r)' 'imm8')
		#('RMV' 'ModRM:reg (w)' 'ModRM:r/m (r)' 'VEX.vvvv (r)')
		#('RVM' 'ModRM:reg (w)' 'VEX.vvvv' 'ModRM:r/m (r)')
		#('RVMI' 'ModRM:reg (w)' 'VEX.vvvv (r)' 'ModRM:r/m (r)' 'imm8[3:0]')
		#('RVMR' 'ModRM:reg (w)' 'VEX.vvvv (r)' 'ModRM:r/m (r)' 'imm8[7:4]')
		#('T1S' 'ModRM:reg (w)' 'EVEX.vvvv' 'ModRM:r/m (r)')
		#('T1S-RVM' 'ModRM:reg (w)' 'EVEX.vvvv' 'ModRM:r/m (r)')
		#('TD' 'Moffs (w)' 'AL/AX/EAX/RAX')
		#('VM' 'VEX.vvvv (w)' 'ModRM:r/m (r)')
		#('VMI' 'VEX.vvvv (w)' 'ModRM:r/m (r)' 'imm8')
		#('XM' 'ModRM:reg (w)' 'ModRM:r/m (r)'))
! !

!OperandEncoding class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:56:04'!
initializeEncodings
	Encodings := OrderedCollection new.
	self defs
		do: [ :def | 
			| oe n selectors |
			n := def first replaceAllSubstrings: '-' with: ''.
			oe := self new.
			selectors := (2 to: def size)
				collect: [ :i | ('encode' , n , 'Operand' , (i - 1) asString , ':') asSymbol ].
			oe
				name: n;
				selectors: selectors;
				descriptions: def allButFirst.
			selectors
				reject: [ :s | self includesSelector: s ]
				thenDo: [ :s | self compile: s , ' instruction' ].
			Encodings add: oe ].
	Encodings := Encodings asArray
! !

!OperandEncoding class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:56:04'!
named: aString
	^Encodings
		detect: [:e | e name = aString]
		ifNone: [(aString includes: $-) ifTrue: [self halt]]
! !

!ABI methodsFor: 'unclassified' stamp: 'KenD 10/23/2022 15:53:47'!
is32bits
	^self widthInBits = 32
! !

!ABI methodsFor: 'unclassified' stamp: 'KenD 10/23/2022 15:53:37'!
is64bits
	^self widthInBits = 64
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regA
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regE
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regFP
	^ self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regFalse
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regG
	^ self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regIP
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regM
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regNil
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regR
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regS
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regSP
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regT
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regTrue
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regV
	^self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regX0
	^ self subclassResponsibility
! !

!ABI methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:37:49'!
regX1
	^ self subclassResponsibility
! !

!X64ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
bits
	^64
! !

!X64ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
wordSize
	^8
! !

!X64ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:11'!
wordSizeShift
	^3
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regA
	^rdx
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regE
	^rdi
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regFP
	^rbp
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regFalse
	^ r14
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regG
	^r15
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regIP
	^ rip
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regM
	^rbx
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regNil
	^ r12
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regR
	^rax
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regS
	^rsi
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regSP
	^rsp
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regT
	^rcx
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regTrue
	^ r13
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regV
	^r11
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regX0
	^xmm0
! !

!X64ABI methodsFor: 'registers - IR' stamp: 'KenD 11/22/2023 07:58:11'!
regX1
	^xmm1
! !

!SysVX64ABI methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:58:11'!
emitEntrypoint: anFFIDescriptor with: anAssembler
	anAssembler saveCallerFrame;
			pushG;
		pushNil;
		pushTrue;
		pushFalse;
		pushM.
	self storeArgumentsInStack: anFFIDescriptor with: anAssembler.
	
! !

!SysVX64ABI methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:58:11'!
popRetaddrAndArgs: anFFIDescriptor with: anAssembler
	anAssembler
		popA;
		popA;
		popA
! !

!SysVX64ABI methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:58:11'!
restoreContext: anFFIDescriptor with: anAssembler
	self popRetaddrAndArgs: anFFIDescriptor with: anAssembler.
	anAssembler
		popM;
		popFalse;
		popTrue;
		popNil;
		popG;
		popFP;
		return
! !

!SysVX64ABI methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:58:11'!
storeArgumentsInStack: anFFIDescriptor with: anAssembler
	anAssembler pushS;
		loadRwithArgPointer;
		convertRtoSmallInteger;
		pushR
! !

!WinX64ABI methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:23'!
emitEntrypoint: anFFIDescriptor with: anAssembler
	anAssembler saveCallerFrame;
		pushG;
		pushNil;
		pushTrue;
		pushFalse;
		pushM;
		pushE;
		pushS.
	self storeArgumentsInStack: anFFIDescriptor with: anAssembler.
	
! !

!WinX64ABI methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:23'!
popRetaddrAndArgs: anFFIDescriptor with: anAssembler
	anAssembler
		popA;
		popA;
		popA
! !

!WinX64ABI methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:23'!
restoreContext: anFFIDescriptor with: anAssembler
	self popRetaddrAndArgs: anFFIDescriptor with: anAssembler.
	anAssembler
		popS;
		popE;
		popM;
		popFalse;
		popTrue;
		popNil;
		popG;
		popFP;
		return
! !

!WinX64ABI methodsFor: 'services' stamp: 'KenD 11/22/2023 13:23:23'!
storeArgumentsInStack: anFFIDescriptor with: anAssembler
	anAssembler pushS;
		loadRwithArgPointer;
		convertRtoSmallInteger;
		pushR
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
bits
	^32
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
regA
	^edx
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
regE
	^edi
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
regFP
	^ebp
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
regR
	^eax
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
regS
	^esi
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
regSP
	^esp
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
regT
	^ecx
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
wordSize
	^4
! !

!X86ABI methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:56:05'!
wordSizeShift
	^2
! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:44:26'!
regA

	^RegA! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:44:41'!
regE

	^RegE! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:44:51'!
regFP

	^RegFP! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:45:04'!
regFalse

	^RegFalse! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:45:23'!
regG

	^RegG! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 10/4/2022 10:44:26'!
regIP

	^ self error: 'RISC-V: PC is not a visible register. Use auipc instruction!!' ! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:46:09'!
regM

	^RegM! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:46:22'!
regNil

	^RegNil! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:46:34'!
regR

	^RegR! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:46:54'!
regS

	^RegS! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:47:09'!
regSP

	^RegSP! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 10:47:25'!
regT

	^RegT! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 13:07:47'!
regTrue

	^RegTrue! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 13:07:59'!
regV

	^RegV! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 13:08:17'!
regX0

	^RegX0! !

!RV64GABI methodsFor: 'registers - IR' stamp: 'KenD 9/27/2022 13:08:27'!
regX1

	^RegX1! !

!RV64GABI methodsFor: 'registers - internal use only' stamp: 'KenD 10/4/2022 10:47:37'!
regFlags

	^ RegFlags! !

!RV64GABI methodsFor: 'registers - internal use only' stamp: 'KenD 10/4/2022 10:45:20'!
regLink

	^ RegLink! !

!RV64GABI methodsFor: 'registers - internal use only' stamp: 'KenD 10/14/2022 13:22:28'!
regTmp0

	^ RegTmp0! !

!RV64GABI methodsFor: 'registers - internal use only' stamp: 'KenD 10/4/2022 10:45:28'!
regTmp1

	^ RegTmp1! !

!RV64GABI methodsFor: 'registers - internal use only' stamp: 'KenD 10/4/2022 10:46:06'!
regZero

	^RegZero! !

!RV64GABI methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:52:00'!
bits
	"Pointers are 8 bytes with 8 bits per byte"
	^ 64 "8 * 8"! !

!RV64GABI methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:53:19'!
widthInBits
	"Pointers are 8 bytes with 8 bits per byte"
	^ 64 "8 * 8"! !

!RV64GABI methodsFor: 'accessing' stamp: 'KenD 9/26/2022 16:42:07'!
wordSize
	"Pointers are 8 bytes"
	^ 8! !

!RV64GABI methodsFor: 'accessing' stamp: 'KenD 9/26/2022 16:42:51'!
wordSizeShift

	^ 3
! !

!RV64GABI class methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:54:13'!
widthInBits

	^ 64 "8 bytes per pointer"! !

!RV64GABI class methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:50:37'!
wordSize

	^ 8 "bytes per pointer"! !

!RV64GABI class methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:50:16'!
wordSizeShift
	
	^ 3! !

!Assembler methodsFor: 'labels' stamp: 'KenD 9/26/2022 12:38:17'!
@ label
	self addLabel: label
! !

!Assembler methodsFor: 'labels' stamp: 'KenD 9/26/2022 12:38:17'!
addLabel: aString
	self addLabel: aString to: self currentAddress
! !

!Assembler methodsFor: 'labels' stamp: 'KenD 9/26/2022 12:38:17'!
addLabel: label to: location
	labels at: label put: location
! !

!Assembler methodsFor: 'labels' stamp: 'KenD 9/26/2022 12:38:17'!
newLabel
	| label next |
	next := labels size + 1.
	IndexedLabels size < next ifTrue: [self class growIndexedLabelsTo: next].
	label := IndexedLabels at: next.
	self addLabel: label to: nil.
	^label
! !

!Assembler methodsFor: 'labels' stamp: 'KenD 9/26/2022 12:38:17'!
resolveLabel: aString
	^labels at: aString
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
add: source1 to: source2andDest
	codegen add: source1 to: source2andDest
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
addImm: imm to: dest
	codegen addImm: imm to: dest
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
alignTo: anInteger
	codegen alignTo: anInteger
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
breakpoint
	codegen breakpoint
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 11/8/2022 14:46:57'!
callIndirectA
	"Looks like this shoule be indirect through a `SendSite`"
	| memref |
	self flag: 	#ExpectSendSite.
	memref := codegen memRef: codegen regA indexImm: 1.
	codegen callIndirect: memref
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
callIndirectM
	| memref |
	memref := codegen memRef: codegen regM indexImm: 1.
	codegen callIndirect: memref
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
callR
	codegen call: codegen regR
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
clearIntegerBit: srcAndDstReg
	self clearSafeIntegerBit: srcAndDstReg

! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
clearRintegerBit
	self dec: codegen regR
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
clearSafeIntegerBit: srcAndDstReg
	self and: srcAndDstReg withImm: -2
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
clearSafeRintegerBit
	self clearSafeIntegerBit: codegen regR

! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compare: reg1 with: reg2
	codegen compare: reg1 with: reg2
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compare: register withLiteral: anObject
	| index memref |
	index := self addLiteral: anObject.
	memref := codegen memRef: codegen regM indexImm: index.
	codegen compare: register withMem: memref
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareAwithFalse
	codegen compare: codegen regA with: codegen regFalse
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareAwithTrue
	codegen compare: codegen regA with: codegen regTrue
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareRwithA
	codegen compare: codegen regR with: codegen regA
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareRwithFalse
	codegen compare: codegen regR with: codegen regFalse
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareRwithImmediate: imm
	codegen compare: codegen regR withImm: imm
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareRwithNil
	codegen compare: codegen regR with: codegen regNil
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareRwithTrue
	codegen compare: codegen regR with: codegen regTrue
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareSwithTindex: index
	| memref |
	memref := codegen memRef: codegen regT indexImm: index.
	codegen compare: codegen regS withMem: memref
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareTwithA
	codegen compare: codegen regT with: codegen regA
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareTwithImmediate: imm
	codegen compare: codegen regT withImm: imm
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareWithFalse: register
	codegen compare: register with: codegen regFalse
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareWithNil: register
	codegen compare: register with: codegen regNil
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
compareWithTrue: register
	codegen compare: register with: codegen regTrue
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
popSPindirect
	| memref |
	memref := codegen memRef: codegen regSP indexImm: 1.
	codegen popIntoMem: memref
! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
sub: src2 from: src1AndDst
	codegen sub: src2  from: src1AndDst

! !

!Assembler methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
subImm: imm from: srcAndDst
	codegen subImm: imm from: srcAndDst

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
addAtoR
	codegen add: codegen regA to: codegen regR
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
addDoubleX1toX0
	codegen addDouble: codegen regX1 to: codegen regX0

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
addRwithImmediate: imm
	codegen addImm: imm to: codegen regR 
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
addTtoR
	codegen add: codegen regT to: codegen regR
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
andRwithImmediate: imm
	codegen and: codegen regR withImm: imm
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
convertAtoNativeInteger
	self convertToNativeInteger: codegen regA
	
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
convertRtoNativeInteger
	self convertToNativeInteger: codegen regR
	
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
convertRtoSmallInteger
	self convertToSmallInteger: codegen regR
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
convertToNativeInteger: srcAndDstReg
	codegen shiftRightArithmetic: srcAndDstReg byImm: 1
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
convertToSmallInteger: srcAndDstReg
	self shiftLeft: srcAndDstReg byImm: 1; inc: srcAndDstReg
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
convertTtoNativeInteger
	self convertToNativeInteger: codegen regT
	
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
exchangeRindirectWithT
	| memref |
	memref := codegen memRef: codegen regR indexImm: 1.
	codegen exchange: codegen regT withMem: memref
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithKnown: anObject
	codegen breakpoint
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
nativeCode
	^(NativeCode withAll: literals) code: codegen memory bytes
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
pushSmallInteger: integer
	| smi |
	smi := self smallInteger: integer.
	self pushImm: smi
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
setIntegerBit: srcAndDstReg
	self setSafeIntegerBit: srcAndDstReg
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
setRintegerBit
	self setIntegerBit: codegen regR

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
setSafeIntegerBit: srcAndDstReg
	self or: srcAndDstReg withImm: 1
! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
setSafeRintegerBit
	self setSafeIntegerBit: codegen regR

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
shiftLeftRwithT
	codegen shiftLeft: codegen regR by: codegen regT

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
shiftLogicalRright: count
	codegen shiftRight: codegen regR byImm: count

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
shiftRightRwithT
	codegen shiftRightArithmetic: codegen regR by: codegen regT

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
shiftRleft: count
	 codegen shiftLeft: codegen regR byImm: count

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
shiftRright: count
	codegen shiftRightArithmetic: codegen regR byImm: count

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
shiftTright: count
	codegen shiftRightArithmetic: codegen regT byImm: count

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
subAfromR
	codegen sub: codegen regA from: codegen regR

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
subAfromT
	codegen sub: codegen regA from: codegen regT    

! !

!Assembler methodsFor: 'arithmetic' stamp: 'KenD 9/26/2022 12:38:17'!
subFromRconstant: imm
	codegen subImm: imm from: codegen regR

! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
addLiteral: anObject
	| index |
	index := literals
		identityIndexOf: anObject
		ifAbsent: [ literals
				add: anObject;
				size ].
	^ index + 2
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
load:dstReg withImmediate: imm
	codegen moveImm: imm to: dstReg

! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
load: register withLiteral: anObject
	| index memref |
	index := self addLiteral: anObject.
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: register
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithAindex: index
	| memref |
	memref := codegen memRef: codegen regA indexImm: index.
	codegen
		load: codegen regA
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithEindex: index
	| memref |
	memref := codegen memRef: codegen regE indexImm: index.
	codegen
		load: codegen regA
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithFPindex: index
	| memref |
	memref := codegen memRef: codegen regFP indexImm: index.
	codegen
		load: codegen regA
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithFalse
	codegen move: codegen regFalse to: codegen regA
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithGlobal: aSymbol
	| index |
	index := NativizationEnvironment indexOfGlobal: aSymbol.
	self loadAwithGindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithLiteral: anObject
	| index |
	index := self addLiteral: anObject.
	self loadAwithMindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regA
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithNil
	codegen move: codegen regNil to: codegen regA
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithR
	codegen move: codegen regR to: codegen regA
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 11/2/2022 13:16:49'!
loadAwithRoffsetAtA
	| memref |
	memref := codegen memRef
				base: codegen regR;
				index: codegen regA.
	codegen
		load: codegen regA
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithS
	codegen move: codegen regS to: codegen regA
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithSindex: index
	| memref |
	memref := codegen memRef: codegen regS indexImm: index.
	codegen
		load: codegen regA
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithTrue
	codegen move: codegen regTrue to: codegen regA
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadEwithFPindex: index
	| memref |
	memref := codegen memRef: codegen regFP indexImm: index.
	codegen
		load: codegen regE
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadEwithNil
	codegen move: codegen regNil to: codegen regE
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadEwithR
	codegen move: codegen regR to: codegen regE
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadFPwithR
	codegen move: codegen regR to: codegen regFP
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadFPwithSP
	codegen move: codegen regSP to: codegen regFP
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadFalseWithLiteral: anObject
	| index |
	index := self addLiteral: anObject.
	self loadFalseWithMindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadFalseWithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regFalse
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadGwithLiteral: anObject
	| index |
	index := self addLiteral: anObject.
	self loadGwithMindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadGwithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regG
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadMwithFPindex: index
	| memref |
	memref := codegen memRef: codegen regFP indexImm: index.
	codegen
		load: codegen regM
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadMwithGlobal: aSymbol
	| index |
	index := NativizationEnvironment indexOfGlobal: aSymbol.
	self loadMwithGindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadMwithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regM
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadMwithRindex: index
	| memref |
	memref := codegen memRef: codegen regR indexImm: index.
	codegen
		load: codegen regM
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadMwithTindex: index
	| memref |
	memref := codegen memRef: codegen regT indexImm: index.
	codegen
		load: codegen regM
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadNilWithLiteral: anObject
	| index |
	index := self addLiteral: anObject.
	self loadNilWithMindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadNilWithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regNil
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithA
	codegen move: codegen regA to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithE
	codegen move: codegen regE to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithEindex: index
	| memref |
	memref := codegen memRef: codegen regE indexImm: index.
	codegen
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithFP
	codegen move: codegen regFP to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithFPindex: index
	| memref |
	memref := codegen memRef: codegen regFP indexImm: index.
	codegen
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithFalse
	codegen move: codegen regFalse to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithLiteral: anObject
	| index |
	index := self addLiteral: anObject.
	self loadRwithMindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithM
	codegen move: codegen regM to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithNil
	codegen move: codegen regNil to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 11/2/2022 13:17:00'!
loadRwithRatOffsetA
	| memref |
	memref := codegen memRef
				base: codegen regR;
				index: codegen regA.
	codegen
		load: codegen regR
		fromMem:
			memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithRindex: index
	| memref |
	memref := codegen memRef: codegen regR indexImm: index.
	codegen
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithS
	codegen move: codegen regS to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithSPindex: index
	| memref |
	memref := codegen memRef: codegen regSP indexImm: index.
	codegen
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithSindex: index
	| memref |
	memref := codegen memRef: codegen regS indexImm: index.
	codegen
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithT
	codegen move: codegen regT to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithTrue
	codegen move: codegen regTrue to: codegen regR
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadSPwithFP
	codegen move: codegen regFP to: codegen regSP
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadSwithFPindex: index
	| memref |
	memref := codegen memRef: codegen regFP indexImm: index.
	codegen
		load: codegen regS
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadSwithGlobal: aSymbol
	| index |
	index := NativizationEnvironment indexOfGlobal: aSymbol.
	self loadSwithGindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadSwithNil
	codegen move: codegen regNil to: codegen regS
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadSwithRindex: index
	| memref |
	memref := codegen memRef: codegen regR indexImm: index.
	codegen
		load: codegen regS
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTrueWithLiteral: anObject
	| index |
	index := self addLiteral: anObject.
	self loadTrueWithMindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTrueWithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regTrue
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithA
	codegen move: codegen regA to: codegen regT
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithAindex: index
	| memref |
	memref := codegen memRef: codegen regA indexImm: index.
	codegen
		load: codegen regT
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithEindex: index
	| memref |
	memref := codegen memRef: codegen regE indexImm: index.
	codegen
		load: codegen regT
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithFPindex: index
	| memref |
	memref := codegen memRef: codegen regFP indexImm: index.
	codegen
		load: codegen regT
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithLiteral: anObject
	| index |
	index := self addLiteral: anObject.
	self loadTwithMindex: index
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen
		load: codegen regT
		fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithR
	codegen move: codegen regR to: codegen regT
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithTindex: index
	| memref |
	memref := codegen memRef: codegen regT indexImm: index.
	codegen load: codegen regT fromMem: memref
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadWithFalse: register
	codegen move: codegen regFalse to: register
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadWithNil: register
	codegen move: codegen regNil to: register
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
loadWithTrue: register
	codegen move: codegen regTrue to: register
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
reserveStackSlots: amount
	codegen subImm: amount * codegen addressSize from: codegen regSP
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
saveCallerFrame
	self pushFP; loadFPwithSP
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
testIntegerBit: aRegister
	codegen testIntegerBit: aRegister
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
testIntegerBitOf: aRegister
	codegen test: aRegister byte withImm: 1
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
testRintegerBit
	codegen test: codegen regR byte withImm: 1
! !

!Assembler methodsFor: 'loading' stamp: 'KenD 9/26/2022 12:38:17'!
testRwithR
	codegen test: codegen regR with: codegen regR
! !

!Assembler methodsFor: 'logic' stamp: 'KenD 9/26/2022 12:38:17'!
addSPwithImmediate: imm
	codegen addImm: imm to: codegen regSP
! !

!Assembler methodsFor: 'logic' stamp: 'KenD 9/26/2022 12:38:17'!
addTwithImmediate: imm
	codegen addImm: imm to: codegen regT
! !

!Assembler methodsFor: 'logic' stamp: 'KenD 9/26/2022 12:38:17'!
andRwithA
	codegen and: codegen regR with: codegen regA
! !

!Assembler methodsFor: 'logic' stamp: 'KenD 9/26/2022 12:38:17'!
orRwithA
	codegen or: codegen regR with: codegen regA

! !

!Assembler methodsFor: 'logic' stamp: 'KenD 9/26/2022 12:38:17'!
xorAwithR
	codegen xor: codegen regA with: codegen regR

! !

!Assembler methodsFor: 'logic' stamp: 'KenD 9/26/2022 12:38:17'!
xorFPwithFP
	codegen xor: codegen regFP with: codegen regFP

! !

!Assembler methodsFor: 'logic' stamp: 'KenD 9/26/2022 12:38:17'!
xorRwithA
	codegen xor: codegen regR with: codegen regA

! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
and: source1andDest with: source2
	codegen and: source1andDest with: source2
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
and: source1andDest withImm: imm
	codegen and: source1andDest withImm: imm
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
or: src1AndDst with: src2
	^ codegen or: src1AndDst with: src2
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
or: source1andDest withImm: imm
	codegen or: source1andDest withImm: imm
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
shiftLeft: srcAndDst by: countReg
	self subclassResponsibility
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
shiftLeft: srcAndDst byImm: count
	codegen shiftLeft: srcAndDst byImm: count
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
shiftRight: srcAndDst by: countReg
	self subclassResponsibility
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
shiftRight: srcAndDst byImm: count
	self subclassResponsibility
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
shiftRightArithmetic: srcAndDst by: countReg
	codegen shiftRightArithmetic: srcAndDst by: countReg
! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
shiftRightArithmetic: srcAndDst byImm: count
	codegen shiftRightArithmetic: srcAndDst byImm: count

! !

!Assembler methodsFor: 'operations - logical' stamp: 'KenD 9/26/2022 12:38:17'!
xor: src1AndDst with: src2
	^ self subclassResponsibility

! !

!Assembler methodsFor: 'relocation' stamp: 'KenD 9/26/2022 12:38:17'!
applyFixups
	codegen memory applyFixupsWith: self
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
buildFrame
	self
		push: codegen regFP;
		move: codegen regSP to: codegen regFP
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
bytes
	^codegen bytes
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
decRindirect
	| memref |
	memref := codegen memRef: codegen regR indexImm: 1.
	codegen decMem: memref
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
discardArguments: anInteger
	anInteger = 0 ifTrue: [^self].
	codegen addImm: anInteger * codegen wordSize to: codegen regSP
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithGindex: index
	| memref |
	memref := codegen memRef: codegen regG indexImm: index.
	codegen
		load: codegen regA
		fromMem: memref
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
loadMwithGindex: index
	| memref |
	memref := codegen memRef: codegen regG indexImm: index.
	codegen
		load: codegen regM
		fromMem: memref
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
loadSwithGindex: index
	| memref |
	memref := codegen memRef: codegen regG indexImm: index.
	codegen
		load: codegen regS
		fromMem: memref
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
pop: dstReg
	codegen pop: dstReg
! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
push: srcReg
	codegen push: srcReg

! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
pushImm: imm
	codegen pushImm: imm

! !

!Assembler methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:17'!
pushIndirectR
	| memref |
	memref := codegen memRef: codegen regR indexImm: 1.
	codegen pushMem: memref
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
clearFPUFlags
	codegen clearFPUFlags
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
compareEqualDoubleX0withAindirect
	codegen compareEqualDoubleX0withAindirect
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
compareLessThanDoubleX0withAindirect
	codegen compareLessThanDoubleX0withAindirect
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
dropTopOfFPU
	codegen dropTopOfFPU
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
leadingRzeroCount
	codegen leadingRzeroCount
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
loadLongMwithIPoffset: anInteger
	codegen loadLongMwithIPoffset: anInteger
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
loadMXCSRfromA
	codegen loadMXCSRfromA
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendByte: dstReg from: srcBaseReg atIndexAt: srcIndexReg
	codegen loadZeroExtendByte: dstReg from: srcBaseReg atIndexAt: srcIndexReg

! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendByte: dstReg from: srcBaseReg atIndexImm: indexImm

	codegen
		loadZeroExtendByte: dstReg
		from: srcBaseReg
		atIndexImm: indexImm
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendShortRwithRoffset: offset
	codegen
		loadZeroExtendShortRwithRoffset: offset
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
lock
	codegen lock
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
moveTslots
	codegen moveTslots
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
readFPUStatusOnA
	codegen readFPUStatusOnA
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
scaleFloatOnRWithA
	codegen scaleFloatOnRWithA
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
storeMXCSRintoA
	codegen storeMXCSRintoA

! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
subTslotsToSP
	codegen subTslotsToSP
! !

!Assembler methodsFor: 'to-cleanup' stamp: 'KenD 9/26/2022 12:38:17'!
writeTslots
	codegen writeTslots
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
clearRhigh32
	codegen clearHigh32: codegen regR

! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
dec: srcAndDstReg
	codegen dec: srcAndDstReg

! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
dropTos: count
	codegen addImm: (count * codegen addressSize) to: codegen regSP

! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
inc: srcAndDstReg
	codegen inc: srcAndDstReg

! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
initializeS
	codegen move: codegen regR to: codegen regS
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadEwithAddressOfRatA
	| memref |
	memref := codegen
		memRef: codegen regR
		index: codegen regA
		offsetImm: codegen wordSize negated.
	codegen lea: codegen regE withMem: memref
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadLargeX0withRindirect
	| memref |
	memref := codegen memRef64: codegen regR indexImm: 1.
	codegen loadDouble: codegen regX0 fromMem: memref
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadLargeX1withAindirect
	| memref |
	memref := codegen memRef64: codegen regA indexImm: 1.
	codegen loadDouble: codegen regX1 fromMem: memref
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadLongRwithRatOffsetA
	| memref |
	memref := codegen
		memRef32: codegen regR
		offset: codegen regA.
	codegen load: codegen regR fromMem: memref

! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadLongSwithRindex: index
	| memref |
	memref := codegen memRef32: codegen regR indexImm: index.
	codegen load: codegen regS fromMem: memref

! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadMwithA
	codegen move: codegen regA to: codegen regM
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadRconvertingDoublePointedByR
	| memref |
	memref := codegen memRef64: codegen regR indexImm: 1.
	codegen load: codegen regR convertingDoubleToIntegerFromMem: memref
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithArgPointer
	| memref |
	memref := codegen memRef: codegen regFP indexImm: 3.
	codegen lea: codegen regR withMem: memref
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadSwithAddressOfSatA
	| memref |
	memref := codegen
		memRef: codegen regS
		index: codegen regA
		offsetImm: codegen wordSize negated.
	codegen lea: codegen regS withMem: memref
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
loadX0withRasDouble
	codegen convert: codegen regR toDouble: codegen regX0
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popA
	codegen pop: codegen regA
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popE
	codegen pop: codegen regE
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popFP
	codegen pop: codegen regFP
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popFalse
	codegen pop: codegen regFalse
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popG
	codegen pop: codegen regG
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popM
	codegen pop: codegen regM
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popNil
	codegen pop: codegen regNil
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popR
	codegen pop: codegen regR
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popS
	codegen pop: codegen regS
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popT
	codegen pop: codegen regT
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
popTrue
	codegen pop: codegen regTrue
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushA
	codegen push: codegen regA
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushE
	codegen push: codegen regE
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushFP
	codegen push: codegen regFP
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushFalse
	codegen push: codegen regFalse
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushG
	codegen push: codegen regG
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushM
	codegen push: codegen regM
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushNil
	codegen push: codegen regNil
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushR
	codegen push: codegen regR
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushS
	codegen push: codegen regS
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushT
	codegen push: codegen regT
! !

!Assembler methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:17'!
pushTrue
	codegen push: codegen regTrue
! !

!Assembler methodsFor: 'comparing' stamp: 'KenD 9/26/2022 12:38:17'!
compare: register withBoolean: aBoolean
	aBoolean
		ifTrue: [ self compareWithTrue: register ]
		ifFalse: [ self compareWithFalse: register ]
! !

!Assembler methodsFor: 'comparing' stamp: 'KenD 9/26/2022 12:38:17'!
compareAwithBoolean: aBoolean
	aBoolean
		ifTrue: [ self compareAwithTrue ]
		ifFalse: [ self compareAwithFalse ]
! !

!Assembler methodsFor: 'comparing' stamp: 'KenD 9/26/2022 12:38:17'!
compareRwithBoolean: aBoolean
	aBoolean
		ifTrue: [ self compareRwithTrue ]
		ifFalse: [ self compareRwithFalse ]
! !

!Assembler methodsFor: 'comparing' stamp: 'KenD 9/26/2022 12:38:17'!
compareRwithSmallInteger: anInteger
	| smi |
	smi := self smallInteger: anInteger.
	self compareRwithImmediate: smi
! !

!Assembler methodsFor: 'comparing' stamp: 'KenD 9/26/2022 12:38:17'!
smallInteger: anInteger
	^(anInteger bitShift: 1) + 1
! !

!Assembler methodsFor: 'services' stamp: 'KenD 9/26/2022 12:38:17'!
currentAddress
	^ codegen currentAddress
! !

!Assembler methodsFor: 'services' stamp: 'KenD 9/26/2022 12:38:17'!
move: srcReg to: dstReg
	^ codegen move: srcReg to: dstReg

! !

!Assembler methodsFor: 'services' stamp: 'KenD 9/26/2022 12:38:17'!
moveImm: imm to: dstReg
	codegen moveImm: imm to: dstReg

! !

!Assembler methodsFor: 'services' stamp: 'KenD 9/26/2022 12:38:17'!
wordSize
	^codegen wordSize
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
divideDoubleX0byX1
	codegen divDouble: codegen regX0 by: codegen regX1
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithTIBatR
	codegen load: codegen regR withTIBat: codegen regR
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithThreadVariableAtR
	codegen load: codegen regR withThreadVariableAt: codegen regR
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
moveX0toR
	codegen moveDouble: codegen regX0 into: codegen regR
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
multiplyDoubleX0byX1
	codegen mulDouble: codegen regX0 by: codegen regX1
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
pushAatToffset: offset
	| memref |
	memref := codegen memRef: codegen regA index: codegen regT.
	memref displacement: offset.
	codegen pushMem: memref
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
renameByteRegisterIfNeeded: register preserving: preserved1 preserving: preserved2 during: aBlock
	codegen renameByteRegisterIfNeeded: register preserving: preserved1 preserving: preserved2 during: aBlock
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
roundDoubleX0intoX1
	codegen roundDouble: codegen regX0 into: codegen regX1
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
sqrtDoubleX0
	codegen sqrtDouble: codegen regX0 into: codegen regX0
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
storeAinThreadVariableAtIndexR
	codegen store: codegen regA intoThreadVariableAt: codegen regR
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
storeDoubleResultInRindirect
	| memref |
	memref := codegen memRef: codegen regR indexImm: 1.
	codegen storeDoubleResultIntoMem:  memref
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
storeTIBatRwithA
	codegen store: codegen regA intoTIBat: codegen regR
! !

!Assembler methodsFor: 'floting point' stamp: 'KenD 9/26/2022 12:38:17'!
subDoubleX1fromX0
	codegen subDouble: codegen regX1 from: codegen regX0
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
extendRtoAandDividebyT
	codegen divide: codegen regR extendingTo: codegen regA by: codegen regT
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
multiplyRbyAwideningToA
	codegen
		multiply: codegen regR
		by: codegen regA
		wideningTo: codegen regA
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeAinTindex: index
	| memref |
	memref := codegen memRef: codegen regT indexImm: index.
	codegen
		store: codegen regA
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeByteAinRindex: index
	| memref |
	memref := codegen memRef8: codegen regR indexImm: index.
	codegen store: codegen regA byte intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeByteTinRatA
	| memref |
	memref := codegen memRef8: codegen regR index: codegen regA.
	codegen store: codegen regT byte intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeEinRindex: index
	| memref |
	memref := codegen memRef: codegen regR indexImm: index.
	codegen
		store: codegen regE
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeLargeX0inA
	| memref |
	memref := codegen memRef64: codegen regA indexImm: 1.
	codegen storeDouble: codegen regX0 intoMem: memref
		

! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeLargeX0inT
	| memref |
	memref := codegen memRef64: codegen regT indexImm: 1.
	codegen storeDouble: codegen regX0 intoMem: memref
		

! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeLongTinRatA
	| memref |
	memref := codegen memRef32: codegen regR index: codegen regA.
	codegen
		store: codegen regT
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeLongTinRatOffsetA
	| memref |
	memref := codegen memRef32: codegen regR offset: codegen regA.
	codegen store: codegen regT long intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeRinAindex: index
	| memref |
	memref := codegen memRef: codegen regA indexImm: index.
	codegen
		store: codegen regR
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeRinEindex: index
	| memref |
	memref := codegen memRef: codegen regE indexImm: index.
	codegen
		store: codegen regR
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeRinFPindex: index
	| memref |
	memref := codegen memRef: codegen regFP indexImm: index.
	codegen
		store: codegen regR
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeRinSindex: index
	| memref |
	memref := codegen memRef: codegen regS indexImm: index.
	codegen
		store: codegen regR
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeRinTindex: index
	| memref |
	memref := codegen memRef: codegen regT indexImm: index.
	codegen
		store: codegen regR
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeShortAinRoffset: offset
	|  memref |
	memref := codegen memRef16: codegen regR offsetImm: offset.
	codegen store: codegen regA short intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeShortTinRatOffsetA
	| memref |
	memref := codegen memRef16: codegen regR offset: codegen regA.
	codegen store: codegen regT short intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeSinRindex: index
	| memref |
	memref := codegen memRef: codegen regR indexImm: index.
	codegen
		store: codegen regS
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeTinRatA
	| memref |
	memref := codegen memRef: codegen regR index: codegen regA.
	codegen
		store: codegen regT
		intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeTinRatOffsetA
	| memref |
	memref := codegen memRef: codegen regR offset: codegen regA.
	codegen store: codegen regT intoMem: memref
! !

!Assembler methodsFor: 'storing' stamp: 'KenD 9/26/2022 12:38:17'!
storeTinRindex: index
	| memref |
	memref := codegen memRef: codegen regR indexImm: index.
	codegen
		store: codegen regT
		intoMem: memref
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfEqualTo: label
	codegen jumpIfEqualTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfGreaterOrEqualSignedTo: label
	codegen jumpIfGreaterOrEqualSignedTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfGreaterSignedTo: label
	codegen jumpIfGreaterSignedTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfLessOrEqualSignedTo: label
	codegen jumpIfLessOrEqualSignedTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfLessSignedTo: label
	codegen jumpIfLessSignedTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfNotEqualTo: label
	codegen jumpIfNotEqualTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfNotZeroTo: label
	codegen jumpIfNotZeroTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfOverflowTo: label
	codegen jumpIfOverflowTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfSignTo: label
	codegen jumpIfSignTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
jumpIfZeroTo: label
	codegen jumpIfZeroTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendByte: reg1 from: reg2 atOffset: offset
	codegen loadZeroExtendByte: reg1 from: reg2 atOffset: offset
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
loop: aBlock times: anInteger
	| loop |
	loop := self newLabel.
	self loadTwithImmediate: anInteger; @ loop.
	aBlock value.
	self dec: codegen regT; shortJumpIfNotZeroTo: loop
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
loopTtimes: aBlock
	| loop end |
	loop := self newLabel.
	end := self newLabel.
	self
		compareTwithImmediate: 0;
		@ loop;
		shortJumpIfEqualTo: end.
	aBlock value.
	self
		dec: codegen regT;
		shortJumpTo: loop;
		@ end
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
renameByteRegisterIfNeeded: register preserving: preserved during: aBlock
	codegen renameByteRegisterIfNeeded: register preserving: preserved during: aBlock
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
return
	codegen return
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpIfCarryTo: label
	codegen shortJumpIfCarryTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpIfEqualTo: label
	codegen shortJumpIfEqualTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpIfNotCarryTo: label
	codegen shortJumpIfNotCarryTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpIfNotEqualTo: label
	codegen shortJumpIfNotEqualTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpIfNotZeroTo: label
	self shortJumpIfNotEqualTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpIfSignTo: label
	codegen shortJumpIfSignTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpIfZeroTo: label
	self shortJumpIfEqualTo: label
! !

!Assembler methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:38:17'!
shortJumpTo: label
	codegen shortJumpTo: label
! !

!Assembler methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:17'!
jumpOver: aBlock
	| label |
	label := self newLabel.
	self jumpTo: label.
	aBlock value.
	self @ label
! !

!Assembler methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:17'!
jumpTo: label
	codegen jumpTo: label
! !

!Assembler methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:17'!
jumpToMindex: index
	| memref |
	memref := codegen memRef: codegen regM indexImm: index.
	codegen jumpToMem: memref
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledIntegerBitTestOf: aRegister
	| label |
	self testIntegerBitOf: aRegister.
	label := self newLabel.
	self shortJumpIfZeroTo: label.
	^label
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledIntegerBitTestOfR
	^self labeledIntegerBitTestOf: codegen regR

! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledIntegerBitTestOfT
	^self labeledIntegerBitTestOf: codegen regT byte
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledIntegerNativizationOf: aRegister
	| label |
	self convertToNativeInteger: aRegister.
	label := self newLabel.
	self shortJumpIfNotCarryTo: label.
	^label
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledIntegerNativizationOfA
	^self labeledIntegerNativizationOf: codegen regA
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledIntegerNativizationOfR
	^self labeledIntegerNativizationOf: codegen regR
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledIntegerNativizationOfT
	^self labeledIntegerNativizationOf: codegen regT
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledNonIntegerBitTestOf: aRegister
	| label |
	self testIntegerBitOf: aRegister.
	label := self newLabel.
	self shortJumpIfNotZeroTo: label.
	^label
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
labeledNonIntegerBitTestOfR
	^self labeledNonIntegerBitTestOf: codegen regR

! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithImmediate: imm
	self load: codegen regA withImmediate: imm
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadAwithSmallInteger: anInteger
	| smi |
	smi := (anInteger bitShift: 1) + 1.
	self loadAwithImmediate: smi
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithImmediate: imm
	self load: codegen regR withImmediate: imm
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithRatA
	| memref |
	memref := codegen memRef: codegen regR index: codegen regA.
	self
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadRwithSmallInteger: anInteger
	| smi |
	smi := self smallInteger: anInteger.
	self loadRwithImmediate: smi
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadTwithImmediate: imm
	self load: codegen regT withImmediate: imm
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendByteRwithRatA
	self loadZeroExtendByte: codegen regR from: codegen regR atIndexAt: codegen regA
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendByteRwithRindex: index
	#dontOptimize.
	self loadZeroExtendByte: codegen regR from: codegen regR atIndexImm: index
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendByteRwithSPatA
	self loadZeroExtendByte: codegen regR from: codegen regSP atIndexAt: codegen regA
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendByteTwithAindex: index
	#dontOptimize.
	self loadZeroExtendByte: codegen regT from: codegen regA atIndexImm: index
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendLongRwithRatA
	| memref |
	memref := codegen memRef32: codegen regR index: codegen regA.
	codegen
		load: codegen regR
		fromMem: memref
! !

!Assembler methodsFor: 'integers' stamp: 'KenD 9/26/2022 12:38:17'!
loadZeroExtendLongRwithRindex: index
	| memref |
	#dontOptimize.
	memref := codegen memRef32: codegen regR indexImm: index.
	codegen
		load: codegen regR e
		fromMem: memref
! !

!Assembler methodsFor: 'memory - load / store' stamp: 'KenD 9/26/2022 12:38:17'!
load: dstReg fromMem: srcMemRef
	^codegen load: dstReg fromMem: srcMemRef

! !

!Assembler methodsFor: 'memory - load / store' stamp: 'KenD 9/26/2022 12:38:17'!
store: srcReg intoMem: dstMemRef
	^ codegen store: srcReg intoMem: dstMemRef
! !

!Assembler methodsFor: 'memory - load / store' stamp: 'KenD 9/26/2022 12:38:17'!
storeImm: imm intoMem: dstMemRef
	"Store constant into memory location `dstMemRef`. 

	 The size of data loaded is specified in `dstMemRef`"

	self
		moveImm: imm to: self regV;
		store: self regV intoMem: dstMemRef
! !

!Assembler methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:17'!
memRef
	"Return clean instance of pointer-sized memory reference"

	^ codegen memRef

! !

!Assembler methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:17'!
memRef32: baseReg indexImm: indexImm
	^ codegen memRef32: baseReg indexImm: indexImm
! !

!Assembler methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:17'!
memRef8
	"Return clean instance of byte-sized memory reference"

	^ codegen memRef8
! !

!Assembler methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:17'!
memRef8: baseReg index: indexReg
	^ codegen memRef8: baseReg index: indexReg
! !

!Assembler methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:17'!
memRef: baseReg index: indexReg
	^ codegen memRef: baseReg index: indexReg
! !

!Assembler methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:17'!
memRef: baseReg indexImm: indexImm
	^ codegen memRef: baseReg indexImm: indexImm
! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regA
	^codegen regA

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regA8
	^ codegen regA byte

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regE
	^ codegen regE
! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regFP
	^ codegen regFP

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regFalse
	^ codegen regFalse

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regG
	^ codegen regG

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regIP
	^ codegen regIP

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regM
	^ codegen regM

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regNil
	^ codegen regNil

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regR
	^ codegen regR

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regR8
	^ codegen regR byte

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regS
	^ codegen regS
! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regSP
	^ codegen regSP

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regT
	^ codegen regT
! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regT8
	^ codegen reg byte
! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regTrue
	^ codegen regTrue

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regV
	^ codegen regV

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regX0
	"IEEE 754 double register"
	^ codegen regX0

! !

!Assembler methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:17'!
regX1
	"IEEE 754 double register"
	^ codegen regX1
! !

!Assembler methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:17'!
platform: aNativizationPlatform
	codegen := aNativizationPlatform newCodeGenerator.
	self reset
! !

!Assembler methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:17'!
reset
	labels := Dictionary new: 100.
	literals := OrderedCollection new.
	codegen reset
! !

!Assembler methodsFor: 'epilogue' stamp: 'KenD 9/26/2022 12:38:17'!
restoreCallerEnvironment
	self loadEwithFPindex: -2
! !

!Assembler methodsFor: 'epilogue' stamp: 'KenD 9/26/2022 12:38:17'!
restoreCallerFrame
	codegen
		move: codegen regFP to: codegen regSP;
		pop: codegen regFP
! !

!Assembler methodsFor: 'epilogue' stamp: 'KenD 9/26/2022 12:38:17'!
restoreCallerM
	self loadMwithFPindex: -1
! !

!Assembler methodsFor: 'epilogue' stamp: 'KenD 9/26/2022 12:38:17'!
restoreCallerSelf
	self loadSwithFPindex: 0
! !

!Assembler class methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:17'!
growIndexedLabelsTo: anInteger
	| new |
	new := (IndexedLabels size + 1 to: anInteger)
		collect: [:i | ('@' , i asString) asSymbol].
	IndexedLabels := IndexedLabels , new
! !

!Assembler class methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:17'!
initialize
	self initializeIndexedLabels
	
! !

!Assembler class methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:17'!
initializeIndexedLabels
	IndexedLabels := #().
	self growIndexedLabelsTo: 100
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
addAtoR
	self assembleBytes: #[16r48 16r1 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
addDoubleX1toX0
	self assembleBytes: #[16rF2 16rF 16r58 16rC1].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
addTtoR
	self assembleBytes: #[16r48 16r1 16rC8].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
assembleByte: anInteger
	codegen assembleByte: anInteger
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
assembleBytes: aByteArray
	codegen assembleBytes: aByteArray
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
assembleBytes: value count: count
	codegen assembleBytes: value count: count

! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
divideDoubleX0byX1
	self assembleBytes: #[16rF2 16rF 16r5E 16rC1].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
extendRtoAandDividebyT
	self assembleBytes: #[16r48 16r99 16r48 16rF7 16rF9].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
lock
	self assembleBytes: #[16rF0].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
multiplyDoubleX0byX1
	self assembleBytes: #[16rF2 16rF 16r59 16rC1].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
multiplyRbyAwideningToA
	self assembleBytes: #[16r48 16rF7 16rEA].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
shiftLeftRwithT
	self assembleBytes: #[16r48 16rD3 16rE0].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
shiftRightRwithT
	self assembleBytes: #[16r48 16rD3 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
sqrtDoubleX0
	self assembleBytes: #[16rF2 16rF 16r51 16rC0].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
subAfromR
	self assembleBytes: #[16r48 16r29 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
subAfromT
	self assembleBytes: #[16r48 16r29 16rD1].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
subDoubleX1fromX0
	self assembleBytes: #[16rF2 16rF 16r5C 16rC1].
	
! !

!AMD64TemplateAssembler methodsFor: 'arithmetic' stamp: 'KenD 11/22/2023 13:44:21'!
subTslotsToSP
	self assembleBytes: #[16r48 16rF7 16rD9 16r48 16r8D 16r24 16rCC 16r48 16rF7 16rD9].
	
! !

!AMD64TemplateAssembler methodsFor: 'logic' stamp: 'KenD 11/22/2023 13:44:21'!
addSPwithImmediate: imm
	(-128 <= imm and: [ imm < 128 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r83 16rC4];
				assembleByte: imm ].
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r81 16rC4];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r49 16rBB];
		assembleBytes: imm count: 8;
		assembleBytes: #[16r4C 16r1 16rDC]
! !

!AMD64TemplateAssembler methodsFor: 'logic' stamp: 'KenD 11/22/2023 13:44:21'!
andRwithA
	self assembleBytes: #[16r48 16r21 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'logic' stamp: 'KenD 11/22/2023 13:44:21'!
andRwithImmediate: imm
	(-128 <= imm and: [ imm < 128 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r83 16rE0];
				assembleByte: imm ].
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r25];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r49 16rBB];
		assembleBytes: imm count: 8;
		assembleBytes: #[16r4C 16r21 16rD8]
! !

!AMD64TemplateAssembler methodsFor: 'logic' stamp: 'KenD 11/22/2023 13:44:21'!
orRwithA
	self assembleBytes: #[16r48 16r9 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'logic' stamp: 'KenD 11/22/2023 13:44:21'!
xorAwithR
	self assembleBytes: #[16r48 16r31 16rC2].
	
! !

!AMD64TemplateAssembler methodsFor: 'logic' stamp: 'KenD 11/22/2023 13:44:21'!
xorFPwithFP
	self assembleBytes: #[16r48 16r31 16rED].
	
! !

!AMD64TemplateAssembler methodsFor: 'logic' stamp: 'KenD 11/22/2023 13:44:21'!
xorRwithA
	self assembleBytes: #[16r48 16r31 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'private' stamp: 'KenD 11/22/2023 13:44:21'!
buildFrame
	self assembleBytes: #[16r55 16r48 16r89 16rE5].
	
! !

!AMD64TemplateAssembler methodsFor: 'private' stamp: 'KenD 11/22/2023 13:44:21'!
callIndirectA
	self assembleBytes: #[16rFF 16r12].
	
! !

!AMD64TemplateAssembler methodsFor: 'private' stamp: 'KenD 11/22/2023 13:44:21'!
callR
	self assembleBytes: #[16rFF 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'private' stamp: 'KenD 11/22/2023 13:44:21'!
initializeS
	self assembleBytes: #[16r48 16r89 16rC6].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
clearFPUFlags
	self assembleBytes: #[16rDB 16rE2].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
compareEqualDoubleX0withAindirect
	self assembleBytes: #[16rF2 16rF 16rC2 16r2 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
compareLessThanDoubleX0withAindirect
	self assembleBytes: #[16rF2 16rF 16rC2 16r2 16r1].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
compareSwithTindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r3B 16r31]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r3B 16r71];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r3B 16rB1];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
dropTopOfFPU
	self assembleBytes: #[16rDD 16rD8].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
exchangeRindirectWithT
	self assembleBytes: #[16r48 16r87 16r8].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithAindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r12]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r52];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r92];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithEindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r17]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r57];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r97];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithFPindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r55 16r0]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r55];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r95];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithFalse
	self assembleBytes: #[16r4C 16r89 16rF2]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithImmediate: imm
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16rC7 16rC2];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r48 16rBA];
		assembleBytes: imm count: 8
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithNil
	self assembleBytes: #[16r4C 16r89 16rE2]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithR
	self assembleBytes: #[16r48 16r89 16rC2].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithRoffsetAtA
	self assembleBytes: #[16r48 16r8B 16r14 16r10].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithS
	self assembleBytes: #[16r48 16r89 16rF2].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithSindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r16]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r56];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r96];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadAwithTrue
	self assembleBytes: #[16r4C 16r89 16rEA]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadEwithFPindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r7D 16r0]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r7D];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16rBD];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadEwithR
	self assembleBytes: #[16r48 16r89 16rC7].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadFPwithR
	self assembleBytes: #[16r48 16r89 16rC5].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadFPwithSP
	self assembleBytes: #[16r48 16r89 16rE5].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadLargeX0withRindirect
	self assembleBytes: #[16r66 16r48 16rF 16r6E 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadLargeX1withAindirect
	self assembleBytes: #[16r66 16r48 16rF 16r6E 16rA].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadLongRwithRatOffsetA
	self assembleBytes: #[16r8B 16r4 16r10].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadMXCSRfromA
	self assembleBytes: #[16rF 16rAE 16r12].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRconvertingDoublePointedByR
	self assembleBytes: #[16rF2 16r48 16rF 16r2C 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithA
	self assembleBytes: #[16r48 16r89 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithArgPointer
	self assembleBytes: #[16r48 16r8D 16r45 16r10].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithE
	self assembleBytes: #[16r48 16r89 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithEindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r7]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r47];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r87];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithFP
	self assembleBytes: #[16r48 16r89 16rE8].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithFPindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r45 16r0]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r45];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r85];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithFalse
	self assembleBytes: #[16r4C 16r89 16rF0]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithImmediate: imm
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16rC7 16rC0];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r48 16rB8];
		assembleBytes: imm count: 8
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithM
	self assembleBytes: #[16r48 16r89 16rD8]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithMindex: index
	| offset |
	offset := (index - 1) * wordSize.
	offset = 0
		ifTrue: [ ^ self assembleBytes: #[16r48 16r8B 16r03] ].
	(-128 <= offset and: [ offset < 128 ])
		ifTrue: [ self
				assembleBytes: #[16r48 16r8B 16r43];
				assembleByte: offset ]
		ifFalse: [ self
				assembleBytes: #[16r48 16r8B 16r83];
				assembleBytes: offset count: 4 ]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithNil
	self assembleBytes: #[16r4C 16r89 16rE0]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithRatOffsetA
	self assembleBytes: #[16r48 16r8B 16r4 16r10].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithRindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r0]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r40];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r80];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithS
	self assembleBytes: #[16r48 16r89 16rF0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithSPindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r4 16r24]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r44 16r24];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r84 16r24];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithSindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r6]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r46];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r86];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithT
	self assembleBytes: #[16r48 16r89 16rC8].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithTrue
	self assembleBytes: #[16r4C 16r89 16rE8]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadSPwithFP
	self assembleBytes: #[16r48 16r89 16rEC].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadSwithFPindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r75 16r0]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r75];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16rB5];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadSwithRindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r30]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r70];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16rB0];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadTwithA
	self assembleBytes: #[16r48 16r89 16rD1].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadTwithAindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16rA]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r4A];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r8A];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadTwithEindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16rF]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r4F];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r8F];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadTwithFPindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r4D 16r0]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r4D];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r8D];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadTwithImmediate: imm
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16rC7 16rC1];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r48 16rB9];
		assembleBytes: imm count: 8
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadTwithR
	self assembleBytes: #[16r48 16r89 16rC1].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadTwithTindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r8B 16r9]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r8B 16r49];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r8B 16r89];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
loadX0withRasDouble
	self assembleBytes: #[16rF2 16r48 16rF 16r2A 16rC0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
moveX0toR
	self assembleBytes: #[16r66 16r48 16rF 16r7E 16rC0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
pushAOnFPUStack
	self assembleBytes: #[16rDD 16r2].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
pushROnFPUStack
	self assembleBytes: #[16rDD 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
roundDoubleX0intoX1
	self assembleBytes: #[16r66 16rF 16r3A 16rB 16rC8 16r3].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
saveCallerFrame
	self assembleBytes: #[16r55 16r48 16r89 16rE5].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
scaleFloatOnRWithA
	self assembleBytes: #[16rDD 16r2 16rDD 16r0 16rD9 16rFD 16rDD 16r18 16rDD 16rD8].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
storeLargeX0inA
	self assembleBytes: #[16r66 16r48 16rF 16r7E 16r2].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
storeLargeX0inT
	self assembleBytes: #[16r66 16r48 16rF 16r7E 16r1].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
storeMXCSRintoA
	self assembleBytes: #[16rF 16rAE 16r1A].
	
! !

!AMD64TemplateAssembler methodsFor: 'loading' stamp: 'KenD 11/22/2023 13:44:21'!
testRwithR
	self assembleBytes: #[16r48 16r85 16rC0].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
clearRhigh32
	self assembleBytes: #[16r89 16rC0].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
clearRintegerBit
	self assembleBytes: #[16r48 16rFF 16rC8].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
clearSafeRintegerBit
	self assembleBytes: #[16r24 16rFE].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
convertAtoNativeInteger
	self assembleBytes: #[16r48 16rD1 16rFA].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
convertRtoNativeInteger
	self assembleBytes: #[16r48 16rD1 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
convertRtoSmallInteger
	self assembleBytes: #[16r48 16rD1 16rE0 16r48 16rFF 16rC0].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
convertTtoNativeInteger
	self assembleBytes: #[16r48 16rD1 16rF9].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
loadEwithAddressOfRatA
	self assembleBytes: #[16r48 16r8D 16r7C 16rD0 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithRatA
	self assembleBytes: #[16r48 16r8B 16r44 16rD0 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
loadSwithAddressOfSatA
	self assembleBytes: #[16r48 16r8D 16r74 16rD6 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
loadZeroExtendByteRwithRatA
	self assembleBytes: #[16r48 16rF 16rB6 16r44 16r10 16rFF].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
loadZeroExtendByteRwithSPatA
	self assembleBytes: #[16r48 16rF 16rB6 16r44 16r14 16rFF].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
loadZeroExtendLongRwithRatA
	self assembleBytes: #[16r8B 16r44 16r90 16rFC].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
setRintegerBit
	self assembleBytes: #[16rC 16r1].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
setSafeRintegerBit
	self assembleBytes: #[16rC 16r1].
	
! !

!AMD64TemplateAssembler methodsFor: 'integers' stamp: 'KenD 11/22/2023 13:44:21'!
testRintegerBit
	self assembleBytes: #[16rA8 16r1].
	
! !

!AMD64TemplateAssembler methodsFor: 'comparing' stamp: 'KenD 11/22/2023 13:44:21'!
compareRwithA
	self assembleBytes: #[16r48 16r39 16rD0].
	
! !

!AMD64TemplateAssembler methodsFor: 'comparing' stamp: 'KenD 11/22/2023 13:44:21'!
compareRwithImmediate: imm
	(-128 <= imm and: [ imm < 128 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r83 16rF8];
				assembleByte: imm ].
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r3D];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r49 16rBB];
		assembleBytes: imm count: 8;
		assembleBytes: #[16r4C 16r39 16rD8]
! !

!AMD64TemplateAssembler methodsFor: 'comparing' stamp: 'KenD 11/22/2023 13:44:21'!
compareTwithImmediate: imm
	(-128 <= imm and: [ imm < 128 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r83 16rF9];
				assembleByte: imm ].
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r48 16r81 16rF9];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r49 16rBB];
		assembleBytes: imm count: 8;
		assembleBytes: #[16r4C 16r39 16rD9]
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
loadMwithA
	self assembleBytes: #[16r48 16r89 16rD3]
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
popA
	self assembleBytes: #[16r5A].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
popE
	self assembleBytes: #[16r5F].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
popFP
	self assembleBytes: #[16r5D].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
popR
	self assembleBytes: #[16r58].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
popS
	self assembleBytes: #[16r5E].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
popSPindirect
	self assembleBytes: #[16r8F 16r4 16r24].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
popT
	self assembleBytes: #[16r59].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushA
	self assembleBytes: #[16r52].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushE
	self assembleBytes: #[16r57].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushFP
	self assembleBytes: #[16r55].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushImmediate: imm
	(-128 <= imm and: [ imm < 128 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r6A];
				assembleByte: imm ].
	(-16r80000000 <= imm and: [ imm < 16r80000000 ])
		ifTrue: [ ^ self
				assembleBytes: #[16r68];
				assembleBytes: imm count: 4 ].
	self
		assembleBytes: #[16r49 16rBB];
		assembleBytes: imm count: 8;
		assembleBytes: #[16r41 16r53]
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushIndirectR
	self assembleBytes: #[16rFF 16r30].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushR
	self assembleBytes: #[16r50].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushS
	self assembleBytes: #[16r56].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
pushT
	self assembleBytes: #[16r51].
	
! !

!AMD64TemplateAssembler methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 13:44:21'!
storeDoubleResultInRindirect
	self assembleBytes: #[16r66 16r48 16rF 16r7E 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithTIBatR
	self assembleBytes: #[16r65 16r48 16r8B 16r4 16rC5 16r0 16r0 16r0 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
loadRwithThreadVariableAtR
	self assembleBytes: #[16r65 16r48 16r8B 16r4 16rC5 16r80 16r14 16r0 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeAinThreadVariableAtIndexR
	self assembleBytes: #[16r65 16r48 16r89 16r14 16rC5 16r80 16r14 16r0 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeAinTindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r11]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r51];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16r91];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeByteTinRatA
	self assembleBytes: #[16r88 16r4C 16r10 16rFF].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeEinRindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r38]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r78];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16rB8];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeLongTinRatA
	self assembleBytes: #[16r89 16r4C 16r90 16rFC].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeLongTinRatOffsetA
	self assembleBytes: #[16r89 16rC 16r10].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeRinAindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r2]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r42];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16r82];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeRinEindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r7]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r47];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16r87];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeRinFPindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r45 16r0]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r45];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16r85];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeRinSindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r6]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r46];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16r86];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeRinTindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r1]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r41];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16r81];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeShortTinRatOffsetA
	self assembleBytes: #[16r66 16r89 16rC 16r10].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeSinRindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r30]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r70];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16rB0];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeTIBatRwithA
	self assembleBytes: #[16r65 16r48 16r89 16r14 16rC5 16r0 16r0 16r0 16r0].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeTinRatA
	self assembleBytes: #[16r48 16r89 16r4C 16rD0 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeTinRatOffsetA
	self assembleBytes: #[16r48 16r89 16rC 16r10].
	
! !

!AMD64TemplateAssembler methodsFor: 'storing' stamp: 'KenD 11/22/2023 13:44:21'!
storeTinRindex: index
	| offset |
	offset := index - 1 * wordSize.
	offset = 0 ifTrue: [^self assembleBytes: #[16r48 16r89 16r8]].
	(-128 <= offset and: [offset < 128])
		 ifTrue: [
			self
				assembleBytes: #[16r48 16r89 16r48];
		 		assembleByte: offset]
		ifFalse: [ 
			self
				assembleBytes: #[16r48 16r89 16r88];
				assembleBytes: offset count: 4]
! !

!AMD64TemplateAssembler methodsFor: 'opcodes - integer related' stamp: 'KenD 11/22/2023 13:44:21'!
moveTslots
	self assembleBytes: #[16rF3 16r48 16rA5].
	
! !

!AMD64TemplateAssembler methodsFor: 'opcodes - integer related' stamp: 'KenD 11/22/2023 13:44:21'!
writeTslots
	self assembleBytes: #[16rF3 16r48 16rAB].
	
! !

!AMD64TemplateAssembler methodsFor: 'epilogue' stamp: 'KenD 11/22/2023 13:44:21'!
restoreCallerEnvironment
	self assembleBytes: #[16r48 16r8B 16r7D 16rE8].
	
! !

!AMD64TemplateAssembler methodsFor: 'epilogue' stamp: 'KenD 11/22/2023 13:44:21'!
restoreCallerFrame
	self assembleBytes: #[16r48 16r89 16rEC 16r5D].
	
! !

!AMD64TemplateAssembler methodsFor: 'epilogue' stamp: 'KenD 11/22/2023 13:44:21'!
restoreCallerM
	self assembleBytes: #[16r48 16r8B 16r5D 16rF0]
! !

!AMD64TemplateAssembler methodsFor: 'epilogue' stamp: 'KenD 11/22/2023 13:44:21'!
restoreCallerSelf
	self assembleBytes: #[16r48 16r8B 16r75 16rF8].
	
! !

!AMD64TemplateAssembler methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:44:21'!
platform: aNativizationPlatform
	super platform: aNativizationPlatform.
	wordSize := aNativizationPlatform wordSize.
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
add: source1 to: source2andDest
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
addImm: imm to: dest
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
and: source1andDest with: source2
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
and: source1andDest withImm: imm
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
breakpoint
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
call: srcReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
clearHigh32: srcAndDstReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
compare: reg1 with: reg2
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
compare: reg1 withImm: imm
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
compare: reg1 withMem: aMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
convert: src toDouble: dst
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
dec: srcAndDstReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
decMem: aMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
divDouble: src1andDstReg by: src2reg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
divide: srcAndDstReg extendingTo: extReg by: divisorReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
exchange: srcAndDstReg withMem: aMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
inc: srcAndDstReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
jumpTo: label
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
jumpToMem: aMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
load: dstReg convertingDoubleToIntegerFromMem: srcMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
load: dstReg withTIBat: indexReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
load: dstReg withThreadVariableAt: indexReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
moveDouble: srcReg into: dstReg
	"move from X-type register srcReg into general purpose dstReg"
	
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
moveImm: imm to: dstReg
	"Load constant to register `dstImm`"

	self subclassResponsibility

! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
mulDouble: src1andDstReg by: src2reg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
multiply: src1AndDstLoReg by: src2reg wideningTo: dstHiReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
or: src1andDest withImm: imm
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
reset
	memory reset
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
shiftLeft: srcAndDst byImm: count
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
shiftRight: srcAndDst byImm: count
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
shiftRightArithmetic: srcAndDst by: countReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
shiftRightArithmetic: srcAndDst byImm: count
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
sqrtDouble: srcReg into: dstReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
sub: src1 from: src2AndDst
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
subDouble: src1 from: src2AndDst
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
subImm: imm from: srcAndDst
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
test: src1Reg with: src2Reg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'basic' stamp: 'KenD 9/26/2022 12:38:32'!
test: srcReg withImm: imm
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 9/26/2022 12:38:32'!
addDouble: source1 to: source2andDest
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 10/23/2022 16:02:56'!
addressBitSize
	"# bytes * 8 bits per byte"
	^self addressSize * 8

! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
addressLength
	^wordSize * 8
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
addressSize
	"Return the size of address in bytes, e.g, 4 for 32bit archs
	 and 8 for 64bit archs"

	^wordSize
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
bytes
	^memory bytes
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
callIndirect: aMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
codeSize
	^memory codeSize
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
memory
	^memory
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
nativeCode
	^ NativeCode new code: memory bytes
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
wordSize
	^wordSize
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/8/2022 14:49:42'!
wordSize: anInteger
	self assert: anInteger == 8.
	wordSize := anInteger.
! !

!CodeGenerator methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:32'!
wordSizeShift
	^wordSize = 8 ifTrue: [3] ifFalse: [2]
! !

!CodeGenerator methodsFor: 'alignment' stamp: 'KenD 9/26/2022 12:38:32'!
alignTo: aNumber
	| current count |
	current := memory position.
	count := (current alignedTo: aNumber) - current.
	self nop: count
! !

!CodeGenerator methodsFor: 'relocation' stamp: 'KenD 9/26/2022 12:38:32'!
baseAddress
	^memory baseAddress
! !

!CodeGenerator methodsFor: 'private' stamp: 'KenD 9/26/2022 12:38:32'!
bitLengthOf: anInteger
	(anInteger between: -16r80 and: 16r7F) ifTrue: [^8].
	(anInteger between: -16r8000 and: 16r7FFF) ifTrue: [^16].
	(anInteger between: -16r80000000 and: 16r7FFFFFFF) ifTrue: [^32].
	(anInteger between: -16r8000000000000000 and: 16r7FFFFFFFFFFFFFFF)
		ifTrue: [^64].
	(anInteger
		between: -16r80000000000000000000000000000000
		and: 16r7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
		ifTrue: [^128].
	^nil
! !

!CodeGenerator methodsFor: 'labels' stamp: 'KenD 9/26/2022 12:38:32'!
currentAddress
	^memory currentAddress
! !

!CodeGenerator methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:32'!
initialize
	memory := RelocatableBuffer new.
! !

!CodeGenerator methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:32'!
platform: aNativizationPlatform
	abi := aNativizationPlatform abi.
	wordSize := aNativizationPlatform wordSize.
! !

!CodeGenerator methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:38:32'!
stream
	^memory stream
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
lea: dstReg withMem: srcMemRef
	^self subclassResponsibility
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
load: dstReg fromMem: srcMemRef
	"Load `dstReg` from memory location `srcMemRef`.
	 The size of data loaded is specified in `srcMemRef`.

	 When loading 32bits into 64bit register, high 32bits must be
	 cleared (in other words, 32bit value is *zero* extended to
	 64bits and stored in `dstReg`.

	 However, when loading 16bits or 8bits, high 48 or 56 bits
	 are *left intact*.

	 This somewhat weird behavior is heritage of x86.
	"

	^ self subclassResponsibility

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
loadDouble: dstReg fromMem: srcMemRef
	"Load 64-bit floating point `dstReg` from memory location `srcMemRef`"
	
	^ self subclassResponsibility
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
memRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:17:07'!
memRef16
	"Return clean instance of memory reference."

	^ self memRef widthInBits: 16; yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:00:34'!
memRef16: baseReg offset: offsetReg
	^ self memRef16
		base: baseReg;
		index: offsetReg;
		yourself
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
memRef16: baseReg offsetImm: offsetImm
	^ self memRef16
		base: baseReg;
		displacement: offsetImm;
		yourself
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:17:12'!
memRef32
	"Return clean instance of memory reference."

	^ self memRef widthInBits: 32; yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:01:18'!
memRef32: baseReg index: indexReg
	^ self memRef32 
		base: baseReg; 
		displacement: -4;
		index: indexReg;
		yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
memRef32: baseReg indexImm: indexImm
	^ self memRef32 
		base: baseReg; 
		displacement: (indexImm - 1) * 4;
		yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:01:32'!
memRef32: baseReg offset: offsetReg
	^ self memRef32
		base: baseReg;
		index: offsetReg;
		yourself
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:05:11'!
memRef64
	"Return clean instance of memory reference."

	^ self memRef "defaults OK"

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
memRef64: baseReg indexImm: indexImm
	^ self memRef64
		base: baseReg;
		displacement: (indexImm - 1) * 8;
		yourself
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:17:18'!
memRef8
	"Answer reference to a single byte"

	^ self memRef widthInBits: 8; yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:06:44'!
memRef8: baseReg index: indexReg
	^ self memRef8 
		base: baseReg; 
		displacement: -1;
		index: indexReg;
		yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
memRef8: baseReg indexImm: indexImm
	^ self memRef8
		base: baseReg; 
		displacement: (indexImm - 1);
		yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:12:02'!
memRef: baseReg index: indexRef
	"Nota Bene: Zero based slot indexing"
	^ self memRef 
		base: baseReg; 
		displacement: (self addressSize negated);
		index: indexRef;
		yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:07:27'!
memRef: baseReg index: indexRef offsetImm: anInteger
	^ self memRef 
		base: baseReg; 
		displacement: anInteger;
		index: indexRef;
		yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:09:56'!
memRef: baseReg indexImm: indexImm
	"Nota Bene: Zero based slot indexing"
	^ self memRef 
		base: baseReg; 
		displacement: (indexImm - 1) * self addressSize;
		yourself

! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:08:33'!
memRef: baseReg offset: indexReg
	^ self memRef
		base: baseReg;
		index: indexReg;
		yourself
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
memRefAatT
^self memRef: self regA index: self regT
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
memRefSPatT
	^ self memRef: self regSP index: self regT
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
roundDouble: srcReg into: dstReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
store: srcReg intoMem: dstMemRef
	"Store `srcReg` into memory location `dstMemRef`. 

	 The size of data loaded is specified in `dstMemRef`"
	^self subclassResponsibility
! !

!CodeGenerator methodsFor: 'memory' stamp: 'KenD 9/26/2022 12:38:32'!
storeDouble: srcReg intoMem: dstMemRef
	^ self subclassResponsibility
! !

!CodeGenerator methodsFor: 'services' stamp: 'KenD 9/26/2022 12:38:32'!
move: srcReg to: dstReg
	^ self subclassResponsibility

! !

!CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:32'!
pop: dstReg
	^ self subclassResponsibility

! !

!CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:32'!
popIntoMem: dstMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:32'!
push: srcReg
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:32'!
pushAOnFPUStack
	^ self subclassResponsibility

! !

!CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:32'!
pushImm: imm
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:32'!
pushMem: aMemRef
	self subclassResponsibility
! !

!CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 9/26/2022 12:38:32'!
pushROnFPUStack
	^ self subclassResponsibility

! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regA
	^abi regA
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regE
	^abi regE
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regFP
	^abi regFP
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regFalse
	^abi regFalse
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regG
	^ abi regG
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regIP
	^abi regIP
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regM
	^abi regM
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regNil
	^abi regNil
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regR
	^abi regR
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regS
	^abi regS
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regSP
	^abi regSP
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regT
	^abi regT
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regTrue
	^abi regTrue
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regV
	^abi regV
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regX0
	^ abi regX0
! !

!CodeGenerator methodsFor: 'registers - IR' stamp: 'KenD 9/26/2022 12:38:32'!
regX1
	^ abi regX1
! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
add: src2 to: src1AndDst
	self assemble: 'add' with: src1AndDst with: src2

! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
addDouble: source1 to: source2andDest
	self 
		assemble: 'addsd'
		with: source2andDest
		with: source1

! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
addImm: imm to: src2AndDst
	self assemble: 'add' with: src2AndDst withImm: imm
! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
load: dstReg withTIBat: indexReg
	| seg |
	seg := wordSize = 8
		ifTrue: [ gs ]
		ifFalse: [ fs ].
	pointer
		reset;
		length: self addressLength;
		index: indexReg; 
		scale: wordSize;
		segment: seg.
	self assemble: 'mov' with: dstReg with: pointer
! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
load: dstReg withThreadVariableAt: indexReg
	pointer
		reset;
		length: self addressLength;
		index: indexReg;
		scale: wordSize.
	wordSize = 8
		ifTrue: [ pointer
				segment: gs;
				displacement: 16r1480 ]
		ifFalse: [ pointer
				segment: fs;
				displacement: 16rE10 ].
	self assemble: 'mov' with: dstReg with: pointer
! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
sqrtDouble: srcReg into: dstReg
	self 
		assemble: 'sqrtsd'
		with: srcReg
		with: dstReg
! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
store: srcReg intoTIBat: indexReg
	| seg |
	seg := wordSize = 8
		ifTrue: [ gs ]
		ifFalse: [ fs ].
	pointer
		reset;
		length: self addressLength;
		index: indexReg;
		scale: wordSize;
		segment: seg.
	self assemble: 'mov' with: pointer with: srcReg
! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
sub: src1 from: src2AndDst
	self assemble: 'sub' with: src2AndDst with:  src1

! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
subDouble: src1 from: src2AndDst
	self 
		assemble: 'subsd'
		with: src2AndDst
		with: src1
! !

!AMD64CodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/22/2023 07:58:08'!
subImm: imm from: srcAndDst
	self assemble: 'sub' with: srcAndDst withImm: imm

! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
and: src1AndDst with: source2
	self assemble: 'and' with: src1AndDst with: source2

! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
and: src1AndDst withImm: imm

	(imm between: -128 and: -1) ifTrue: [ 
		"When `imm` is a small negative, we can safely
		 and bits only in lower part of the 64 bit register
		 since higher bits of immediate are all ones anyway.
		 This helps to generate shorter code on x86."
		self assemble: 'and' with: src1AndDst byte withImm: imm
	] ifFalse: [
		self assemble: 'and' with: src1AndDst withImm: imm
	].

! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
call: srcReg
	self assemble: 'call' with: srcReg
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
callIndirect: aMemRef
	self assemble: 'call' with: aMemRef 
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
clearHigh32: srcAndDstReg
	self assemble: 'mov' with: srcAndDstReg e with: srcAndDstReg e
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
exchange: srcAndDstReg withMem: aMemRef
	self assemble: 'xchg' with: aMemRef with: srcAndDstReg
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
or: src1AndDst with: src2
	self assemble: 'or' with: src1AndDst with: src2

! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
or: src1AndDst withImm: imm

	(imm between: 0 and: 127) ifTrue: [ 
		"When `imm` is a small POSITIVE, we can safely
		 or bits only in lower part of the 64 bit register
		 since higher bits of immediate are all zeros anyway.
		 This helps to generate shorter code on x86."
		self assemble: 'or' with: src1AndDst byte withImm: imm
	] ifFalse: [
		self assemble: 'or' with: src1AndDst withImm: imm
	].

! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
shiftLeft: srcAndDst by: countReg
	self ASSERT: countReg r = rcx.
	self assemble: 'sal' with: srcAndDst with: countReg b
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
shiftLeft: srcAndDst byImm: count
	self ASSERT: (count between: 0 and: srcAndDst length - 1).
	self assemble: 'sal' with: srcAndDst withImm: count
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
shiftRight: srcAndDst byImm: count
	self ASSERT: (count between: 0 and: srcAndDst length - 1).
	self assemble: 'shr' with: srcAndDst withImm: count
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
shiftRightArithmetic: srcAndDst by: countReg
	self ASSERT: countReg r = rcx.
	self assemble: 'sar' with: srcAndDst with: countReg b
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
shiftRightArithmetic: srcAndDst byImm: count
	self ASSERT: (count between: 0 and: srcAndDst length - 1).
	self assemble: 'sar' with: srcAndDst withImm: count
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
test: src1Reg with: src2Reg
	self assemble: 'test' with: src1Reg with: src2Reg
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
test: srcReg withImm: imm
	self assemble: 'test' with: srcReg with: imm
! !

!AMD64CodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 11/22/2023 07:58:08'!
xor: src1AndDst with: src2
	self assemble: 'xor' with: src1AndDst with: src2

! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble
	encoder reset; writeEncodingOn: memory
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic
	instruction mnemonic: mnemonic; operands: #().
	self assemble
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic with: op
	| op1 |
	op1 := op isInteger ifTrue: [immediate value: op] ifFalse: [op].
	operands1 at: 1 put: op1.
	instruction mnemonic: mnemonic; operands: operands1.
	self assemble
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic with: op1 with: op2
	| op |
	op := op2 isInteger ifTrue: [immediate value: op2] ifFalse: [op2].
	operands2
		at: 1 put: op1;
		at: 2 put: op.
	instruction mnemonic: mnemonic; operands: operands2.
	self assemble
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic with: op1 with: op2 with: op3
	| op |
	op := op3 isInteger ifTrue: [immediate value: op3] ifFalse: [op3].
	operands3
		at: 1 put: op1;
		at: 2 put: op2;
		at: 3 put: op.
	instruction mnemonic: mnemonic; operands: operands3.
	self assemble
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic with: op1 withImm64: op2
	| v |
	v := self regV.
	self
		assemble: 'mov' with: v with: op2;
		assemble: mnemonic with: op1 with: v
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic with: op1 withImm: imm
	immediate value: imm.
	(immediate length <= 32 or: [mnemonic = 'mov' and: [op1 class == Register]])
		ifTrue: [self assemble: mnemonic with: op1 with: immediate]
		ifFalse: [self assemble: mnemonic with: op1 withImm64: immediate]
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic withImm64: op1
	| v |
	v := self regV.
	self
		assemble: 'mov' with: v with: op1;
		assemble: mnemonic with: v
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic withImm: imm
	immediate value: imm.
	immediate length <= 32
		ifTrue: [self assemble: mnemonic with: immediate]
		ifFalse: [self assemble: mnemonic withImm64: immediate]
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic withReg: reg index: index
	pointer
		reset;
		length: self addressLength;
		base: reg;
		displacement: index - 1 * wordSize.
	self assemble: mnemonic with: pointer
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assemble: mnemonic withReg: dst withReg: src index: index
	pointer
		reset;
		length: self addressLength;
		base: src;
		displacement: index - 1 * wordSize.
	self assemble: mnemonic with: dst with: pointer
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assembleByte: byte
	memory nextBytePut: byte
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assembleBytes: aByteArray
	memory nextBytesPut: aByteArray
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
assembleBytes: value count: count
	self ASSERT: value isInteger.
	self ASSERT:(count == 4 or:[ count == 8 ]).

	count == 4 ifTrue: [
		memory nextLongPut: value
	] ifFalse: [ 
		memory nextLargePut: value
	].

! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
convert: src toDouble: dst
	self assemble: 'cvtsi2sd' with: dst with: src
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
dec: srcAndDstReg
	self assemble: 'dec' with: srcAndDstReg
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
decMem: aMemRef
	self assemble: 'dec' with: aMemRef

! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
divDouble: src1andDstReg by: src2reg
	self 
		assemble: 'divsd'
		with: src1andDstReg
		with: src2reg
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
divide: srcAndDstReg extendingTo: extReg by: divisorReg
	| conversion |
	self
		ASSERT: srcAndDstReg r == rax;
		ASSERT: extReg r == rdx.
	conversion := wordSize = 8
		ifTrue: [ 'cqo' ]
		ifFalse: [ 'cdq' ].
	self
		assemble: conversion;
		assemble: 'idiv' with: divisorReg
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
dropTopOfFPU
	"
	fstp st(0)
	"
	self assembleBytes: #[16rDD 16rD8]
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
inc: srcAndDstReg
	self assemble: 'inc' with: srcAndDstReg
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
lea: dstReg withMem: srcMemRef
	self assemble: 'lea' with: dstReg with: srcMemRef
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
load: dstReg convertingDoubleToIntegerFromMem: srcMemRef
	self assemble: 'cvttsd2si' with: dstReg with: srcMemRef
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
loadZeroExtendShortRwithRoffset: offset
	pointer
		reset;
		length: 16;
		base: self regR;
		displacement: offset.
	self assemble: 'movzx' with: self regR with: pointer
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
lock
	self assembleByte: 16rF0
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
move: srcReg to: dstReg
	self ASSERT: (srcReg class = Register and: [dstReg class = Register]).
	self assemble: 'mov' with: dstReg with: srcReg

! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
moveDouble: srcReg into: dstReg
	| mov |

	mov := wordSize = 8 ifTrue: [
			'movq'
		] ifFalse: [ 'movd' ].
	self 
		assemble: mov
		with: dstReg
		with: srcReg
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
moveImm: imm to: dstReg
	self ASSERT: (imm isInteger and: [dstReg class = Register]).
	self assemble: 'mov' with: dstReg with: imm

! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
mulDouble: src1andDstReg by: src2reg
	self 
		assemble: 'mulsd'
		with: src1andDstReg
		with: src2reg
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
multiply: src1AndDstLoReg by: src2reg wideningTo: dstHiReg
	self
		ASSERT: src1AndDstLoReg r == rax;
		ASSERT: dstHiReg r == rdx.
	self assemble: 'imul' with: src2reg
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
roundDouble: srcReg into: dstReg
	self 
		assemble: 'roundsd'
		with: dstReg
		with: srcReg
		with: 3
! !

!AMD64CodeGenerator methodsFor: 'basic' stamp: 'KenD 11/22/2023 07:58:08'!
store: srcReg intoThreadVariableAt: indexReg
	pointer
		reset;
		length: self addressLength;
		index: indexReg;
		scale: wordSize.
	wordSize = 8
		ifTrue: [ pointer
				segment: gs;
				displacement: 16r1480 ]
		ifFalse: [ pointer
				segment: fs;
				displacement: 16rE10 ].
	self assemble: 'mov' with: pointer with: srcReg
! !

!AMD64CodeGenerator methodsFor: 'debugging' stamp: 'KenD 11/22/2023 07:58:08'!
breakpoint
	self assemble: 'int' with: 3
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
clearFPUFlags
	self assemble: 'fnclex'
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
compareEqualDoubleX0withAindirect
	pointer
		reset;
		length: 64;
		base: self regA.
	self 
		assemble: 'cmpsd'
		with: self regX0
		with: pointer
		with: 0
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
compareLessThanDoubleX0withAindirect
	pointer
		reset;
		length: 64;
		base: self regA.
	self
		assemble: 'cmpsd'
		with: self regX0
		with: pointer
		with: 1
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
loadLongMwithIPoffset: anInteger
	| instsize |
	#dontOptimize.
	instsize := 6.
	pointer
		reset;
		length: 32;
		base: self regIP;
		displacement: anInteger - instsize.
	self assemble: 'mov' with: self regM e with: pointer
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
loadMXCSRfromA
	pointer
		reset;
		length: 32;
		base: self regA.
	self assemble: 'ldmxcsr' with: pointer
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
moveTslots
	| rep mnemonic |
	rep := 16rF3.
	mnemonic := wordSize = 8
		ifTrue: [ 'movsq' ]
		ifFalse: [ 'movsd' ].
	self
		assembleByte: rep;
		assemble: mnemonic
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
readFPUStatusOnA
	pointer
		reset;
		length: 16;
		base: self regA.
	self assemble: 'fstsw' with: pointer
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
renameByteRegisterIfNeeded: register preserving: preserved during: aBlock
	self
		renameByteRegisterIfNeeded: register
		preserving: preserved
		preserving: nil
		during: aBlock
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
renameByteRegisterIfNeeded: register preserving: preserved1 preserving: preserved2 during: aBlock
	| final |
	(self addressSize !!= 4 or: [register byte isLongModeOld8BitRegister not])
		ifTrue: [aBlock value: register]
		ifFalse: [
			final := self renameRegisterPreserving: preserved1 preserving: preserved2.
			self exchange: register e with: final.
			aBlock value: final.
			self exchange: final with: register e]
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
renameRegisterPreserving: preserved1 preserving: preserved2
	preserved1 == self regR
		ifTrue: [preserved2 == self regA
			ifTrue: [^self regT]
			ifFalse: [^self regA]].
	preserved2 == self regR
		ifTrue: [preserved1 == self regA
			ifTrue: [^self regT]
			ifFalse: [^self regA]].
	^self regR
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
scaleFloatOnRWithA
	self
		pushAOnFPUStack;
		pushROnFPUStack;
		assemble: 'fscale'.
	pointer
		reset;
		length: 64;
		base: self regR.
	self
		assemble: 'fstp' with: pointer;
		dropTopOfFPU
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
shiftRight: srcAndDst by: countReg
	self ASSERT: countReg r = rcx.
	self assemble: 'sar' with: srcAndDst with: countReg b
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
storeMXCSRintoA
	pointer
		reset;
		length: 32;
		base: self regA.
	self assemble: 'stmxcsr' with: pointer
! !

!AMD64CodeGenerator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:58:08'!
wordSize: anInteger
	super wordSize: anInteger.
	encoder wordSize: anInteger
! !

!AMD64CodeGenerator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:08'!
compare: reg1 with: reg2
	self assemble: 'cmp' with: reg1 with: reg2
! !

!AMD64CodeGenerator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:08'!
compare: reg1 withImm: imm
	#imm8.
	#imm32.
	self assemble: 'cmp' with: reg1 withImm: imm
! !

!AMD64CodeGenerator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:08'!
compare: reg1 withMem: aMemRef
	self assemble: 'cmp' with: reg1 with: aMemRef
! !

!AMD64CodeGenerator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:08'!
disassembledText32
	^self nativeCode disassembledText32
! !

!AMD64CodeGenerator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:08'!
disassembledText64
	^self nativeCode disassembledText64
! !

!AMD64CodeGenerator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:08'!
exchange: op1 with: op2
	self assemble: 'xchg' with: op1 with: op2
! !

!AMD64CodeGenerator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:58:08'!
testIntegerBit: op1
	| op |
	op := op1 byte.
	(self addressSize = 4 and: [op isLongModeOld8BitRegister])
		ifTrue: [op := op1].
	self assemble: 'test' with: op with: 1
! !

!AMD64CodeGenerator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:58:08'!
initialize
	super initialize.
	instruction := ISAInstruction new.
	operands1 := Array new: 1.
	operands2 := Array new: 2.
	operands3 := Array new: 3.
	immediate := ISAImmediate new.
	pointer := MemoryOperand new.
	encoder := instruction encoder.

! !

!AMD64CodeGenerator methodsFor: 'private - jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jump: mnemonic to: label size: n
	| placeholder end |
	placeholder := 1 bitShift: n - 1 * 8.
	self assemble: mnemonic with: placeholder.
	end := memory position.
	memory
		skip: -1;
		nextPut: 0;
		skip: n negated;
		addRelativeFixup: label size: n;
		position: end
! !

!AMD64CodeGenerator methodsFor: 'private - jumps' stamp: 'KenD 11/22/2023 07:58:08'!
nearJump: mnemonic to: label
	self jump: mnemonic to: label size: 4
! !

!AMD64CodeGenerator methodsFor: 'private - jumps' stamp: 'KenD 11/22/2023 07:58:08'!
shortJump: mnemonic to: label
	self jump: mnemonic to: label size: 1
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfEqualTo: label
	self nearJump: 'jz' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfGreaterOrEqualSignedTo: label
	self nearJump: 'jge' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfGreaterSignedTo: label
	self nearJump: 'jg' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfLessOrEqualSignedTo: label
	self nearJump: 'jle' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfLessSignedTo: label
	self nearJump: 'jl' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfNotEqualTo: label
	self nearJump: 'jnz' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfNotZeroTo: label
	self jumpIfNotEqualTo: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfOverflowTo: label
	self nearJump: 'jo' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfSignTo: label
	self nearJump: 'js' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpIfZeroTo: label
	self jumpIfEqualTo: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
jumpTo: label
	self nearJump: 'jmp' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
shortJumpIfCarryTo: label
	self shortJump: 'jc' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
shortJumpIfEqualTo: label
	self shortJump: 'jz' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
shortJumpIfNotCarryTo: label
	self shortJump: 'jnc' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
shortJumpIfNotEqualTo: label
	self shortJump: 'jnz' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
shortJumpIfSignTo: label
	self shortJump: 'js' to: label
! !

!AMD64CodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/22/2023 07:58:08'!
shortJumpTo: label
	self shortJump: 'jmp' to: label
! !

!AMD64CodeGenerator methodsFor: 'loading' stamp: 'KenD 11/22/2023 07:58:08'!
jumpToMem: aMemRef
	self assemble: 'jmp' with: aMemRef
! !

!AMD64CodeGenerator methodsFor: 'integers' stamp: 'KenD 11/22/2023 07:58:08'!
leadingRzeroCount
	"
	lzcnt is a special x64 extension: it puts the REX
	prefix after the first opcode byte. Our x64 
	encoder doesn't support that, so we fix the
	bytes by hand
	"
	| pos |
	pos := self currentAddress.
	self assemble: 'lzcnt' with: self regR with: self regR.
	memory
		writeByte: 16rF3 at: pos;
		writeByte: 16r48 at: pos + 1
! !

!AMD64CodeGenerator methodsFor: 'memory - load / store' stamp: 'KenD 11/22/2023 07:58:08'!
load: dstReg fromMem: srcMemRef
	| adjusted |
	adjusted := dstReg forLength: srcMemRef length.
	self
		assemble: 'mov'
		with: adjusted
		with: srcMemRef
! !

!AMD64CodeGenerator methodsFor: 'memory - load / store' stamp: 'KenD 11/22/2023 07:58:08'!
loadDouble: dstReg fromMem: srcMemRef
	self ASSERT: srcMemRef sizeInBits == 64.
	self 
		assemble: 'movq'
		with: dstReg
		with: srcMemRef

! !

!AMD64CodeGenerator methodsFor: 'memory - load / store' stamp: 'KenD 11/22/2023 07:58:08'!
store: srcReg intoMem: dstMemRef
	| adjusted |
	adjusted := srcReg forLength: dstMemRef length.
	self
		assemble: 'mov'
		with: dstMemRef
		with: adjusted
! !

!AMD64CodeGenerator methodsFor: 'memory - load / store' stamp: 'KenD 11/22/2023 07:58:08'!
storeDouble: srcReg intoMem: dstMemRef
	self ASSERT: dstMemRef sizeInBits == 64.
	self 
		assemble: 'movq'
		with: dstMemRef
		with: srcReg

! !

!AMD64CodeGenerator methodsFor: 'memory - load / store' stamp: 'KenD 11/22/2023 07:58:08'!
storeDoubleResultIntoMem: dstMemRef
	wordSize = 8
		ifTrue:
			[ self assemble: 'movq' with: dstMemRef  with: self regX0 ]
		ifFalse: [ self assemble: 'fstp' with: dstMemRef ]
! !

!AMD64CodeGenerator methodsFor: 'memory - load / store' stamp: 'KenD 11/22/2023 07:58:08'!
storeImm: imm intoMem: dstMemRef
	self
		assemble: 'mov'
		with: dstMemRef
		withImm: imm

! !

!AMD64CodeGenerator methodsFor: 'storing' stamp: 'KenD 11/22/2023 07:58:08'!
loadZeroExtendByte: reg1 from: reg2 atIndexAt: reg3
	pointer
		reset;
		length: 8;
		base: reg2;
		index: reg3;
		displacement: -1.
	self assemble: 'movzx' with: reg1 with: pointer
! !

!AMD64CodeGenerator methodsFor: 'storing' stamp: 'KenD 11/22/2023 07:58:08'!
loadZeroExtendByte: reg1 from: reg2 atIndexImm: index
	self loadZeroExtendByte: reg1 from: reg2 atOffset: index - 1
! !

!AMD64CodeGenerator methodsFor: 'storing' stamp: 'KenD 11/22/2023 07:58:08'!
loadZeroExtendByte: reg1 from: reg2 atOffset: offset
	pointer
		reset;
		length: 8;
		base: reg2;
		displacement: offset.
	self assemble: 'movzx' with: reg1 with: pointer
! !

!AMD64CodeGenerator methodsFor: 'storing' stamp: 'KenD 11/22/2023 07:58:08'!
storeByte: byte in: reg2 offset: offset
	pointer
		reset;
		length: 8;
		base: reg2;
		displacement: offset.
	self assemble: 'mov' with: pointer with: byte
! !

!AMD64CodeGenerator methodsFor: 'memory' stamp: 'KenD 11/22/2023 07:58:08'!
memRef
	^ MemoryOperand new
		length: self addressBitSize
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop
	self assemble: 'nop'
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop2
	memory nextPutAll: #[16r66 16r90]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop3
	memory nextPutAll: #[16r0F 16r1F 16r00]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop4
	memory nextPutAll: #[16r0F 16r1F 16r40 16r00]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop5
	memory nextPutAll: #[16r0F 16r1F 16r44 16r00 16r00]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop6
	memory nextPutAll: #[16r66 16r0F 16r1F 16r44 16r00 16r00]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop7
	memory nextPutAll: #[16r0F 16r1F 16r80 16r00 16r00 16r00 16r00]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop8
	memory nextPutAll: #[16r0F 16r1F 16r84 16r00 16r00 16r00 16r00 16r00]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop9
	memory nextPutAll: #[16r66 16r0F 16r1F 16r84 16r00 16r00 16r00 16r00 16r00]
! !

!AMD64CodeGenerator methodsFor: 'alignment' stamp: 'KenD 11/22/2023 07:58:08'!
nop: count
	"
	ShellDLL current openWebPage: 'http://www.felixcloutier.com/x86/NOP.html'
	"
	| r |
	r := count.
	r >= 9 ifTrue: [
		r // 9 timesRepeat: [self nop9].
		r := r \\ 9].
	r = 8 ifTrue: [^self nop8].
	r = 7 ifTrue: [^self nop7].
	r = 6 ifTrue: [^self nop6].
	r = 5 ifTrue: [^self nop5].
	r = 4 ifTrue: [^self nop4].
	r = 3 ifTrue: [^self nop3].
	r = 2 ifTrue: [^self nop2].
	r = 1 ifTrue: [^self nop].

! !

!AMD64CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 07:58:08'!
pop: dstReg
	self assemble: 'pop' with: dstReg

! !

!AMD64CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 07:58:08'!
popIntoMem: dstMemRef
	self assemble: 'pop' with: dstMemRef
! !

!AMD64CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 07:58:08'!
push: srcReg
	self assemble: 'push' with: srcReg

! !

!AMD64CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 07:58:08'!
pushAOnFPUStack
	pointer reset; length: 64; base: self regA.
	self assemble: 'fld' with: pointer
! !

!AMD64CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 07:58:08'!
pushImm: imm
	#imm8.
	#imm32.
	self assemble: 'push' withImm: imm
! !

!AMD64CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 07:58:08'!
pushMem: aMemRef
	self push: aMemRef
! !

!AMD64CodeGenerator methodsFor: 'push/pop' stamp: 'KenD 11/22/2023 07:58:08'!
pushROnFPUStack
	pointer reset; length: 64; base: self regR.
	self assemble: 'fld' with: pointer
! !

!AMD64CodeGenerator methodsFor: 'printing & storing' stamp: 'KenD 11/22/2023 07:58:08'!
printOn: aStream
	aStream print: self class; cr; cr;
		nextPutAll: memory bytes disassembledAmd64
! !

!AMD64CodeGenerator methodsFor: 'calls' stamp: 'KenD 11/22/2023 07:58:08'!
return
	self assemble: 'ret'
! !

!AMD64CodeGenerator methodsFor: 'calls' stamp: 'KenD 11/22/2023 07:58:08'!
return: anInteger
	anInteger = 0
		ifTrue: [self assemble: 'ret']
		ifFalse: [self assemble: 'ret' with: anInteger * self addressSize]
! !

!AMD64CodeGenerator methodsFor: 'to-cleanup' stamp: 'KenD 11/22/2023 07:58:08'!
subTslotsToSP
	self assemble: 'neg' with: self regT.
	pointer
		reset;
		length: self addressLength;
		base: self regSP;
		index: self regT;
		scale: self regSP sizeInBytes.
	self
		assemble: 'lea' with: self regSP with: pointer;
		assemble: 'neg' with: self regT
! !

!AMD64CodeGenerator methodsFor: 'to-cleanup' stamp: 'KenD 11/22/2023 07:58:08'!
writeTslots
	| rep mnemonic |
	rep := 16rF3.
	mnemonic := wordSize = 8
		ifTrue: [ 'stosq' ]
		ifFalse: [ 'stosd' ].
	self
		assembleByte: rep;
		assemble: mnemonic
! !

!AMD64CodeGenerator class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:58:08'!
new
	^ self basicNew initialize.

! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:39:12'!
clearHigh32: srcAndDstReg
	self
		shiftLeft: srcAndDstReg byImm: 32;
		shiftRight: srcAndDstReg byImm: 32
! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:39:12'!
dec: srcAndDstReg
	self addImm: -1 to: srcAndDstReg

! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:39:12'!
decMem: aMemRef
	self addImm: -1 toMem: aMemRef

! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:39:12'!
inc: srcAndDstReg
	self addImm: 1 to: srcAndDstReg

! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:39:12'!
pop: srcReg
	| memref |
	memref := self memRef base: self regSP.
	self
		load: srcReg fromMem: memref;
		addImm: wordSize to: self regSP 
! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 10/31/2022 13:48:27'!
push: srcReg
	"Stack is 16 byte aligned, so pushing sometimes adds a pad"
	| memref |
	memref := self memRef base: self regSP; displacement: -8. "Stack grows down"
	self
		store: srcReg intoMem: memref;
		subImm: wordSize from: self regSP 
! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 10/4/2022 13:09:41'!
pushImm: imm
	| memref |
	memref := self memRef base: self regSP; displacement: -8. "Stack grows down"
	self moveImm: imm to: self regV;
		store: self regV intoMem: memref;
		subImm: wordSize from: self regSP 
! !

!RISCCodeGenerator methodsFor: 'jumps' stamp: 'KenD 9/26/2022 12:39:12'!
subImm: anInteger from: srcAndDstReg
	self addImm: anInteger negated to: srcAndDstReg

! !

!RV64GCodeGenerator methodsFor: 'alignment' stamp: 'KenD 10/16/2022 08:52:02'!
noOp
	"Add 32 bits of space to the instruction stream.
	This is required in some cases to keep 64 bit (8 byte) memory address alignment."
	memory nextInstructionPut: 
		(RV64ADDI regDest: RegZero regSource: RegZero imm12: 0).! !

!RV64GCodeGenerator methodsFor: 'alignment' stamp: 'KenD 10/16/2022 08:50:05'!
noOp: count

	"assemble `count` noOps
	 With some CPUs, need NoOps at end of code sequence 
	 to avoid prefetch signalling an illegal instruction (which would never be executed)"
	1 to count do: [
		memory nextInstructionPut: 
			(RV64ADDI regDest: RegZero regSource: RegZero imm12: 0)
	]! !

!RV64GCodeGenerator methodsFor: 'floating point' stamp: 'KenD 10/9/2022 10:53:32'!
addDouble: floatSource1 to: source2andDest

	memory nextInstructionPut: 
		(RV64FADD regDest: source2andDest regA: floatSource1 regB: source2andDest 
					roundingMode: self class defaultRoundingMode).! !

!RV64GCodeGenerator methodsFor: 'floating point' stamp: 'KenD 10/9/2022 11:00:27'!
convert: intReg toDouble: floatReg
	"Convert signed integer from int register intReg into DoubleFLoat floatReg"
	"NB: does do coercion; NOT a bit copy"
	memory nextInstructionPut: 
		(RV64FCVTI2D regDest: floatReg regA: intReg roundingMode: self class defaultRoundingMode).! !

!RV64GCodeGenerator methodsFor: 'floating point' stamp: 'KenD 10/9/2022 11:04:01'!
divDouble: src1andDstReg by: src2reg

	memory nextInstructionPut: 
		(RV64FDIV regDest: src1andDstReg regA: src1andDstReg regB: src2reg 
					roundingMode: self class defaultRoundingMode).! !

!RV64GCodeGenerator methodsFor: 'floating point' stamp: 'KenD 10/9/2022 10:56:21'!
moveDouble: floatRegSrc to: intRegDest
	"move from float register floatRegSrc into general purpose intRegDest"
	"NB: no coercion; just copy the bits"
	memory nextInstructionPut: 
		(RV64FMVD2IR regDest: intRegDest regA: floatRegSrc).
! !

!RV64GCodeGenerator methodsFor: 'initialization' stamp: 'KenD 10/14/2022 13:23:03'!
initialize

	super initialize. "sets memory, a RelocatableBuffer"
	self platform: NativizationPlatform default. "sets abi & wordsize"
	zeroReg  := abi regZero.
	flagsReg := abi regFlags.
	tmp0Reg := abi regTmp0.
	tmp1Reg := abi regTmp1.
	linkReg    := abi regLink.
	
	
	! !

!RV64GCodeGenerator methodsFor: 'initialization' stamp: 'KenD 10/4/2022 11:00:12'!
target: aNativizationTarget
	super target: aNativizationTarget.
	zeroReg := abi regZero.
	flagsReg := abi regFlags.
	tmp1Reg := abi regTmp1.
	linkReg := abi regLink.
! !

!RV64GCodeGenerator methodsFor: 'jumps' stamp: 'KenD 10/5/2022 15:38:44'!
call: srcReg
	"Goto address #srcReg, placing return address in #linkReg"
	memory nextInstructionPut: 
		(RV64JALR destReg: linkReg baseReg: srcReg immedOffset: 0).
! !

!RV64GCodeGenerator methodsFor: 'jumps' stamp: 'KenD 10/5/2022 15:35:26'!
call: srcReg withOffset: imm

	memory nextInstructionPut: 
		(RV64JALR destReg: linkReg baseReg: srcReg immedOffset: imm).
! !

!RV64GCodeGenerator methodsFor: 'jumps' stamp: 'KenD 11/8/2022 15:08:50'!
jumpTo: label
	| offset |
	offset := 0. "assembler labels at: label."
	self halt. "@@FIXME@@"
	self moveImm: offset to: tmp1Reg.
	self add: RegM to: tmp1Reg. "label is offset from Method code"
	self call: RegTmp1.! !

!RV64GCodeGenerator methodsFor: 'jumps' stamp: 'KenD 10/23/2022 14:28:30'!
jumpToMem: memRef

	self lea: RegTmp1 withMem: memRef.
	self call: RegTmp1.! !

!RV64GCodeGenerator methodsFor: 'jumps' stamp: 'KenD 10/5/2022 15:39:50'!
return
	"Return from subroutine"
	"Goto address in #linkReg, remembering nothing"
	memory nextInstructionPut: 
		(RV64JALR regDest: zeroReg regBase: linkReg offset: 0).
! !

!RV64GCodeGenerator methodsFor: 'jumps' stamp: 'KenD 10/13/2022 07:48:59'!
return: imm12offset
	"Return from subroutine"
	"Goto address in #linkReg + offset, remembering nothing"
	
	"Nota Bene: unshifted imm12offset is sign extended and the lowest bit set to zero"
	memory nextInstructionPut: 
		(RV64JALR regDest: zeroReg regBase: linkReg offset: imm12offset).
! !

!RV64GCodeGenerator methodsFor: 'memory' stamp: 'KenD 11/2/2022 13:17:31'!
memRef
	"Default for RV64G is size for 64 bit references."

	^ RVMemoryReference new
		widthInBits: self wordSize * 8;
		yourself
! !

!RV64GCodeGenerator methodsFor: 'memory - load/store' stamp: 'KenD 11/2/2022 08:00:39'!
lea: addressReg withMem: memRef

	"Answer baseRegister + (indexRegister*scale) + offset.
	`indexRegister` may be RegZero (0).
	`scale` may be 1. 2, 4, or 8
	`addressReg` may be tmp1, NEVER tmp0 !!"
	(memRef baseRegister = addressReg)
		ifFalse: [ self move: memRef baseRegister to: addressReg ].
	(memRef offset isZero)
		ifFalse: [ self addImm: memRef offset to: addressReg ].
	(memRef indexRegister isZero)
	ifFalse: [
		(memRef scale = 1)
		ifTrue: [ self add: memRef index to: addressReg 		] 
		ifFalse: [
			memory nextInstructionPut:  "(index * scale) is just a shift"
				(RV64SLLI 		regDest: RegTmp0 regSource: memRef indexRegister imm12: memRef scale).
			memory nextInstructionPut: 
				(RV64ADD regDest: addressReg regA: addressReg regB: RegTmp0).
		]
	]
 	
	! !

!RV64GCodeGenerator methodsFor: 'memory - load/store' stamp: 'KenD 10/22/2022 16:01:46'!
load: dstReg convertingDoubleToIntegerFromMem: srcMemRef
	"Assume signed integer target"
	self loadDouble: FTmp0 fromMem: srcMemRef.
	memory nextInstructionPut: 
			(RV64FCVTD2I 
				regDest: dstReg 
				regA: FTmp0 
				roundingMode: RoundNearestToEven).! !

!RV64GCodeGenerator methodsFor: 'memory - load/store' stamp: 'KenD 11/2/2022 12:51:11'!
load: dstReg fromMem: srcMemRef

	"Load `dstReg` from memory location `srcMemRef`.
	 The size of data loaded is specified in `srcMemRef`.
	
	Nota Bene: Uses BOTH tmp0 and tmp1, 
			 so `dstReg` cannot be either !!
	 
	 When loading 32bits into 64bit register, high 32bits must be
	 cleared (in other words, 32bit value is *zero* extended to
	 64bits and stored in `dstReg`.
	 
	 However, when loading 16bits or 8bits, high 48 or 56 bits
	 are *left intact*.
	 
	 This somewhat weird behavior is heritage of x86."
	
	| bitWidth |
	self lea: RegTmp1 withMem: srcMemRef.
	bitWidth := srcMemRef widthInBits.
	bitWidth isNil ifTrue: [ self error: 'Unknown memory bitWidth' ].
	(bitWidth = 64)
	ifTrue: [ "load 64 bit Double-wide Integer"
		memory nextInstructionPut: 
			(RV64LD regDest: dstReg regBase: RegTmp1 immediateOffset: 0)
	]
	ifFalse: [
		(bitWidth = 32)
		ifTrue: [
			memory nextInstructionPut: 
				(RV64LWU "zero extended Load Word Unsigned"
					regDest: dstReg regBase: RegTmp1 immediateOffset: 0)
		] 
		ifFalse: [
			(bitWidth = 16)
			ifTrue: [
				memory nextInstructionPut: "load 16 bit HalfWord"
					(RV64LHU regDest: tmp0Reg regBase: RegTmp1 immediateOffset: 0).
				memory nextInstructionPut: "shift out lower 16 bits"
					(RV64SRLI destReg: dstReg  regSource: dstReg imm12: 16).
				memory nextInstructionPut: "upper bits back where they started"
					(RV64SLLI destReg: dstReg  regSource: dstReg imm12: 16).
				memory nextInstructionPut: "glue the pieces together"
					(RV64AND regDest: dstReg regA: dstReg regB: tmp0Reg)
			] 
			ifFalse: [
				self assert: (bitWidth = 8).
				memory nextInstructionPut: "load 8 bit Byte"
					(RV64LB regDest: tmp0Reg regBase: RegTmp1 immediateOffset: 0).
				memory nextInstructionPut: "shift out lower 8 bits"
					(RV64SRLI  destReg: dstReg  regSource: dstReg imm12: 8).
				memory nextInstructionPut: "upper bits back where they started"
					(RV64SLLI  destReg: dstReg  regSource: dstReg imm12: 8).
				memory nextInstructionPut: "glue the pieces together"
					(RV64AND regDest: dstReg regA: dstReg regB: tmp0Reg)
			] 
		]
	]
		! !

!RV64GCodeGenerator methodsFor: 'memory - load/store' stamp: 'KenD 10/23/2022 15:32:51'!
loadDouble: dstReg fromMem: srcMemRef
	"Load 64-bit floating point `dstReg` from memory location spec: `srcMemRef`"
	self lea: RegTmp1 withMem: srcMemRef.
	memory nextInstructionPut: 
		(RV64FLD destReg: dstReg baseReg: RegTmp1 immedOffset: 0)! !

!RV64GCodeGenerator methodsFor: 'memory - load/store' stamp: 'KenD 10/23/2022 08:36:53'!
loadReg: destReg withBase: baseReg offset: imm

	(self fitsIn12bits: imm) 
	ifTrue: [
		memory nextInstructionPut: 
			(RV64LD destReg: destReg baseReg: baseReg immedOffset: imm)
	]
	ifFalse: [
		self moveImm: imm to: tmp0Reg.
		memory nextInstructionPut: 
			(RV64ADD regDest: tmp0Reg regA: baseReg regB: tmp0Reg).
		memory nextInstructionPut: 
			(RV64LD destReg: destReg baseReg: tmp0Reg immedOffset: 0)
	]! !

!RV64GCodeGenerator methodsFor: 'memory - load/store' stamp: 'KenD 11/2/2022 07:46:40'!
store: srcReg intoMem: dstMemRef

	"Store `srcReg` value into memory location `dstMemRef`.
	 The bitSize of value is specified in `dstMemRef`.
	
	Nota Bene: Uses BOTH tmp0 and tmp1, 
			 so `srcReg` cannot be either !!"
	
	| bitWidth |
	self lea: RegTmp1 withMem: dstMemRef.
	bitWidth := dstMemRef widthInBits.
	bitWidth isNil ifTrue: [ self error: 'Unknown memory bitWidth' ].
	(bitWidth = 64)
	ifTrue: [ 
		memory nextInstructionPut:  "store 64 bit DoubleWord"
			(RV64SD regSource: srcReg regBase: RegTmp1 immediateOffset: 0)
	]
	ifFalse: [
		(bitWidth = 32)
		ifTrue: [
			memory nextInstructionPut: "store 32 bit Word"
				(RV64SW regSource: srcReg regBase: RegTmp1 immediateOffset: 0)
		] 
		ifFalse: [
			(bitWidth = 16)
			ifTrue: [
				memory nextInstructionPut: "store 16 bit HalfWord"
					(RV64SH regSource: srcReg regBase: RegTmp1 immediateOffset: 0)
			] 
			ifFalse: [
				self assert: (bitWidth = 8).
				memory nextInstructionPut: "store 8 bit Byte"
					(RV64SB regSource: srcReg regBase: RegTmp1 immediateOffset: 0)
			] 
		]
	]
		! !

!RV64GCodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 11/2/2022 07:59:07'!
add: src1Reg to: src2andDstReg
	"Signed Addition with flagsReg nonZero on overflow

	Note overflow check notes in 
	-- https://riscv-programming.org/book/riskbook.html 6.9: Detecting Overflow
	-- RISCV-SPEC section 2.4: Integer Computational Instructions
	"

	 "tmp1Reg to 1 if (regB < 0)"
	memory nextInstructionPut: 
		(RV64SLTI regDest: tmp1Reg regSource: src2andDstReg imm12: 0).
		
	 "Do the addition that may overflow"
	memory nextInstructionPut: 
		(RV64ADD regDest: src2andDstReg regA: src1Reg regB: src2andDstReg).
		
	"set flagsReg to 1 if (regA+regB < regA)"
	memory nextInstructionPut: 
		(RV64SLT regDest: flagsReg regA: src2andDstReg regB: src1Reg).
"
	tmp1   flags   overflow? condition
	 0           0             0         NO-overflow
	 1           1             0         NO-overflow
	 0           1           -1         (regA+regB < regA)
	 1            0            1        (regB < 0)
	
	If (tmp1=flags), flagsReg gets zero, else non-zero 
	(1 or -1, but who cares? Can test if salient. Avoid test+jump to flag Overflow)"
	memory nextInstructionPut: 
		(RV64SUB regDest: flagsReg regA: tmp1Reg regB: flagsReg).

! !

!RV64GCodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 10/14/2022 13:30:39'!
addImm: imm to: srcAndDst
	"Signed Addition with flagsReg nonZero on overflow"
	"Place immediate value into a register and use #add:to:"
	self moveImm: imm to: tmp1Reg. "NB: uses `tmp0Reg` internally, so `tmp1Reg` OK"
	self add: tmp1Reg to: srcAndDst.
! !

!RV64GCodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 10/9/2022 11:09:47'!
dec: srcAndDstReg
	"Decriment register value"
	memory nextInstructionPut: 
		(RV64ADDI regDest: srcAndDstReg regSource: srcAndDstReg imm12: -1).
	! !

!RV64GCodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 10/9/2022 11:09:59'!
inc: srcAndDstReg
	"Incriment register value"
	memory nextInstructionPut: 
		(RV64ADDI regDest: srcAndDstReg regSource: srcAndDstReg imm12: 1).
	! !

!RV64GCodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 10/15/2022 17:01:11'!
sub: src1 from: src2AndDest

	"NB:  destReg := regA - regB"
	self flag: #UnderflowUntested.
	memory nextInstructionPut: 
		(RV64SUB regDest: src2AndDest regA: src2AndDest regB: src1).
! !

!RV64GCodeGenerator methodsFor: 'operations - arithmetic' stamp: 'KenD 10/16/2022 14:08:17'!
subDouble: src1 from: src2AndDest
	"Assume RV64G DoubleFloat registers "
	memory nextInstructionPut: 
		(RV64FSUB regDest: src2AndDest regA: src2AndDest regB: src1). 
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/5/2022 12:43:06'!
and: srcAndDstReg with: source2

	memory nextInstructionPut: 
		(RV64AND regDest: srcAndDstReg regA: srcAndDstReg regB: source2).
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/16/2022 13:51:46'!
and: srcAndDstReg withImm: imm

	(self fitsIn12bits: imm)
	ifTrue: [
		memory nextInstructionPut: 
			(RV64ANDI destReg: srcAndDstReg regSource: srcAndDstReg imm12: imm).
	]
	ifFalse: [
		self moveImm: imm to: tmp0Reg.
		memory nextInstructionPut: 
				(RV64AND regDest: srcAndDstReg regA: srcAndDstReg regB: tmp0Reg).
	].
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/6/2022 16:40:03'!
compare: regA with: regB
	self flag: #CheckSemantics.
	memory nextInstructionPut: 
		(RV64SUB regDest: flagsReg regA: regA regB: regB).
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/16/2022 14:04:39'!
compare: reg1 withImm: imm
	"Just use a register" 
	self moveImm: imm to: tmp0Reg.
	self compare: reg1 with: tmp0Reg 
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/16/2022 13:52:49'!
or: srcAndDstReg withImm: imm

	(self fitsIn12bits: imm)
	ifTrue: [
		memory nextInstructionPut: 
			(RV64ORI destReg: srcAndDstReg regSource: srcAndDstReg imm12: imm).
	]
	ifFalse: [
		self moveImm: imm to: tmp0Reg.
		memory nextInstructionPut: 
				(RV64OR regDest: srcAndDstReg regA: srcAndDstReg regB: tmp0Reg).
	].
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/5/2022 12:30:08'!
shiftLeft: srcAndDstReg by: countReg

	"logical shiift left"
	memory nextInstructionPut: 
		(RV64SLL regDest: srcAndDstReg regA: srcAndDstReg  regB: countReg).
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/16/2022 13:56:25'!
shiftLeft: srcAndDstReg byImm: imm

	"logical shiift left"
	(self fitsIn12bits: imm)
	ifTrue: [
		memory nextInstructionPut: 
			(RV64SLLI regDest: srcAndDstReg regSource: srcAndDstReg  imm12: imm).
	]
	ifFalse: [
		self moveImm: imm to: tmp0Reg.
		memory nextInstructionPut: 
				(RV64SLL regDest: srcAndDstReg regA: srcAndDstReg regB: tmp0Reg).		
	]
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/5/2022 12:34:44'!
shiftRight: srcAndDstReg by: countReg

	"logical shiift right"
	memory nextInstructionPut: 
		(RV64SRL regDest: srcAndDstReg regA: srcAndDstReg regB: countReg ).
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/16/2022 13:58:38'!
shiftRight: srcAndDstReg byImm: imm

	"logical shiift right"
	(self fitsIn12bits: imm)
	ifTrue: [
		memory nextInstructionPut: 
			(RV64SRLI regDest: srcAndDstReg regSource: srcAndDstReg  imm12: imm).
	]
	ifFalse: [
		self moveImm: imm to: tmp0Reg.
		memory nextInstructionPut: 
				(RV64SRL regDest: srcAndDstReg regA: srcAndDstReg regB: tmp0Reg).
	].
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/5/2022 12:32:59'!
shiftRightArithmetic: srcAndDstReg by: countReg

	"arithmetic shiift right; most significant bit duplicated"
	memory nextInstructionPut: 
		(RV64SRA regDest: srcAndDstReg regA: srcAndDstReg  regB: countReg ).
! !

!RV64GCodeGenerator methodsFor: 'operations - logical' stamp: 'KenD 10/16/2022 13:59:18'!
shiftRightArithmetic: srcAndDstReg byImm: imm

	"arithmetic shiift right"
	(self fitsIn12bits: imm)
	ifTrue: [
		memory nextInstructionPut: 
			(RV64SRAI regDest: srcAndDstReg regSource: srcAndDstReg  imm12: imm).
	]
	ifFalse: [
		self moveImm: imm to: tmp0Reg.
		memory nextInstructionPut: 
				(RV64SRA regDest: srcAndDstReg regA: srcAndDstReg regB: tmp0Reg).
	].
! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/16/2022 13:03:38'!
clearReg: reg

	memory nextInstructionPut: 
		(RV64ADDI regDest: reg regSource: zeroReg imm12: 0).
	! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/22/2022 16:25:58'!
loadEwithAddressOfRatA

	self flag: #revisit.
	memory nextInstructionPut: 
			(RV64ADD destReg: RegTmp0 regA: RegR regB: RegA).
	memory nextInstructionPut: 
			(RV64ADDI destReg: RegE regSource: RegTmp0 imm12: wordSize negated)! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/22/2022 16:25:32'!
loadLongMwithIPoffset: anInteger

	self flag: #revisit.
	(self fitsIn12bits: anInteger) 
	ifTrue:  [
		memory nextInstructionPut: 
			(RV64AUIPC regDest: RegM immediate: anInteger)
	]
	ifFalse: [
		memory nextInstructionPut: 
			(RV64AUIPC regDest: RegM immediate: 0).
		self moveImm: anInteger to: tmp1Reg. "NB: uses `tmp0Reg` internally, but `tmp1Reg` OK"
		self add: tmp1Reg to: RegM.
	]! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/21/2022 10:08:52'!
loadMXCSRfromA

	self move: RegA to: flagsReg ! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/22/2022 16:24:55'!
loadRwithArgPointer

	self flag: #revisit.
	memory nextInstructionPut: 
			(RV64ADDI destReg: RegR regSource: RegFP imm12: (2 * self addressSize))! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/22/2022 16:25:15'!
loadSwithAddressOfSatA

	self flag: #revisit.
	memory nextInstructionPut: 
			(RV64ADD destReg: RegTmp0 regA: RegS regB: RegA).
	memory nextInstructionPut: 
			(RV64ADDI destReg: RegS regSource: RegTmp0 imm12: wordSize negated)! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/5/2022 13:04:50'!
move: srcReg to: dstReg

	memory nextInstructionPut:
		(RV64ADDI regDest: dstReg regSource: srcReg imm12: 0).
! !

!RV64GCodeGenerator methodsFor: 'operations - register' stamp: 'KenD 10/16/2022 07:59:06'!
moveImm: imm to: dstReg
	"Load Integer constant to register `dstReg`"

	"Nota Bene: `dstReg` may be `tmp1Reg` so use `tmp0Reg`"
	
	(self fitsIn12bits: imm)
	ifTrue: [ 
		memory nextInstructionPut: 
			(RV64ORI regDest: dstReg regSource: zeroReg imm12: imm).
	]
	ifFalse: [ | bitWidth |
		bitWidth := self bitLengthOf: imm.
		(bitWidth isNil) ifTrue: [self error: 'immediate value does not fit in a register'].
		(bitWidth <= 32) "Fits in 32 bits"
		ifTrue: [
			memory nextInstructionPut: "Upper 20 bits"
				(RV64LUI regDest: dstReg immediate: imm >> 12).
			memory nextInstructionPut: "Lower 12 bits"
				(RV64ORI regDest: dstReg regSource: zeroReg imm12: (imm bitAnd: 16rFFF)).
		]
		ifFalse: [ 	"Fits in 64 bits"
			self assert: (bitWidth <= 64).
			" Upper 32 bits into `tmp0Reg`.
			We know by construction that immediate fits in 32 bits, 
			so following recursive call never tries to use `tmp0Reg` recursively."
			self moveImm: ((imm bitAnd: 16rFFFF0000) >> 32) to: tmp0Reg.
			memory nextInstructionPut:  "shift back into top"
				(RV64SLLI regDest: tmp0Reg regSource: tmp0Reg imm12: 32).
			"Lower 32 bits to `dstReg`"
			self moveImm: (imm bitAnd: 16r0000FFFF) to: dstReg.
			"Or upper and lower bits back together into `dstReg`"
			memory nextInstructionPut: 
				(RV64OR regDest: dstReg regA: dstReg regB: tmp0Reg).
		]
	]
! !

!RV64GCodeGenerator methodsFor: 'registers - internal use only' stamp: 'KenD 10/4/2022 11:00:12'!
regFlags
	^ flagsReg
! !

!RV64GCodeGenerator methodsFor: 'services' stamp: 'KenD 10/16/2022 15:24:13'!
alignTo: aNumber
	| current |
	current := memory position. "Should always be modulo 32"
	self assert: ((current alignedTo: aNumber) = current).
! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:52:32'!
breakpoint
	"System Breakpoint - transfer control to debugger (e.g. gdb)"
	memory nextInstructionPut: (RV64EBREAK new).
! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:54:41'!
syscall: callNumber 
	"Low level Linux Syscall.  Args in a0..a5; call# in a7; result in a0"
	self clearReg: 10. "arg0"
	self clearReg: 11.
	self clearReg: 12.
	self clearReg: 13. "zero unused regs"
	self clearReg: 14.
	self clearReg: 15.
	memory nextInstructionPut: 
		(RV64ADDI regDest: 17 regSource: RegZero imm12: callNumber).
	memory nextInstructionPut: (RV64ECALL new).
	self move: 10 to: RegR.  "Result from A0 into RegR"
	 ! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:54:16'!
syscall: callNumber arg: reg0 
	"Low level Linux Syscall.  Args in a0..a5; call# in a7; result in a0"
	self move: reg0 to: 10. "arg0"
	self clearReg: 11.
	self clearReg: 12.
	self clearReg: 13. "zero unused regs"
	self clearReg: 14.
	self clearReg: 15.
	memory nextInstructionPut: 
		(RV64ADDI regDest: 17 regSource: RegZero imm12: callNumber).
	memory nextInstructionPut: (RV64ECALL new).
	self move: 10 to: RegR.  "Result from A0 into RegR"
	 ! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:54:01'!
syscall: callNumber arg: reg0 arg: reg1 
	"Low level Linux Syscall.  Args in a0..a5; call# in a7; result in a0"
	self move: reg0 to: 10. "arg0"
	self move: reg1 to: 11.
	self clearReg: 12.
	self clearReg: 13. "zero unused regs"
	self clearReg: 14.
	self clearReg: 15.
	memory nextInstructionPut: 
		(RV64ADDI regDest: 17 regSource: RegZero imm12: callNumber).
	memory nextInstructionPut: (RV64ECALL new).
	self move: 10 to: RegR.  "Result from A0 into RegR"
	 ! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:53:30'!
syscall: callNumber arg: reg0 arg: reg1 arg: reg2
	"Low level Linux Syscall.  Args in a0..a5; call# in a7; result in a0"
	self move: reg0 to: 10. "arg0"
	self move: reg1 to: 11.
	self move: reg2 to: 12.
	self clearReg: 13. "zero unused regs"
	self clearReg: 14.
	self clearReg: 15.
	memory nextInstructionPut: 
		(RV64ADDI regDest: 17 regSource: RegZero imm12: callNumber).
	memory nextInstructionPut: (RV64ECALL new).
	self move: 10 to: RegR.  "Result from A0 into RegR"
	 ! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:55:33'!
syscall: callNumber arg: reg0 arg: reg1 arg: reg2 arg: reg3
	"Low level Linux Syscall.  Args in a0..a5; call# in a7; result in a0"
	self move: reg0 to: 10. "arg0"
	self move: reg1 to: 11.
	self move: reg2 to: 12.
	self move: reg3 to: 13.
	self clearReg: 14.
	self clearReg: 15.
	memory nextInstructionPut: 
		(RV64ADDI regDest: 17 regSource: RegZero imm12: callNumber).
	memory nextInstructionPut: (RV64ECALL new).
	self move: 10 to: RegR.  "Result from A0 into RegR"
	 ! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:56:00'!
syscall: callNumber arg: reg0 arg: reg1 arg: reg2 arg: reg3 arg: reg4
	"Low level Linux Syscall.  Args in a0..a5; call# in a7; result in a0"
	self move: reg0 to: 10. "arg0"
	self move: reg1 to: 11.
	self move: reg2 to: 12.
	self move: reg3 to: 13.
	self move: reg4 to: 14.
	self clearReg: 15.
	memory nextInstructionPut: 
		(RV64ADDI regDest: 17 regSource: RegZero imm12: callNumber).
	memory nextInstructionPut: (RV64ECALL new).
	self move: 10 to: RegR.  "Result from A0 into RegR"
	 ! !

!RV64GCodeGenerator methodsFor: 'system calls' stamp: 'KenD 10/5/2022 13:56:25'!
syscall: callNumber arg: reg0 arg: reg1 arg: reg2 arg: reg3 arg: reg4 arg: reg5
	"Low level Linux Syscall.  Args in a0..a5; call# in a7; result in a0"
	self move: reg0 to: 10. "arg0"
	self move: reg1 to: 11.
	self move: reg2 to: 12.
	self move: reg3 to: 13.
	self move: reg4 to: 14.
	self move: reg5 to: 15.
	memory nextInstructionPut: 
		(RV64ADDI regDest: 17 regSource: RegZero imm12: callNumber).
	memory nextInstructionPut: (RV64ECALL new).
	self move: 10 to: RegR.  "Result from A0 into RegR"
	 ! !

!RV64GCodeGenerator methodsFor: 'testing' stamp: 'KenD 10/16/2022 08:06:45'!
fitsIn12bits: anInteger
	"Signed integer `anInteger` fits in immediate12 ?"
	^ (anInteger between: -16r800 and: 16r7FF) ! !

!RV64GCodeGenerator methodsFor: 'testing' stamp: 'KenD 10/16/2022 08:44:02'!
is8byteAligned: integerAddress

	"Does address have lower 3 bits all zero ?"
	^ (integerAddress bitAnd: 02r0111) isZero! !

!RV64GCodeGenerator class methodsFor: 'instance creation' stamp: 'KenD 9/27/2022 13:46:16'!
new
	^ self basicNew initialize.

! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
beAbsolute
	absolute := true
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
classBinding
	^source classBinding
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
for: anObject
	self target: anObject
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
initialize
	absolute := false
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
isAbsolute
	^absolute
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
printOn: aStream
	aStream nextPutAll: 'Ref to '; print: target
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
source: sourceObject
	source := sourceObject
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
sourceOffset
	^sourceOffset
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
sourceOffset: aNumber
	sourceOffset := aNumber
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
target
	^target
! !

!NativeCodeReference methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:38:58'!
target: anObject
	target := anObject
! !

!NativeCodeReference class methodsFor: 'as yet unclassified' stamp: 'KenD 9/26/2022 12:38:58'!
absoluteFor: anObject
	^(self new for: anObject) beAbsolute
! !

!NativeCodeReference class methodsFor: 'instance creation' stamp: 'KenD 9/26/2022 12:38:58'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!RelocatableBuffer methodsFor: 'fixups' stamp: 'KenD 9/26/2022 12:39:25'!
addAbsoluteFixup: label
	| fixup |
	fixup := RelocationFixup absoluteFrom: self currentAddress to: label.
	fixups add: fixup
! !

!RelocatableBuffer methodsFor: 'fixups' stamp: 'KenD 9/26/2022 12:39:25'!
addRelativeFixup: label size: n
	| fixup |
	fixup := RelocationFixup relativeFrom: self currentAddress to: label.
	fixup size: n.
	fixups add: fixup
! !

!RelocatableBuffer methodsFor: 'fixups' stamp: 'KenD 9/26/2022 12:39:25'!
applyFixupsWith: solver
	fixups do: [:fixup | fixup patch: self with: solver]
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
baseAddress
	^address
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
bytes
	^stream contents
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
codeSize
	^stream size
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
currentAddress
	^address + stream position
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
peek
	^stream peek
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
peek: n
	^stream peek: n
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
position
	^stream position
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
position: anInteger
	stream position: anInteger
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
size
	^stream size
! !

!RelocatableBuffer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:25'!
skip: anInteger
	stream skip: anInteger
! !

!RelocatableBuffer methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:39:25'!
initialize
	super initialize.
	fixups := OrderedCollection new.
	address := 0.
	stream := ReadWriteStream on: #[]

! !

!RelocatableBuffer methodsFor: 'initialization' stamp: 'KenD 9/26/2022 12:39:25'!
reset
	fixups := OrderedCollection new.
	stream reset
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 9/26/2022 12:39:25'!
nextBytePut: byte
	| value |
	value := byte < 0 ifTrue: [ byte + 256 ] ifFalse: byte.
	stream nextBytePut: value
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 9/26/2022 12:39:25'!
nextBytesPut: aByteArray
	stream nextBytesPut: aByteArray
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 10/4/2022 16:13:08'!
nextDoublePut: large
	stream nextDoublePut: large

! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 11/2/2022 07:54:35'!
nextInstructionPut: rv64gInstruction
	"Assemble instruction into 4 byte unsigned integer and add to stream"
	stream nextULongPut: rv64gInstruction instruction
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 11/22/2023 13:59:45'!
nextLargePut: large
	stream nextLargePut: large

! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 10/4/2022 16:14:02'!
nextLongPut: long
	"Place 4 byte signed integer into stream"
	stream nextLongPut: long

! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 9/26/2022 12:39:25'!
nextPut: byte
	stream nextPut: byte
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 9/26/2022 12:39:25'!
nextPutAll: aByteArray
	stream nextPutAll: aByteArray
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 10/4/2022 16:21:08'!
nextUDoublePut: udouble
	"Place 8 byte unsigned integer into stream"
	stream nextUDoublePut: udouble

! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 11/22/2023 13:59:45'!
nextULargePut: large
	stream nextULargePut: large

! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 10/4/2022 16:20:53'!
nextULongPut: ulong
	"Place 4 byte unsigned integer into stream"
	stream nextULongPut: ulong
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 9/26/2022 12:39:25'!
stream
	^stream
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 9/26/2022 12:39:25'!
writeByte: byte at: location
	| previous value |
	previous := stream position.
	value := byte < 0 ifTrue: [ byte + 256 ] ifFalse: [ byte ].
	stream
		position: location - address;
		nextBytePut: value;
		position: previous
! !

!RelocatableBuffer methodsFor: 'writing' stamp: 'KenD 9/26/2022 12:39:25'!
writeLong: long at: location
	| previous |
	previous := stream position.
	stream
		position: location - address;
		nextLongPut: long;
		position: previous
! !

!RelocatableBuffer methodsFor: 'relocation' stamp: 'KenD 9/26/2022 12:39:25'!
relocateTo: location with: solver
	| delta |
	delta := location - address.
	address := location.
	fixups do: [:fixup | fixup relocateBy: delta].
	self applyFixupsWith: solver
! !

!RelocatableBuffer methodsFor: 'private' stamp: 'KenD 9/26/2022 12:39:25'!
stream: aStream
	stream := aStream
! !

!RelocatableBuffer class methodsFor: 'instance creation' stamp: 'KenD 9/26/2022 12:39:25'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!RelocationFixup methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:48:28'!
addressSize
	"RV64G is 8 bytes, but original code had 4 ??
	Perhaps used for instruction size, rather than address size??"
	self flag: #revisit.  
	^ RV64GABI wordSize
! !

!RelocationFixup methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:39'!
beAbsolute
	relative := false.
	size := self addressSize
! !

!RelocationFixup methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:39'!
beRelative
	relative := true
! !

!RelocationFixup methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:39'!
from: address1 to: address2
	source := address1.
	target := address2
! !

!RelocationFixup methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:39'!
size: anInteger
	size := anInteger
! !

!RelocationFixup methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:39:39'!
target
	^target
! !

!RelocationFixup methodsFor: 'testing' stamp: 'KenD 9/26/2022 12:39:39'!
isRelative
	^relative
! !

!RelocationFixup methodsFor: 'services' stamp: 'KenD 10/17/2022 11:38:54'!
patch: buffer with: solver
	| delta address |
	address := solver resolveLabel: target.
	self assert: address notNil.
	relative
		ifTrue: [
			delta := address - source - size.
			size = 1
				ifTrue: [buffer writeByte: delta at: source]
				ifFalse: [buffer writeLong: delta at: source]]
		ifFalse: [buffer writeLong: address at: source]
! !

!RelocationFixup methodsFor: 'services' stamp: 'KenD 9/26/2022 12:39:39'!
relocateBy: delta
	source := source + delta
! !

!RelocationFixup methodsFor: 'printing' stamp: 'KenD 9/26/2022 12:39:39'!
printOn: aStream
	aStream
		nextPutAll: self class name;
		nextPut: $:;
		space;
		nextPutAll: target printString
! !

!RelocationFixup class methodsFor: 'instance creation' stamp: 'KenD 9/26/2022 12:39:39'!
absoluteFrom: source to: target
	^self new beAbsolute; from: source to: target
! !

!RelocationFixup class methodsFor: 'instance creation' stamp: 'KenD 9/26/2022 12:39:39'!
relativeFrom: source to: target
	^self new beRelative; from: source to: target
! !

!Assembly methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:48:37'!
initialize
	super initialize.
	labels := Dictionary new.
	instructions := OrderedCollection new.
	parser := AssemblerParser new
! !

!Assembly methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:37'!
parse
	| everything |
	everything := parser parse: source.
	everything do: [:token | 
		token isString
			ifTrue: [labels at: token allButLast put: instructions size]
			ifFalse: [instructions add: token]]
! !

!Assembly methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:37'!
parser: anAssemblerParser
	parser := anAssemblerParser
! !

!Assembly methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:37'!
source: aString
	source := aString
! !

!Assembly class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:48:37'!
new
	^super new initialize
! !

!Assembly class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:48:37'!
on: aString
	^self new source: aString
! !

!ISAInstructionPartReader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
contents
	^contents contents
! !

!ISAInstructionPartReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:35'!
from: aStream
	contents := #[] writeStream
! !

!ISAModRMReader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
contents
	^contents
! !

!ISAModRMReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:35'!
from: aStream
	contents := aStream atEnd ifFalse: [ModRM new on: aStream next]
! !

!ISAOpcodeReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:35'!
from: aStream
	| byte octets |
	super from: aStream.
	byte := aStream next.
	contents nextPut: byte.
	byte = 16rF ifTrue: [
		octets := (#[16r66 16rF2 16rF3] includes: contents contents first)
			ifTrue: [aStream next: 2]
			ifFalse: [{aStream next}].
		contents nextPutAll: octets]
! !

!ISAOpcodeReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:35'!
printOn: aStream
	contents contents
		do: [:byte | aStream nextPutAll: byte hex]
		separatedBy: [aStream nextPut: $.]
! !

!ISAPrefixReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
from: aStream
	super from: aStream.
	self
		legacyFrom: aStream;
		rexFrom: aStream;
		vexFrom: aStream
! !

!ISAPrefixReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
legacyFrom: aStream
	| prefix |
	legacy := #() writeStream.
	[
		prefix := LegacyPrefix withValue: aStream peek.
		prefix isNil]
		whileFalse: [
			legacy nextPut: prefix.
			contents nextPut: aStream next]
! !

!ISAPrefixReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
rexFrom: aStream
	(aStream peek bitAnd: 16rF0) = REXPrefix rex value ifTrue: [
		rex := aStream next.
		contents nextPut: rex]
! !

!ISAPrefixReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
vexFrom: aStream
	| byte |
	byte := aStream peek.
	vex := byte = 16rC4 ifTrue: [aStream next: 3] ifFalse: [
		byte = 16rC5 ifFalse: [^self].
		aStream next: 2].
	contents nextPutAll: vex
! !

!ISAPrefixReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printLegacyOn: aStream
	legacy contents
		do: [:p | aStream nextPutAll: p asString]
		separatedBy: [aStream space]
! !

!ISAPrefixReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printOn: aStream
	self printLegacyOn: aStream.
	legacy size > 0 ifTrue: [aStream space].
	rex notNil ifTrue: [
		self printRexOn: aStream.
		aStream space].
	vex notNil ifTrue: [self printVexOn: aStream]
! !

!ISAPrefixReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printRexOn: aStream
	rex isNil ifTrue: [^self].
	aStream nextPutAll: REXPrefix rex asString.
	(rex isOnBit: REXPrefix w value) ifTrue: [aStream nextPutAll: '.W'].
	(rex isOnBit: REXPrefix r value) ifTrue: [aStream nextPutAll: '.R'].
	(rex isOnBit: 1) ifTrue: [aStream nextPutAll: '.B'].
	(rex isOnBit: 2) ifTrue: [aStream nextPutAll: '.X']
! !

!ISAPrefixReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printVex2On: aStream
	self printVexVvvvLpp: vex second on: aStream
! !

!ISAPrefixReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printVex3On: aStream
	| byte x b mmmmm w |
	byte := vex second.
	x := (byte bitAnd: 2r1000000) > 0 ifTrue: [$1] ifFalse: [$0].
	aStream nextPut: x; nextPut: $..
	b := (byte bitAnd: 2r100000) > 0 ifTrue: [$1] ifFalse: [$0].
	aStream nextPut: b; nextPut: $..
	mmmmm := byte bitAnd: 2r11111.
	aStream
		nextPutAll: (mmmmm bin: 5);
		nextPut: $|.
	byte := vex third.
	w := byte >= 16r80 ifTrue: [$1] ifFalse: [$0].
	aStream nextPut: w; nextPut: $..
	self printVexVvvvLpp: byte on: aStream
! !

!ISAPrefixReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printVexOn: aStream
	| byte r |
	vex isNil ifTrue: [^self].
	aStream nextPutAll: vex first hex; nextPut: $|.
	byte := vex second.
	r := byte // 16r80 > 0 ifTrue: [$1] ifFalse: [$0].
	aStream nextPut: r; nextPut: $..
	vex size = 2
		ifTrue: [self printVex2On: aStream]
		ifFalse: [self printVex3On: aStream]
! !

!ISAPrefixReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printVexVvvvLpp: byte on: aStream
	| vvvv l pp |
	vvvv := (byte bitShift: -3) bitAnd: 2r1111.
	aStream
		nextPutAll: (vvvv bin: 4);
		nextPut: $..
	l := (byte bitAnd: 2r100) > 0 ifTrue: [$1] ifFalse: [$0].
	aStream nextPut: l; nextPut: $..
	pp := byte bitAnd: 2r11.
	aStream nextPutAll: (pp bin: 2)
! !

!ISASibReader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
contents
	^contents
! !

!ISASibReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
from: aStream
	contents := SIB new on: aStream next
! !

!ISAInstructionReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
displacementFrom: aStream
	
! !

!ISAInstructionReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
from: aStream
	self
		prefixesFrom: aStream;
		opcodeFrom: aStream;
		modrmFrom: aStream;
		sibFrom: aStream;
		displacementFrom: aStream;
		immediateFrom: aStream
! !

!ISAInstructionReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
immediateFrom: aStream
	immediate := aStream upToEnd
! !

!ISAInstructionReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
modrmFrom: aStream
	modrm := ISAModRMReader new from: aStream; contents
! !

!ISAInstructionReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
opcodeFrom: aStream
	opcode := ISAOpcodeReader new from: aStream; asString
! !

!ISAInstructionReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
prefixesFrom: aStream
	prefixes := ISAPrefixReader new from: aStream; asString
! !

!ISAInstructionReader methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
sibFrom: aStream
	self hasSib ifFalse: [^self].
	aStream atEnd ifTrue: [^self].
	sib := ISASibReader new from: aStream; contents
! !

!ISAInstructionReader methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:48:34'!
hasSib
	^modrm notNil and: [modrm mod = 0]
! !

!ISAInstructionReader methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printOn: aStream
	aStream nextPutAll: prefixes.
	prefixes size > 0 ifTrue: [aStream nextPutAll: '| '].
	aStream nextPutAll: opcode.
	aStream nextPutAll: ' | '.
	modrm notNil ifTrue: [modrm printOn: aStream].
	sib notNil ifTrue: [
		aStream nextPutAll: ' | '.
		sib printOn: aStream].
	displacement notNil ifTrue: [
		aStream nextPutAll: ' |'.
		displacement do: [:byte | | hex |
			hex := byte hex.
			hex size = 1 ifTrue: [hex := '0' , hex].
			aStream space; nextPutAll: hex]].
	immediate notNil ifTrue: [
		aStream nextPutAll: ' |'.
		immediate do: [:byte | | hex |
			hex := byte hex.
			hex size = 1 ifTrue: [hex := '0' , hex].
			aStream space; nextPutAll: hex]]
! !

!OctalStructure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
hi
	^byte bitShift: -6
! !

!OctalStructure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
hi: anInteger
	| bits |
	self ASSERT: anInteger < 4.
	bits := anInteger bitShift: 6.
	byte := (byte bitAnd: 2r111111) bitOr: bits
! !

!OctalStructure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
mid
	^(byte bitShift: -3) bitAnd: 7
! !

!OctalStructure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
mid: anInteger
	| bits |
	self ASSERT: anInteger < 8.
	bits := anInteger bitShift: 3.
	byte := (byte bitAnd: 2r11000111) bitOr: bits
! !

!OctalStructure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
on: anInteger
	byte := anInteger
! !

!OctalStructure methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
value
	^byte
! !

!OctalStructure methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
lo
	^byte bitAnd: 7
! !

!OctalStructure methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
lo: anInteger
	self ASSERT: anInteger < 8.
	byte := (byte bitAnd: 2r11111000) bitOr: anInteger
! !

!OctalStructure methodsFor: 'printing' stamp: 'KenD 11/22/2023 13:48:34'!
printOn: aStream
	| hi mid lo |
	hi := self hi printPaddedWith: $0 to: 2 base: 2.
	mid := self mid printPaddedWith: $0 to: 3 base: 2.
	lo := self lo printPaddedWith: $0 to: 3 base: 2.
	aStream
		nextPutAll: hi;
		nextPut: $.;
		nextPutAll: mid;
		nextPut: $.;
		nextPutAll: lo
! !

!OctalStructure class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:48:34'!
new
	^super new initialize
! !

!ModRM methodsFor: 'private' stamp: 'KenD 11/22/2023 13:48:34'!
beRR
	self mod: 2r11
! !

!ModRM methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:48:34'!
initialize
	byte := 0
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
mod
	^self hi
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
mod: anInteger
	self hi: anInteger
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
opcode
	^self reg
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
opcode: anInteger
	self reg: anInteger
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
reg
	^self mid
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
reg: aRegister
	| mid |
	mid := aRegister isInteger
		ifTrue: [aRegister]
		ifFalse: [aRegister index \\ 8].
	self mid: mid
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
rm
	^self lo
! !

!ModRM methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:34'!
rm: anInteger
	self lo: anInteger
! !

!ModRM class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:48:34'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
base
	^self lo
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
base: anInteger
	self lo: anInteger
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
baseRegister: aRegister
	self base: aRegister index
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
index
	^self mid
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
index: anInteger
	self mid: anInteger
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
indexRegister: aRegister
	self index: aRegister index
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
scale
	^self hi
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
scale: anInteger
	self hi: anInteger
! !

!SIB methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:48:35'!
scaleFactor: s
	| index |
	index := #[1 2 4 8] indexOf: s.
	self scale: index - 1
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/24/2022 10:31:48'!
base: register

	self baseRegister: register.
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:15:50'!
baseRegister
	^ baseRegister
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:15:27'!
baseRegister: register

	baseRegister := register.
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/24/2022 10:32:22'!
displacement: addressDelta

	self offset: addressDelta
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/24/2022 10:31:32'!
index: register

	self indexRegister: register.
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:16:16'!
indexRegister
	^ indexRegister
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/24/2022 10:30:36'!
indexRegister: register

	indexRegister := register.
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/24/2022 10:33:24'!
length:  anInteger

	self widthInBits: anInteger.
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/24/2022 10:18:56'!
offset

	^ offset
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/24/2022 10:19:38'!
offset: addressDelta

	offset := addressDelta
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 11/2/2022 13:15:25'!
scale
	"Answer bytes per index"
	^ widthInBits / 8
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:18:58'!
widthInBits
	^ widthInBits
! !

!RVMemoryReference methodsFor: 'accessing' stamp: 'KenD 10/23/2022 15:18:58'!
widthInBits:anInteger

	widthInBits := anInteger.
! !

!RVMemoryReference methodsFor: 'initialization' stamp: 'KenD 11/2/2022 12:57:46'!
initialize
	"Invoked when a new instance is created."

	super initialize.
	self widthInBits: 64. "default is pointer size (8 bytes)"
	indexRegister := 0.
	scale := 8.
	offset := 0.
! !

!RVMemoryReference methodsFor: 'printing & storing' stamp: 'KenD 10/4/2022 11:04:49'!
printOn:aStream
! !

!RVMemoryReference class methodsFor: 'instance creation' stamp: 'KenD 10/4/2022 11:04:49'!
new
	"return an initialized instance"

	^ self basicNew initialize.
! !

!LookupNativizer methodsFor: 'as yet unclassified' stamp: 'KenD 9/26/2022 12:34:38'!
>> aSymbol
	^bootstrapper spec at: aSymbol
! !

!LookupNativizer methodsFor: 'as yet unclassified' stamp: 'KenD 9/26/2022 12:34:38'!
closureMethods
	^ self selectorLookupMethods , self globalLookupMethods
		, self otherLookupMethods , bootstrapper undermethods
		, self sendSiteMethods
! !

!LookupNativizer methodsFor: 'as yet unclassified' stamp: 'KenD 9/26/2022 12:34:38'!
globalLookupMethods
	| result out global |
	result := OrderedCollection new.
	result
		add: (self >> #ProtoObject) >> #_cachedLookup:;
		add: (self >> #ProtoObject) >> #_cachedLookup:in:;
		add: (self >> #Thread) metaclass >> #currentGlobalLookup;
		add: (self >> #GlobalDispatchCache) metaclass >> #current.
	out := #(initialize flushAll: #flush:forSpecies: #flush:for: #flush:for:startingAt:).
	global := (self >> #GlobalDispatchCache) methods
		reject: [ :m | out includes: m selector ].
	^ result
		addAll: global;
		yourself
! !

!LookupNativizer methodsFor: 'as yet unclassified' stamp: 'KenD 9/26/2022 12:34:38'!
otherLookupMethods
	^ OrderedCollection new
		add: self >> #ProtoObject >> #objectAtValid:put:;
		add: self >> #ProtoObject >> #behavior;
		add: self >> #CompiledMethod >> #prepareForExecution;
		add: self >> #CompiledMethod >> #isNativized;
		add: self >> #CompiledMethod >> #validNativeCodeAddress;
		add: self >> #CompiledMethod >> #nativeCode;
		add: self >> #CompiledMethod >> #selector;
		add: self >> #NativeCode >> #code;
		add: self >> #NativeCode >> #compiledCode;
		add: self >> #Species >> #instanceBehavior;
		add: self >> #Process >> #wantsToStepInto;
		yourself
! !

!LookupNativizer methodsFor: 'as yet unclassified' stamp: 'KenD 9/26/2022 12:34:38'!
selectorLookupMethods
	^ OrderedCollection new
		add: (self >> #ProtoObject) >> #_lookup:;
		add: (self >> #ProtoObject) >> #_lookup:in:;
		add: (self >> #ProtoObject) >> #_lookup:inDictionary:;
		yourself
! !

!LookupNativizer methodsFor: 'as yet unclassified' stamp: 'KenD 9/26/2022 12:34:38'!
sendSiteMethods
	| sendsite |
	sendsite := self >> #SendSite.
	^ #(_dispatchOn: _dispatchOn:startingAt: _dispatchDebuggableOn: _dispatchDebuggableOn:startingAt: sentSelector when:use: beInvoke:using: bePolymorphic isStaticSend monomorphicMap:to: polymorphicMap:to: maxSize reset takeNextFreeMIC takeNextFreePIC)
		collect: [ :s | sendsite >> s ]
! !

!LookupNativizer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:34:38'!
bootstrapper: aSmalltalkBootstrapper
	bootstrapper := aSmalltalkBootstrapper
! !

!LookupNativizer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:34:38'!
methodFor: selector
	^methods detect: [:m | m selector == selector].

! !

!LookupNativizer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:34:38'!
methods
	^methods
! !

!LookupNativizer methodsFor: 'accessing' stamp: 'KenD 9/26/2022 12:34:38'!
nativizeMethods
	| environment | 
	methods := self closureMethods collect: [:m | bootstrapper compile: m ].
	environment := self newNativizationEnvironment.
	methods do: [:m | environment nativize: m]
! !

!LookupNativizer methodsFor: 'instance creation' stamp: 'KenD 9/26/2022 12:34:38'!
newNativizationEnvironment
	| environment ignored lookup invoke |
	environment := NativizationEnvironment new 
		platform: bootstrapper platform;
		globals: bootstrapper nativizer globals;
		optimizedMethods: bootstrapper nativizer optimizedMethods.
	ignored := HaltingSend new
		filter: #(< <= = > + - * // bitAnd: bitOr: bitXor:).
	lookup := LookupLinker new initializeFrom: environment.
	lookup
		filter:
			#(debuggableCopy acquireReferences nativize refreshBlocks doesNotUnderstandSelector: mustBeBoolean class allocateMoreCaches).
	invoke := InvokeLinker new
		invoker: environment invokeStub;
		addMethods: methods.
	^ environment
		addLinker: invoke;
		addLinker: ignored;
		addLinker: lookup;
		completeInitialization
! !

!ObjectMap methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:43'!
allSlotNames
	^#()
! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:28:54'!
arrayedSize 

	^self size! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:29:11'!
at: index 

	"Return indexed value at given index, starting with 1. This CANNOT be 
	 used for accessing named slots (aka, instance variables), to access 
	 them use #instVarAt:"
	
	self subclassResponsibility  ! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:29:24'!
at: index put: value 

	"Set indexed value at given `index` to `value`. This CANNOT be used for 
	 setting named slots (aka, instance variables), to access them use 
	 #instVarAt:put:"
	
	self subclassResponsibility  ! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:29:36'!
behavior 

	^behavior! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:29:49'!
behavior: anObjectMap 

	behavior := anObjectMap! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:30:03'!
bodySizeInBytes 

	"Return the size of object body(s) in bytes,
	 padded if a byte object"
	^ self subclassResponsibility ! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:30:14'!
classname 

	^spec name! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:30:30'!
headerSizeInBytes 
	"
		Return the size of object header in bytes, 
		including both small and large part (if any).
	"
	
	^ self isSmall ifTrue: [ 8 ] ifFalse: [ 16 ]! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:31:00'!
headerSmallSize 

	"Return value of 'size' field of small header"
	 | size |	
 	size := self size.
  	^ size < 256 ifTrue: [ size ] ifFalse: [ 0 ]! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:33:29'!
size 

	"Return the size if this object, that this, the value of
	 size field in object header. 
	
	 For slot (pointer) objects, this is a number of slots. 
	 For byte objects, this is a number of bytes. "
	
	self subclassResponsibility ! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:33:43'!
sizeInBytes 

	"Return the size of object in bytes without padding"
	^ self subclassResponsibility ! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:34:03'!
slotAt: index 

	"Get named slot at given `index`, starting with 1. This CANNOT be used 
	 for accessing indexed slots  (i.e., variable part of array-like objects), 
   to set them use #at:"
	
	self subclassResponsibility  ! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:34:26'!
slotAt: index put: value 

	"Set named slot at given `index` to `value`. This CANNOT be used 
	 for setting indexed slots  (i.e., variable part of array-like objects), 
   to set them use #at:put:"
	
	self subclassResponsibility! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:34:47'!
slotNamed: name 

	"Get a named slot with given `name`"

	| index |
	index := self allInstVarNames indexOf: name.
	index == 0
		ifTrue: [ ^ self error: 'No slot named "' , name , '"' ].
	^ self slotAt: index! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:35:02'!
slotNamed: name put: value 

	"Set a named slot with given `name` to `value`"

	| index |
	index := self allInstVarNames indexOf: name.
	index == 0
		ifTrue: [ ^ self error: 'No slot named "' , name , '"' ].
	^ self slotAt: index put: value! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:37:35'!
spec 

	^ spec! !

!ObjectMap methodsFor: 'accessing' stamp: 'KenD 2/22/2021 13:37:51'!
wordSize 

	"Return the size in bytes of the word (i.e, a reference to an object)"
	
	^ 8 "For now, 64bit only!!"! !

!ObjectMap methodsFor: 'initialization' stamp: 'KenD 2/22/2021 13:31:21'!
initializeAs: anRGBehavior sized: size 

	self subclassResponsibility! !

!ObjectMap methodsFor: 'initialization' stamp: 'KenD 2/22/2021 13:32:33'!
nilAll: nilObject! !

!ObjectMap methodsFor: 'initialization' stamp: 'KenD 2/22/2021 13:32:41'!
nilWith: nilObject ! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 2/22/2021 13:31:45'!
isBytes 

	^ false! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
isClosure
	^ false
! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
isDictionaryMap
	^ false
! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 2/22/2021 13:31:52'!
isImmediate 

	^ false! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
isNil
	^ spec notNil and: [spec name = #UndefinedObject]
! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 2/22/2021 13:32:00'!
isPointers 

	^ false! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 2/22/2021 13:32:14'!
isSmall 

	^self size < 256! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
loadIvar: aSymbol
	^nil
! !

!ObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
storeIvar: aSymbol with: anObjectMap
	^ nil
! !

!ObjectMap methodsFor: 'iterating' stamp: 'KenD 2/22/2021 13:35:51'!
slotsDo: aBlock

	self notYetImplemented ! !

!ObjectMap methodsFor: 'validation' stamp: 'KenD 2/22/2021 13:38:23'!
validate 
	
	self assert: behavior notNil! !

!ObjectMap class methodsFor: 'instance creation' stamp: 'KenD 2/22/2021 13:26:08'!
classFor: anRGBehavior 

	anRGBehavior name == #SmallInteger ifTrue: [^SmallintObjectMap].
	^anRGBehavior isBytes
		ifTrue: [ ByteObjectMap ]
		ifFalse: [ SlotObjectMap ]! !

!ObjectMap class methodsFor: 'instance creation' stamp: 'KenD 2/22/2021 13:28:00'!
new: anRGBehavior 
	
	^self new: anRGBehavior size: 0! !

!ObjectMap class methodsFor: 'instance creation' stamp: 'KenD 2/22/2021 13:28:19'!
new: anRGBehavior size: size 

	| class |
	self assert: (anRGBehavior isVariable or: [ size == 0 ]).
	class := self classFor: anRGBehavior.
	^ class new initializeAs: anRGBehavior sized: size! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
associationAt: aSymbol ifAbsent: aBlock
	^ assocs at: aSymbol ifAbsent: aBlock
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
associationAt: aSymbol ifPresent: aBlock
	assocs at: aSymbol ifPresent: [:assoc |  ^ aBlock value: assoc ].
	^ nil
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
associations
	^ assocs values
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
at: aSymbol
	^self
		at: aSymbol
		ifAbsent: [ self error: aSymbol , ' was not found in dictionary' ]
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
at: aSymbol ifAbsent: aBlock
	| assoc |
	assoc := assocs
		at: aSymbol
		ifAbsent: [ ^ aBlock value ].
	^ assoc value
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
at: aSymbol ifPresent: aBlock
	| value |
	value := self at: aSymbol ifAbsent: [ ^ nil ].
	^ aBlock value: value
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
at: aSymbol put: anObject
	| s assoc value |
	assoc := assocs
		at: aSymbol
		ifAbsentPut: [ s := image newSymbol: aSymbol.
			assoc := image newAssociation: s -> image nil ].
	value := image transferLiteralDeep: anObject.
	assoc value: value .
	^ value
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
beConstant
	constant := true
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
image: aPowertalkRingImage
	image := aPowertalkRingImage
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
includesKey: aSymbol
	^assocs includesKey: aSymbol
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
initialize
	assocs := Dictionary new.
	constant := false
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
initializeAs: anRGBehavior
	spec := anRGBehavior
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
isConstant
	^ constant
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
isDictionaryMap
	^ true
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
keys
	| keys |
	keys := assocs values collect: #key.
	^image newArray: keys
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
realSpec
	^realSpec
! !

!BootstrapDictionaryMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
realSpec: anRGBehavior
	realSpec := anRGBehavior 
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
asString
	| string |
	string := bytes allButLast asString.
	^spec name = #String ifTrue: [ string ] ifFalse: [ string asSymbol ]
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
bytes
	^ bytes
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
contentsString
		spec name == #String
		ifTrue: [ ^bytes allButLast asString storeString ].
		spec name == #Symbol
				ifTrue: [ ^bytes allButLast asString asSymbol storeString ].
		spec name == #ByteArray
			ifTrue: [ ^bytes storeString ].
		^spec name withArticle, ': ', bytes printString
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
headerFlags
	| byte variable small |
	byte := 1.
	variable := 2.
	small := self isSmall ifTrue: [ 16r80 ] ifFalse: [ 0 ].
	^ byte | variable | small
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
headerHash
	^ hash
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
headerHash: anInteger
	hash := anInteger
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
isBytes
	^true
! !

!ByteObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
printOn: aStream
	spec ifNil: [ ^ super printOn: aStream ].
	aStream
		nextPutAll: '<<';
		nextPutAll: self contentsString;
		nextPutAll: '>>'
! !

!ByteObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:43'!
at: index
	"Return indexed value at given index, starting with 1. This CANNOT be 
	 used for accessing named slots (aka, instance variables), to access 
	 them use #instVarAt:"
	
	self assert: (index between: 1 and: bytes size).
	^bytes at: index
! !

!ByteObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:43'!
at: index put: anObjectMap
	"Set indexed value at given `index` to `value`. This CANNOT be used for 
	 setting named slots (aka, instance variables), to access them use 
	 #instVarAt:put:"

	| value |
	self assert: (index between: 1 and: bytes size).
	self assert: anObjectMap isImmediate.
	value := anObjectMap value.
	self assert: (value between: 0 and: 255).
	bytes at: index put: value.
	^anObjectMap
! !

!ByteObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:43'!
bodySizeInBytes
	"Return the size of object body(s) in bytes, padded"
	^ self size alignedTo: self wordSize
! !

!ByteObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:43'!
fillFrom: anObject
	self assert: anObject size == bytes size.
	bytes replaceFrom: 1 to: bytes size with: anObject startingAt: 1
! !

!ByteObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:43'!
size
	"Return the size if this object, that this, the value of
	 size field in object header. 
	
	 For slot (pointer) objects, this is a number of slots. 
	 For byte objects, this is a number of bytes. "
	
	^ bytes size
! !

!ByteObjectMap methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:43'!
initialize
	hash := 0
! !

!ByteObjectMap methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:43'!
initializeAs: anRGBehavior sized: size
	self assert: anRGBehavior notNil.
"	self assert: anRGBehavior isBytes.
	self assert: anRGBehavior isVariable.
"	
	spec := anRGBehavior.
	bytes := ByteArray new: size
! !

!ByteObjectMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:43'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!ByteObjectMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:43'!
new: anRGBehavior size: anInteger

	^ self new
		initializeAs: anRGBehavior sized: anInteger
! !

!ByteObjectMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:43'!
new: anRGBehavior valued: bytes
	"self assert: anRGBehavior isBytes."
	^self new initializeAs: anRGBehavior sized: bytes size; fillFrom: bytes
! !

!SymbolMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
asString
	^ symbol
! !

!SymbolMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
contentsString
	^symbol storeString

! !

!SymbolMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
symbol
	^symbol
! !

!SymbolMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
symbol: aSymbol
	symbol := aSymbol 
! !

!SymbolMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:42'!
new: anRGBehavior symbol: aSymbol
	| bytes |
	bytes := aSymbol copyWith: Character null.
	^ self new
		initializeAs: anRGBehavior sized: bytes size;
		fillFrom: bytes;
		symbol: aSymbol
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
allSlotNames
	^ spec properties
		at: #allSlotNames
		ifAbsentPut: [ self computeAllSlotNames ]
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
arrayedSize
	"
	 Return the size of the arrayed part of this object, that this,
	 the value of size field in object header minus the instSize. 
	"

	^ self size - self instSize
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
asBoolean
	spec name = #True ifTrue: [ ^true ].	spec name = #False ifTrue: [ ^false ].
		self ASSERT: false
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
at: index
	"Return indexed value at given index, starting with 1. This CANNOT be 
	 used for accessing named slots (aka, instance variables), to access 
	 them use #instVarAt:"
	
	self assert: (index between: 1 and: slots size - self instSize).
	^slots at: self instSize + index
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
at: index put: value
	"Set indexed value at given `index` to `value`. This CANNOT be used for 
	 setting named slots (aka, instance variables), to access them use 
	 #instVarAt:put:"
	self assert: spec isVariable.
	self assert: (index between: 1 and: slots size - self instSize).
	self assert: (value isKindOf: ObjectMap).
	^slots at: self instSize + index put: value
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
basicAt: index
	"Return indexed value at given raw index, starting with 1"

	self assert: (index between: 1 and: slots size).
	^ slots at: index
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
bodySizeInBytes
	^ self sizeInBytes

! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
computeAllSlotNames
	^spec allInstVarNames
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
doesNotUnderstand: aMessage
	| sel ivars |
	sel := aMessage selector.
	ivars := self allSlotNames.
	sel isUnary
		ifTrue: [ (ivars includes: sel)
				ifTrue: [ ^ self slotNamed: sel ] ].
	(sel isKeyword and: [ sel numArgs == 1 ])
		ifTrue: [ sel := sel allButLast.
			(ivars includes: sel)
				ifTrue: [ ^ self slotNamed: sel put: aMessage arguments first ] ].
	^ super doesNotUnderstand: aMessage
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
instSize
	| c |
	^ spec properties at: #instSize ifAbsentPut: [spec isMeta
		ifTrue: [ c := spec environment at: #Class.
			
			c instSize + spec instSize ]
		ifFalse: [ spec instSize ]]
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
isPointers
	^true
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
loadIvar: aSymbol
	| ivar |
	ivar := self allSlotNames indexOf: aSymbol.
	^ ivar > 0
		ifTrue: [ self slotAt: ivar ]
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
printOn: aStream
	aStream
		nextPutAll: '<<';
		nextPutAll: spec name withArticle;
		nextPutAll: '>>'
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
size
	"Return the size if this object, that this, the value of
	 size field in object header. 
	
	 For slot (pointer) objects, this is a number of slots. 
	 For byte objects, this is a number of bytes. "
	
	^ slots size
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
sizeInBytes
	^ self size * self wordSize

! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
slotAt: index
	"Get named slot at given `index`, starting with 1. This CANNOT be used 
	 for accessing indexed slots  (i.e., variable part of array-like objects), 
   to set them use #at:"
	
	self assert: (index between: 1 and: self instSize).
	^slots at: index
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
slotAt: index put: value
	"Set named slot at given `index` to `value`. This CANNOT be used 
	 for setting indexed slots  (i.e., variable part of array-like objects), 
   to set them use #at:put:"
	
	self assert: (index between: 1 and: self instSize).
	self assert: (value isKindOf: ObjectMap).
	^slots at: index put: value
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
slots
	^slots
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
slotsDo: aBlock
	slots do: aBlock
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
storeIvar: aSymbol with: anObject
	| ivar |
	ivar := self allSlotNames indexOf: aSymbol.
	^ ivar > 0
		ifTrue: [ self slotAt: ivar put: anObject ]
! !

!SlotObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:52'!
value
	| message |
	(self allSlotNames includes: #value)
		ifFalse: [ ^ super value ].
	message := Message selector: #value.
	^ self doesNotUnderstand: message
! !

!SlotObjectMap methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:52'!
atAllPut: value
	slots atAllPut: value
! !

!SlotObjectMap methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:52'!
initializeAs: anRGBehavior sized: size
	self assert: anRGBehavior notNil.
	self assert: anRGBehavior isPointers.
	self assert: (anRGBehavior isVariable or: [ size == 0 ]).
	spec := anRGBehavior.
	slots := Array new: self instSize + size
! !

!SlotObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:52'!
headerFlags
	| variable named small |
	variable := spec isVariable ifTrue: [2] ifFalse: [0].
	named := spec instSize == 0 ifTrue: [0] ifFalse: [4].
	small := self isSmall ifTrue: [16r80] ifFalse: [0].
	^ variable | named | small
! !

!SlotObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:52'!
headerHash
	^hash
! !

!SlotObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:52'!
headerHash: anInteger
	hash := anInteger
! !

!SlotObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:52'!
initialize
	hash := 0
! !

!SlotObjectMap methodsFor: 'validation' stamp: 'KenD 11/22/2023 07:48:52'!
validate
	super validate.
	slots withIndexDo:[:value :index | self assert: value notNil ]
! !

!SlotObjectMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:52'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SlotObjectMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:52'!
new: anRGBehavior size: size

	^ self new initializeAs: anRGBehavior sized: size
! !

!SlotObjectMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:52'!
new: anRGBehavior size: size withAll: value
	| obj |
	obj := self new: anRGBehavior size: size.
	^obj atAllPut: value; yourself
	
! !

!ClosureMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
block
	^block
! !

!ClosureMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
block: anSCompiledBlock
	block := anSCompiledBlock
! !

!ClosureMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
executionTree
	^ block optimizedCode
! !

!ClosureMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
home
	block capturesHome ifFalse: [ self error: 'closure has no home' ].
	^block capturesSelf ifTrue: [ self at: 2 ] ifFalse: [ self at: 1 ]
! !

!ClosureMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
isClosure
	^true
! !

!ClosureMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
printOn: aStream
	aStream
		nextPutAll: '<< ['.
	self slots do: [ :slot | aStream print: slot ] separatedBy: [ aStream nextPutAll: ', ' ].
aStream
		nextPutAll: '] >>'
! !

!ClosureMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:13'!
classFor: anRGBehavior
	^ self
! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
allInstVarNames
	^self subclassResponsibility
! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
allSlotNames
	^ slotNames ifNil: [ self computeAllSlotNames ]
! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
instanceSpec
	^instanceSpec
! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
instanceSpec: anRGBehavior
	instanceSpec := anRGBehavior
! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
storeCvar: aSymbol with: anObject
	| species namespaces |
	species := self. 
	[ namespaces := species namespaces.
	namespaces slotsDo: [ :namespace |
	(namespace includesKey: aSymbol)
		ifTrue: [ ^ namespace at: aSymbol put: anObject ]].
	species := species superclass.
	species isNil 
	] whileFalse.
	^ nil


! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
storeNamed: aSymbol with: anObjectMap
	(self storeCvar: aSymbol with: anObjectMap) ifNotNil: [ :value | ^ value ].
	^ self module namespace
		at: aSymbol
		put: anObjectMap
! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
superclass
	^ self slotNamed: #superclass
! !

!SpeciesMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
superclass: aSpeciesMap
	^ self slotNamed: #superclass put: aSpeciesMap
! !

!SpeciesMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:46'!
classFor: anRGBehavior
	^self
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
allInstVarNames
	^ (spec environment at: #Class)allInstVarNames, spec allInstVarNames
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
computeAllSlotNames
	| c |
	c := spec environment at: #Class.
	^slotNames := c allInstVarNames , spec allInstVarNames
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
instanceSide
	^ self
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
name
	^instanceSpec name
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
namespaces
	^ self slotNamed: #namespaces
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
namespaces: array
	^ self slotNamed: #namespaces put: array
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
printOn: aStream
	aStream
		nextPutAll: '<<';
		nextPutAll: self name asString;
		nextPutAll: '>>'
! !

!ClassMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
withAllSuperclasses
	^self superclass isNil ifTrue: [ OrderedCollection with: self ]
		ifFalse: [self superclass withAllSuperclasses
				addFirst: self;
				yourself ]
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
allInstVarNames
	^ (spec environment at: #Metaclass) allInstVarNames
		, spec allInstVarNames
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
class: aClassMap
	self slotNamed: #class put: aClassMap
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
computeAllSlotNames
	| c |
	c := spec environment at: #Metaclass.
	^slotNames := c allInstVarNames
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
createClassAssociationsWith: aVirtualImage
	
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
instanceSide
	^ self slotNamed: #class
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
module
	^ self instanceSide module
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
namespaces
	^ self instanceSide namespaces
! !

!MetaclassMap methodsFor: 'accessing - parallel hierarchy' stamp: 'KenD 11/22/2023 07:48:57'!
printOn: aStream
	aStream
		nextPutAll: '<<';
		nextPutAll: self instanceSide name asString;
		nextPutAll: ' class>>'
! !

!SmallintObjectMap methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:49:10'!
= anObject
	anObject class == self class
		ifFalse: [ ^ false ].
	^ value = anObject value
! !

!SmallintObjectMap methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:49:10'!
hash
	^ value hash
! !

!SmallintObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
at: index
	self errorNotIndexable
! !

!SmallintObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
at: index put: anObject
	self errorNotIndexable
! !

!SmallintObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
size
	^ 0
! !

!SmallintObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
slotAt: index
	self errorNotIndexable
! !

!SmallintObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
slotAt: index put: anObject
	self errorNotIndexable
! !

!SmallintObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
value
	^value
! !

!SmallintObjectMap methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
value: aSmallInteger
	value := aSmallInteger
! !

!SmallintObjectMap methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:10'!
initializeAs: anRGBehavior sized: size
	self shouldNotImplement
! !

!SmallintObjectMap methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:10'!
initializeAs: anRGBehavior valued: anInteger
	self assert: anRGBehavior name == #SmallInteger.
	self assert: anInteger isInteger.
	spec := anRGBehavior.
	value := anInteger
! !

!SmallintObjectMap methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:10'!
isImmediate
	^ true
! !

!SmallintObjectMap methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:10'!
printOn: aStream
	aStream
		nextPutAll: '<<';
		nextPutAll: value printString;
		nextPutAll: '>>'
! !

!SmallintObjectMap methodsFor: 'validation' stamp: 'KenD 11/22/2023 07:49:10'!
validate
	super validate.
	self assert: value isSmallInteger 
! !

!SmallintObjectMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:10'!
new: anRGBehavior valued: anInteger
	^self new initializeAs: anRGBehavior valued: anInteger
! !

!SmalltalkBootstrapper methodsFor: 'accessing' stamp: 'KenD 3/2/2021 13:02:37'!
builder: anImageSegmentBuilder 

	builder := anImageSegmentBuilder! !

!SmalltalkBootstrapper methodsFor: 'accessing' stamp: 'KenD 3/2/2021 13:03:13'!
spec 

	^builder image kernel! !

!SmalltalkBootstrapper methodsFor: 'services' stamp: 'KenD 3/2/2021 13:03:02'!
compile: anRGMethod 

	^builder compile: anRGMethod! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:04:44'!
initializeInlinedMethods 
	| compiled |
	compiled := self inlinedMethods
		collect: [ :method | builder methods at: method ].
	nativizer inlinedMethods: compiled! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:05:08'!
initializeInvokedMethods 
	| compiled |
	compiled := self invokedMethods
		collect: [ :method | builder methods at: method ].
	nativizer invokedMethods: compiled! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:05:26'!
initializeKernelModule 
	| runtime smethod transferred array module |
	module := builder module.
	runtime := {(image => #Kernel >> #entry:argv:)}
		collect: [ :def | 
			smethod := builder methods at: def.
			transferred := image surrogateFor: smethod.
			transferred nativeCode machineCode ].
	array := image newArray: builder classes values.
	module
		name: (image newString: 'Kernel');
		version: (image newString: '0.1.0');
		exports: array;
		hash: image nil;
		loadAction: builder createLoadAction;
		runtime: (image newArray: runtime)! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:06:32'!
initializeNativizer 

	nativizer := NativizationEnvironment new.
	self
		initializeNativizerGlobals;
		initializeInlinedMethods;
		initializeInvokedMethods;
		initializeOptimizedMethods;
		nativizeInvoke;
		nativizeWriteBarrier;
		nativizeLookup;
		transferNativizerGlobals;
		setupMessageLinkers! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:06:55'!
initializeNativizerGlobals 
	| smi items |
	smi := image classNamed: #SmallInteger.
	nativizer globalNamed: #SmallIntegerBehavior put: smi behavior.
	items := {(#Lookup -> (NativeCode new code: 'Lookup Placeholder')).
	(#LookupSuper -> (NativeCode new code: 'LookupSuper Placeholder')).
	(#DebuggableLookup
		-> (NativeCode new code: 'DebuggableLookup placeholder')).
	(#DebuggableLookupSuper
		-> (NativeCode new code: 'DebuggableLookupSuper placeholder')).
	(#Invoke -> (NativeCode new code: 'Invoke placeholder')).
	(#Safepoint -> (NativeCode new code: 'SafepointCheck placeholder')).
	(#WriteBarrier -> (NativeCode new code: 'Write Barrier placeholder'))}
		asDictionary.
	items
		keysAndValuesDo: [ :key :placeholder | nativizer globalNamed: key put: placeholder ]! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:07:33'!
initializeOptimizedMethods 
	| compiled |
	compiled := self optimizedMethods
		collect: [ :method | builder methods at: method ].
	nativizer optimizedMethods: compiled! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:08:08'!
initializeSendSite 

	self 
		initializeSendSiteMIC: nativizer monomorphicCache
		PIC: nativizer polymorphicCache! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:08:33'!
initializeSendSiteMIC: micStub PIC: picStub 
	| class lkup invk mic pic |
	class := image classNamed: #SendSite.
	lkup := nativizer globalNamed: #Lookup.
	lkup := image surrogateFor: lkup.
	invk := nativizer globalNamed: #Invoke.
	invk := image surrogateFor: invk.
	mic := image newBytesFrom: micStub.
	pic := image newBytesFrom: picStub.
	builder runtime
		send: #allocateInitialCachesUsing: to: class with: {lkup};
		send: #initializeInvoke: to: class with: {invk};
		send: #monomorphicCache: to: class with: {mic};
		send: #polymorphicCache: to: class with: {pic}! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:11:14'!
inlinedMethods 
	| map |
	map := 
	{(#ProtoObject
		->
		#(#objectAtValid: #objectAtValid:put: #behavior #class   
		  #primitiveAt: #_cachedLookup: #_cachedLookup:in:)).
	(#Object
		-> 
		#(#byteAtValid: #byteAtValid:put: #basicObjectIndexOf: #at:put:)).
	(#Species
		->
		#(#instSize #_instancesAreArrayed #_instancesHavePointers 
		    #memory #instanceBehavior #primitiveNew #primitiveNew:)).
	(#CompiledMethod
		->
		#(#prepareForExecution #isNativized #nativeCode 
		   #blockCount #literalIndexFrom:)).
	(#CompiledBlock 
	 	-> 
		#(#argumentCount #blockNumber #blockCode #method)).
	(#NativeCode -> #(#code)).
	(#GCSpace -> #(#commitedLimit #nextFree #nextFree:)).
	(#CharacterArray -> #(#characterAtValid:))}.

	^ builder undermethods , (builder methodSubset: map)
	! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:22:21'!
invokedMethods 
	| map |
	map := 
	{(#ProtoObject
		-> #(behavior class primitiveAt: #initializeExtended:contentSize:)).
	(#Object 
		-> #(#_replaceFrom:to:with:)).
	(#Species
		->
		#(#allocate:size: instanceBehavior _instancesAreArrayed 
		_instancesHavePointers #nil:slotsOf: memory primitiveNewBytes: 
		primitiveNewPointers: #zero:bytesOf:))}.

	^ builder undermethods , (builder methodSubset: map)! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:22:37'!
mapNativizerGlobal: name to: transferred 
	| placeholder |
	placeholder := nativizer globalNamed: name.
	image
		map: placeholder to: transferred;
		map: placeholder code to: transferred machineCode.
	builder export: transferred as: name! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:22:51'!
nativize 

	self
		initializeNativizer;
		initializeSendSite;
		nativizeRemainingMethods! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:23:05'!
nativizeInvoke 
	| invoke |
	invoke := builder compile: builder => #SendSite >> #_invokeOn:.
	nativizer nativizeOptimizing: invoke.
	self transfer: invoke in: #ProtoObject asNativizerGlobal: #Invoke! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:23:20'!
nativizeLookup 
	| n transferred species lookup lookupSuper |
	n := LookupNativizer new
		bootstrapper: self;
		nativizeMethods.
	lookup := n methodFor: #_dispatchOn:.
	lookupSuper := n methodFor: #_dispatchOn:startingAt:.
	n methods
		do: [ :m | 
			species := image speciesFor: image => m classBinding name.
			transferred := builder transferMethod: m in: species.
			image map: m to: transferred ];
		do: [ :m | 
			transferred := image surrogateFor: m.
			self transferNativeCode: m nativeCode of: transferred ].
	transferred := (image surrogateFor: lookup) nativeCode.
	self mapNativizerGlobal: #Lookup to: transferred.
	transferred := (image surrogateFor: lookupSuper) nativeCode.
	self mapNativizerGlobal: #LookupSuper to: transferred! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:24:59'!
nativizeRemainingMethods 

	builder classSpecs
		do: [ :def | 
			self
				trace: 'nativizing ' , def name , '...';
				nativizeRemainingMethodsIn: def;
				nativizeRemainingMethodsIn: def metaclass ]! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:25:17'!
nativizeRemainingMethodsIn: species 

	builder methods
		do: [ :smethod | 
			smethod nativeCode
				ifNil: [ "self haltIf: smethod selector == #foo."
					nativizer nativize: smethod.
					self transferNativeCodeOfMethod: smethod ] ]! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:25:37'!
nativizeWriteBarrier 
	| map inlined dispatcher barrier |
	map := {('Memory class' -> #(current)).
	(#Memory -> #(isYoung: isYoungSafe: remember:)).
	(#CriticalArray -> #(unsafeAdd: #unsafeAt:put:)).
	(#Magnitude -> #(#between:and:))}.
	inlined := builder methodSubset: map.
	inlined addAll: builder undermethods.
	inlined := inlined collect: [ :m | builder compile: m ].
	barrier := builder
		compile: builder => #ProtoObject >> #holdRefererIfNeeded:.
	dispatcher := LookupLinker new initializeFrom: nativizer.
	NativizationEnvironment new
		globals: nativizer globals;
		inlinedMethods: inlined;
		messageLinker: dispatcher;
		completeInitialization;
		nativizeOptimizing: barrier.
	self
		transfer: barrier
		in: #ProtoObject
		asNativizerGlobal: #WriteBarrier! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:28:22'!
optimizedMethods 
	| map |
	map := 
	{(#ProtoObject
		->
		#(behavior class primitiveAt: #primitiveAt:put: 
		  #initializeExtended:contentSize:)).
	(#Object
		->
		#(at: #at:put: basicByteAt: #basicByteAt:put: byteAtValid: 
		  #byteAtValid:put: basicObjectAt: #basicObjectAt:put: 
		  #replaceBytesForwardFrom:to:with:startingAt:)).
	(#SendSite
		->
		#(_dispatchOn: #_dispatchOn:startingAt: 
		  _dispatchDebuggableOn: #_dispatchDebuggableOn:startingAt:)).
	(#Species
		->
		#(#allocate:size: primitiveNew primitiveNew: instSize
		   primitiveNewBytes: primitiveNewPointers:)).
	(#'Float class' 
		-> #(new)).
	(#CompiledBlock 
		-> #(argumentCount arity blockCode method)).
	(#Closure 
		-> #(value value: #value:value:)).
	(#CompiledMethod 
		-> #(blockCount isNativized)).
	(#String 
		-> #(at: #at:put: byteAt: #byteAt:put:)).
	(#GCSpace
		-> 
		#(lockedAllocateIfPossible: lockedAllocateUnsafe: shallowCopy:)).
	(#Memory 
		-> #(shallowCopy:))}.

	^ builder undermethods , (builder methodSubset: map)! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:28:45'!
setupMessageLinkers 
	| invoker dispatcher |
	invoker := InvokeLinker new
		invoker: nativizer invokeStub;
		addMethods: nativizer invokedMethods.
	dispatcher := LookupLinker new initializeFrom: nativizer.
	nativizer
		addLinker: invoker;
		addLinker: dispatcher;
		completeInitialization! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:29:13'!
transfer: anSMethod in: classname asNativizerGlobal: name 
	| species transferred |
	species := image classNamed: classname.
	transferred := builder transferMethod: anSMethod in: species.
	transferred := self
		transferNativeCode: anSMethod nativeCode
		of: transferred.
	self mapNativizerGlobal: name to: transferred! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:29:36'!
transferNativeCode: aNativeCode of: compiledCode 
	| size transferred code slot callback |
	size := aNativeCode size.
	transferred := image newSlots: 'NativeCode' sized: size.
	callback := compiledCode classname = #CallbackMethod.
	code := callback
		ifTrue: [ builder newCallback: transferred bytesFrom: aNativeCode code ]
		ifFalse: [ image newBytesFrom: aNativeCode code ].
	transferred
		machineCode: code;
		compiledCode: compiledCode.
	compiledCode nativeCode: transferred.
	aNativeCode
		withIndexDo: [ :elem :i | 
			slot := image transferLiteralDeep: elem.
			transferred at: i put: slot ].
	^ transferred! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:30:08'!
transferNativeCodeOfMethod: anSCompiledMethod 
	| transferred remaining literal block position |
	transferred := image surrogateFor: anSCompiledMethod.
	self transferNativeCode: anSCompiledMethod nativeCode of: transferred.
	remaining := anSCompiledMethod blockCount.
	position := 1.
	[ remaining > 0 ]
		whileTrue: [ literal := anSCompiledMethod at: position.
			literal isBlock
				ifTrue: [ block := transferred at: position.
					self transferNativeCode: literal nativeCode of: block.
					remaining := remaining - 1 ].
			position := position + 1 ].
	^ transferred! !

!DMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 3/2/2021 13:30:22'!
transferNativizerGlobals 

	image transferLiteralDeep: nativizer globals! !

!DMRBootstrapper methodsFor: 'accessing' stamp: 'KenD 3/2/2021 13:04:20'!
image: aVirtualSmalltalkImage 

	image := aVirtualSmalltalkImage! !

!DMRBootstrapper methodsFor: 'accessing' stamp: 'KenD 3/2/2021 13:26:05'!
nativizer 

	^nativizer! !

!DMRBootstrapper methodsFor: 'accessing' stamp: 'KenD 3/2/2021 13:30:37'!
undermethods 

	^builder undermethods! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
argumentAt: anInteger
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
argumentAt: anInteger in: environmentIndex
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
arguments
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
captureClosure: anSBlock
	| closure s i type env arg |
	closure := system newClosureFor: anSBlock compiledCode.
	s := anSBlock capturedVariables readStream.
	i := 1.
	[ s atEnd ]
		whileFalse: [ type := s next.
			type = Self
				ifTrue: [ closure at: i put: self self ].
			type = Environment
				ifTrue: [ closure at: i put: self environment ].
			type = EnvironmentValue
				ifTrue: [ env := self environment at: s next.
					closure at: i put: env ].
			type = LocalArgument
				ifTrue: [ arg := self argumentAt: s next.
					closure at: i put: arg ].
			i := i + 1 ].
	^ closure
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
environment
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
false
	^ system false
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
firstArgument
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
fourthArgument
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
instanceVarAt: index
	^ system instanceVarOf: self self at: index
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
instanceVarAt: index put: value
	^ system instanceVarOf: self self at: index put: value
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
method
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
method: anSCompiledMethod
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
methodArguments
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
nil
	^ system nil
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
receiver
	^self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
secondArgument
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
self
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
stackTemporaryAt: index
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
stackTemporaryAt: index put: value
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
staticBindingFor: aSymbol
	| symbol |
	symbol := system symbolFrom: aSymbol.
	(self staticBindingForIvar: symbol) ifNotNil: [ :b | ^ b ].
	(self staticBindingForCvar: symbol) ifNotNil: [ :b | ^ b ].
	^ self staticBindingForMvar: symbol
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
system: aPowertalkRuntime
	system := aPowertalkRuntime
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
temporaryAt: index in: environmentIndex
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
temporaryAt: index in: environmentIndex put: value
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
thirdArgument
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:58'!
true
	^ system true
! !

!EvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:58'!
backtrace
	^ self subclassResponsibility
! !

!EvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:58'!
classBinding
	^system methodClassBinding: self method
! !

!EvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:58'!
loadAssociationValue: anObject
	^system loadAssociationValue: anObject
! !

!EvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:58'!
staticBindingForNested: name
	| binding module |
	binding := self staticBindingFor: (name at: 1).
	module := binding valueWithin: self.
	^self staticBindingFor: (name at: 2) inModule: module
! !

!EvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:58'!
storeAssociation: association value: anObject
	system storeAssociation: association value: anObject 
! !

!EvaluationContext methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:58'!
printOn: aStream
 self backtrace
				do: [ :frame | 
					frame
						do: [ :elem | elem printOn: aStream ]
						separatedBy: [ aStream nextPutAll: '. ' ].
					aStream cr ]
! !

!EvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:58'!
staticBindingFor: symbol inModule: module
	|  namespace assoc |
	namespace := system moduleNamespace: module.
	assoc := system lookupAssociationFor: symbol in: namespace.
	assoc ifNil: [ self error: 'unbound variable: ' , symbol asString ].
	^ SAssociationBinding new association: assoc
! !

!EvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:58'!
staticBindingForCvar: aSymbol
	| species namespaces namespace nilObj |
	species := system methodClassBinding: self method.
	nilObj := system nil.
	[ namespaces := system speciesNamespaces: species.
	1 to: namespaces size do: [ :i | 
		namespace := namespaces at: i. 
		(system lookupAssociationFor: aSymbol in: namespace)
			ifNotNil: [ :assoc | ^ SAssociationBinding new association: assoc ] ].
	species := system speciesSuperclass: species.
	species = nilObj ] whileFalse.
	^ nil
! !

!EvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:58'!
staticBindingForIvar: aSymbol
	| ivar |
	ivar := system staticBindingForIvar: aSymbol in: self self.
	^ ivar > 0
		ifTrue: [ SInstVarBinding new index: ivar ]
! !

!EvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:58'!
staticBindingForMvar: symbol
	| species module |
	species := system methodClassBinding: self method.
	module := system speciesModule: species.
	^ self staticBindingFor: symbol inModule: module
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
argumentAt: anInteger
	^arguments at: anInteger
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
argumentAt: index in: environmentIndex
	| env | 
	environmentIndex ifNil: [ ^ arguments at: index ].
	env := self environmentFor: environmentIndex.
	^ env at: index
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
arguments
	^arguments
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
arguments: aCollection
	arguments := aCollection
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
beBlock
	isBlock := true
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
environment: anObject
	environment := anObject
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
environmentFor: anInteger
	"
	-1: inlined argument.
	 0: current env.
 	>0: index of env in current env. "

	anInteger = 0
		ifTrue: [ ^ environment ].
	anInteger = -1
		ifTrue: [ ^ temporaries ].
	^ environment at: anInteger
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
homeContext
	| frame searched |
	isBlock
		ifFalse: [ ^ self ].
	frame := parent.
	searched := system closureHome: environment.
	[ frame notNil ]
		whileTrue: [ frame environment == searched
				ifTrue: [ ^ frame ].
			frame := frame parent ].
	self error: 'home context not found'
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
initialize
	isBlock := false
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
initializeForBlock: sblock args: anArray closure: closure
	"When the block is not inlined, closure becomes the environment of the new context.
	But when it is inlined, the environment is the one of the builder, which is already
	set because we copied from the builder frame."


	sblock isInlined
		ifTrue: [ anArray
				with: sblock inlinedArgs
				do: [ :arg :i | temporaries at: i put: arg ] ]
		ifFalse: [ temporaries := Array new: sblock tempCount.
			arguments := anArray.
			environment := closure. ]
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
isBlock
	^isBlock
	
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
isHomeOf: env
	^ environment == env andNot: [ isBlock ]
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
method
	^method
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
methodArguments
	^ arguments
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
parent
	^parent
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
parent: anEvaluationContext
	parent := anEvaluationContext.
	(isBlock not and: [self framesCount > 1000])
		ifTrue: [ self halt ].
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
receiver
	^_self
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
self
	^ _self
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
self: anObject
	_self := anObject
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
stackTemporaryAt: index
	^ temporaries at: index
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
stackTemporaryAt: index put: value
	^temporaries at: index put: value
	
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
temporaryAt: index in: environmentIndex
	| env |
	environmentIndex ifNil: [ ^ self stackTemporaryAt: index ].
	env := self environmentFor: environmentIndex.
	^ env at: index
! !

!LinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:05'!
temporaryAt: index in: environmentIndex put: value
	| env |
	environmentIndex ifNil: [ ^ self stackTemporaryAt: index put: value ].
	env := self environmentFor: environmentIndex.
	^ env at: index put: value
! !

!LinkedEvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:05'!
backtrace
	| bt next |
	bt := OrderedCollection new.
	next := self.
	[ next notNil and: [ next method notNil ] ]
		whileTrue: [ bt
				add:
					{next method signature.
					next self} , next arguments.
			next := next parent ].
	^ bt
! !

!LinkedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:05'!
environment
	^ environment
! !

!LinkedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:05'!
firstArgument
	^arguments at: 1
! !

!LinkedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:05'!
fourthArgument
	^ arguments at: 4
! !

!LinkedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:05'!
framesCount
	| current result |
	current := self.
	result := 0.
	[ current notNil ]
		whileTrue: [ result := result + 1.
			current := current parent ].
	^ result
! !

!LinkedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:05'!
method: aMethod
	| count |
	method := aMethod.
	count := system methodTempCount: aMethod.
	temporaries := Array new: count
! !

!LinkedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:05'!
secondArgument
	^ arguments at: 2
! !

!LinkedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:05'!
thirdArgument
	^ arguments at: 3
! !

!LinkedEvaluationContext class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:05'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!IterativeLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:00'!
beBlock
	super beBlock.
	operands := nil
! !

!IterativeLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:00'!
dropOperands: anInteger
	anInteger timesRepeat: [ operands removeLast ]
! !

!IterativeLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:00'!
hasFinished
	^parent isNil
! !

!IterativeLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:00'!
popOperand
	^operands removeLast
! !

!IterativeLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:00'!
popOperands: anInteger

	^ anInteger = 0 ifTrue: [#()] ifFalse: [operands removeLast: anInteger]
! !

!IterativeLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:00'!
pushOperand: anObject
	
	operands ifNil: [ operands := OrderedCollection new ].
	operands add: anObject
! !

!IterativeLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:00'!
restart
	operands ifNotNil: [operands reset]
! !

!IterativeLinkedEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:00'!
operandAt: anInteger
	^operands at: operands size - anInteger 
! !

!LinkedLinearEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:55'!
initialize
	super initialize.
pc := 1
! !

!LinkedLinearEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:55'!
restart
	super restart.
	pc := 1
! !

!LinkedLinearEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:55'!
work: aCollection
	work := aCollection
! !

!LinkedLinearEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
nextOperation
	| op |
	pc <= work size ifFalse: [^nil].
	op := work at: pc.
	pc := pc + 1.
	^ op
! !

!LinkedLinearEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
regPC: anInteger
	pc := anInteger
! !

!LinkedLinearEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
stackTemporaryAt: index
	| size |
	size := temporaries size.
	^index > size
		ifTrue: [ operands at: index - size ]
		ifFalse: [ temporaries at: index ]
! !

!LinkedLinearEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
stackTemporaryAt: index put: value
	| size |
	size := temporaries size.
	^ index > size
		ifTrue: [ operands at: index - size put: value ]
		ifFalse: [ temporaries at: index put: value ]
! !

!LinkedTreeEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:07'!
beBlock
	super beBlock.
	work := OrderedCollection new: 5.

! !

!LinkedTreeEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:07'!
hasWork
	^work notEmpty
! !

!LinkedTreeEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:07'!
initialize
	super initialize.
	work := OrderedCollection new: 5
! !

!LinkedTreeEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:07'!
popOperation
	^ work removeLast
! !

!LinkedTreeEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:07'!
pushOperation: anSExpression
	work add: anSExpression
! !

!LinkedTreeEvaluationContext methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:07'!
restart
	super restart.
		work reset.

! !

!LinkedTreeEvaluationContext class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:07'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!RecursiveLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:52'!
evaluateFor: interpreter

	| sexpressions result |
	nonLocalReturn := [ :value | 
	                  interpreter context: self homeContext parent.
	                  ^ value ].
	sexpressions := interpreter prepareForExecuting: method.
	result := interpreter visitMethod: sexpressions.
	interpreter context: self parent.
	^ result
! !

!RecursiveLinkedEvaluationContext methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:52'!
return: anObject
	^self isBlock
		ifTrue: [ nonLocalReturn value: anObject ]
		ifFalse: [ anObject ]
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
argumentAt: anInteger
	| args |
	args := self isBlock ifTrue: [ system blockArgumentCount: regM ] ifFalse: [ system methodArgumentCount: regM ].
	^stack at: regBP + 1 + (args - anInteger + 1)
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
argumentAt: index in: environmentIndex
	environmentIndex ifNil: [ ^ self argumentAt: index ].
	^self environment: environmentIndex at: index.

! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
arguments
	| count |
	self halt.
	count := system argumentCountOf: regM.
	^ (count to: 1 by: -1) collect: [ :i | self argumentAt: i ]
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
buildClosureFrameFor: receiver code: code environment: environment
	| temps |
	temps := system blockTempCount: code.
	self buildFrameFor: receiver code: code environment: environment temps: temps
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
buildFrameFor: receiver code: code environment: environment temps: temps
	regS := receiver.
	regM := code.
	self
		push: pc;
		push: regBP.
	regBP := regSP.
	regBP < 100 ifTrue: [ self error: 'stack overflow' ].
	self
		push: receiver;
		push: code;
		push: regE;
		push: environment.
	regE := environment.
	pc := 0.
	temps timesRepeat: [ self push: self nil ]
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
buildLaunchFrame
	| launcher code executable |
	launcher := system newCompiledMethod.
	code := system newArraySized: 0.
	executable := system newExecutableCodeFor: code.
	system methodExecutableCode: launcher put: executable.
	self
		buildMethodFrameFor: system nil
		code: launcher
		environment: system nil
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
buildMethodFrameFor: receiver code: code environment: environment
	| temps |
	temps := system methodTempCount: code.
	self
		buildFrameFor: receiver
		code: code
		environment: environment
		temps: temps
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
environment
	^regE
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
environment: environmentIndex at: index
	"
	-1: inlined argument.
	 0: current env.
 	>0: index of env in current env. "

	| env |
	environmentIndex = -1
		ifTrue: [ ^ self stackTemporaryAt: index ].
	env := environmentIndex = 0
		ifTrue: [ regE ]
		ifFalse: [ regE at: environmentIndex ].
	^ env at: index
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
environment: environmentIndex at: index put: value
	"
	-1: inlined argument.
	 0: current env.
 	>0: index of env in current env. "

	| env |
	environmentIndex = -1
		ifTrue: [ ^ self stackTemporaryAt: index put: value ].
	env := environmentIndex = 0
		ifTrue: [ regE ]
		ifFalse: [ regE at: environmentIndex ].
	^ env at: index put: value
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
firstArgument
	^ self argumentAt: 1
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
fourthArgument
	^ self argumentAt: 4
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
hasFinished
	^ regBP = 0 and: [ regSP = (stack size + 1) ]
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
incRegPC
	^pc := pc + 1
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
initialize
	super initialize.
	stack := Array new: 64 * 1024.
	regSP := stack size + 1.
	regBP := 0.
	pc := 0
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
isBlock
	^ system isBlock: regM
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
method
	^ self isBlock
		ifTrue: [ system blockMethod: regM ]
		ifFalse: [ regM ]
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
method: anSCompiledMethod
	regM := anSCompiledMethod

! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
methodArguments
	| count |
	count := system methodArgumentCount: regM.
	^ (count to: 1 by: -1) collect: [ :i | self argumentAt: i ]
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
operandAt: anInteger
	^ stack at: regSP + anInteger
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
pop
	| result |
	result := stack at: regSP.
	regSP := regSP + 1.
	^result

! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
popFrame
	regSP := regBP.
	regE := stack at: regBP - 3.
	regBP := self pop.
	pc := self pop.
		regM := stack at: regBP - 2.
	regS := stack at: regBP - 1.

! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
popLaunchFrame
	regSP := regBP.
	regE := stack at: regBP - 3.
	regBP := self pop.
	pc := self pop.
	regBP = 0
		ifTrue: [ ^ self ].
	regM := stack at: regBP - 2.
	regS := stack at: regBP - 1.

! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
popOperand
	^self pop
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
popOperands: anInteger
	| result |
	anInteger = 0
		ifTrue: [ ^ #() ].
	result := Array new: anInteger.
	anInteger to: 1 by: -1 do: [ :i | result at: i put: self pop ].
	^ result
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
printOn: aStream
	| slot |
	regSP to: regBP + 3 do: [ :i | slot := stack at: i. aStream nextPutAll: i hex; nextPutAll: ' -> '; print: slot;cr ].
	aStream nextPutAll: '...'; cr.

super printOn: aStream
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
printStack
	^String
		streamContents: [ :stream | 
			| slot |
			regSP to: stack size do: [ :i | 
				slot := stack at: i.
				stream
					nextPutAll: i hex;
					nextPutAll: ' -> ';
					print: slot;
					cr ] ]
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
push: anObject
	anObject ifNil: [ self halt ].
	regSP := regSP - 1.
	stack at: regSP put: anObject
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
pushOperand: anObject
	anObject ifNil: [ self halt ].
	regSP := regSP - 1.
	stack at: regSP put: anObject
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
receiver
	^ regS
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
regBP
	^ regBP
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
restart
	| nilObj |
	nilObj := system nil.
	regBP - self tempOffset to: regSP by: -1 do: [ :i | stack at: i put: nilObj ].
	pc := 1
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
secondArgument
	^ self argumentAt: 2
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
self
	^ regS
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
stackTemporaryAt: index
	^ stack at: regBP - self tempOffset - index
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
stackTemporaryAt: index put: value
	^ stack at: regBP - self tempOffset - index put: value
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
system: aPowertalkRuntime
	super system: aPowertalkRuntime.
	regE := regS := system nil
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
tempOffset
"should be 2 or 4 if we had methods without environment"
	^4
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
temporaryAt: index in: environmentIndex
	environmentIndex ifNil: [ ^ self stackTemporaryAt: index].
	^ self environment: environmentIndex at: index
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
temporaryAt: index in: environmentIndex put: value
	environmentIndex ifNil: [ ^ self stackTemporaryAt: index put: value ].
	^ self environment: environmentIndex at: index put: value
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
thirdArgument
	^ self argumentAt: 3
! !

!StackedEvaluationContext methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
unwind
	| home bp environment |
	home := system closureHome: self environment.
	home == system nil ifTrue: [ self error: 'cannot return because closure has no home' ].
	bp := regBP.
	[ bp !!= 0 ]
		whileTrue: [ environment := stack at: bp - 4.
			environment == home
				ifTrue: [ regBP := bp.
					^ self popFrame ].
			bp := stack at: bp ].
	self error: 'cannot return from this closure'
! !

!StackedEvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:47'!
backtrace
	| result bp code receiver |
	result := OrderedCollection new.
	bp := regBP.
	[ bp !!= 0 ]
		whileTrue: [ code := stack at: bp - 2.
			receiver := stack at: bp - 1.
			result add: {code. receiver}.
			bp := stack at: bp ].
	^ result
! !

!StackedEvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:47'!
dropOperands: anInteger
	regSP := regSP + anInteger
! !

!StackedEvaluationContext methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:47'!
reserveStackSlots: anInteger
	regSP := regSP - anInteger
! !

!StackedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
regM
	^ regM
! !

!StackedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
regPC
	^pc
! !

!StackedEvaluationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
regPC: anInteger
	pc := anInteger
! !

!PowertalkEvaluator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:59'!
booleanFor: aBoolean
	^ aBoolean
		ifTrue: [ trueObj ]
		ifFalse: [ falseObj ]
! !

!PowertalkEvaluator methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:59'!
booleanFrom: anObject
	anObject == falseObj
		ifTrue: [ ^ false ].
	anObject == trueObj
		ifTrue: [ ^ true ].
	self error: 'not a boolean'
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
context
	^ context 
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
context: anEvaluationContext
	context := anEvaluationContext
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
evaluateClosure: receiver
	^ self evaluateClosure: receiver withArgs: #()
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
evaluatePrimitiveHash: receiver
	| hash |
	hash := receiver headerHash.
	hash = 0
		ifTrue: [ hash := self nextHash.
			receiver headerHash: hash ].
	^ runtime newInteger: hash
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
initializeExecutableCodeOf: method

	^self subclassResponsibility
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
initializeLinearExecutableCodeOf: method

	| sexpressions executable |
	sexpressions := runtime sexpressionsOf: method.
	self linearizer visitMethod: sexpressions.
	executable := runtime newExecutableCodeFor:
		              self linearizer operations asArray.
	^runtime methodExecutableCode: method put: executable
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
initializeRecursiveExecutableCodeOf: method

	| sexpressions executable |
	sexpressions := runtime sexpressionsOf: method.
	executable := runtime newExecutableCodeFor: sexpressions.
	^runtime methodExecutableCode: method put: executable
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
isIdentical: anObject to: anotherObject
	^ anObject == anotherObject
		or: [ anObject isImmediate
				and: [ anotherObject isImmediate
						and: [ anObject value = anotherObject value ] ] ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
linearizer
	^self subclassResponsibility
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
lookup: aSymbol startingAt: aBehavior sendSite: anSMessage
	| method symbol |
	method := anSMessage methodFor: aBehavior.
	method
		ifNil: [ undermessages
				at: aSymbol
				ifPresent: [ :block | 
					anSMessage cacheUndermessage: block.
					^ block ].
			symbol := runtime symbolFrom: aSymbol.
			method := runtime lookup: symbol startingAt: aBehavior.
			method isNil ifTrue: [PowertalkEvaluatorError signal: symbol asString , ' not found in ', aBehavior asString on: context].
			anSMessage
				registerCacheWith: runtime;
				cache: method when: aBehavior ].
	^ method
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
prepareExecutableCode: method

	| code |
	code := runtime methodExecutableCode: method.
	(runtime isExecutableCode: code) ifTrue: [ ^ code ].
	^ self initializeExecutableCodeOf: method
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveFor: aSymbol
	^primitives at: aSymbol
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
primitivePrimeFor: anInteger
	| result |

	result := #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 269 359 479 641 857 1151 1549 2069 2237 2423 2617 2797 2999 3167 3359 3539 3727 3911 4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853 8783 9601 10243 10867 11549 12239 12919 13679 14293 15013 15731 17569 19051 20443 21767 23159 24611 25847 27397 28571 30047 31397 35771 38201 40841 43973 46633 48989 51631 54371 57349 60139 62969)
		detect: [ :i | i >= anInteger ].
	^ runtime newInteger: result
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
sendLocal: aSymbol to: receiver
	^ self sendLocal: aSymbol to: receiver with: {}
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
stackSize
	^context framesCount
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveBasicFlags
	^ [ :receiver :arguments | runtime newInteger: receiver headerFlags ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveBasicHash
	^ [ :receiver :arguments | runtime newInteger: receiver headerHash ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveBasicHashPut
	^ [ :receiver :arguments | receiver headerHash: arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveBitShiftLeft
	| result |
	^ [ :receiver :arguments | 
	result := receiver value bitShift: arguments first value.
	runtime newInteger: result ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveByteAt
	| result |
	^ [ :receiver :arguments | 
	result := receiver bytes at: arguments first value.
	runtime newInteger: result ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveByteAtPut

	^ [ :receiver :arguments | 
	receiver bytes
		at: arguments first value
		put: arguments second value.
	arguments second ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveHalt
	^ [ :receiver :arguments | receiver halt ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveIdentityEquals
	^ [ :receiver :arguments | runtime booleanFor: (self isIdentical: receiver to: arguments first)]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveIsLarge
	^ [ :receiver :arguments | runtime booleanFor: receiver isSmall not ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveIsSmallInteger
	^ [ :receiver :arguments | runtime booleanFor: receiver isImmediate ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveLargeSize
	^ [ :receiver :arguments | 
	receiver isSmall
		ifTrue: [ self error ].
	runtime newInteger: receiver size ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveLeadingZeroBitCount
	^ [ :receiver :arguments | 
	runtime
		newInteger: (self
		underprimitiveLeadingZeroBitCount: receiver value) ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveLeadingZeroBitCount: anInteger
	^ anInteger < 0
		ifTrue: [ 0 ]
		ifFalse: [ runtime wordSize * 8 - anInteger highBit ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIBitAnd
	^ [ :receiver :arguments | runtime newInteger: (receiver value bitAnd: arguments first value) ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIBitOr
	^ [ :receiver :arguments | runtime newInteger: (receiver value bitOr: arguments first value) ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIBitShiftLeft
	^ [ :receiver :arguments | runtime newInteger: receiver value << arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIBitShiftRight
	^ [ :receiver :arguments | 
	runtime
		newInteger: (receiver value >> arguments first value) ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIEquals
	^ [ :receiver :arguments | runtime booleanFor: receiver value = arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIGreaterEqualThan
	^ [ :receiver :arguments | runtime booleanFor: receiver value >= arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIGreaterThan
	^ [ :receiver :arguments | runtime booleanFor: receiver value > arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMILowerEqualThan
	^ [ :receiver :arguments | runtime booleanFor: receiver value <= arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMILowerThan
	^ [ :receiver :arguments | runtime booleanFor: receiver value < arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIMinus
	^ [ :receiver :arguments | runtime newInteger: receiver value - arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIPlus
	^ [ :receiver :arguments | runtime newInteger: receiver value + arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIQuotientTowardZero
	^ [ :receiver :arguments | runtime newInteger: (receiver value quo: arguments first value) ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMIRemainderTowardZero
	^ [ :receiver :arguments | runtime newInteger: (receiver value \\ arguments first value) ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSMITimes
	^ [ :receiver :arguments | runtime newInteger: receiver value * arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSmallIntegerByteAt
	| result |
	^ [ :receiver :arguments | 
	result := receiver value byteAt: arguments first value.
	runtime newInteger: result ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveSmallSize
	^ [ :receiver :arguments | 
	receiver isSmall
		ifFalse: [ self error ].
	runtime newInteger: receiver size ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveULongAtOffset
	| result |
	^ [ :receiver :arguments | 
	result := receiver bytes unsignedLongAt: arguments second value + 1.
	runtime newInteger: result ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveULongAtOffsetPut
	| value |
	^ [ :receiver :arguments | 
	value := arguments second.
	receiver bytes
		unsignedLongAt: arguments first value + 1
		put: value value.
	value ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveUShortAtOffset
	| result |
	^ [ :receiver :arguments | 
	result := receiver bytes
		unsignedShortAt: arguments second value + 1.
	runtime newInteger: result ]
! !

!PowertalkEvaluator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveUShortAtOffsetPut
	| value |
	^ [ :receiver :arguments | 
	value := arguments second.
	receiver bytes
		unsignedShortAt: arguments first value + 1
		put: value value.
	value ]
! !

!PowertalkEvaluator methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:59'!
convertPrimitives
	| original |
	original := primitives.
	primitives := IdentityDictionary new.
	original
		keysAndValuesDo:
			[ :symbol :block | primitives at: (runtime symbolFromLocal: symbol) put: block ]
! !

!PowertalkEvaluator methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:59'!
convertUndermessages
	| original |
	original := undermessages.
	undermessages := IdentityDictionary new.
	original keysAndValuesDo: [ :symbol :block | undermessages at: (runtime symbolFromLocal: symbol) put: block ]

! !

!PowertalkEvaluator methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:59'!
initializePrimitives

	primitives := IdentityDictionary new.
	primitives
		at: #Behavior put: self primitiveBehavior;
		at: #SetBehavior put: self primitiveSetBehavior;
		at: #Class put: self primitiveClass;
		at: #UnderHash put: self primitiveUnderHash;
		at: #UnderIsBytes put: self primitiveUnderIsBytes;
		at: #UnderPointersSize put: self primitiveUnderPointersSize;
		at: #UnderSize put: self primitiveUnderSize;
		at: #Size put: self primitiveSize;
		at: #Hash put: self primitiveHash;
		at: #At put: self primitiveAt;
		at: #AtPut put: self primitiveAtPut;
		at: #New put: self primitiveNew;
		at: #NewSized put: self primitiveNewSized;
		at: #NewBytes put: self primitiveNewBytes;
		at: #Equal put: self primitiveEqual;
		at: #SMIPlus put: self primitiveSMIPlus;
		at: #SMIMinus put: self primitiveSMIMinus;
		at: #SMITimes put: self primitiveSMITimes;
		at: #SMIIntDiv put: self primitiveSMIIntDiv;
		at: #SMIIntQuot put: self primitiveSMIIntQuot;
		at: #SMIBitAnd put: self primitiveSMIBitAnd;
		at: #SMIBitOr put: self primitiveSMIBitOr;
		at: #SMIBitXor put: self primitiveSMIBitXor;
		at: #SMIBitShift put: self primitiveSMIBitShift;
		at: #SMIHighBit put: self primitiveSMIHighBit;
		at: #SMIGreaterThan put: self primitiveSMIGreaterThan;
		at: #SMIGreaterEqualThan put: self primitiveSMIGreaterEqualThan;
		at: #SMIEqual put: self primitiveSMIEqual;
		at: #SMINotEqual put: self primitiveSMINotEqual;
		at: #SMISize put: self primitiveSMISize;
		at: #ClosureValue put: self primitiveClosureValue;
		at: #ClosureValueWithArgs put: self primitiveClosureValueWithArgs;
		at: #ClosureArgumentCount put: self primitiveClosureArgumentCount;
		at: #StringReplaceFromToWithStartingAt
		put: self primitiveStringReplaceFromToWithStartingAt;
		at: #FloatNew put: self primitiveFloatNew;
		at: #DictionaryNew put: self primitiveBootstrapDictNew;
		at: #FlushDispatchCaches put: self primitiveFlushDispatchCaches;
		at: #BootstrapDictBeConstant
		put: self primitiveBootstrapDictBeConstant;
		at: #BootstrapDictKeys put: self primitiveBootstrapDictKeys;
		at: #BootstrapDictAt put: self primitiveBootstrapDictAt;
		at: #BootstrapDictAtPut put: self primitiveBootstrapDictAtPut;
		at: #HostLoadModule put: self primitiveHostLoadModule;
		at: #HostFixOverrides put: self primitiveHostFixOverrides;
		at: #PrimeFor put: self primitivePrimeFor;
		at: #FlushFromCaches put: self primitiveFlushFromCaches
! !

!PowertalkEvaluator methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:59'!
initializeUndermessages
	undermessages := IdentityDictionary new.
	undermessages
		at: #_isSmallInteger put: self underprimitiveIsSmallInteger;
		at: #_isLarge put: self underprimitiveIsLarge;
		at: #_smallSize put: self underprimitiveSmallSize;
		at: #_largeSize put: self underprimitiveLargeSize;
		at: #_basicFlags put: self underprimitiveBasicFlags;
		at: #_basicAt: put: self underprimitiveBasicAt;
		at: #_basicAt:put: put: self underprimitiveBasicAtPut;
		at: #_byteAt: put: self underprimitiveByteAt;
		at: #_byteAt:put: put: self underprimitiveByteAtPut;
		at: #_basicHash put: self underprimitiveBasicHash;
		at: #_basicHash: put: self underprimitiveBasicHashPut;
		at: #_smallIntegerByteAt:
			put: self underprimitiveSmallIntegerByteAt;
		at: #_bitShiftLeft: put: self underprimitiveBitShiftLeft;
		at: #_primitiveULongAtOffset: put: self underprimitiveULongAtOffset;
		at: #_primitiveULongAtOffset:put:
			put: self underprimitiveULongAtOffsetPut;
		at: #_uShortAtOffset: put: self underprimitiveUShortAtOffset;
		at: #_uShortAtOffset:put: put: self underprimitiveUShortAtOffsetPut;
		at: #_smiPlus: put: self underprimitiveSMIPlus;
		at: #_smiMinus: put: self underprimitiveSMIMinus;
		at: #_smiTimes: put: self underprimitiveSMITimes;
		at: #_smiLowerThan: put: self underprimitiveSMILowerThan;
		at: #_smiLowerEqualThan: put: self underprimitiveSMILowerEqualThan;
		at: #_smiGreaterThan: put: self underprimitiveSMIGreaterThan;
		at: #_smiGreaterEqualThan:
			put: self underprimitiveSMIGreaterEqualThan;
		at: #_smiEquals: put: self underprimitiveSMIEquals;
		at: #_identityEquals: put: self underprimitiveIdentityEquals;
		at: #_leadingZeroBitCount
			put: self underprimitiveLeadingZeroBitCount;
		at: #_quotientTowardZero:
			put: self underprimitiveSMIQuotientTowardZero;
		at: #_remainderTowardZero:
			put: self underprimitiveSMIRemainderTowardZero;
		at: #_bitShiftLeft: put: self underprimitiveSMIBitShiftLeft;
		at: #_bitShiftRight: put: self underprimitiveSMIBitShiftRight;
		at: #_smiBitAnd: put: self underprimitiveSMIBitAnd;
		at: #_smiBitOr: put: self underprimitiveSMIBitOr;
		at: #_halt put: self underprimitiveHalt
! !

!PowertalkEvaluator methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:59'!
runtime
	^runtime

! !

!PowertalkEvaluator methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:59'!
runtime: aPowertalkRuntime
	runtime := aPowertalkRuntime.
	nilObj := runtime nil.
	trueObj := runtime true.
	falseObj := runtime false.
	self
		initializeUndermessages;
		initializePrimitives; convertUndermessages ; convertPrimitives 
! !

!PowertalkEvaluator methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:59'!
evaluateClosure: aPClosure with: anObject
	 ^self evaluateClosure: aPClosure withArgs: { anObject }
! !

!PowertalkEvaluator methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:59'!
evaluateClosure: aPClosure with: anObject with: anotherObject
	^ self evaluateClosure: aPClosure withArgs: {anObject. anotherObject}
! !

!PowertalkEvaluator methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:59'!
prepareForExecuting: method

	| code |
	code := self prepareExecutableCode: method.
	^ runtime executableCodeWork: code
! !

!PowertalkEvaluator methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:59'!
evaluateClosure: receiver withArgs: arguments
	^self subclassResponsibility
! !

!PowertalkEvaluator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:59'!
false
	^ falseObj
! !

!PowertalkEvaluator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:59'!
initialize

	messageCount := 0
! !

!PowertalkEvaluator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:59'!
nil
	^nilObj
	
! !

!PowertalkEvaluator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:59'!
true
	^ trueObj
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveAt
	| receiver index value |
	^ [ receiver := context self.
	index := context firstArgument value.
	value := receiver at: index.
	receiver isBytes
		ifTrue: [ runtime newInteger: value ]
		ifFalse: [ value ] ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveAtPut
	| index |
	^ [ index := context firstArgument value.
	context self at: index put: context secondArgument ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveBehavior
	| receiver |
	^ [ receiver := context self.
	receiver isImmediate
		ifTrue: [ self smallintBehavior ]
		ifFalse: [ receiver behavior ] ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveBootstrapDictAt
	| string |
	^ [ string := context firstArgument asString.
	context self at: string ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveBootstrapDictAtPut
	| string |
	^ [ string := context firstArgument asString.
	context self at: string put: context secondArgument ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveBootstrapDictBeConstant
	^ [ context self beConstant ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveBootstrapDictKeys
	^ [ context self keys ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveBootstrapDictNew
	^ [ runtime newBootstrapDictionaryOf: context self ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveClass
	^ [ runtime speciesFor: context self ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveClosureArgumentCount
	^ [ runtime newInteger: context self block argumentCount ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveClosureValue
	^ [ self evaluateClosure: context self ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveClosureValueWithArgs
	^ [ self
		evaluateClosure: context self
		withArgs: context methodArguments ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveEqual
	^ [ runtime booleanFor: context self = context firstArgument ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveFloatNew
	^ [ runtime newBytesOf: context self sized: 8 ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveFlushDispatchCaches
	^ [ runtime
		flushDispatchCache: context self
		in: context firstArgument ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveFlushFromCaches

	^ [ runtime flushDispatchCache: (runtime methodSelector: context self)]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveHash
	^ [ runtime newInteger: (runtime hashFor: context self) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveHostFixOverrides
	^ [ runtime fixOverrides ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveHostLoadModule
	^ [ runtime loadModule: context firstArgument]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveNew
	^ [ runtime newSlotsOf: context self ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveNewBytes
	| size |
	^ [ size := context firstArgument value.
	runtime newBytesOf: context self sized: size ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveNewObjectHeap
	^ [ runtime newObjectHeap ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveNewSized
	| size |
	^ [ size := context firstArgument value.
	runtime newOf: context self sized: size ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitivePrimeFor
	^ [ self primitivePrimeFor: context firstArgument value ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIBitAnd
	^ [ runtime
		newInteger:
			(context self value
				bitAnd: (runtime integerFrom: context firstArgument)) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIBitOr
	^ [ runtime
		newInteger:
			(context self value
				bitOr: (runtime integerFrom: context firstArgument)) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIBitShift
	^ [ runtime
		newInteger:
			(context self value
				bitShift: (runtime integerFrom: context firstArgument)) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIBitXor
	^ [ runtime
		newInteger:
			(context self value
				bitXor: (runtime integerFrom: context firstArgument)) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIEqual
	^ [ runtime
		booleanFor: (
			context self value = 
				context firstArgument value) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIGreaterEqualThan
	^ [ runtime
		booleanFor:
			context self value
				>= (runtime integerFrom: context firstArgument) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIGreaterThan
	^ [ runtime
		booleanFor: context self value > (runtime integerFrom: context firstArgument) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIHighBit
	^ [ runtime newInteger: context self value highBit ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIIntDiv
	^ [ runtime
		newInteger:
			context self value
				// (runtime integerFrom: context firstArgument ) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIIntQuot
	^ [ runtime
		newInteger:
			context self value
				\\ (runtime integerFrom: context firstArgument) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIMinus
	^ [ runtime
		newInteger:
			context self value
				- (runtime integerFrom: context firstArgument) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMINotEqual
	^ [ runtime
		booleanFor:
			context self value
				!!= (runtime integerFrom: context firstArgument) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMIPlus
	^ [ runtime
		newInteger:
			context self value
				+ (runtime integerFrom: context firstArgument) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMISize
	^ [ runtime newInteger: context self value bytesCount ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSMITimes
	^ [ runtime
		newInteger:
			context self value
				* (runtime integerFrom: context firstArgument) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSetBehavior
	| receiver |
	^ [ receiver := context self.
	receiver behavior: context firstArgument.
	receiver ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveSize
	^ [ runtime newInteger: (runtime arrayedSizeOf: context self) ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveStringReplaceFromToWithStartingAt
	| receiver |
	^ [ receiver := context self.
	receiver bytes
		replaceFrom: context firstArgument value
		to: context secondArgument value
		with: context thirdArgument bytes
		startingAt: context fourthArgument value.
	receiver ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveUnderHash
	^ [ runtime newInteger: context self headerHash ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveUnderIsBytes
	^ [ runtime booleanFor: context self isBytes ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveUnderPointersSize
	^ [ runtime newInteger: context self pointersSize ]
! !

!PowertalkEvaluator methodsFor: 'primitives' stamp: 'KenD 11/22/2023 07:48:59'!
primitiveUnderSize
	^ [ runtime newInteger: context self size ]
! !

!PowertalkEvaluator methodsFor: 'underprimitives' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveBasicAt
	^ [ :receiver :arguments | receiver slots at: arguments first value ]
! !

!PowertalkEvaluator methodsFor: 'underprimitives' stamp: 'KenD 11/22/2023 07:48:59'!
underprimitiveBasicAtPut

	^ [ :receiver :arguments | 
	  receiver slots
		  at: arguments first value
		  put: arguments second.
	  arguments second ]
! !

!PowertalkEvaluator class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:59'!
undermessages
	^#(_basicAt: #_basicAt:put: _bitShiftLeft: _byteAt: #_byteAt:put: _smallSize _largeSize _isSmallInteger _basicHash _basicHash: _smallIntegerByteAt: _uShortAtOffset: #_uShortAtOffset:put:)
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
evaluate
	^self subclassResponsibility

! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
hasFinished
	^ context hasFinished
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
prepareDispatch: dispatch
	self subclassResponsibility
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
prepareForBlock: sblock
	^self subclassResponsibility	
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
regR: anObject
	regR := anObject
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
underprimitiveRestart
	^ self subclassResponsibility 
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitBlock: anSBlock
	regR := context captureClosure: anSBlock
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitIdentifier: anSIdentifier
	regR := anSIdentifier binding valueWithin: context
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitLiteral: anSLiteral
	regR := runtime literalFor: anSLiteral value
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpAssign: anSOpAssign
	anSOpAssign assignees
		do: [ :identifier | identifier binding assign: regR within: context ]
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpDropToS: anSOpDropToS
	context dropOperands: anSOpDropToS count
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpLoadRfromFrame: anSOpLoadRfromFrame
	regR := context stackTemporaryAt: anSOpLoadRfromFrame index
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpLoadRfromStack: anSOpLoadRfromStack
	regR := context operandAt: anSOpLoadRfromStack index
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpLoadRwithNil: anSOpLoadRwithNil
	regR := nilObj
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpLoadRwithSelf: anSOpLoadRwithSelf
	regR := context self
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpPushR: anSOpPushR
	context pushOperand: regR
! !

!PowertalkIterativeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:00'!
visitOpStoreRintoFrame: anSOpStoreRintoFrame
	context stackTemporaryAt: anSOpStoreRintoFrame index put: regR
! !

!PowertalkIterativeInterpreter methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:49:00'!
initializeUndermessages
	super initializeUndermessages.
	undermessages 		at: #_restart put: self underprimitiveRestart
	
! !

!PowertalkIterativeLinkedInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:45'!
evaluateClosure: closure withArgs: arguments
	| frame sblock |
	frame := closure builder.
	sblock := closure executionTree.
	context := frame copy
		beBlock;
		parent: context;
		initializeForBlock: sblock args: arguments closure: closure.
	^ self prepareForBlock: sblock
! !

!PowertalkIterativeLinkedInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:45'!
evaluationContextClass
	^self subclassResponsibility
! !

!PowertalkIterativeLinkedInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:45'!
sendLocal: aSymbol to: receiver with: anArray
	| symbol literal dummy message dispatch |
	symbol := runtime symbolFromLocal: aSymbol.
	literal := SLiteral new value: nilObj.
	dummy := Array new: anArray size withAll: literal.
	message := SMessage new
		selector: symbol;
		receiver: literal;
		arguments: dummy.
	dispatch := SOpDispatchMessage new message: message.
	regR := receiver.
	context := self evaluationContextClass new system: self.
	self prepareDispatch: dispatch.
	dummy isEmpty
		ifFalse: [ context pushOperand: receiver ].
	anArray do: [ :arg | context pushOperand: arg ].
	self evaluate.
	^ regR
! !

!PowertalkIterativeLinkedInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:45'!
visitOpDispatchMessage: anSOpDispatchMessage

	| message argcount arguments behavior method size environment |
	message := anSOpDispatchMessage message.
	argcount := message argumentCount.
	arguments := context popOperands: argcount.
	(argcount > 0 andNot: [ message isCascadeMessage ]) ifTrue: [ 
		context popOperand ].
	message cachedUndermessage ifNotNil: [ :block | 
		^ regR := block value: regR value: arguments ].
	behavior := message receiver isSuper
		            ifTrue: [ runtime superBehaviorOf: context classBinding ]
		            ifFalse: [ runtime behaviorOf: regR ].
	method := self
		          lookup: message selector
		          startingAt: behavior
		          sendSite: message.
	method isBlock ifTrue: [ 
		^ regR := method value: regR value: arguments ].
	size := runtime methodEnvironmentSize: method.
	environment := runtime newEnvironmentSized: size.
	context := self evaluationContextClass new
		           self: regR;
		           arguments: arguments;
		           environment: environment;
		           system: runtime;
		           method: method;
		           parent: context.
	self prepareForExecuting: method
! !

!PowertalkIterativeLinkedInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:45'!
visitOpNonLocalReturn: anSOpReturn
	context := context homeContext parent
! !

!PowertalkIterativeLinkedInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:45'!
visitOpReturn: anSOpReturn
	context := context parent
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
evaluate
	| operation |
	[ operation := context nextOperation. operation notNil]
		whileTrue: [ 			operation acceptVisitor: self ].
	Transcript print: 'MessageCount: ' , messageCount asString; cr.
	^ regR
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
evaluationContextClass
	^ LinkedLinearEvaluationContext
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
initialize
	super initialize.
	linearizer := SExpressionLinearizer new.

! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
initializePrimitives
	super initializePrimitives.
	linearizer primitives: primitives
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
prepareDispatch: dispatch
	context work:  {dispatch}
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
prepareForBlock: sblock
	| operations |
	operations := sblock optimizedCode.
	context work: operations; restart .
	^ nilObj
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
prepareForExecuting: method
| work |
work := self prepareForExecuting: method.
	context work: work
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
underprimitiveRestart
	^ [ :receiver :arguments | 
	context
		restart]
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
visitOpJump: anSOpJump
	context regPC: anSOpJump target + 1
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
visitOpJumpFalse: anSOpJumpFalse
	regR == falseObj
		ifTrue: [ context regPC: anSOpJumpFalse target+1 ]
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
visitOpJumpTrue: anSOpJumpTrue
	regR == trueObj
		ifTrue: [ context regPC: anSOpJumpTrue target +1]
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
visitOpPopR: anSOpPopR
	regR := context popOperand
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:13'!
visitOpPrimitive: anSOpPrimtive
	regR := anSOpPrimtive block value
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:13'!
initializeExecutableCodeOf: method

	^ self initializeLinearExecutableCodeOf: method
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:13'!
linearizer
	^linearizer
! !

!PowertalkLinkedLinearInterpreter methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:13'!
runtime: aPowertalkRuntime
	super runtime: aPowertalkRuntime.
	linearizer runtime: aPowertalkRuntime
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
dropToS
	context pushOperation: SOpDropToS new
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
evaluate
	| operation |
	[ context hasWork ]
		whileTrue: [ operation := context popOperation.
			operation acceptVisitor: self ].
	Transcript print: 'MessageCount: ' , messageCount asString; cr.
	^ regR
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
evaluationContextClass
	^ LinkedTreeEvaluationContext
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
initializeExecutableCodeOf: method

	^self initializeRecursiveExecutableCodeOf: method
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
linearizer

	self shouldNotImplement
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
loadRfromStack: anInteger
	| load |
	load := SOpLoadRfromStack new index: anInteger.
		context pushOperation: load
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
loadRwithSelf
		context pushOperation:SOpLoadRwithSelf new
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
prepareDispatch: dispatch
	context pushOperation: dispatch
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
prepareForBlock: sblock
	| statements |
	statements := sblock statements.
	(statements isEmpty orNot: [ statements last isReturn ])
		ifTrue: [ context pushOperation: SOpReturn new ].
	statements reverseDo: [ :exp | context pushOperation: exp ].
	^ nilObj
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
prepareForExecuting: method

	| work |
	work := super prepareForExecuting: method.
	self push: work
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
push: anSExpression
		context pushOperation: anSExpression
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
pushOpAssign: aCollection
	| op |
	op := SOpAssign new assignees: aCollection.
		context pushOperation: op
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
pushOpReturn
		context pushOperation: SOpReturn new
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
pushOpReturn: aBoolean
	| class |
	class := (aBoolean andNot: [ context isBlock ])
		ifTrue: [ SOpReturn ]
		ifFalse: [ SOpNonLocalReturn ].
	context pushOperation: class new
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
pushR
		context pushOperation: SOpPushR new
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
visitAssignment: anSAssignment
	self
		pushOpAssign: anSAssignment assignees;		push: anSAssignment expression

! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
visitCascade: anSCascade
	| dispatch args argsize |
	self dropToS.
	anSCascade messages
		reverseDo: [ :msg | 
			dispatch := SOpDispatchMessage new message: msg.
			self push: dispatch.
			args := msg arguments.
			argsize := args size.
			self loadRfromStack: argsize.
			args
				reverseDo: [ :arg | 
					self
						pushR;
						push: arg ] ].
	self
		pushR;
		push: anSCascade receiver
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
visitMessage: anSMessage
	| dispatch args argsize |
	messageCount := messageCount + 1.
	dispatch := SOpDispatchMessage new message: anSMessage.
	self push: dispatch.
	args := anSMessage arguments.
	argsize := args size.
	argsize > 0
		ifTrue: [ self loadRfromStack: argsize ].
	args
		reverseDo: [ :arg | 
			self
				pushR;
				push: arg ].
	argsize > 0
		ifTrue: [ self pushR ].
	self push: anSMessage receiver
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
visitMethod: anSMethod
	| primitive statements |
	primitive := anSMethod pragma.
	primitive
		ifNotNil: [ primitive class == SPragma
				ifTrue: [ primitive := self primitiveFor: anSMethod primitive.
					anSMethod pragma: primitive ].
			self pushOpReturn.
			^ regR := primitive value ].
	statements := anSMethod statements.
	(statements isEmpty orNot: [ statements last isReturn ])
		ifTrue: [ self
				pushOpReturn;
				loadRwithSelf ].
	statements reverseDo: [ :node | self push: node ]
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
visitOpRestart: anSOpRestart

 self prepareForExecuting: context method
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
visitReturn: anSReturn
	self
		pushOpReturn: anSReturn local;
		push: anSReturn expression
! !

!PowertalkLinkedTreeInterpreter methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:49:06'!
underprimitiveRestart

	^ [ :receiver :arguments | 
	  
	  context
		  restart.
		self prepareForExecuting: context method.
	  
		   ]
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
evaluate
	| operation |
	[ operation := self nextOperation.
	operation notNil ] whileTrue: [ operation acceptVisitor: self ].
	^ regR
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
evaluateUndermessage: message with: block
	| argcount arguments |
	argcount := message argumentCount.
	arguments := context popOperands: argcount.
	regR := block value: regR value: arguments.
	context reserveStackSlots: argcount
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
initialize
	super initialize.
	context := StackedEvaluationContext new.
	linearizer := SExpressionLinearizer new
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
initializePrimitives
	super initializePrimitives.
	linearizer primitives: primitives
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
nextOperation
 | pc |
pc := context incRegPC.
	pc <= work size
		ifFalse: [ ^ nil ].
	^ work at: pc
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
sendLocal: aSymbol to: receiver with: anArray
	| symbol literal dummy message dispatch prevWork prevPC |
	symbol := runtime symbolFromLocal: aSymbol.
	literal := SLiteral new value: nilObj.
	dummy := Array new: anArray size withAll: nil.
	message := SMessage new
		selector: symbol;
		receiver: literal;
		arguments: dummy.
	dispatch := SOpDispatchMessage new message: message.
	prevWork := work.
	prevPC := context regPC.
	context buildLaunchFrame.
	regR := receiver.
	anArray isEmpty
		ifFalse: [ context pushOperand: receiver ].
	anArray do: [ :arg | context pushOperand: arg ].
	work := {dispatch}.
	context regPC: 0.
	self evaluate.
	context popLaunchFrame.
	work := prevWork.
	context regPC: prevPC.
	^ regR
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
underprimitiveRestart
	^ [ :receiver :arguments | context restart ]
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpDispatchMessage: anSOpDispatchMessage

	| message behavior method size environment |
	message := anSOpDispatchMessage message.
	message cachedUndermessage ifNotNil: [ :block | 
		^ self evaluateUndermessage: message with: block ].
	behavior := message receiver isSuper
		            ifTrue: [ runtime superBehaviorOf: context classBinding ]
		            ifFalse: [ runtime behaviorOf: regR ].
	method := self
		          lookup: message selector
		          startingAt: behavior
		          sendSite: message.
	method isBlock ifTrue: [ 
		^ self evaluateUndermessage: message with: method ].
	size := runtime methodEnvironmentSize: method.
	environment := runtime newEnvironmentSized: size.
	work := self prepareForExecuting: method.
	context
		buildMethodFrameFor: regR
		code: method
		environment: environment
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpJump: anSOpJump
	context regPC: anSOpJump target
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpJumpFalse: anSOpJumpFalse
	regR == falseObj
		ifTrue: [ context regPC: anSOpJumpFalse target ]
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpJumpTrue: anSOpJumpTrue
	regR == trueObj
		ifTrue: [ context regPC: anSOpJumpTrue target ]
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpNonLocalReturn: anSOpReturn

	| code |
	context unwind.
	code := runtime methodExecutableCode: context regM.
	work := runtime executableCodeWork: code
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpPopR: anSOpPopR
	regR := context pop
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpPrimitive: anSOpPrimtive
	regR := anSOpPrimtive block value
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:54'!
visitOpReturn: anSOpReturn

	| code |
	context popFrame.
	code := runtime methodExecutableCode: context regM.
		work := runtime executableCodeWork: code.
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:54'!
evaluateClosure: closure withArgs: arguments

	| block code receiver |
	block := runtime closureBlock: closure.
	code := self prepareBlockExecutableCode: block.
	work := runtime executableCodeWork: code.
	receiver := (runtime blockCapturesSelf: block)
		            ifTrue: [ closure at: 1 ]
		            ifFalse: [ nilObj ].
	context
		popFrame;
		buildClosureFrameFor: receiver code: block environment: closure.
	^ regR
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:54'!
initializeExecutableCodeOf: method

	^ self initializeLinearExecutableCodeOf: method
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:54'!
linearizer
	^linearizer
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:54'!
prepareBlockExecutableCode: block

	| code method |
	code := runtime blockExecutableCode: block.
	(runtime isExecutableCode: code) ifTrue: [ ^ code ].
	method := runtime blockMethod: block.
	self initializeExecutableCodeOf: method.
	code := runtime blockExecutableCode: block.
	self ASSERT: (runtime isExecutableCode: code).
	^ code
! !

!PowertalkIterativeStackedInterpreter methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:54'!
runtime: aPowertalkRuntime
	super runtime: aPowertalkRuntime.
	linearizer
		runtime: aPowertalkRuntime;
		dropsArguments.
	context system: runtime
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
evaluateClosure: receiver whileFalse: arg
	| result |
	[ result := self evaluateClosure: receiver.
	self booleanFrom: result ]
		whileFalse: [ self evaluateClosure: arg ].
	^ receiver
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
evaluateClosure: receiver whileTrue: arg
	| result |
	[ result := self evaluateClosure: receiver.
	self booleanFrom: result ] whileTrue: [ self evaluateClosure: arg ].
	^ receiver
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
hasFinished
	^context isNil
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
initializeExecutableCodeOf: method

	^self initializeRecursiveExecutableCodeOf: method
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
initializePrimitives
	super initializePrimitives.
	primitives 
		at: #ClosureWhileTrue put: self primitiveClosureWhileTrue;
		at: #ClosureWhileFalse put: self primitiveClosureWhileFalse
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
primitiveClosureWhileFalse
	^ [ self
		evaluateClosure: context self
		whileFalse: context arguments first ]
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
primitiveClosureWhileTrue
	^ [ self
		evaluateClosure: context self
		whileTrue: context arguments first ]
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
send: aSymbol to: receiver with: arguments super: aBoolean
	^self send: aSymbol to: receiver with: arguments super: aBoolean sendSite: SMessage new

! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
send: aSymbol to: receiver with: arguments super: aBoolean sendSite: anSMessage
	| behavior method environment size |
	anSMessage cachedUndermessage
		ifNotNil: [ :block | ^ block value: receiver value: arguments ].
	behavior := aBoolean
		ifTrue: [ runtime superBehaviorOf: context classBinding ]
		ifFalse: [ runtime behaviorOf: receiver ].
	method := self
		lookup: aSymbol
		startingAt: behavior
		sendSite: anSMessage.
	method isBlock
		ifTrue: [ ^ method value: receiver value: arguments ].
	self ASSERT: method notNil.
	size := runtime methodEnvironmentSize: method.
	environment := runtime newEnvironmentSized: size.
	context := RecursiveLinkedEvaluationContext new
		self: receiver;
		arguments: arguments;
		environment: environment;
		parent: context;
		method: method;
		system: runtime.
	^ context evaluateFor: self
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
sendLocal: aSymbol to: receiver with: anArray
	| symbol res |
	symbol := runtime symbolFromLocal: aSymbol.
	res := self
		send: symbol
		to: receiver
		with: anArray
		super: false.
	^ res
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitAssignment: anSAssignment
	| result |
	result := anSAssignment expression acceptVisitor: self.
	anSAssignment assignees
		do: [ :identifier | identifier binding assign: result within: context ].
	^ result
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitBlock: anSBlock
	^ context captureClosure: anSBlock
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitCascade: anSCascade
	| recv args  last |
	recv := anSCascade receiver acceptVisitor: self.
	anSCascade messages
		do: [ :msg | 
			args := msg arguments collect: [ :code | code acceptVisitor: self ].
			last := self
				send: msg selector
				to: recv
				with: args
				super: anSCascade receiver isSuper
				sendSite: msg ].
	^ last
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitIdentifier: anSIdentifier
	^ anSIdentifier binding valueWithin: context
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitLiteral: anSLiteral
	^ runtime literalFor: anSLiteral value
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitMessage: anSMessage
	| recv args |
	recv := anSMessage receiver acceptVisitor: self.
	args := anSMessage arguments
		collect: [ :code | code acceptVisitor: self ].
	^ self
		send: anSMessage selector
		to: recv
		with: args
		super: anSMessage receiver isSuper
		sendSite: anSMessage
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitMethod: anSMethod
	| primitive |
	primitive := anSMethod pragma.
	primitive ifNil: [ ^ self evaluateMethodStatements: anSMethod ].
	primitive class == SPragma
		ifTrue: [ primitive := self primitiveFor: anSMethod primitive.
			anSMethod pragma: primitive ].
	^ primitive value
! !

!PowertalkRecursiveInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:18'!
visitReturn: anSReturn
	| value |
	value := anSReturn expression acceptVisitor: self.
	^context return: value
! !

!PowertalkRecursiveInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:18'!
evaluateClosure: closure withArgs: arguments
	| frame sblock result |
	frame := closure builder.
	sblock := closure executionTree.
	context := frame copy
		beBlock;
		parent: context;
		initializeForBlock: sblock args: arguments closure: closure.
	result := nilObj.
	sblock statements do: [ :node | result := node acceptVisitor: self ].
	^ result
! !

!PowertalkRecursiveInterpreter methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:18'!
evaluateMethodStatements: anSMethod
	| last result |
	last := nil.
	anSMethod statements
		do: [ :node | 
			last := node.
			result := node acceptVisitor: self ].
	^ (last notNil and: [ last isReturn ])
		ifTrue: [ result ]
		ifFalse: [ context self ]
! !

!PowertalkRecursiveInterpreter methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:18'!
linearizer

	self shouldNotImplement
! !

!PowertalkRecursiveInterpreter methodsFor: 'initializing' stamp: 'KenD 11/22/2023 07:48:18'!
runtime: aPowertalkRuntime
	super runtime: aPowertalkRuntime.
	aPowertalkRuntime
		override: #Closure -> #whileTrue: withPrimitive: 'ClosureWhileTrue';
		override: #Closure -> #whileFalse: withPrimitive: 'ClosureWhileFalse'
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
behaviorOf: anObject
	^self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
evaluatePrimitiveHash: receiver
	| hash |
	hash := receiver headerHash.
	hash = 0
		ifTrue: [ hash := self nextHash.
			receiver headerHash: hash ].
	^ self newInteger: hash
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
executableCodeWork: anLMRExecutableCode

	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
flushDispatchCache: aSymbol

	| cached |
	symbolCache
		at: aSymbol
		ifPresent: [ :messages | messages do: #flushCache ].
	cached := methodCache keys select: [ :key |  key key == aSymbol ].
	cached do: [ :key | methodCache removeKey: key]
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
flushDispatchCache: aSymbol in: class
	| behavior |
	behavior := self speciesInstanceBehavior: class.
	symbolCache at: aSymbol ifPresent: [ :messages | messages do: #flushCache ].
	^ methodCache removeKey: aSymbol -> behavior ifAbsent: nil
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
instanceVarOf: receiver at: anInteger
	^ receiver slotAt: anInteger
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
instanceVarOf: receiver at: anInteger put: value
	^ receiver slotAt: anInteger put: value
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
isClosure: anObjectMap
	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
literalFor: anObject
	^anObject
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
localMethodAstcodes: method

	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
localSymbolFrom: anObject
	^ anObject bytes allButLast asString asSymbol
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
lookup: aSymbol startingAt: aBehavior
	^methodCache at: aSymbol -> aBehavior ifAbsentPut: [ self doLookup: aSymbol startingAt: aBehavior ]
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
methodAstcodes: method

	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
methodClassBinding: method
	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
methodEnvironmentSize: anObject
	^self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newBootstrapDictionaryOf: receiver
	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newBytesOf: receiver sized: size
	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newClosureFor: compiledBlock
	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newEnvironmentSized: anInteger
	^self subclassResponsibility

! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newExecutableCodeFor: anObject
	^ self subclassResponsibility

! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newInteger: anInteger
	^self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newOf: receiver sized: size
	^ self subclassResponsibility

! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
newSlotsOf: receiver
^self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
registerCache: anSMessage for: symbol
	| messages |
	messages := symbolCache at: symbol ifAbsentPut: [OrderedCollection new].
	messages add: anSMessage 
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
sendLocal: aSymbol to: receiver
	^ self sendLocal: aSymbol to: receiver with: {}
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
sendLocal: aSymbol to: receiver with: anArray
	^interpreter sendLocal: aSymbol to: receiver with: anArray
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
sexpressionsOf: method

	| astcodes decoder |
	astcodes := self localMethodAstcodes: method.
	decoder := AstcodeDecoder new
		           stream: astcodes readStream;
		           method: method;
		           builder: self.
	^ decoder decodeMethod
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
speciesFor: anObject
	^ self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
speciesInstanceBehavior: class
^	self subclassResponsibility 
! !

!PowertalkRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:12'!
symbolFrom: anObject
	^anObject
! !

!PowertalkRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:12'!
booleanFor: aBoolean
	^ aBoolean
		ifTrue: [ trueObj ]
		ifFalse: [ falseObj ]
! !

!PowertalkRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:12'!
booleanFrom: anObject
	anObject == falseObj
		ifTrue: [ ^ false ].
	anObject == trueObj
		ifTrue: [ ^ true ].
	self error: 'not a boolean'
! !

!PowertalkRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:12'!
false
	^ falseObj
! !

!PowertalkRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:12'!
initialize
	methodCache := Dictionary new.
	symbolCache := Dictionary new.
	overrides := Dictionary new
! !

!PowertalkRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:12'!
initializeInterpreter
	"interpreter := PowertalkRecursiveInterpreter new runtime: self"

	"interpreter := PowertalkIterativeTreeInterpreter new runtime: self"

	"interpreter := PowertalkLinkedLinearInterpreter new runtime: self"

	interpreter := PowertalkIterativeStackedInterpreter new runtime: self
! !

!PowertalkRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:12'!
interpreter
	^interpreter
! !

!PowertalkRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:12'!
nil
	^nilObj
	
! !

!PowertalkRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:12'!
symbolFromLocal: aSymbol
	^self subclassResponsibility
! !

!PowertalkRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:12'!
true
	^ trueObj
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
addSymbol: aSymbol
	| string |
	string := self newString: aSymbol asString.
	^ self sendLocal: #asSymbol to: string
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
arrayClass: anLMRObject
	arrayClass := anLMRObject 
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
arrayedSizeOf: anLMRObject
	| species ivars |
	anLMRObject isImmediate ifTrue: [ ^0 ].
	species := self speciesFor: anLMRObject.
	ivars := self speciesInstanceSize: species.
	^anLMRObject size - ivars
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorClass: anLMRObject
	^ anLMRObject slotAt: behaviorClassIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorClassIndex: anInteger
	behaviorClassIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorClass_: anLMRObject
	behaviorClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorMethodDictionary: anLMRObject
	^ anLMRObject slotAt: behaviorMethodDictionaryIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorMethodDictionaryIndex: anInteger
	behaviorMethodDictionaryIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorNext: anLMRObject
	^ anLMRObject slotAt: behaviorNextIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorNextIndex: anInteger
	behaviorNextIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
behaviorOf: anLMRObject
	^anLMRObject isImmediate ifTrue: [ self smallIntegerBehavior ] ifFalse: [anLMRObject behavior]
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockArgumentCount: anLMRObject
	| flags |
	flags := anLMRObject slotAt: methodFlagsIndex.
	^ flags value bitsAt: BlockArgCount
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockCapturesHome: block
	| flags |
	flags := block slotAt: methodFlagsIndex.
	^ flags value anyMask: BlockCapturesHome
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockCapturesSelf: block
	| flags |
	flags := block slotAt: methodFlagsIndex.
	^ flags value anyMask: BlockCapturesSelf
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockClass: anLMRObject
	blockClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockEnvironmentCount: anLMRObject
	| flags |
	flags := anLMRObject slotAt: methodFlagsIndex.
	^ flags value bitsAt: BlockEnvCount
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockExecutableCode: anLMRObject

	^ self methodExecutableCode: anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockExecutableCode: anLMRObject put: anObject
	^ self methodExecutableCode: anLMRObject put: anObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockExecutionTree: anLMRObject
	^ anLMRObject slotAt: compiledCodeExecutableCodeIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockMethod: anLMRObject
	^ anLMRObject slotAt: blockMethodIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockMethodIndex: anInteger
	blockMethodIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
blockTempCount: anLMRObject
	| flags |
	flags := anLMRObject slotAt: methodFlagsIndex.
	^ flags value bitsAt: BlockTempCount
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
bootstrapper
	^bootstrapper
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
bootstrapper: aBootstrapper
	bootstrapper := aBootstrapper
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
byteArrayClass: anLMRObject
	byteArrayClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
classIvars: anLMRObject
	^ anLMRObject slotAt: speciesIvarsIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
classModule: class
	^ class slotAt: classModuleIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
classModuleIndex: anInteger
	classModuleIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
className: anLMRObject
	^ anLMRObject slotAt: classNameIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
classNameIndex: anInteger
	classNameIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
classNamespacesIndex: anInteger
	classNamespacesIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
closureBlock: closure
	^closure slotAt: closureBlockIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
closureBlockIndex: anInteger
	closureBlockIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
closureClass: anLMRObject
	closureClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
closureHome: closure
	| block |
	block := self closureBlock: closure.
	(self blockCapturesHome: block)
		ifFalse: [ self error: 'closure has no home' ].
	^ (self blockCapturesSelf: block)
		ifTrue: [ closure at: 2 ]
		ifFalse: [ closure at: 1 ]
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
dictionaryTable: anLMRObject
	^anLMRObject slotAt: dictionaryTableIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
dictionaryTableIndex: anInteger
	dictionaryTableIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
doLookup: aSymbol startingAt: aBehavior
	| behavior m |
	behavior := aBehavior.
	[ m := self methodFor: aSymbol in: behavior.
	m ifNotNil: [ ^m ].
	behavior := self behaviorNext: behavior.
	behavior !!= nilObj ] whileTrue.
	^ nil
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
executableCodeWork: anLMRExecutableCode
	self ASSERT: anLMRExecutableCode !!== nilObj.
	^anLMRExecutableCode code
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
fixOverrides
	| selector md |
	overrides
		keysAndValuesDo: [ :assoc :method | 
			selector := assoc value.
			md := self behaviorMethodDictionary: assoc key.
			self
				sendLocal: #at:put:
				to: md
				with:
					{selector.
					method} ]
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
hashFor: anLMRObject
	| shifted hash current |
	anLMRObject isImmediate
		ifTrue: [ ^ anLMRObject value ].
	current := anLMRObject headerHash.
	current !!= 0
		ifTrue: [ ^ current ].
	shifted := lastHash bitShift: -1.
	hash := (lastHash bitAnd: 1) = 0
		ifTrue: [ shifted ]
		ifFalse: [ shifted bitXor: 16rB9C8 ].
	anLMRObject headerHash: hash.
	^ lastHash := hash
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
initialize
	lastHash := 1.
	super initialize
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
integerFrom: anLMRObject
	| behavior class |
	anLMRObject isImmediate
		ifTrue: [ ^ anLMRObject value ].
	behavior := self behaviorOf: anLMRObject.
	class := self behaviorClass: behavior.
	^ class == largePositiveIntegerClass
		ifTrue: [ anLMRObject bytes asLittleEndianPositiveInteger ]
		ifFalse: [ anLMRObject bytes asLittleEndianNegativeInteger ]
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
isBlock: compiledCode
	^ (self behaviorClass: compiledCode behavior) ==
	blockClass 
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
isExecutableCode: code
	^code class == LMRExecutableCode
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
isMetaclass: anLMRObject
	^ (self speciesFor: anLMRObject) == metaclassClass
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
kernel
	^kernel
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
kernel: anLMRObject
	kernel := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
knownSymbols: associations
	knownSymbols := Dictionary withAll: associations
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
largeNegativeIntegerClass: anLMRObject
	largeNegativeIntegerClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
largePositiveIntegerClass: anLMRObject
	largePositiveIntegerClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
loadAssociationValue: association
	^ association slotAt: 2.

! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
loadModule: symbol
	^ bootstrapper loadModule: symbol asLocalString
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
localMethodAstcodes: method

	^ (self methodAstcodes: method) bytes
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
lookupAssociationFor: aSymbol in: dictionary
	|  table assoc key |
	table := self dictionaryTable: dictionary.
	2 to: table size do: [ :index | 
		assoc := table slotAt: index.
		assoc == nilObj ifFalse: [key := assoc slotAt: 1. key == aSymbol
			ifTrue: [ ^ assoc] ]].
	^ nil
	
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
metaclassClass: anLMRObject
	metaclassClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
metaclassInstanceClass: anLMRObject
	^ anLMRObject slotAt: metaclassInstanceClassIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
metaclassInstanceClassIndex: anInteger
	metaclassInstanceClassIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
method: method literalAt: index
	^ method slotAt: methodInstSize + index
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodArgumentCount: anLMRObject
	| flags |
	flags := anLMRObject slotAt: methodFlagsIndex.
	^ flags value bitsAt: ArgCount
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodAstcodes: anLMRObject
	^ anLMRObject slotAt: methodAstcodesIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodAstcodesIndex: anInteger
	methodAstcodesIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodClass: anLMRObject
	methodClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodClassBinding: anLMRObject
	^ anLMRObject slotAt: methodClassBindingIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodClassBindingIndex: anInteger
	methodClassBindingIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodEnvironmentSize: anLMRObject
	| flags |
	flags := anLMRObject slotAt: methodFlagsIndex.
	^ flags value bitsAt: EnvCount
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodExecutableCode: anLMRObject

^anLMRObject slotAt: compiledCodeExecutableCodeIndex.
	
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodExecutableCode: anLMRObject put: anObject

	^ anLMRObject slotAt: compiledCodeExecutableCodeIndex put: anObject 
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodExecutableCodeIndex: anInteger
	compiledCodeExecutableCodeIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodFlagsIndex: anInteger
	methodFlagsIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodFor: aSymbol in: behavior
	| md table  |
	overrides at: behavior -> aSymbol ifPresent: [ :m | ^ m ].
	md := self behaviorMethodDictionary: behavior.
	table := self dictionaryTable: md.
	2 to: table size by: 2 do: [ :index | 
		(table slotAt: index) == aSymbol
			ifTrue: [ ^ table slotAt: index + 1 ] ].
	^ nil
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodInstSize: anInteger
	methodInstSize := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodSelector: anLMRObject

	^ anLMRObject slotAt: methodSelectorIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodSelectorIndex: anInteger

	methodSelectorIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
methodTempCount: anLMRObject
	| flags |
	flags := anLMRObject slotAt: methodFlagsIndex.
	^ flags value bitsAt: TempCount
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
moduleNamespace: anLMRObject
	^anLMRObject slotAt: moduleNamespaceIndex

! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
moduleNamespaceIndex: anInteger

	moduleNamespaceIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newArray: anArray
| result |
result := 	self newArraySized: anArray size.
	anArray withIndexDo: [ :elem :i | result at: i put: elem ].
	^result
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newArraySized: anInteger
	| behavior header |
	behavior := self speciesInstanceBehavior: arrayClass.
	header := LMRObjectHeader new
		behavior: behavior;
		bytes: false arrayed: true named: false;
		size: anInteger;
		hash: 0.
	^ LMRSlotObject new header: header
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newByteArray: aByteArray
	| behavior header |
	behavior := self speciesInstanceBehavior: byteArrayClass.
	header := LMRObjectHeader new
		behavior: behavior;
		bytes: false arrayed: true named: false;
		size: aByteArray size;
		hash: 0.
	^ LMRByteObject new header: header; bytes: aByteArray
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newBytes: species size: anInteger
	| behavior header |
	behavior := self speciesInstanceBehavior: species.
	header := LMRObjectHeader new
		behavior: behavior;
		bytes: false arrayed: true named: false;
		size: anInteger;
		hash: 0.
	^ LMRByteObject new
		header: header;
		bytes: (ByteArray new: anInteger)
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newBytesOf: species sized: size
	^ self newBytes: species size: size
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newCharacter: aCharacter
	| value |
	value := self newInteger: aCharacter asInteger.
	^self sendLocal: #asCharacter to: value.

! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newClosureFor: compiledBlock
	| size closure |
	size := self blockEnvironmentCount: compiledBlock.
	closure := self newSlots: closureClass size:  size.
	closure slotAt: closureBlockIndex put: compiledBlock.
	^ closure
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newCompiledMethod
	| behavior header method |
	behavior := self speciesInstanceBehavior: methodClass.
	header := LMRObjectHeader new
		behavior: behavior;
		bytes: false arrayed: true named: false;
		size: methodInstSize;
		hash: 0.
	method := LMRSlotObject new header: header.
	method slotAt: methodFlagsIndex put: (self newInteger: 0).
	^method
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newEnvironmentSized: anInteger
	^ self newArraySized: anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newExecutableCodeFor: anObject
		| behavior header |
	behavior := self speciesInstanceBehavior: arrayClass.
	header := LMRObjectHeader new
		behavior: behavior;
		bytes: false arrayed: true named: false;
		size: 0;
		hash: 0.

	 ^LMRExecutableCode new header: header; code: anObject.

! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newInteger: anInteger
	anInteger > maxSMI
		ifTrue: [ ^ self newLargePositiveInteger: anInteger ].
	anInteger < minSMI
		ifTrue: [ ^ self newLargeNegativeInteger: anInteger ].
	^ LMRSmallInteger new value: anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newLargeNegativeInteger: anInteger
	| size bytes byte result complement |
	size := (anInteger bytesCount alignedTo: 2) max: wordSize.
	complement := anInteger negated - 1.
	bytes := ByteArray new: size withAll: 16rFF.
	1 to: anInteger bytesCount do: [ :i | 
		byte := 255 - (complement byteAt: i).
		bytes at: i put: byte ].
	(bytes at: size) < 128 ifTrue: [ bytes := bytes, #[16rFF 16rFF] ].
	result := self newBytes: largeNegativeIntegerClass size: bytes size.
	^result bytes: bytes

! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newLargePositiveInteger: anInteger
	| size bytes result |
	size := (anInteger bytesCount alignedTo: 2) max: wordSize.
	bytes := anInteger asByteArrayOfSize: size.
	result := self newBytes: largePositiveIntegerClass size: size.
	^ result bytes: bytes reversed
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newOf: aSpecies sized: anInteger
	^(self speciesIsBytes: aSpecies)
		ifTrue: [ self newBytes: aSpecies size: anInteger ]
		ifFalse: [ self newSlots: aSpecies size: anInteger ]
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newSlots: class
	^self newSlots: class size: 0
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newSlots: class size: anInteger
	| ivars behavior header result |
	ivars := self speciesInstanceSize: class.
	behavior := self speciesInstanceBehavior: class.
	header := LMRObjectHeader new
		behavior: behavior;
		bytes: false arrayed: false named: true;
		size: ivars + anInteger;
		hash: 0.
	result := class == behaviorClass
		ifTrue: [ LMRBehaviorObject new runtime: self]
		ifFalse: [ LMRSlotObject new ].
	^ result
		header: header;
		nilSlots: nilObj
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newSlotsOf: class
	^ self newSlots: class size: 0
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newSmallInteger: anInteger
	^ LMRSmallInteger new value: anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
newString: aString
	| behavior header bytes |
	behavior := self speciesInstanceBehavior: stringClass.
	bytes := aString asByteArray copyWith: 0.
	header := LMRObjectHeader new
		behavior: behavior;
		bytes: false arrayed: true named: false;
		size: bytes size;
		hash: 0.
	^ LMRByteObject new
		header: header;
		bytes: bytes
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
nil: n true: t false: f
	nilObj := n.
	trueObj := t.
	falseObj := f
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
override: assoc with: method
	overrides at: assoc put: method
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
print: anLMRObject on: aStream
	| species name selector |
	species := self behaviorClass: anLMRObject behavior.
	name := self speciesLocalName: species.
	name = 'Symbol'
		ifTrue: [ ^ aStream nextPutAll: '<#' , anLMRObject asLocalString , '>' ].
	name = 'String'
		ifTrue: [ ^ aStream nextPutAll: '<''' , anLMRObject asLocalString , '''>' ].
	name = 'CompiledMethod'
		ifTrue: [
			selector := anLMRObject slotAt: methodSelectorIndex.
			selector := selector == nilObj ifTrue: ['<nil>'] ifFalse: [ selector asLocalString ].
			  ^ aStream
				nextPutAll: '<';
				print: (self methodClassBinding: anLMRObject);
				nextPutAll: '>>#';
				nextPutAll: selector;
				nextPutAll: '>' ].
	aStream
		nextPut: $<;
		nextPutAll: name withArticle;
		nextPut: $>
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
printBehavior: anLMRBehavior on: aStream
	| species name |
	species := self behaviorClass: anLMRBehavior.
	name := self speciesLocalName: species.
	aStream
		nextPutAll: '<' , name , ' instanceBehavior>'
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
removeOverride: assoc
	| species selector |
	species := assoc key.
	selector := assoc value.
	overrides removeKey: species -> selector.
	methodCache removeKey: selector -> species ifAbsent: nil.
	symbolCache
		at: selector
		ifPresent: [ :messages | messages do: #flushCache ]
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
smallIntegerBehavior
	^self speciesInstanceBehavior: smallIntegerClass
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
smallIntegerClass: anLMRObject
	smallIntegerClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesFor: anLMRObject
	| behavior |
	behavior := self behaviorOf: anLMRObject.
	^self behaviorClass: behavior.


! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesFormatIndex: anInteger
	speciesFormatIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesInstanceBehavior: anLMRObject
	^anLMRObject slotAt: speciesInstanceBehaviorIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesInstanceBehaviorIndex: anInteger
	speciesInstanceBehaviorIndex := anInteger 
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesInstanceClass: anLMRObject
	| metaclass |
	metaclass := self isMetaclass: anLMRObject.
	^ metaclass
		ifTrue: [ self metaclassInstanceClass: anLMRObject ]
		ifFalse: [ anLMRObject ]
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesInstanceSize: anLMRObject
	^ (anLMRObject slotAt: speciesFormatIndex) value bitAnd: 16r7F.
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesIsBytes: anLMRObject
	^ (anLMRObject slotAt: speciesFormatIndex) value noMask: 16r4000
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesIvarsIndex: anInteger
	speciesIvarsIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesLocalName: species
	| name class |
	(self isMetaclass: species) ifFalse: [
		name :=self className: species.
		^name asLocalString].
	
	class := self metaclassInstanceClass: species. 
	name := self className: class.
	^ name asLocalString, ' class'
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesModule: species
	| class |
	(self isMetaclass: species)
		ifFalse: [ ^ self classModule: species ].
	class := self metaclassInstanceClass: species.
	^ self classModule: class
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesNamespaces: anLMRObject
	| class |
	class := self speciesInstanceClass: anLMRObject.
	^class slotAt: classNamespacesIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesSuperclass: anLMRObject
	^ anLMRObject slotAt: speciesSuperclassIndex
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
speciesSuperclassIndex: anInteger
	speciesSuperclassIndex := anInteger
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
staticBindingForIvar: aSymbol in: receiver
	| class all slots bytes |
	
	class := self speciesFor: receiver.
	all := Array new: 0.
	[ class !!= nilObj ]
		whileTrue: [ slots := self classIvars: class.
			slots == nilObj
				ifFalse: [ all := slots slots , all ].
			class := self speciesSuperclass: class ].
	bytes := aSymbol bytes.
	all withIndexDo: [ :ivar :index | ivar bytes = bytes ifTrue: [ ^ index ] ].
	^0
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
stringClass: anLMRObject
	stringClass := anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
superBehaviorOf: class
	| superclass |
	superclass := self speciesSuperclass: class.
	^ self speciesInstanceBehavior: superclass
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
symbolFromLocal: aSymbol
	| bytes table symbol |
	knownSymbols at: aSymbol ifPresent: [ :s | ^s ].
	bytes := aSymbol asByteArray, #[0].
	table := symbolTable slotAt: 2.
	2 to: table size do: [:i | symbol := table slotAt: i. symbol == nilObj ifFalse: [symbol bytes = bytes ifTrue: [ ^symbol ] ] ].
	self error: 'symbol not found'
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
symbolTable: anLMRObject
	symbolTable:= anLMRObject
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
wordSize
	^wordSize
! !

!PowertalkLMR methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:53'!
wordSize: anInteger
	wordSize := anInteger.
	maxSMI := (1 bitShift: wordSize * 8 - 2) - 1.
	minSMI := maxSMI negated - 1
! !

!PowertalkLMR methodsFor: 'validating' stamp: 'KenD 11/22/2023 07:48:53'!
nativizeForLMR
	| script |
	script := 'nativizeForLMR
	lmr := Kernel loadModule: ''Nativization/LMR''. 
	lmr nativizeLoadedModules'.
	self
		compile: script in: #UndefinedObject;
		sendLocal: #nativizeForLMR to: nilObj
! !

!PowertalkLMR methodsFor: 'validating' stamp: 'KenD 11/22/2023 07:48:53'!
readKernel
	| script |
	script := 'readKernel
	| reader |
	reader := Kernel loadModule: ''ImageSegment/Reader''. 
	segment := reader read: ''build/Kernel.ims''.
	^segment'.
	self
		compile: script in: #UndefinedObject;
		sendLocal: #readKernel to: nilObj
! !

!PowertalkLMR methodsFor: 'validating' stamp: 'KenD 11/22/2023 07:48:53'!
writeKernelAt: anInteger
	| script |
	script := 'writeKernel
	| writer |
	writer := Kernel loadModule: ''ImageSegment/Writer''. 
	writer write: Kernel at: ' , anInteger asString
		, ' to: ''build/Kernel.ims'''.
	self
		compile: script in: #UndefinedObject;
		sendLocal: #writeKernel to: nilObj
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
argumentCountOf: anObjectMap
self halt.
	^ anObjectMap argumentCount
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
behaviorOf: anObjectMap
	^ anObjectMap spec
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
blockArgumentCount: block
	^ block argumentCount
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
blockExecutableCode: block
	^block optimizedCode
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
blockExecutableCode: block put: anObject
	block optimizedCode: anObject
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
blockExecutionTree: block
	^ block executionTree
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
blockMethod: anObjectMap
	^ anObjectMap method
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
blockTempCount: block
	^ block tempCount
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
closureBlock: aClosureMap
	^aClosureMap block
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
closureHome: anObjectMap
	^ anObjectMap home
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
homeEnvironmentOf: aClosureMap
	^ aClosureMap slotAt: 2
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
integerFrom: anObjectMap
	anObjectMap isImmediate
		ifTrue: [ ^ anObjectMap value ].
		self halt.
	^ anObjectMap spec name == #LargePositiveInteger
		ifTrue: [ anObjectMap bytes asLittleEndianPositiveInteger ]
		ifFalse: [ anObjectMap bytes asLittleEndianNegativeInteger ]
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
isClosure: anObjectMap
	^anObjectMap class = ClosureMap
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
isExecutableCode: code

	^ code !!== nil and: [code !!== nilObj]
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
localMethodAstcodes: anSCompiledMethod

	^ self methodAstcodes: anSCompiledMethod
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
localSymbolFrom: anObjectMap
	^ anObjectMap symbol
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
methodArgumentCount: method
	^ method argumentCount
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
methodAstcodes: anSCompiledMethod

	^ anSCompiledMethod astcodes
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
methodClassBinding: method
	^ method classBinding
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
methodEnvironmentSize: anSCompiledMethod
	^anSCompiledMethod environmentCount
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
methodExecutableCode: anSCompiledMethod
	^ anSCompiledMethod optimizedCode
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
methodExecutableCode: method put: anObject

	method optimizedCode: anObject.
		^anObject 
		
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
methodTempCount: method
	^ method tempCount
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
newSymbol: aSymbol
	^ image newSymbol: aSymbol
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
override: classname with: rgMethod
	| species selector method override |
	species := image specs at: classname.
	selector := rgMethod selector.
	method := species methodNamed: selector.
	override := method copy sourceCode: rgMethod sourceCode.
	overrides at: species -> selector put: override
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
symbolFrom: anObjectMap
	^ anObjectMap symbol
! !

!PowertalkRingRuntime methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:03'!
symbolFromLocal: aSymbol
	^ image newSymbol: aSymbol
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
arrayedSizeOf: anObjectMap
	^anObjectMap arrayedSize
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
compile: anRGMethod
	| class |
	class := image speciesFor: anRGMethod parent.
	^ SCompiler new
		forClass: class;
		compile: anRGMethod sourceCode
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
doLookup: aSymbol startingAt: aBehavior
	| behavior m c smethod |
	self ASSERT: aSymbol !!== #error:.
	behavior := aBehavior.
	[ m := self methodFor: aSymbol in: behavior.
	m
		ifNotNil: [ smethod := self compile: m.
			^ self transferMethodLiterals: smethod ].
	behavior := behavior superclass.
	behavior notNil ] whileTrue.
	^ aBehavior isMeta
		ifTrue: [ c := aBehavior environment at: #Class.
			self doLookup: aSymbol startingAt: c ]
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
executableCodeWork: code
	^code
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
image
	^image
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
image: aPowertalkImage
	image := aPowertalkImage.
	nilObj := image nil.
	trueObj := image true.
	falseObj := image false.
	self
		initializeEmulationOverrides;
		initializeInterpreter
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
isBlock: anSCompiledMethod
	^anSCompiledMethod isBlock
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
literalFor: anObject
	^ image transferLiteral: anObject
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
loadAssociationValue: association
	^association value
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
lookupAssociationFor: aSymbol in: dictionary
^dictionary
				associationAt: aSymbol
				ifPresent: [ :assoc | assoc]
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
method: anSCompiledMethod literalAt: index
	^anSCompiledMethod at: index
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
methodFor: aSymbol in: anRGBehavior
	overrides at: anRGBehavior->aSymbol ifPresent: [:m | ^m].
	^anRGBehavior methodNamed: aSymbol
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
moduleNamespace: anObjectMap
	^ anObjectMap namespace
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newArraySized: anInteger
	^ image newArraySized: anInteger
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newBootstrapDictionaryOf: aSpeciesMap
	^ image newBootstrapDictionaryOf: aSpeciesMap spec instanceSide
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newBytesOf: aSpeciesMap sized: size
	^ image newOf: aSpeciesMap spec instanceSide sized: size
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newClosureFor: compiledBlock
	| closure |
	closure :=  image newClosure: compiledBlock environmentCount.
	^closure
		block: compiledBlock

! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newCompiledMethod
	^ SCompiledMethod new
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newEnvironmentSized: anInteger
	^ image newArraySized: anInteger
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newExecutableCodeFor: anObject
	^anObject
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newInteger: anInteger
	^image newInteger: anInteger
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newOf: aSpeciesMap sized: size
	^ image newOf: aSpeciesMap spec instanceSide sized: size
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
newSlotsOf: aSpeciesMap
	^image newSlotsOf: aSpeciesMap spec instanceSide sized: 0
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
override: assoc withPrimitive: primitive
	| species selector method override count source |
	species := image specs at: assoc key.
	selector := assoc value.
	source := String
		streamContents: [ :s | 
			selector numArgs = 0
				ifTrue: [ s nextPutAll: selector ]
				ifFalse: [ count := 1.
					selector keywords
						do: [ :keyword | 
							s
								nextPutAll: keyword;
								nextPutAll: ' arg';
								nextPutAll: count asString;
								space.
							count := count + 1 ] ].
			s nextPutAll: '<primitive: ' , primitive , '>' ].
	method := species methodNamed: selector.
	override := method copy sourceCode: source.
	overrides at: species -> selector put: override
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
removeBootstrapDictionaryOverrides
self
		removeOverride: #'Namespace class' -> #new

! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
removeOverride: assoc
	| species selector symbol |
	species := image specs at: assoc key.
	selector := assoc value.
	overrides removeKey: species -> selector.
	methodCache removeKey: selector -> species ifAbsent: nil.
	symbol := self symbolFromLocal: selector.
	symbolCache
		at: symbol
		ifPresent: [ :messages | messages do: #flushCache ]
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
speciesFor: anObjectMap
	^ image speciesFor: anObjectMap spec
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
speciesModule: aSpeciesMap
	^ aSpeciesMap module
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
speciesNamespaces: aSpeciesMap
	^ aSpeciesMap namespaces
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
speciesSuperclass: aSpeciesMap
	^ aSpeciesMap superclass
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
staticBindingForIvar: aSymbol in: receiver
	^receiver allSlotNames indexOf: aSymbol.
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
storeAssociation: association value: anObject
	association value: anObject
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
superBehaviorOf: aSpeciesMap
	^ aSpeciesMap superclass instanceSpec
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
transferLiteral: anObject
	^image transferLiteral: anObject
! !

!PowertalkRingRuntime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:03'!
transferMethodLiterals: method
	| class |
	method withIndexDo: [:literal :i | 
		class := literal class.
		((class inheritsFrom: ObjectMap)
			or: [ class = SCompiledBlock ])
			ifFalse: [ method at: i put: (image transferLiteralDeep: literal) ] ].
	^ method
! !

!PowertalkRingRuntime methodsFor: 'own services' stamp: 'KenD 11/22/2023 07:49:03'!
blockCapturesSelf: block
	^ block capturesSelf 
! !

!PowertalkRingRuntime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:03'!
initializeEmulationOverrides
	| classes |
	classes := image vmPrimitivesSpec allExtensionClasses.
	classes
		do: [ :class | 
			class methods do: [ :m | self override: class name with: m ].
			class metaclass methods
				do: [ :m | self override: class metaclass name with: m ] ]
! !

!PowertalkRingRuntime class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:03'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
assign: aCollection
	| op |
	op := SOpAssign new assignees: aCollection.
	operations add: op

! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
branchIf: aBoolean
	| class op |
	class := aBoolean
		ifTrue: [ SOpJumpTrue ]
		ifFalse: [ SOpJumpFalse ].
		op := class new.
	operations add: op.
	^op
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
branchTargetOf: branch
	branch target: self currentPC
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
currentPC
	^ operations size
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
dispatch: message
	| op count |
	op := SOpDispatchMessage new message: message.
	operations add: op.
	dropsArguments ifTrue: [ ^self ].
	
	count := message arguments size.
	count > 0 ifTrue: [ count := count + 1 ].
	stackTop := stackTop - count 
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
dropCascadeMessageArgs: argsize
	(argsize = 0 orNot: [ dropsArguments ])
		ifTrue: [ ^ self ].
	self dropToS: argsize
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
dropMessageArgs: argsize
	(argsize = 0 orNot: [ dropsArguments ])
		ifTrue: [ ^ self ].
	self dropToS: argsize + 1
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
dropToS
	^self dropToS: 1
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
dropToS: anInteger
	| op |
	op := SOpDropToS new count: anInteger.
	operations add: op.
	stackTop := stackTop - anInteger
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
dropsArguments
	dropsArguments := true
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
initialize
	dropsArguments := false
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inline: anSMessage binaryWhile: aBoolean
	"TODO: cleanup block locals to nil after each cycle"

	| start end |
	start := self currentPC.
	self visitStatements: anSMessage receiver statements.
	end := self branchIf: aBoolean not.
	self
		visitStatements: anSMessage arguments first statements;
		jumpTo: start;
		branchTargetOf: end
		
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inline: anSMessage if: aBoolean
	| branch end |
	anSMessage receiver acceptVisitor: self.
	branch := self branchIf: aBoolean not.
	end := self
		visitStatements: anSMessage arguments first statements;
		jump.
	self
		branchTargetOf: branch;
		loadRwithNil;
		branchTargetOf: end 
		
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inline: anSMessage ifNil: aBoolean
	| nilObj message branch end arg index |
	anSMessage receiver acceptVisitor: self.
	arg := anSMessage arguments first.
	(arg isBlock and: [ arg inlinedArgs size = 1]) ifTrue: [ 
		index := arg inlinedArgs first.
		self storeRintoFrameAt: index
		 ].
	self pushR.
	nilObj := SLiteral new value: runtime nil.
	message := SMessage new
		receiver: (SOpLoadRfromStack new index: 0);
		arguments: {nilObj};
		selector: equalsEquals.
	self visitMessage: message.
	branch := self branchIf: aBoolean not.

	arg isBlock
		ifTrue: [ self visitStatements: arg statements ]
		ifFalse: [ arg acceptVisitor: self ].
	end := self
		dropToS;
		jump.
	self
		branchTargetOf: branch;
		popR;
		branchTargetOf: end
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inline: anSMessage ifNilIfNotNil: aBoolean
	| arguments nilObj message branch end arg index |
	anSMessage receiver acceptVisitor: self.
	arguments := anSMessage arguments.
	arg := aBoolean ifTrue: [arguments second] ifFalse: [arguments first].
	(arg isBlock and: [ arg inlinedArgs size = 1 ])
		ifTrue: [ index := arg inlinedArgs first.
			self storeRintoFrameAt: index ].
	self pushR.
	nilObj := SLiteral new value: runtime nil.
	message := SMessage new
		receiver: (SOpLoadRfromStack new index: 0);
		arguments: {nilObj};
		selector: equalsEquals.
	self visitMessage: message.
	branch := self branchIf: aBoolean not.
	end := self
		visitStatements: arguments first statements;
		jump.
	self
		branchTargetOf: branch;
		visitStatements: arguments second statements;
		branchTargetOf: end;
		dropToS
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inline: anSMessage ifTrueIfFalse: aBoolean
	| branch end |
	anSMessage receiver acceptVisitor: self.
	branch := self branchIf: aBoolean not.
	end := self
		visitStatements: anSMessage arguments first statements;
		jump.
	self
		branchTargetOf: branch;
		visitStatements: anSMessage arguments second statements;
		branchTargetOf: end
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inline: anSMessage unitaryWhile: aBoolean
	"TODO: cleanup block locals to nil after each cycle"

	| start branch |
	start := self currentPC.
	self visitStatements: anSMessage receiver statements.
	branch :=  self branchIf: aBoolean.
	branch target: start.

! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inlineAnd: anSMessage
	| branches |
	anSMessage receiver acceptVisitor: self.
	branches := OrderedCollection new.
	anSMessage arguments
		do: [ :block | 
			branches add: (self branchIf: false).
	
	self
		visitStatements: block statements].
	branches do: [ :branch | self branchTargetOf: branch ]
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inlineAndNot: anSMessage
	| branch message |
	anSMessage receiver acceptVisitor: self.
	branch := self branchIf: false.
	"the receiver is added just to have an object that knows to respond isSuper"
	message := SMessage new
		receiver: (SInlinerOperation new);
		selector: not;
		arguments: #().
	self
		visitStatements: anSMessage arguments first statements;
		dispatch: message;
		branchTargetOf: branch
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inlineOr: anSMessage
	|  branches |
	anSMessage receiver acceptVisitor: self.
	branches := OrderedCollection new.
	 anSMessage arguments do: [ :block | 
		branches add: (self branchIf: true).
		self visitStatements: block statements].
	branches do: [:branch | self branchTargetOf: branch]
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inlineOrNot: anSMessage
	| branch message |
	anSMessage receiver acceptVisitor: self.
	branch := self branchIf: true.
	"the receiver is added just to have an object that knows to respond isSuper"
	message := SMessage new
		receiver: (SInlinerOperation new);
		selector: not;
		arguments: #().
	self
		visitStatements: anSMessage arguments first statements;
		dispatch: message;
		branchTargetOf: branch
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inlineRepeat: anSMessage
	"TODO: cleanup block locals to nil after each cycle"

	| start |
	start := self currentPC.
	self
		visitStatements: anSMessage receiver statements;
		jumpTo: start
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inlineTimesRepeat: anSMessage
	"TODO: cleanup block locals to nil after each cycle"

	| current limit start end compare increment |
	operations add: one.
	self pushR.
	current := SOpLoadRfromFrame new index: stackTop.
	anSMessage receiver acceptVisitor: self.
	self pushR.
	limit := SOpLoadRfromFrame new index: stackTop.
	start := self currentPC.
	compare := SMessage new
		receiver: current;
		selector: greaterThan;
		arguments: {limit}.
	self visitMessage: compare.
	end := self branchIf: true.
	self visitStatements: anSMessage arguments first statements.
	increment := SMessage new
		receiver: current;
		selector: plus;
		arguments: {one}.
	self
		visitMessage: increment;
		storeRintoFrameAt: current index;
		jumpTo: start;
		branchTargetOf: end;
		dropToS: 2
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
inlineToDo: anSMessage
	"TODO: cleanup block locals to nil after each cycle"

	| index current limit start end compare increment |
	anSMessage receiver acceptVisitor: self.
	index := anSMessage arguments second inlinedArgs first.
	current := SOpLoadRfromFrame new index: index.
	self storeRintoFrameAt: index.
	anSMessage arguments first acceptVisitor: self.
	self pushR.
	limit := SOpLoadRfromFrame new index: stackTop.
	start := self currentPC.
	compare := SMessage new
		receiver: current;
		selector: greaterThan;
		arguments: {limit}.
	self visitMessage: compare.
	end := self branchIf: true.
	self visitStatements: anSMessage arguments second statements.
	increment := SMessage new
		receiver: current;
		selector: plus;
		arguments: {one}.
	self
		visitMessage: increment;
		storeRintoFrameAt: index;
		jumpTo: start;
		branchTargetOf: end;
		dropToS: 1
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
jump
	| op |
	op := SOpJump new.
	operations add: op.
	^op
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
jumpTo: anInteger
| op |
op := SOpJump new target: anInteger.
	operations add: op
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
loadRfromStack: anInteger
	| op |
	op := SOpLoadRfromStack new index: anInteger.
	operations add: op

! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
loadRwithNil
	operations add: SOpLoadRwithNil new
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
loadRwithSelf
	operations add: SOpLoadRwithSelf new
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
operations
^operations
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
popR
	operations add: SOpPopR new.
	stackTop := stackTop - 1
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
primitive: aClosure
	operations add: (SOpPrimitive new block: aClosure)
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
pushR
	operations add: SOpPushR new.
	stackTop := stackTop + 1
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
reset
	operations := OrderedCollection new.
	inBlock := false.

! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
return
	operations add: SOpReturn new
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
return: isLocal
	|  class |
	class := (isLocal andNot: [ inBlock ])
		ifTrue: [ SOpReturn ]
		ifFalse: [ SOpNonLocalReturn ].
	operations add: class new
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
runtime: aPowertalkRuntime
	| literal |
	runtime := aPowertalkRuntime.
	literal := runtime newInteger: 1.
	one := SLiteral new value: literal.
	plus := runtime symbolFromLocal: #+.
	greaterThan := runtime symbolFromLocal: #>.
	equalsEquals := runtime symbolFromLocal: #==.
	not := runtime symbolFromLocal: #not.
	ifTrue := runtime symbolFromLocal: #ifTrue:.
	ifFalse := runtime symbolFromLocal: #ifFalse:.
	ifTrueIfFalse := runtime symbolFromLocal: #ifTrue:ifFalse:.
	ifFalseIfTrue := runtime symbolFromLocal: #ifFalse:ifTrue:.
	ifNil := runtime symbolFromLocal: #ifNil:.
	ifNotNil := runtime symbolFromLocal: #ifNotNil:.
	ifNilIfNotNil := runtime symbolFromLocal: #ifNil:ifNotNil:.
	ifNotNilIfNil := runtime symbolFromLocal: #ifNotNil:ifNil:.
	repeat := runtime symbolFromLocal: #repeat.
	whileTrue := runtime symbolFromLocal: #whileTrue.
	whileFalse := runtime symbolFromLocal: #whileFalse.
	whileTrue_ := runtime symbolFromLocal: #whileTrue:.
	whileFalse_ := runtime symbolFromLocal: #whileFalse:.
	timesRepeat := runtime symbolFromLocal: #timesRepeat:.
	toDo := runtime symbolFromLocal: #to:do:.
	toByDo := runtime symbolFromLocal: #to:by:do:.
	andNot := runtime symbolFromLocal: #andNot:.
	orNot := runtime symbolFromLocal: #orNot:
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
storeRintoFrameAt: anInteger
	| op |
	op := SOpStoreRintoFrame new index: anInteger.
	operations add: op
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitAssignment: anSAssignment
	anSAssignment expression acceptVisitor: self.
	self
		assign: anSAssignment assignees
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitBlock: anSBlock

	| prevInBlock prevOperations statements code |
	operations add: anSBlock.
	prevInBlock := inBlock.
	prevOperations := operations.
	inBlock := true.
	operations := OrderedCollection new.
	statements := anSBlock statements.
	statements do: [ :node | node acceptVisitor: self ].
	statements isEmpty
		ifTrue: [ self loadRwithNil ]
		ifFalse: [ statements last isReturn ifFalse: [ self return ] ].
	anSBlock isInlined ifFalse: [ 
		code := runtime newExecutableCodeFor: operations asArray.
		runtime
			blockExecutableCode: anSBlock compiledCode
			put: code ].
	operations := prevOperations.
	inBlock := prevInBlock
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitCascade: anSCascade
	| args argsize |
	anSCascade receiver acceptVisitor: self.
	self pushR.
	anSCascade messages
		do: [ :msg | 
			args := msg arguments.
			argsize := args size.
			args
				do: [ :arg | 
					arg acceptVisitor: self.
					self pushR ].
			self
				loadRfromStack: argsize;
				dispatch: msg;
				dropCascadeMessageArgs: argsize ].
	self dropToS
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitIdentifier: anSIdentifier
	operations add: anSIdentifier
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitInlinedMessage: anSMessage
	| selector |
	selector := anSMessage selector.
	selector == ifTrue
		ifTrue: [ ^ self inline: anSMessage if: true ].
	selector == ifFalse
		ifTrue: [ ^ self inline: anSMessage if: false ].
	selector == ifNil
		ifTrue: [ ^ self inline: anSMessage ifNil: true ].
	selector == ifNotNil
		ifTrue: [ ^ self inline: anSMessage ifNil: false ].
	selector == ifNilIfNotNil
		ifTrue: [ ^ self inline: anSMessage ifNilIfNotNil: true ].
	selector == ifNotNilIfNil
		ifTrue: [ ^ self inline: anSMessage ifNilIfNotNil: false ].
	selector == ifTrueIfFalse
		ifTrue: [ ^ self inline: anSMessage ifTrueIfFalse: true ].
	selector == ifFalseIfTrue
		ifTrue: [ ^ self inline: anSMessage ifTrueIfFalse: false ].
	selector == whileTrue
		ifTrue: [ ^ self inline: anSMessage unitaryWhile: true ].
	selector == whileFalse
		ifTrue: [ ^ self inline: anSMessage unitaryWhile: false ].
	selector == whileTrue_
		ifTrue: [ ^ self inline: anSMessage binaryWhile: true ].
	selector == whileFalse_
		ifTrue: [ ^ self inline: anSMessage binaryWhile: false ].
	selector == repeat
		ifTrue: [ ^ self inlineRepeat: anSMessage ].
	selector == toDo
		ifTrue: [ ^ self inlineToDo: anSMessage ].
	selector == toByDo
		ifTrue: [ ^ self inlineToByDo: anSMessage ].
	selector == timesRepeat
		ifTrue: [ ^ self inlineTimesRepeat: anSMessage ].
	selector == andNot
		ifTrue: [ ^ self inlineAndNot: anSMessage ].
	selector == orNot
		ifTrue: [ ^ self inlineOrNot: anSMessage ].
	selector := runtime localSymbolFrom: selector.
	(selector beginsWith: #or:)
		ifTrue: [ ^ self inlineOr: anSMessage ].
	(selector beginsWith: #and:)
		ifTrue: [ ^ self inlineAnd: anSMessage ].

	self ASSERT: false
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitLiteral: anSLiteral
	operations add: anSLiteral
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitMessage: anSMessage
	| args argsize |
	anSMessage isInlined
		ifTrue: [ ^ self visitInlinedMessage: anSMessage ].
	anSMessage receiver acceptVisitor: self.
	args := anSMessage arguments.
	argsize := args size.
	argsize > 0
		ifTrue: [ self pushR ].
	args
		do: [ :arg | 
			arg acceptVisitor: self.
			self pushR ].
	argsize > 0
		ifTrue: [ self loadRfromStack: argsize ].
	self dispatch: anSMessage; dropMessageArgs: argsize.
	
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitMethod: anSMethod
	| primitive statements symbol |
	self reset.
	primitive := anSMethod pragma.
	primitive
		ifNotNil: [ symbol := runtime localSymbolFrom: anSMethod primitive.
			primitive := primitives at: symbol.
			^ self
				primitive: primitive;
				return ].
	stackTop := runtime methodTempCount: anSMethod compiledCode.
	statements := anSMethod statements.
	statements do: [ :node | node acceptVisitor: self ].
	(statements isEmpty orNot: [ statements last isReturn ])
		ifTrue: [ self
				loadRwithSelf;
				return ]
! !

!SExpressionLinearizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:01'!
visitReturn: anSReturn
	anSReturn expression acceptVisitor: self.
	self
		return: anSReturn local
! !

!SExpressionLinearizer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:01'!
primitives: aCollection
	primitives := aCollection
! !

!SExpressionLinearizer methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:01'!
visitOpLoadRfromFrame: anSOpLoadRfromFrame
	operations add: anSOpLoadRfromFrame
! !

!SExpressionLinearizer methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:01'!
visitOpLoadRfromStack: anSOpLoadRfromStack
self loadRfromStack: anSOpLoadRfromStack index
! !

!SExpressionLinearizer methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:01'!
visitStatements: aCollection
	aCollection do: [:sexpression | sexpression acceptVisitor: self]
	
! !

!LMRObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
at: index
	"Return indexed value at given index, starting with 1. This CANNOT be 
	 used for accessing named slots (aka, instance variables), to access 
	 them use #instVarAt:"
	
	self subclassResponsibility  
! !

!LMRObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
at: index put: value
	"Set indexed value at given `index` to `value`. This CANNOT be used for 
	 setting named slots (aka, instance variables), to access them use 
	 #instVarAt:put:"
	
	self subclassResponsibility  
! !

!LMRObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
isBytes
	^ false
! !

!LMRObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
isImmediate
	^false
! !

!LMRObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
pointersSize
	^0
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
behavior
	^header behavior
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
behavior: anLMRHeapObject
	header behavior: anLMRHeapObject
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
header: anInteger
	header := anInteger
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
headerFlags
	^header flags
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
headerHash
	^ header hash
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
headerHash: anInteger
	header hash: anInteger
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
isSmall
	^ header isSmall
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
localClassName
	^ self behavior localClassName
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
printOn: aStream
	self behavior printInstance: self on: aStream
! !

!LMRHeapObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
size
	^header size
! !

!LMRByteObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
asLocalString
	^ bytes allButLast asString
! !

!LMRByteObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
at: index

	^bytes at: index
! !

!LMRByteObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
at: index put: anLMRObject
	| value |
	value := anLMRObject value.
	bytes at: index put: value.
	^ anLMRObject
! !

!LMRByteObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
bytes
	^bytes
! !

!LMRByteObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
bytes: aByteArray
	self ASSERT: aByteArray size = header size.
	self ASSERT: aByteArray class == ByteArray.
	bytes := aByteArray
! !

!LMRByteObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
header: anLMRObjectHeader
	super header: anLMRObjectHeader.
	bytes := ByteArray new: header size
! !

!LMRByteObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
isBytes
	^true
! !

!LMRExecutableCode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:58'!
code
	^code
! !

!LMRExecutableCode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:58'!
code: anObject
	code := anObject
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
at: index
	^ slots at: header behavior classInstSize + index
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
at: index put: anLMRObject
	^ slots at: header behavior classInstSize + index put: anLMRObject
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
basicAt: index put: anLMRObject
	^ slots at: index put: anLMRObject
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
header: anLMRObjectHeader
	super header: anLMRObjectHeader.
	slots := Array new: header size
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
nilSlots: nilObj
	slots atAllPut: nilObj
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
pointersSize
	^ header size
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
size
	^header size
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
slotAt: index
	^ slots at: index
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
slotAt: index put: anLMRObject
	^ slots at: index put: anLMRObject
! !

!LMRSlotObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
slots
	^ slots
! !

!LMRBehaviorObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
classInstSize
	| class |
	class := runtime behaviorClass: self.
	^runtime speciesInstanceSize: class
! !

!LMRBehaviorObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
localClassName
	| class |
	class := runtime behaviorClass: self.
	^ runtime speciesLocalName: class
! !

!LMRBehaviorObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
printInstance: anLMRObject on: aStream
	runtime print: anLMRObject on: aStream
! !

!LMRBehaviorObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
printOn: aStream
	runtime printBehavior: self on: aStream
! !

!LMRBehaviorObject methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
runtime: aPowertalkLMR
	runtime := aPowertalkLMR
! !

!LMRSmallInteger methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:48:46'!
= anObject
	anObject class == self class
		ifFalse: [ ^ false ].
	^ value = anObject value
! !

!LMRSmallInteger methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
hash
	^value hash
! !

!LMRSmallInteger methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
isImmediate
	^true
! !

!LMRSmallInteger methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
printOn: aStream
	aStream
		nextPut: $<;
		print: value;
		nextPut: $>
! !

!LMRSmallInteger methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
value
	^value
! !

!LMRSmallInteger methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
value: anInteger
	value := anInteger
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
behavior
	^behavior
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
behavior: anLMRHeapObject
	behavior := anLMRHeapObject
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
bytes: bytes arrayed: arrayed named: named
	| b a n |
	b := bytes
		ifTrue: [ 1 ]
		ifFalse: [ 0 ].
	a := arrayed
		ifTrue: [ 2 ]
		ifFalse: [ 0 ].
	n := named	ifTrue: [ 4 ]
		ifFalse: [ 0 ].
	flags := b | a | n 
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
flags
	^flags
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
hash
	^hash
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
hash: anInteger
	hash := anInteger
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
isSmall
	^ self size < 256
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
printOn: aStream

	aStream
		nextPutAll: '[ hash: ';
		print: hash;
		nextPutAll: ' | size: ';
		print: size;
		nextPutAll: ' | flags: ';
		nextPutAll: flags hex;
		nextPutAll: ' | ';
		print: behavior;
		nextPut: $]
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
size
	^size 
! !

!LMRObjectHeader methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:56'!
size: anInteger
	size := anInteger.
	self isSmall ifTrue: [ flags := flags | 16r80]
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
=> aSymbol
	| classmap |
	classmap := source classNamed: aSymbol.
	^mapping at: classmap
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
addClasses: classes to: module
	classes
		do: [ :c | 
			dest
				sendLocal: #addClass: to: module with: {c};
				sendLocal: #module: to: c with: {module} ].
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
classesSortedBySuperclass: anArray

	| result seen s dfs |
	result := OrderedCollection new.
	seen := IdentitySet new.
	dfs := [ :class | 
	       s := class superclass.
	       ((anArray includes: s) andNot: [ seen includes: s ]) ifTrue: [ 
		       dfs value: s ].	
	       result add: class.
	       seen add: class ].
	anArray do: [ :class | (seen includes: class) ifFalse: [ dfs value: class ] ].
	self assert: result asSet  = anArray asSet.
	^ result
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
closureCompiledBlock: anSCompiledBlock
	| method index spec species table s selector m |
	method := anSCompiledBlock method.
	selector := source newSymbol: method selector.
	index := method indexOf: anSCompiledBlock.
	spec := source specs at: method classBinding name.
	species := source speciesFor: spec.
	table := species instanceBehavior methods table.
	2 to: table size by: 2 do: [ :i | 
		s := table basicAt: i.
		s == selector
			ifTrue: [ m := table basicAt: i + 1.
				closureMethods add: m.
				^ m at: index ] ].
	^ self halt
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
convert
	nilObj := self newMapping: source nil.
	trueObj := self newMapping: source true.
	falseObj := self newMapping: source false.
	dest nil: nilObj true: trueObj false: falseObj.
	self
		map: source nil to: nilObj;
		map: source true to: trueObj;
		map: source false to: falseObj;
		instantiateMetaobjects;
		fixBehaviors;
		convertBootstrapDictionaries;
		convertClosure;
		initializeSymbolTable;
		initializeRuntime.

! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
convertBootstrapDictionaries
	source bootstrapDictionaries do: [ :dict | self convertBootstrapDictionary: dict ]
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
convertBootstrapDictionary: aBootstrapDictionary
	| class dict converted |
	class := source classes at: aBootstrapDictionary realSpec.
	dict := source runtime sendLocal: #new to: class.
	aBootstrapDictionary
		associations do: [ :assoc | 
			source runtime
				sendLocal: #at:put:
				to: dict
				with:
					{assoc key.
					assoc value} ].
	converted:= self newMapping: dict.
	self map: aBootstrapDictionary to: converted
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
convertClosure
	| obj |
	[ stack isEmpty ]
		whileFalse: [ obj := stack removeFirst.
			self convertSlotsOf: obj key in: obj value ]
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
convertSlotsOf: ringObj in: lmrObj
	| mapped block |
	ringObj isPointers
		ifFalse: [ ^ self ].
	ringObj slots
		withIndexDo: [ :slot :index | 
			mapped := mapping at: slot ifAbsentPut: [ self newMapping: slot ].
			lmrObj basicAt: index put: mapped ].
	ringObj isClosure ifFalse: [^self]. block := self closureCompiledBlock: ringObj block.
			mapped := mapping at: block ifAbsentPut: [ self newMapping: block ].
			lmrObj basicAt: 1 put: mapped
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
createExtensionMethodsOf: spec in: module

	| name namespace class metaclass |
	name := dest addSymbol: spec name.
	namespace := dest sendLocal: #namespace to: module. 
	class := dest sendLocal: #at: to: namespace with: { name }.
	metaclass := dest behaviorClass: class behavior.
	spec methods do: [ :m | self createNewMethod: m in: class ].
	spec metaclass methods do: [ :m | 
		self createNewMethod: m in: metaclass ].
	^ module
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
createNewBlock: sblock
	| format transferred method literal tliteral |
	format := dest newInteger: sblock format.
	transferred := dest
		sendLocal: #new:
		to: self => #CompiledBlock
		with: {(dest newInteger: sblock size)}.
	method := mapping at: sblock method.
	dest
		sendLocal: #format: to: transferred with: {format};
		sendLocal: #method: to: transferred with: {method}.
	1 to: sblock size do: [ :i | 
		literal := sblock at: i.
		tliteral := self transferLiteral: literal.
		transferred at: i put: tliteral ].
	^ transferred
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
createNewClassFrom: spec
	| superclass metaclass class instanceBehavior classBehavior ivars |
	superclass := self => spec superclass name.
	metaclass := dest
		sendLocal: #newSubclassOf:
		to: self => #Class
		with: {superclass}.
	class := dest sendLocal: #instanceClass to: metaclass.
	dest sendLocal: #name: to: class with: {(dest newString: spec name)}.
	ivars := self transferLiteral: spec instVarNames.
	dest sendLocal: #instVarNames: to: class with:  { ivars }.
	instanceBehavior := dest sendLocal: #instanceBehavior to: class.
	classBehavior := dest sendLocal: #instanceBehavior to: metaclass.
	behaviors
		at: spec put: instanceBehavior;
		at: spec metaclass put: classBehavior.
	spec methods do: [ :m | self createNewMethod: m in: class ].
	spec metaclass methods
		do: [ :m | self createNewMethod: m in: metaclass ].
	^ class
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
createNewClassFrom: spec in: module

	| supername superclass namespace metaclass class instanceBehavior classBehavior ivars |
	supername := spec superclass name.
	superclass := module ifNil: [ self => supername ] ifNotNil: [ 
		              namespace := dest sendLocal: #namespace to: module.
		              dest
			              sendLocal: #at:
			              to: namespace
			              with: { (dest addSymbol: supername) } ].
	class := dest
		             sendLocal: #newSubclassOf:
		             to: self => #Class
		             with: { superclass }.
	metaclass := dest sendLocal: #class to: class.
	dest
		sendLocal: #name:
		to: class
		with: { (dest newString: spec name) }.
	ivars := self transferLiteral: spec instVarNames.
	dest sendLocal: #instVarNames: to: class with: { ivars }.
	instanceBehavior := dest sendLocal: #instanceBehavior to: class.
	classBehavior := dest sendLocal: #instanceBehavior to: metaclass.
	behaviors
		at: spec put: instanceBehavior;
		at: spec metaclass put: classBehavior.
	spec methods do: [ :m | self createNewMethod: m in: class ].
	spec metaclass methods do: [ :m | 
		self createNewMethod: m in: metaclass ].
	module ifNotNil: [
	dest
		sendLocal: #addClass: to: module with: { class };
		sendLocal: #module: to: class with: { module }].
	^ class
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
createNewMethod: m in: species

	| smethod size transferred astcodes selector format tliteral md code |
	smethod := SCompiler new compile: m sourceCode.
	smethod classBinding: species.
	size := dest newInteger: smethod size.
	transferred := dest
		               sendLocal: #new:
		               to: self => #CompiledMethod
		               with: { size }.
	mapping at: smethod put: transferred.
	astcodes := dest newByteArray: smethod astcodes.
	selector := dest addSymbol: smethod selector.
	format := dest newInteger: smethod format.
	code := dest newString: smethod source.
	dest
		sendLocal: #astcodes: to: transferred with: { astcodes };
		sendLocal: #classBinding: to: transferred with: { species };
		sendLocal: #selector: to: transferred with: { selector };
		sendLocal: #format: to: transferred with: { format };
		sendLocal: #sourceObject: to: transferred with: { code }.
	smethod withIndexDo: [ :literal :i | 
		tliteral := self transferLiteral: literal.
		transferred at: i put: tliteral ].
	md := dest sendLocal: #methodDictionary to: species.
	dest sendLocal: #at:put: to: md with: { 
			selector.
			transferred }.
	^ transferred
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
createNewModule: spec
	| behavior class module |
	behavior := behaviors at: spec.
	class := dest behaviorClass: behavior.
	module := dest sendLocal: #new to: class.
	dest
		sendLocal: #bindKernelExports to: module;
		sendLocal: #importRequiredModules to: module.
	spec name !!= #Module ifTrue: [ dest sendLocal: #module: to: class with: { module }].
	^ module
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
headerFor: aRingObject
	| behavior |
	behavior := behaviors at: aRingObject spec ifAbsent: nil.
	^ LMRObjectHeader new
		behavior: behavior;
		bytes: aRingObject isBytes
			arrayed: aRingObject spec isVariable
			named: aRingObject spec instSize > 0;
		size: aRingObject size;
		hash: aRingObject headerHash
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
image: aPowertalkRingImage

	| index |
	source := aPowertalkRingImage.
	dest bootstrapper: self.
	index := (source => #Class) allInstVarNames indexOf: 'name'.
	dest classNameIndex: index.
	index := (source => #Class) allInstVarNames indexOf: 'module'.
	dest classModuleIndex: index.
	index := (source => #Metaclass) allInstVarNames indexOf: 'class'.
	dest metaclassInstanceClassIndex: index.
	index := (source => #Species) allInstVarNames indexOf:
		         'instanceVariables'.
	dest speciesIvarsIndex: index.
	index := (source => #Species) allInstVarNames indexOf: 'superclass'.
	dest speciesSuperclassIndex: index.
	index := (source => #Species) allInstVarNames indexOf:
		         'instanceBehavior'.
	dest speciesInstanceBehaviorIndex: index.
	index := (source => #Class) allInstVarNames indexOf: 'namespaces'.
	dest classNamespacesIndex: index.
	index := (source => #Species) allInstVarNames indexOf: 'format'.
	dest speciesFormatIndex: index.
	index := (source => #Module) allInstVarNames indexOf: 'namespace'.
	dest moduleNamespaceIndex: index.
	index := (source => #Behavior) allInstVarNames indexOf: 'methods'.
	dest behaviorMethodDictionaryIndex: index.
	index := (source => #Behavior) allInstVarNames indexOf: 'next'.
	dest behaviorNextIndex: index.
	index := (source => #Behavior) allInstVarNames indexOf: 'class'.
	dest behaviorClassIndex: index.
	index := (source => #MethodDictionary) allInstVarNames indexOf:
		         'table'.
	dest dictionaryTableIndex: index.
	index := (source => #Closure) allInstVarNames indexOf: 'block'.
	dest closureBlockIndex: index.
	index := (source => #CompiledBlock) allInstVarNames indexOf: 'method'.
	dest blockMethodIndex: index.
	index := (source => #CompiledMethod) allInstVarNames indexOf:
		         'format'.
	dest methodFlagsIndex: index.
	index := (source => #CompiledMethod) allInstVarNames indexOf:
		         'astcodes'.
	dest methodAstcodesIndex: index.
	index := (source => #CompiledMethod) allInstVarNames indexOf: 'class'.
	dest methodClassBindingIndex: index.
	index := (source => #CompiledMethod) allInstVarNames indexOf: 'selector'.
	dest methodSelectorIndex: index.
	index := (source => #CompiledMethod) allInstVarNames indexOf:
		         'optimizedCode'.
	dest
		methodExecutableCodeIndex: index;
		methodInstSize: (source => #CompiledMethod) allInstVarNames size
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
initialize
	dest := PowertalkLMR new.
	mapping := IdentityDictionary new.
	behaviors := IdentityDictionary new.
	stack := OrderedCollection new.
	closureMethods := OrderedCollection new
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
initializeEmulationOverrides
	| classes |
	classes := source vmPrimitivesSpec allExtensionClasses.
	classes
		do: [ :class | 
			class methods do: [ :m | self override: class name with: m ].
			class metaclass methods
				do: [ :m | self override: class metaclass name with: m ] ].
	self removeBootstrapDictionaryNewOverride
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
initializeRuntime
	| map symbols array method smi block metaclass kernel byteArray string closure behavior lpi lni |
	symbols := Dictionary new.
	#(+ - < > <= >= = == not)
		do: [ :symbol | 
			map := source newSymbol: symbol.
			symbols at: symbol put: (mapping at: map) ].
	array := mapping at: (source classNamed: #Array).
	byteArray := mapping at: (source classNamed: #ByteArray).
	method := mapping at: (source classNamed: #CompiledMethod).
	block := mapping at: (source classNamed: #CompiledBlock).
	closure := mapping at: (source classNamed: #Closure).
	behavior := mapping at: (source classNamed: #Behavior).
	smi := mapping at: (source classNamed: #SmallInteger).
	lpi := mapping at: (source classNamed: #LargePositiveInteger).
	lni := mapping at: (source classNamed: #LargeNegativeInteger).
	string := mapping at: (source classNamed: #String).
	metaclass := mapping at: (source classNamed: #Metaclass).
	kernel := mapping at: source kernel.
	dest
		arrayClass: array;
		byteArrayClass: byteArray;
		methodClass: method;
		blockClass: block;
		closureClass: closure;
		behaviorClass_: behavior;
		smallIntegerClass: smi;
		largePositiveIntegerClass: lpi;
		largeNegativeIntegerClass: lni;
		stringClass: string;
		metaclassClass: metaclass;
		knownSymbols: symbols;
		wordSize: source wordSize;
		initializeInterpreter;
		kernel: kernel.
	self
		prepareClosuresForExecution;
		initializeEmulationOverrides
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
initializeSymbolTable
	| symbol namespaces cvars table mapped |
	symbol := source classNamed: #Symbol.
	namespaces := symbol namespaces.
	cvars := namespaces at: 1.
	table := cvars at: #SymbolTable.
	mapped := mapping at: table.
	dest symbolTable: mapped
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
instantiateMetaobjects
	| ibehavior mspecies mbehavior |
	source classes , source metaclasses
		do: [ :species | 
			ibehavior := species instanceBehavior.
			mspecies := self newMapping: species.
			mbehavior := self newBehaviorMapping: ibehavior.
			behaviors at: species instanceSpec put: mbehavior.
			mapping
				at: species put: mspecies;
				at: ibehavior put: mbehavior ]
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
loadModule: symbol

	| spec classes moduleName moduleSpec module extensions |
	spec := self readModuleSpec: symbol.
	classes := spec allClasses.
	moduleName := ('.' split: symbol) last asSymbol.
	moduleSpec := spec at: moduleName , #Module.
	moduleSpec ifNil: [ moduleSpec := spec at: #Module , moduleName ].
	moduleSpec
		ifNil: [ moduleSpec := source specs at: #Module ]
		ifNotNil: [ 
			self createNewClassFrom: moduleSpec in: nil.
			classes remove: moduleSpec ].
	module := self createNewModule: moduleSpec.
	classes := self classesSortedBySuperclass: classes.
	classes := classes collect: [ :classSpec | 
		           self createNewClassFrom: classSpec in: module ].
	extensions := spec allExtensionClasses do: [:classSpec | self createExtensionMethodsOf: classSpec in: module].
	dest sendLocal: #justLoaded to: module.
	^ module
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
map: aRingObject to: anLMRObject
	mapping at: aRingObject put: anLMRObject
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
newBehaviorMapping: aRingObject
	| header mapped |
	header := self headerFor: aRingObject.
	mapped := LMRBehaviorObject new header: header; runtime: dest.
	stack add: aRingObject -> mapped.
	^ mapped
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
newCallback: aNativeCode bytesFrom: aByteArray
	| code original behavior class |
	code := source newBytesFrom: aByteArray.
	original := code behavior.
	behavior := source newSlots: 'CallbackBehavior'.
	class := original slotNamed: 'class'.
	behavior
		slotNamed: 'class' put: class;
		methods: original methods;
		next: source nil;
		optimizedCode: aNativeCode.
	code behavior: behavior.
	^ code
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
newMapping: aRingObject
	| header mapped |
	aRingObject isImmediate
		ifTrue: [ ^ LMRSmallInteger new value: aRingObject value ].
	header := self headerFor: aRingObject.
	aRingObject isBytes
		ifTrue: [ ^ LMRByteObject new
				header: header;
				bytes: aRingObject bytes ].
	mapped := LMRSlotObject new header: header.
	stack add: aRingObject -> mapped.
	^ mapped
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
override: classname with: rgMethod
	| spec species behavior smethod rmethod lmrmethod selector |
	spec := source specs at: classname.
	species := (source speciesFor: spec).
	behavior := mapping at: species instanceBehavior.
	smethod := (SCompiler forClass: species) compile: rgMethod sourceCode.
	rmethod := source transferMethod: smethod in: species. 
	lmrmethod := self newMapping: rmethod.
	self convertClosure.
	selector := dest symbolFromLocal: rgMethod selector.
	dest override: behavior -> selector with: lmrmethod
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
prepareClosuresForExecution
	| mapped |
	closureMethods
		do: [ :method | mapped := mapping at: method. dest interpreter prepareExecutableCode: mapped ]
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
readModuleSpec: aSymbol
	| path |
	path := self findModulePath: aSymbol.
	^PowertalkRingModule readSpec: aSymbol at: path parent

	
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
removeBootstrapDictionaryNewOverride
	| spec species behavior selector |
	spec := source specs at: #'Namespace class'.
	species := source speciesFor: spec.
	behavior := mapping at: species instanceBehavior.
	selector := dest symbolFromLocal: #new.
	dest removeOverride: behavior -> selector
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
result
	^dest
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
sendLoadModule: aSymbol

	| symbol |
	symbol := dest addSymbol: aSymbol.
	^ dest sendLocal: #load: to: dest kernel with: { symbol }
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
source: aPowertalkRingImage
	source := aPowertalkRingImage
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
transferLiteral: anObject
	| transferred |
	anObject isInteger
		ifTrue: [ ^ dest newInteger: anObject ].
	anObject class == ByteArray
		ifTrue: [ ^ dest newByteArray: anObject ].
	anObject isSymbol
		ifTrue: [ ^ dest addSymbol: anObject ].
	anObject isString
		ifTrue: [ ^ dest newString: anObject ].
	anObject class == SCompiledBlock
		ifTrue: [ ^self createNewBlock: anObject ].
	anObject class == Array ifTrue: [ 
		transferred := anObject collect: [ :o | self transferLiteral: o ].
		^dest newArray: transferred ].
	anObject isCharacter
		ifTrue: [ ^ dest newCharacter: anObject ].
	self ASSERT: false
! !

!RingBasedLMRBootstrapper methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:00'!
useHostModuleLoader
	dest
	sendLocal: #useHostModuleLoader
	to: dest kernel
	.
! !

!RingBasedLMRBootstrapper methodsFor: 'paths' stamp: 'KenD 11/22/2023 07:49:00'!
findModulePath: moduleName
	| parts path candidates dir |
	parts := '.' split: moduleName.
	path := ('/' join: parts) asFileReference path.
	candidates := self rootDirectory allDirectoriesMatching: parts first.
	candidates do: [:match | 
		dir := match parent / path pathString.
		dir exists ifTrue: [ 	^dir relativeTo: self rootDirectory asAbsolute ]].
	self error: 'module ' , moduleName , ' couldn''t be found'

! !

!RingBasedLMRBootstrapper methodsFor: 'paths' stamp: 'KenD 11/22/2023 07:49:00'!
outputDirectory
	^ self rootDirectory / 'build' 
! !

!RingBasedLMRBootstrapper methodsFor: 'paths' stamp: 'KenD 11/22/2023 07:49:00'!
rootDirectory
	^ '../../modules' asFileReference
! !

!RingBasedLMRBootstrapper methodsFor: 'building' stamp: 'KenD 11/22/2023 07:49:00'!
fixBehaviors
	| metaspec behaviorspec mclass mmetaclass |
	self
		initializeBehavior: nilObj spec: source => #UndefinedObject;
		initializeBehavior: trueObj spec: source => #True;
		initializeBehavior: falseObj spec: source => #False.
	metaspec := source => #Metaclass.
	behaviorspec := source => #Behavior.
	source classes values
		with: source metaclasses values
		do: [ :class :metaclass |
			mclass := mapping at: class.
			mmetaclass := mapping at: metaclass.
			self
				initializeBehavior: mclass spec: metaclass instanceSpec;
				initializeBehavior: mmetaclass spec: metaspec ].
	behaviors
		do: [ :behavior | self initializeBehavior: behavior spec: behaviorspec ]
! !

!RingBasedLMRBootstrapper methodsFor: 'building' stamp: 'KenD 11/22/2023 07:49:00'!
initializeBehavior: anLMRHeapObject spec: anRGBehavior
	| behavior |
	behavior := behaviors at: anRGBehavior.
	anLMRHeapObject behavior: behavior
! !

!RingBasedLMRBootstrapper class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:00'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
=> aSymbol
	^ specs at: aSymbol
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
createMethodDictionary: species sized: anInteger
	| behavior md size dictionary |
	behavior := species instanceBehavior.
	md := self classNamed: #MethodDictionary.
	size := kernel newInteger: anInteger.
	dictionary := runtime sendLocal: #new: to: md with: {size}.
	behavior methods: dictionary.
	^ dictionary
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
fillClasses
	| class meta |
	specs allClasses
		do: [ :def | 
			class := self classFor: def.
			meta := self metaclassFor: def metaclass.
			self
				fillSpecies: meta with: def metaclass;
				fillSpecies: class with: def ]
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
fillSpecies: species with: classDefinition

	| dictionary smethod transferred tags organization category |
	dictionary := self
		              createMethodDictionary: species
		              sized: classDefinition methods size.
	classDefinition methods do: [ :methodDefinition | 
		smethod := runtime compile: methodDefinition.
		transferred := kernel transferMethod: smethod in: species.
		runtime sendLocal: #basicAt:put: to: dictionary with: { 
				transferred selector.
				transferred }.
		tags := methodDefinition tags.
		tags notEmpty ifTrue: [ 
		organization := runtime sendLocal: #organization to: species.
		category := runtime newSymbol: tags anyone.
		runtime sendLocal: #classify:under: to: organization with: { transferred selector. category } ]]
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
fillSymbols
	| table namespaces cvars |
	namespaces := (self classNamed: #Symbol) namespaces.
	cvars := namespaces at: 1.
	table := cvars at: 'SymbolTable'.
	symbols
		do: [ :sym | kernel runtime sendLocal: #add: to: table with: {sym} ]
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
formatOfClass: definition
	| variable pointers  |
	variable := definition isVariable
		ifTrue: [ 16r2000 ]
		ifFalse: [ 0 ].
	pointers := definition isBytes
		ifTrue: [ 0 ]
		ifFalse: [ 16r4000 ].
	^ variable | pointers | definition allInstVarNames size
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
formatOfMetaclass: definition
	| variable pointers size |
	variable := definition isVariable
		ifTrue: [ 16r2000 ]
		ifFalse: [ 0 ].
	pointers := definition isBytes
		ifTrue: [ 0 ]
		ifFalse: [ 16r4000 ].
	size := (self => #Class) allInstVarNames size
		+ definition allInstVarNames size.
	^ variable | pointers | size
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
initialize
	classes := OrderedDictionary new.
	metaclasses := OrderedDictionary new.
	identityMap := IdentityDictionary new.
	symbols := OrderedCollection new
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
initializeBehavior: anObjectMap
	| class |
	class := classes at: anObjectMap spec.
	anObjectMap behavior: class instanceBehavior.

! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
kernel: aPowertalkRingKernelModule
	kernel := aPowertalkRingKernelModule.
	nilObj := kernel nil.
	trueObj := kernel true.
	falseObj := kernel false.
	
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
log: aString
	Transcript
		show: aString;
		cr
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
metaclasses
	^metaclasses
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
newArray: anArray
	| array |
	array := self newArraySized: anArray size.
	anArray withIndexDo: [ :obj :i | array at: i put: obj ].
	^ array
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
newBytesFrom: aByteObject
	^self newBytes: aByteObject class name contents: aByteObject
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
newBytesOf: anRGBehavior sized: anInteger
	| contents |
	contents := ByteArray new: anInteger.
	^ self newBytesOf: anRGBehavior contents: contents
! !

!PowertalkRingModule methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:55'!
newSlots: classname
	^self newSlots: classname sized: 0
! !

!PowertalkRingModule methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:55'!
basicNewBytes: classname contents: aByteObject
	^ self basicNewBytesOf: self => classname contents: aByteObject
! !

!PowertalkRingModule methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:55'!
basicNewBytesOf: anRGBehavior contents: aByteObject
	^ ByteObjectMap new: anRGBehavior valued: aByteObject
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
basicNewSlots: classname
	^ self basicNewSlots: classname sized: 0
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
basicNewSlots: classname in: spec
	^ self basicNewSlots: classname in: spec sized: 0
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
basicNewSlots: classname in: spec sized: size
	| species |
	species := spec at: classname.
	^self basicNewSlotsOf: species sized: size
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
basicNewSlots: classname sized: size
	^ self basicNewSlots: classname in: specs sized: size
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
basicNewSlotsOf: anRGBehavior sized: size
	^ SlotObjectMap new: anRGBehavior size: size withAll: nilObj
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
classFor: anRGBehavior
	^classes at: anRGBehavior
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
classes
	^ classes
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
createSpecies: definition
	| class meta ibehavior cbehavior |
	class := ClassMap new: definition metaclass size: 0 withAll: nilObj.
	class instanceSpec: definition.
	meta := MetaclassMap
		new: (self => #Metaclass) metaclass
		size: 0
		withAll: nilObj.
	meta instanceSpec: definition metaclass.
	ibehavior := self basicNewSlots: #Behavior.
	cbehavior := self basicNewSlots: #Behavior.
	ibehavior class: class.
	cbehavior class: meta.
	meta
		class: class;
		instanceBehavior: cbehavior.
	class instanceBehavior: ibehavior.
	classes at: definition put: class.
	metaclasses at: definition metaclass put: meta
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
false
	^ falseObj
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
genesis
	specs allClasses do: [ :def | self createSpecies: def ].
	specs allClasses do: [ :def | self buildSpecies: def ].

! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
metaclassFor: anRGBehavior
	^ metaclasses at: anRGBehavior
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
newBytes: classname contents: aByteObject
	^self basicNewBytes: classname contents: aByteObject
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
newBytesOf: anRGBehavior contents: aByteObject
^ self basicNewBytesOf: anRGBehavior contents: aByteObject

! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
newOf: anRGBehavior sized: anInteger
	^ anRGBehavior isBytes
		ifTrue: [ self newBytesOf: anRGBehavior sized: anInteger ]
		ifFalse: [ self newSlotsOf: anRGBehavior sized: anInteger ]
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
newSlots: classname sized: size
	"
	Allocate an object of pointer type (as SlotObjectMap).
	It is niled-out, and 	`size` is the size of indexed part (i.e.,
	shall not include named slots)
	"
^ self basicNewSlots: classname sized: size.

! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
newSlotsOf: anRGBehavior sized: size
	"
	Allocate an object of pointer type (as SlotObjectMap).
	It is niled-out, and 	`size` is the size of indexed part (i.e.,
	shall not include named slots)
	"

^ self basicNewSlotsOf: anRGBehavior sized: size

! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
nil
	^ nilObj
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
runtime
	^ runtime
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
speciesFor: anRGBehavior
	^ anRGBehavior isMeta ifTrue: [metaclasses at: anRGBehavior] ifFalse: [ classes at: anRGBehavior ]
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
specs
	^specs
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
specs: anRGEnvironment
	specs := anRGEnvironment.

! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
transferLiteral: anObject
	| class transferred slot |
	class := anObject class.
	(class inheritsFrom: ObjectMap)
		ifTrue: [ ^ anObject ].
	(class inheritsFrom: Integer)
		ifTrue: [ ^ self newInteger: anObject ].
	(class inheritsFrom: Symbol)
		ifTrue: [ ^ self newSymbol: anObject ].
	(class inheritsFrom: String)
		ifTrue: [ ^ self newString: anObject ].
	class = ByteArray
		ifTrue: [ ^ self newBytesFrom: anObject ].
	transferred := self newSlots: anObject class name sized: anObject size.
	anObject
		withIndexDo: [ :elem :i | 
			slot := self transferLiteralDeep: elem.
			transferred at: i put: slot ].
	^ transferred
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
transferLiteralDeep: anObject
	| class transferred slot size ivar |
	class := anObject class.
	anObject isInteger
		ifTrue: [ ^ self newInteger: anObject ].
	anObject == nil
		ifTrue: [ ^ nilObj ].
	anObject == false
		ifTrue: [ ^ falseObj ].
	anObject == true
		ifTrue: [ ^ trueObj ].
	identityMap at: anObject ifPresent: [ :existing | ^ existing ].
	(class == Symbol or: [ class inheritsFrom: Symbol ])
		ifTrue: [ ^ self newSymbol: anObject ].
	anObject isString
		ifTrue: [ ^ self newString: anObject ].
	class = ByteArray
		ifTrue: [ ^ self newBytesFrom: anObject ].
	(class == Float or: [ class inheritsFrom: Float ])
		ifTrue: [ ^ self newFloatFrom: anObject ].
	(class inheritsFrom: ObjectMap)
		ifTrue: [ ^ anObject ].
	class == SCompiledBlock
		ifTrue: [ ^ self transferBlock: anObject ].
	class == Character ifTrue: [ ^self transferCharacter: anObject ].
	size := class isVariable
		ifTrue: [ anObject size ]
		ifFalse: [ 0 ].
	transferred := self newSlots: class name sized: size.
	1 to: class instSize do: [ :i | 
		ivar := anObject instVarAt: i.
		slot := self transferLiteralDeep: ivar.
		transferred slotAt: i put: slot ].
	size > 0
		ifTrue: [ anObject
				withIndexDo: [ :elem :i | 
					slot := self transferLiteralDeep: elem.
					transferred at: i put: slot ] ].
	^ transferred
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
true
	^ trueObj
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
vmPrimitivesSpec
	^vmPrimitivesSpec
! !

!PowertalkRingModule methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
vmPrimitivesSpec: anRGEnvironment
	vmPrimitivesSpec := anRGEnvironment
! !

!PowertalkRingModule methodsFor: 'own services' stamp: 'KenD 11/22/2023 07:48:55'!
buildSpecies: spec
	| sspec sclass sbehavior metasuper  |
	sspec := spec superclass.
	sspec
		ifNil: [ sclass := nilObj.
			sbehavior := nilObj.
			metasuper := classes at: self => #Class ]
		ifNotNil: [ sclass := classes at: sspec.
			sbehavior := sclass instanceBehavior.
			metasuper := metaclasses at: sspec metaclass ].
	self
		initializeClass: spec superclass: sclass superbehavior: sbehavior;
		initializeMetaclass: spec metaclass superclass: metasuper
! !

!PowertalkRingModule methodsFor: 'building' stamp: 'KenD 11/22/2023 07:48:55'!
classNamed: aString
	^self classFor: self => aString
! !

!PowertalkRingModule methodsFor: 'building' stamp: 'KenD 11/22/2023 07:48:55'!
generateLMR
	^(RingBasedLMRBootstrapper new image: self) convert
! !

!PowertalkRingModule methodsFor: 'building' stamp: 'KenD 11/22/2023 07:48:55'!
initializeClass: definition superclass: superclass superbehavior: superbehavior
	| class name flag ivars namespaces subclasses format |
	class := classes at: definition.
	class instanceBehavior next: superbehavior.
	subclasses := definition subclasses
		collect: [ :def | classes at: def ].
	subclasses := kernel newArray: subclasses.
	name := kernel newSymbol: definition name.
	flag := self formatOfClass: definition.
	format := kernel newInteger: flag.
	ivars := kernel newStringArray: definition instVarNames.
	namespaces := kernel createClassNamespaces: definition.
	class
		superclass: superclass;
		format: format;
		instanceVariables: ivars;
		namespaces: namespaces;
		organization: nilObj;
		name: name;
		subclasses: subclasses;
		module: module.
	definition metaclass allInstVarNames
		do: [ :ivar | class slotNamed: ivar put: nilObj ]
! !

!PowertalkRingModule methodsFor: 'building' stamp: 'KenD 11/22/2023 07:48:55'!
initializeMetaclass: definition superclass: superclass
	| meta ivars flags format superbehavior |
	meta := metaclasses at: definition.
	superbehavior := superclass instanceBehavior.
	meta instanceBehavior next: superbehavior.
	ivars := kernel newStringArray: definition instVarNames.
	flags := kernel formatOfMetaclass: definition.
	format := kernel newInteger: flags.
	meta
		superclass: superclass;
		format: format;
		instanceVariables: ivars;
		organization: nilObj
! !

!PowertalkRingModule class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
fromSpec
	^ self new specs: self kernelSpec; vmPrimitivesSpec: self vmPrimitivesSpec
! !

!PowertalkRingModule class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
kernelSpec
	^ KernelSpec ifNil: [ KernelSpec := self readSpec: #Kernel at: '.' ]
! !

!PowertalkRingModule class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
readSpec: specName at: path
	| dir  repo spec subdir |
	dir := '../../modules' asFileReference.
	subdir := path isString ifTrue: [ path ] ifFalse: [ path asPath pathString ].
	subdir notEmpty ifTrue: [ dir := dir  / subdir].
	repo := TonelRepository new
		directory: dir.
		
	spec := repo asRingEnvironmentWith: {('.' split: specName) last}.
	^ spec clean
! !

!PowertalkRingModule class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
resetSpecs

	"
		self resetSpecs
	"

	KernelSpec := nil.
	VMPrimitivesSpec := nil
! !

!PowertalkRingModule class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
vmPrimitivesSpec
	^ VMPrimitivesSpec
		ifNil: [ VMPrimitivesSpec := self readSpec: #VM at: 'Kernel' ]
! !

!PowertalkRingModule class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:55'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!PowertalkRingImage methodsFor: 'own services' stamp: 'KenD 11/22/2023 07:49:08'!
bootstrap
	runtime
		sendLocal: #bootstrap to: module;
		removeBootstrapDictionaryOverrides
! !

!PowertalkRingImage methodsFor: 'own services' stamp: 'KenD 11/22/2023 07:49:08'!
bootstrapDictionaries
	^bootstrapDicts
! !

!PowertalkRingImage methodsFor: 'own services' stamp: 'KenD 11/22/2023 07:49:08'!
builder
	^	RingBasedLMRBootstrapper new image: self.
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
createBootstrapNamespace
	| namespace |
	namespace := self newBootstrapDictionaryOf: self => #Namespace.
	module namespace: namespace.
	namespace
		at: #WordSize put: wordSize;
		at: #LastHash put: 1.
	classes do: [ :c | namespace at: c name asSymbol put: c ]
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
createClassNamespaces: spec
	| names cvars array |
	names := spec classVariables.
	names isEmpty
		ifTrue: [ ^ self newArraySized: 0 ].
	cvars := self newBootstrapDictionaryOf: self => #Namespace.
	names do: [ :rgVar | cvars at: rgVar name put: nilObj ].
	array := self newArraySized: 1.
	array at: 1 put: cvars.
	^ array
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
initialize
	super initialize.
	bootstrapDicts := OrderedCollection new.
	kernel := self
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
newBootstrapDictionaryOf: anRGBehavior
	"
	Allocate a bootstrap dictionary object. Its contents is managed by the
	mother image, but in the baby smalltalk can do	at: and at:put:, via primitives.
	It is used to replace PoolDictionaries and Namespaces until the baby has been
	initialized and is ready to become a fully working image. At that point, the
	BootstrapDictionaries are converted to the corresponding types and discarded.
	"

	| result |
	result := BootstrapDictionaryMap new
		initializeAs: self => #BootstrapDictionary.
	bootstrapDicts add: result.
	^ result
		realSpec: anRGBehavior;
		image: self
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
newClosure: anInteger
	^ ClosureMap new: closureSpec size: anInteger withAll: nilObj
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
newFloatFrom: aFloat
	^ self newBytes: 'Float' contents: aFloat pointerDouble
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
newSymbol: aSymbol
	| new |
	identityMap at: aSymbol ifPresent: [ :s | ^ s ].
	new := SymbolMap new: symbolSpec symbol: aSymbol.
	symbols add: new.
	^ identityMap at: aSymbol put: new
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
specs: anRGEnvironment
	super specs: anRGEnvironment.
	closureSpec := self => #Closure.
	arraySpec := self => #Array.
	smiSpec := self => #SmallInteger.
	symbolSpec := self => #Symbol
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
transferBlock: anSCompiledBlock
	| transferred method format |
	identityMap at: anSCompiledBlock
		ifPresent: [ :b | ^ b ].
	transferred := self newSlots: #CompiledBlock.
	identityMap at: anSCompiledBlock put: transferred.
	method := identityMap at: anSCompiledBlock method.
	format := self newInteger: anSCompiledBlock format.
	transferred
		method: method;
		format: format;
		optimizedCode: nilObj.
	^ transferred
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
transferCharacter: aCharacter
	| class bytechars value transferred int |
	identityMap at: aCharacter ifPresent: [ :c | ^ c ].
	class := self classNamed: #Character.
	bytechars := class namespaces slots first at: #ByteCharacters.
	value := aCharacter asInteger.
	transferred := bytechars slots
		at: value + 1
		ifAbsent: [ int := self newInteger: value.
			(self newSlots: 'Character') value: int ].
	identityMap at: aCharacter put: transferred.
	^ transferred
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
wordSize
	^ wordSize
! !

!PowertalkRingImage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:08'!
wordSize: anInteger
	wordSize := anInteger.
	maxSMI := (1 bitShift: wordSize * 8 - 2) - 1.
	minSMI := maxSMI negated - 1

! !

!PowertalkRingImage methodsFor: 'building' stamp: 'KenD 11/22/2023 07:49:08'!
genesis
	"
	Create the world (should take less than 6 days). This is named 'genesis' to remind us those who had
	done this (and much more) before us. Namely SELF people. I (JV) would like to use this opportunity and point you to
	
	https://github.com/russellallen/self/blob/2bcf2c4cab23f52bf68ac4f617020e748699a548/vm/src/any/memory/universe.cpp#L79
	"

	nilObj := self basicNewSlots: #UndefinedObject.
	trueObj := self basicNewSlots: #True.
	falseObj := self basicNewSlots: #False.
	module := self basicNewSlots: #KernelModule.
	super genesis.
	self createBootstrapNamespace.
	runtime := PowertalkRingRuntime new.
	runtime image: self
! !

!PowertalkRingImage methodsFor: 'building' stamp: 'KenD 11/22/2023 07:49:08'!
kernel
	^module
! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
newArraySized: anInteger
^self basicNewSlotsOf: arraySpec sized: anInteger.

! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
newAssociation: anAssociation
	| assoc key value |
	assoc := self newSlots: 'Association'.
	key := self transferLiteralDeep: anAssociation key.
	value := self transferLiteralDeep: anAssociation value.
	^ assoc
		key: key;
		value: value; yourself
! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
newInteger: anInteger
	anInteger > maxSMI
		ifTrue: [ ^ self newLargePositiveInteger: anInteger ].
	anInteger < minSMI
		ifTrue: [ ^ self newLargeNegativeInteger: anInteger ].
	^ SmallintObjectMap new: smiSpec valued: anInteger
! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
newLargeNegativeInteger: anInteger
	| size bytes byte |
	size := (anInteger bytesCount alignedTo: 2) max: wordSize.
	bytes := ByteArray new: size withAll: 16rFF.
	1 to: anInteger bytesCount do: [ :i | 
		byte := anInteger byteAt: i.
		byte > 0
			ifTrue: [ byte := 256 - byte ].
		bytes at: i put: byte ].
	^ self newBytes: #LargeNegativeInteger contents: bytes
! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
newLargePositiveInteger: anInteger
	| size bytes |
	size := (anInteger bytesCount alignedTo: 2) max: wordSize.
	bytes := anInteger asByteArrayOfSize: size.
	^ self newBytes: #LargePositiveInteger contents: bytes reversed
! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
newString: aString
	| bytes |
	bytes := aString copyWith: Character null.
	^self newBytes: 'String' contents: bytes
! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
newStringArray: strings
	| array bytes |
	array := self newSlots: 'Array' sized: strings size.
	strings
		withIndexDo: [ :s :i |
			bytes := self newString: s.
			array at: i put: bytes ].
	^ array
! !

!PowertalkRingImage methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:08'!
transferMethod: anSCompiledMethod in: species

	| size classname transferred astcodes selector format literal tliteral source |
	(identityMap includesKey: anSCompiledMethod) ifTrue: [ 
		self ASSERT: false ].
	size := anSCompiledMethod size.
	classname := anSCompiledMethod isCallback
		             ifTrue: [ 'CallbackMethod' ]
		             ifFalse: [ 'CompiledMethod' ].
	transferred := self newSlots: classname sized: size.
	identityMap at: anSCompiledMethod put: transferred.
	astcodes := self transferLiteralDeep: anSCompiledMethod astcodes.
	selector := self newSymbol: anSCompiledMethod selector.
	format := self newInteger: anSCompiledMethod format.
	source := self newString: anSCompiledMethod source.
	transferred
		astcodes: astcodes;
		class: species;
		selector: selector;
		format: format;
		source: source.
	1 to: size do: [ :i | 
		literal := anSCompiledMethod at: i.
		tliteral := self transferLiteralDeep: literal.
		transferred at: i put: tliteral ].
	^ transferred
! !

!Bridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:56'!
findObjectNamed: aSymbol
	^self subclassResponsibility
! !

!Bridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:56'!
initialize
	cache := IdentityDictionary new.
	objects := Dictionary new
! !

!Bridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:56'!
mirrorOn: address
	^(runtime handleOn: address) mirror
! !

!Bridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:56'!
name: object as: name
	^objects at: name put: object
! !

!Bridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:56'!
objectNamed: aSymbol
	^ objects at: aSymbol ifAbsentPut: [ self findObjectNamed: aSymbol ]
! !

!Bridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:56'!
objectNamed: aSymbol ifAbsent: aBlock
	^ objects at: aSymbol ifAbsent: aBlock
! !

!Bridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:56'!
runtime: aRuntime
	runtime := aRuntime
! !

!Bridge class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:56'!
new
	^self basicNew initialize
! !

!SmalltalkBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:03'!
false
	^falseObj
! !

!SmalltalkBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:03'!
findRootObjects
	self subclassResponsibility

! !

!SmalltalkBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:03'!
kernel
	^ self
		objectNamed: #kernel
		ifAbsent: [ self
				update;
				objectNamed: #kernel ]
! !

!SmalltalkBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:03'!
nil
	^nilObj
! !

!SmalltalkBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:03'!
true
	^trueObj
! !

!SmalltalkBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:03'!
update
	self
		findRootObjects
! !

!SmalltalkBridge class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:03'!
new
	^self basicNew initialize
! !

!BootstrappedPstBridge methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
bootstrapper: aSmalltalkBootstrapper
	bootstrapper := aSmalltalkBootstrapper
! !

!BootstrappedPstBridge methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
updateGlobals
	bootstrapper globals keysAndValuesDo: [:name :obj | objects at: name put: obj ]
! !

!BootstrappedPstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:42'!
findNilObject
	^ nilObj := ObjectHandle
		on: runtime storage nilObject
		within: runtime
! !

!BootstrappedPstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:42'!
findRootObjects
	nilObj := ObjectHandle on: bootstrapper nilObject within: runtime.
	trueObj := ObjectHandle on: bootstrapper trueObject within: runtime.
	falseObj := ObjectHandle on: bootstrapper falseObject within: runtime
! !

!PharoBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:16'!
findRootObjects
	nilObj := LocalHandle on: nil within: runtime.
	trueObj := LocalHandle on: true within: runtime.
	falseObj := LocalHandle on: false within: runtime
! !

!PstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:12'!
findFalseObject
	| s handle |
	s := runtime storage.
	handle := s class = PowertalkRingImage
		ifTrue: [ s false ]
		ifFalse: [ self ASSERT: false ].
	^ falseObj := ObjectHandle on: handle within: runtime
! !

!PstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:12'!
findKernelModule
	| handle |
	handle := nilObj.
	[ handle getClass localName !!= 'Kernel' ]
		whileTrue: [ handle := handle nextObjectHandle ].

	self name: handle mirror as: #kernel.

! !

!PstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:12'!
findNilObject
	^ nilObj := ObjectHandle
		on: #ImageSegmentWriter nilOffset
		within: runtime
! !

!PstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:12'!
findObjectNamed: name
	| namespace array |
	namespace := self kernel slotOf: #Kernel named: #namespace.
	array := namespace slotOf: #Namespace named: 'table'.
	array
		do: [ :slot | 
			| assoc |
			assoc := slot asAssociationMirror.
			assoc reflectsNil
				ifFalse: [ assoc key asLocalString = name
						ifTrue: [ ^ assoc value ] ] ].
	self error: 'object not found'
! !

!PstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:12'!
findRootClasses
	| object subclasses |
	object := self objectNamed: 'Object'.
	subclasses := object asSpeciesMirror subclasses.
	1 to: subclasses size do: [ :i | 
		| subclass name |
		subclass := (subclasses slotAt: i) asSpeciesMirror.
		name := subclass name asLocalString.
		self name: subclass as: name ]
! !

!PstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:12'!
findRootObjects
	| class |
	nilObj := self findNilObject.
	class := nilObj mirror reflectedClass.
	[ class reflectsNil ]
		whileFalse: [ | name |
			name := class name asLocalString.
			self name: class as: name.
			class := class superclass ].
	self findRootClasses; findKernelModule
! !

!PstBridge methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:12'!
findTrueObject
	self ASSERT: false.
	^ trueObj := ObjectHandle on: 0 within: runtime
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
asLocalCollection
	^handle asLocalCollection
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
asLocalString
	^handle asLocalString
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
dispatch: aMessage
	^self dispatch: aMessage from: nil
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
dispatch: aMessage from: parentInterpreter
	^self subclassResponsibility
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
handle
	^handle
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
handle: anObjectHandle
	handle := anObjectHandle
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
handleOn: objectHandle
	^handle handleOn: objectHandle
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
isLocal
	^handle isLocal
! !

!Gate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
mirror
	^handle mirror
! !

!Gate methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:49'!
maneuvererOn: objectHandle
	^DirectGate subjectOn: objectHandle
! !

!Gate methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:49'!
mirageOn: objectHandle
	^MirageGate subjectOn: objectHandle
! !

!Gate methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:49'!
subject
	^Subject new _gate: self
! !

!Gate class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:49'!
on: handle
	^self new handle: handle
! !

!Gate class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:49'!
subjectOn: handle
	^(self on: handle) subject
! !

!DirectGate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:57'!
dispatch: aMessage from: parentInterpreter
	| receiver method interpreter |
	receiver := aMessage receiver.
	method := handle runtime lookup: aMessage selector on: receiver.
	method ifNil: [ self ASSERT: false ].
	interpreter := SmalltalkInterpreter
		on: receiver
		with: aMessage arguments
		for: method.
	^ interpreter
		parent: parentInterpreter;
		evaluate: method
! !

!DirectGate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:57'!
dispatchSuper: aMessage from: parentInterpreter
	| receiver method interpreter |
	receiver := aMessage receiver.
	method := handle runtime
		lookupSuper: aMessage selector
		on: receiver
		from: parentInterpreter method classBinding superclass name.
	method ifNil: [ self ASSERT: false ].
	interpreter := SmalltalkInterpreter
		on: receiver
		with: aMessage arguments
		for: method.
	^ interpreter
		parent: parentInterpreter;
		evaluate: method
! !

!DirectGate methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:57'!
getInstVarNamed: name
	| index |
	index := handle mirror reflectedClass indexOfSlot: name.
	index = 0 ifTrue: [self error: 'instance variable not found'].
	^self slotAt: index
! !

!DirectGate methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:57'!
slotAt: index
	| slot |
	slot := handle slotAt: index.
	^self maneuvererOn: slot
! !

!MirageGate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:04'!
classBinding
	^class
! !

!MirageGate methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:04'!
handle: anObjectHandle
	super handle: anObjectHandle.
	class := handle isLocal
		ifTrue: [ handle oid class ]
		ifFalse: [ handle mirror reflectedClass localEquivalent ]
! !

!MirageGate methodsFor: 'notifications' stamp: 'KenD 11/22/2023 07:49:04'!
dispatch: aMessage
	^self dispatch: aMessage from: nil
! !

!MirageGate methodsFor: 'notifications' stamp: 'KenD 11/22/2023 07:49:04'!
dispatch: aMessage from: parentInterpreter
	| receiver |
	receiver := aMessage receiver.
	^receiver _gate isLocal
		ifTrue: [ self dispatchLocal: aMessage from: parentInterpreter ]
		ifFalse: [ self dispatchRemote: aMessage from: parentInterpreter ]
! !

!MirageGate methodsFor: 'notifications' stamp: 'KenD 11/22/2023 07:49:04'!
dispatchLocal: aMessage from: parentInterpreter
	| args receiver result hresult |
	"args := aMessage arguments
		collect: [ :arg | 
			arg class == Subject
				ifTrue: [ arg _gate handle oid ]
				ifFalse: [ arg ] ]."
	args := aMessage arguments.
	receiver := aMessage receiver _gate handle.
	result := receiver oid perform: aMessage selector withArguments: args.
	result class == Subject
		ifTrue: [ ^ result ].
	hresult := LocalHandle on: result within: receiver runtime.
	^ hresult mirage
! !

!MirageGate methodsFor: 'notifications' stamp: 'KenD 11/22/2023 07:49:04'!
dispatchRemote: aMessage from: parentInterpreter
	| method interpreter |
	method := self lookup: aMessage selector.
	method ifNil: [ self error: 'cannot interpet ' , aMessage selector ].
	interpreter := SmalltalkInterpreter
		on: aMessage receiver
		with: aMessage arguments
		for: method.
	^ interpreter
		parent: parentInterpreter;
		evaluate: method
! !

!MirageGate methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:04'!
getInstVarNamed: name
	| index |
	index := class indexOfSlot: name.
	index = 0 ifTrue: [self error: 'instance variable not found'].
	^self slotAt: index
! !

!MirageGate methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:04'!
printOn: aStream
	aStream nextPutAll: 'mirage gate on: ' , handle printString
! !

!MirageGate methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:49:04'!
lookup: selector
	^class methodNamed: selector
! !

!MirageGate methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:04'!
slotAt: index
	| slot |
	slot := handle slotAt: index.
	^self mirageOn: slot
! !

!Handle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:16'!
handleOn: objectId
	^self class on: objectId within: runtime
! !

!Handle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:16'!
isLocal
	^runtime isLocal
! !

!Handle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:16'!
objectHandleOn: objectId
	^ ObjectHandle on: objectId within: runtime
! !

!Handle methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
runtime
	^runtime
! !

!Handle methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
runtime: aRuntime
	runtime := aRuntime
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
= anObject
	^ anObject class = self class and: [ oid = anObject oid ]
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
handleOn: anObject
	^self class on: anObject within: runtime
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
indexOf: varname for: aMirror
	| type |
	type := self structureOf: aMirror structureType.
	^type indexOf: varname
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
indexOf: varname inStructureOf: type
	^runtime indexOf: varname inStructureOf: type
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
maneuverer
	^ DirectGate subjectOn: self
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
mirage
	^MirageGate subjectOn: self
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
mirror
	^ObjectMirror on: self
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
runtime
	^runtime
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
runtime: aRuntime
	runtime := aRuntime
! !

!ObjectHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
structureOf: type
	^runtime structureOf: type
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
arrayedSize
	^ runtime objectFormat arrayedSizeOf: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
asLocalBoolean
	runtime false oid = oid ifTrue: [ ^false ].
	runtime true oid = oid ifTrue: [ ^true ].
	self ASSERT: false.
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
asLocalBytes
	^runtime objectFormat bytesOf: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
asLocalCollection
	^self isBytes ifTrue: [runtime bytesOf: oid] ifFalse: [self ASSERT: false]
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
asLocalInteger
	^runtime integerOf: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
asLocalString
	^runtime stringOf: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
asLocalSymbol
	^runtime symbolOf: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
basicFlags
	^runtime objectFormat flagsOf: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
getBehavior
	| behavior |
	behavior := runtime objectFormat behaviorOf: oid.
	^self handleOn: behavior
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
getClass
	^runtime objectFormat classOf: self.

! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
isArrayed
	^runtime objectFormat isArrayed: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
isBytes
	^runtime objectFormat isBytes: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
isFixed
	^self isArrayed not
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
isLarge
	^self isSmall not
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
isSmall
	^runtime objectFormat isSmall: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
largeSize
	^runtime objectFormat largeSizeOf: oid
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
nextObjectHandle
	^ runtime objectFormat nextObjectHandleOf: self
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
printOn: aStream
	| format size bytes |
	format := runtime objectFormat.
	format print: oid on: aStream.
	self isBytes
		ifFalse: [ ^ self ].
	size := self size min: 128.
	size < 30
		ifTrue: [ aStream nextPutAll: ': ' ]
		ifFalse: [ aStream cr ].
	bytes := format bytesOf: oid count: size.
	aStream print: bytes
! !

!ObjectHandle methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:15'!
size
	^runtime objectFormat sizeOf: oid
! !

!ObjectHandle methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:15'!
at: index
	| slot |
	slot := runtime arrayedSlotOf: oid at: index.
	^ self handleOn: slot
! !

!ObjectHandle methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:15'!
at: index put: anOid
	^ runtime arrayedSlotOf: oid at: index put: anOid
! !

!ObjectHandle methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:15'!
slotAt: index
	| slot |
	slot := runtime slotOf: oid at: index.
	^self handleOn: slot
! !

!ObjectHandle methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:15'!
slotAt: index put: anOid
	^runtime slotOf: oid at: index put: anOid
! !

!ObjectHandle methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:48:15'!
hash
	^oid hash
! !

!ObjectHandle methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:48:15'!
isInteger
	^runtime objectFormat isInteger: oid
! !

!ObjectHandle methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:48:15'!
oid
	^oid
! !

!ObjectHandle methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:15'!
nilObject
	^runtime nil
! !

!ObjectHandle methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:15'!
oid: objectId
	self ASSERT: objectId !!== nil.
	oid := objectId
! !

!ObjectHandle class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:15'!
on: anObject within: aRuntime
	^self new oid: anObject; runtime: aRuntime
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
asLocalCollection
	^ oid
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
asLocalInteger
	^ oid
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
asLocalString
	^ oid asString
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
getClass
	| handle |
	handle := runtime handleOn: oid class.
	^ handle mirror asSpeciesMirror
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
indexOf: varname for: aMirror
	^ oid class indexOfSlot: varname asString
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
isLocal
	^true
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
nilObject
	^self handleOn: nil
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
oid: objectId
	oid !!= nil ifTrue: [ self halt ].
	objectId class = ByteString
		ifTrue: [ self halt ].
	oid := objectId
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
size
	^ oid basicSize + oid class instSize
! !

!LocalHandle methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
slotAt: index
	| slot |
	slot := oid instVarAt: index.
	^ self handleOn: slot
! !

!PstFrameHandle methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
currentIp
	^frame currentIp
! !

!PstFrameHandle methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:42'!
frame: aFrame
	frame := aFrame
! !

!PstFrameHandle methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:42'!
objectAtSlot: index
	| slot |
	slot := frame slotAt: index.
	^self objectHandleOn: slot
! !

!PstFrameHandle methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:42'!
slotAt: index
	^self objectAtSlot: index
! !

!PstFrameHandle methodsFor: 'services' stamp: 'KenD 11/22/2023 07:48:42'!
slotAtTop
	^frame slotAtTop
! !

!PstFrameHandle methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:42'!
printOn: aStream
	aStream nextPutAll: 'FH with: ' , String cr , frame printString
! !

!PstFrameHandle class methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:42'!
on: frame within: runtime
	^self new frame: frame; runtime: runtime
! !

!MethodLookup methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:59'!
lookup: aSymbol on: aSubject
	^self subclassResponsibility
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
compile: anRGMethod
	| compiler method |
	compiler := SCompiler new.
	method := compiler
		forClass: anRGMethod parent;
		compile: anRGMethod sourceCode.
	^ method
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
compiledMethodFor: anRGMethod
	| method |
	cache at: anRGMethod ifPresent: [ :cm | ^ cm ].
	method := self compile: anRGMethod.
	^ cache at: anRGMethod put: method
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
globals: aPoolDictionary
	globals := aPoolDictionary
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
initialize
	cache := Dictionary new
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
lookup: aSymbol on: aSubject
	| behavior classname |
	classname := aSubject _gate handle oid classname.
	behavior := spec at: classname.
	^ self lookup: aSymbol startingAt: behavior
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
lookup: aSymbol startingAt: aBehavior
	| next m c |
	next := aBehavior.
	[ m := next methodNamed: aSymbol.
	m ifNotNil: [ ^ self compiledMethodFor: m ].
	next := next superclass.
	next notNil ] whileTrue.
	^ aBehavior isMeta
		ifTrue: [ c := aBehavior environment at: #Class.
			self lookup: aSymbol startingAt: c ]
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
lookupSuper: aSymbol on: aSubject from: classname
	| behavior |
	cache at: classname -> aSymbol ifPresent: [ :cached | ^ cached ].
	behavior := spec at: classname.
	^ self lookup: aSymbol startingAt: behavior
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
spec
	^spec
! !

!EmulationLookup methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
spec: anRGEnvironment
	spec := anRGEnvironment
! !

!EmulationLookup class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:19'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!MirrorLookup methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:14'!
lookup: aSymbol on: aSubject
	^aSubject _gate mirror lookup: aSymbol
! !

!PharoLookup methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:50'!
lookup: aSymbol on: aSubject
	^ aSubject _gate handle oid class lookupSelector: aSymbol
! !

!ObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:13'!
bytesOf: oid
	| size |
	size := self sizeOf: oid.
	^self bytesOf: oid count: size
! !

!ObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:13'!
bytesOf: oid count: size
	^self subclassResponsibility
! !

!ObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:13'!
sizeOf: oid
	^self subclassResponsibility
! !

!ObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:13'!
stringOf: oid
	| size |
	size := self sizeOf: oid.
	^self stringOf: oid count: size - 1
! !

!ObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:13'!
stringOf: oid count: size
	^self subclassResponsibility
! !

!ObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:13'!
symbolOf: oid
	| size |
	size := self sizeOf: oid.
	^self stringOf: oid count: size
! !

!ObjectFormat methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
runtime
	^ runtime
! !

!ObjectFormat methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
runtime: aRuntime
	runtime := aRuntime
! !

!ObjectFormat methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
storage
	^ storage
! !

!ObjectFormat methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:13'!
storage: anObject
	storage := anObject
! !

!ObjectFormat class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:13'!
on: storage
	^self new storage: storage
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
arrayedSizeOf: oid
	^ oid arrayedSize
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
arrayedSlotOf: oid at: index
	^ oid at: index
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
arrayedSlotOf: oid at: index put: anotherOid
	^ oid at: index put: anotherOid
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
behaviorOf: oid
	^oid behavior
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
bytesOf: oid count: size
	^oid bytes copyFrom: 1 to: size
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
classOf: anObjectHandle
	| oid behavior handle class |
	oid := anObjectHandle oid.
	(self isInteger: oid) ifTrue: [ 
		class := storage classNamed: 'SmallInteger'.
		^(anObjectHandle runtime handleOn: class) mirror asClassMirror].
	behavior := self behaviorOf: oid.
	handle := anObjectHandle runtime handleOn: behavior.
	^handle mirror asBehaviorMirror instanceClass
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
integerOf: oid
	self ASSERT: oid isImmediate.
	^ oid value
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
isBytes: oid
	^oid isBytes
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
isInteger: oid
	^oid isImmediate
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
labelFor: oid
	| c |
	(self isInteger: oid) 
		ifTrue: [ ^'SMI 0x', (self integerOf: oid) printString ].
	(storage nameOf: oid) ifNotNil: [:name | ^name].
	c := self classOf: (runtime handleOn: oid).
	^c localName
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
newInteger: anInteger
	^storage newSmallInteger: anInteger
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
print: oid on: aStream
	| label |
	label := self labelFor: oid.
	aStream
		nextPut: $@;
		nextPutAll: label;
		nextPutAll: ' [size: 0x';
		nextPutAll: (self sizeOf: oid) printStringHex;
		nextPut: $].

! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
sizeOf: oid
	^oid size
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
slotOf: oid at: index
	^ oid slotAt: index
! !

!BootstrapObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
stringOf: oid count: size
	^(oid bytes copyFrom: 1 to: size) asString
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
behaviorOf: oid
	^ storage uint32of: oid atOffset: BehaviorOffset
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
classOf: anObjectHandle
	| oid class behavior handle |
	oid := anObjectHandle oid.
	oid odd ifTrue: [ class := storage classNamed: 'SmallInteger'.
			^ (anObjectHandle runtime handleOn: class) mirror asClassMirror ].
	behavior := self behaviorOf: oid.
	handle := anObjectHandle runtime handleOn: behavior.
	^ handle mirror asBehaviorMirror instanceClass
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
flagsOf: anObject
	^ storage uint8of: anObject atOffset: FlagsOffset
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
initialize
	wordSize := 8
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
integerOf: oid
	| shifted complement |
	self ASSERT: oid odd.
	shifted := oid bitShift: -1. 
	complement := 1 bitShift: storage wordSize * 8 - 1.
	^ oid >= complement
		ifTrue: [ shifted - complement ]
		ifFalse: [ shifted ]
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
isArrayed: anObject
	^ (self flagsOf: anObject) anyMask: IsArrayed
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
isBytes: anObject
	^ ((self flagsOf: anObject) anyMask: IsBytes)
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
isInteger: oid
	^oid odd
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
isLarge: anObject
	^(self isSmall: anObject) not
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
isNamed: anObject
	^ (self flagsOf: anObject) anyMask: IsNamed
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
isSmall: oid
	^ (self flagsOf: oid) anyMask: IsSmall
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
nextObjectHandleOf: anObjectHandle
	| addr size |
	addr := anObjectHandle oid.
	size := self sizeInBytesOf: addr.
	^anObjectHandle runtime handleOn: addr + size.
	
! !

!DmrObjectFormat methodsFor: 'services' stamp: 'KenD 11/22/2023 07:49:07'!
slotOf: base at: index
	^ storage uint64atOffset: base + (8 * (index - 1))
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
bodySizeInBytesOf: oid
	| total |
	total := self sizeOf: oid.
	^ (self isBytes: oid)
		ifTrue: [ total + wordSize - 1 bitAnd: 0 - wordSize ]
		ifFalse: [ total * wordSize ]
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
bytesOf: oid count: size
	^ storage bytesAt: oid sized: size
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
headerSizeInBytesOf: oid
	^(self isSmall: oid) ifTrue: [8] ifFalse: [16]

! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
labelFor: oid
	^oid hex
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
largeSizeOf: oid
	^ storage uint32of: oid atOffset: LargeSizeOffset
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
print: oid on: aStream
	| size |
	aStream
		nextPut: $@;
		nextPutAll: oid hex;
		nextPutAll: '[flags: 0x';
		nextPutAll: (self flagsOf: oid) printStringHex.
	self printFlagsOf: oid on: aStream.
	size := self sizeOf: oid.
	aStream
		nextPutAll: ', size: 0x';
		nextPutAll: size printStringHex;
		nextPut: $].


! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
printFlagsOf: oid on: aStream
	| char |
	aStream nextPut: $(.
	char := (self isSmall: oid)
		ifTrue: [ $S ]
		ifFalse: [ $L ].
	aStream
		nextPut: char;
		space.
	char := (self isBytes: oid)
		ifTrue: [ $B ]
		ifFalse: [ $P ].
	aStream
		nextPut: char;
		space.
	char := (self isArrayed: oid)
		ifTrue: [ $A ]
		ifFalse: [ $F ].
	aStream
		nextPut: char;
		nextPut: $)
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
sizeInBytesOf: oid
	^ (self headerSizeInBytesOf: oid) + (self bodySizeInBytesOf: oid)
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
sizeOf: oid
	^ (self isSmall: oid)
		ifTrue: [ self smallSizeOf: oid ]
		ifFalse: [ self largeSizeOf: oid ]
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
smallSizeOf: oid
	^ storage uint8of: oid atOffset: SizeOffset
! !

!DmrObjectFormat methodsFor: 'sizes' stamp: 'KenD 11/22/2023 07:49:07'!
stringOf: oid count: anInteger
	^storage stringAt: oid sized: anInteger
! !

!DmrObjectFormat class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:07'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
behaviorOf: oid
	^self ASSERT: false
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
bytesOf: oid count: size
	^oid copyFrom: 1 to: size
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
classOf: anObjectHandle
	^anObjectHandle oid class
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
integerOf: oid
	self ASSERT: oid isInteger.
	^ oid
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
isBytes: anObject
	^anObject class isBytes
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
isInteger: oid
	^oid isInteger
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
labelFor: oid
	| label |
	label := storage ifNotNil: [storage nameOf: oid].
	^label ifNil: [ 'unknown' ]
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
print: oid on: aStream
	aStream
		nextPutAll: '@local {';
		print: oid;
		nextPut: $}
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
sizeOf: oid
	^oid basicSize + oid class instSize
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
slotOf: oid at: index
	^ oid instVarAt: index
! !

!PharoObjectFormat methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:45'!
stringOf: oid count: size
	^(oid copyFrom: 1 to: size) asString
! !

!ObjectShape methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:07'!
indexOf: ivarName
	^fields at: ivarName asString
! !

!ObjectShape methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:07'!
indexOf: ivarName be: i
	fields at: ivarName put: i
! !

!ObjectShape methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:07'!
initialize
	fields := Dictionary new
! !

!ObjectShape methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:07'!
loadFrom: aClassDefinition
	name := aClassDefinition name asSymbol.
	aClassDefinition allInstVarNames
		withIndexDo: [:ivarName :i | self indexOf: ivarName be: i]
! !

!ObjectShape methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:07'!
name
	^name
! !

!ObjectShape methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:07'!
printOn: aStream
	aStream nextPutAll: 'Shape of '; nextPutAll: name
! !

!ObjectShape class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:07'!
new
	^self basicNew initialize
! !

!Runtime methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:48'!
arrayedSlotOf: object at: index
	^ objectFormat arrayedSlotOf: object at: index
! !

!Runtime methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:48'!
arrayedSlotOf: object at: index put: value
	^ storage arrayedSlotOf: object at: index put: value
! !

!Runtime methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:48'!
bytesOf: oid
	^objectFormat bytesOf: oid
! !

!Runtime methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:48'!
slotOf: object at: index
	^objectFormat slotOf: object at: index
! !

!Runtime methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:48'!
slotOf: object at: index put: value
	^ storage slotOf: object at: index put: value
! !

!Runtime methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:48'!
stringOf: oid
	^objectFormat stringOf: oid
! !

!Runtime methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:48'!
symbolOf: oid
	^objectFormat symbolOf: oid
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
bridge
	^bridge
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
bridge: aBridge
	bridge := aBridge.
	bridge runtime: self
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
false
	^ bridge false
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
loadBridge
	bridge findRootObjects
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
nil
	^bridge nil
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
objectFormat
	^objectFormat
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
objectFormat: anObjectFormat
	objectFormat := anObjectFormat.
	anObjectFormat runtime: self
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
objectNamed: name
	^ bridge objectNamed: name
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
storage
	^storage
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
storage: anObject
	storage := anObject
! !

!Runtime methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
true
	^ bridge true
! !

!Runtime methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:48'!
handleOn: oid
	^ ObjectHandle on: oid within: self
! !

!Runtime methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:48'!
lookup
	^ lookup
! !

!Runtime methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:48'!
lookup: aSymbol on: aSubject
	^lookup lookup: aSymbol on: aSubject
! !

!Runtime methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:48'!
lookupSuper: aSymbol on: aSubject from: classname
	^ lookup lookupSuper: aSymbol on: aSubject from: classname
! !

!Runtime methodsFor: 'shapes' stamp: 'KenD 11/22/2023 07:48:48'!
indexOf: varname inStructureOf: type
	^shapeMap indexOf: varname at: type
! !

!Runtime methodsFor: 'shapes' stamp: 'KenD 11/22/2023 07:48:48'!
structureOf: type
	^shapeMap at: type
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
initialize
	shapeMap := ShapeMap new.
	self useMirrorLookup
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
isLocal
	^objectModel == Smalltalk.

! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
loadShapesFrom: anRGEnvironment
	objectModel := anRGEnvironment.
	anRGEnvironment allClasses do: [ :class | shapeMap load: class ]
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
loadShapesFromImage
	| classes |
	objectModel := Smalltalk.
	classes := #(ClassDescription Class Metaclass) collect: [ :name | Smalltalk at: name ].
	classes do: [ :class | shapeMap load: class ]
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
objectModel
	^objectModel
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
objectModel: aModuleSpec
	^objectModel := aModuleSpec
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
useEmulationLookup: anRGEnvironment
	lookup := EmulationLookup new spec: anRGEnvironment
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
useMirrorLookup
	lookup := MirrorLookup new
! !

!Runtime methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:48'!
usePharoLookup
	lookup := PharoLookup new
! !

!Runtime methodsFor: 'object format' stamp: 'KenD 11/22/2023 07:48:48'!
integerHandle: anInteger
	| oid |
	oid := objectFormat newInteger: anInteger.
	^ self handleOn: oid
! !

!Runtime methodsFor: 'object format' stamp: 'KenD 11/22/2023 07:48:48'!
integerOf: oid
	^objectFormat integerOf: oid
! !

!Runtime methodsFor: 'object format' stamp: 'KenD 11/22/2023 07:48:48'!
new: oid
	| instance |
	instance := storage new: oid.
	^ self handleOn: instance
! !

!Runtime methodsFor: 'object format' stamp: 'KenD 11/22/2023 07:48:48'!
new: oid sized: anInteger
	| instance |
	instance := storage new: oid sized: anInteger.
	^ self handleOn: instance
! !

!Runtime methodsFor: 'object format' stamp: 'KenD 11/22/2023 07:48:48'!
newClosure: anObjectHandle
	| oid |
	oid := storage newClosure: anObjectHandle.
	"should put a thing that lives in remote runtime, not a PCompiledBlock"
	oid block: anObjectHandle.
	^ self handleOn: oid
! !

!Runtime methodsFor: 'object format' stamp: 'KenD 11/22/2023 07:48:48'!
newClosureHandle: aPCompiledBlock
	| oid |
	oid := storage newClosure: aPCompiledBlock.
	"should put a thing that lives in remote runtime, not a PCompiledBlock"
	oid block: aPCompiledBlock.
	^ self handleOn: oid
! !

!Runtime class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:48'!
forBootstrappingPst: aSmalltalkBootstrapper spec: anRGEnvironment
	^ self new
		bridge: (BootstrappedPstBridge new bootstrapper: aSmalltalkBootstrapper);
		objectFormat: (BootstrapObjectFormat on: aSmalltalkBootstrapper);
		storage: (BootstrapStorage on: aSmalltalkBootstrapper);
		useEmulationLookup: anRGEnvironment
! !

!Runtime class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:48'!
forEmulatingPst: aSmalltalkBootstrapper
	^ self new
		bridge: (BootstrappedPstBridge new bootstrapper: aSmalltalkBootstrapper);
		objectFormat: (BootstrapObjectFormat on: aSmalltalkBootstrapper);
		storage: (BootstrapStorage on: aSmalltalkBootstrapper);
		loadBridge
! !

!Runtime class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:48'!
forLocalPharo
	^ self new
		bridge: PharoBridge new;
		objectFormat: PharoObjectFormat new;
		usePharoLookup;
		loadBridge;
		loadShapesFromImage
! !

!Runtime class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:48'!
forSimulating: aModuleSpec memory: aByteArray
	| adapter |
	adapter := ByteArrayAdapter on: aByteArray.
	^ self new
		bridge: PstBridge new;
		objectFormat: (DmrObjectFormat on: adapter);
		storage: adapter;
		loadShapesFrom: aModuleSpec;
		loadBridge
! !

!Runtime class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:48'!
new
	^self basicNew initialize
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
argumentAt: index in: anInteger
	| env |
	anInteger ifNil: [ ^arguments at: index ].
	env := self environmentFor: anInteger.
	^env at: index.
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
arguments: aCollection
	arguments := aCollection
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
captureClosure: anSBlock
	| closure s i type env arg |
	closure := anSBlock compiledCode newClosure home: self.
	s := anSBlock capturedVariables readStream.
	i := 1.
	[ s atEnd ]
		whileFalse: [ type := s next.
			type = Self
				ifTrue: [ closure at: i put: receiver ].
			type = Environment
				ifTrue: [ closure at: i put: environment].
			type = EnvironmentValue
				ifTrue: [ env := environment at: s next.
					closure at: i put: env ].
			type = LocalArgument
				ifTrue: [ arg := arguments at: s next.
					closure at: i put: arg ].
			i := i + 1 ].
	^ closure
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
dispatch: message to: msgReceiver
	^ self subclassResponsibility
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
dispatchSpecial: message
		^self subclassResponsibility 
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
environmentFor: anInteger
	"
	-1: inlined argument.
	 0: current env.
 	>0: index of env in current env. "

	anInteger = 0
		ifTrue: [ ^ environment ].
	anInteger = -1
		ifTrue: [ ^ temporaries ].
	^ environment at: anInteger
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
evaluate: anSCompiledMethod
	method := anSCompiledMethod.
	^ self visitMethod: anSCompiledMethod sexpressions
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
evaluateClosure: aPClosure
	^self evaluateClosure: aPClosure withArgs: {}
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
evaluateClosure: aPClosure with: anObject
	 ^self evaluateClosure: aPClosure withArgs: { anObject }
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
evaluateClosure: aPClosure with: anObject with: anotherObject
	^ self evaluateClosure: aPClosure withArgs: {anObject. anotherObject}
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
initialize
	returned := false.
	blockAstcodes := IdentityDictionary new
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
instVarAt: anInteger
	^receiver _gate slotAt: anInteger
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
instVarAt: index put: aValue
	^ receiver _gate handle slotAt: index put: aValue _gate handle oid
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
isSpecial: aSelectorMirror
	^ self subclassResponsibility 
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
method
	^method
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
mirageOnBoolean: aBoolean
	| runtime handle |
	runtime := receiver _gate handle runtime.
	handle := aBoolean ifTrue: [runtime true] ifFalse: [runtime false].
	^ handle mirage
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
mirageOnInteger: anInteger
	| runtime handle |
	runtime := receiver _gate handle runtime.
	handle := runtime integerHandle: anInteger.
	^ handle mirage
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
mirageOnObject: anObject
	anObject isSmallInteger ifTrue: [ ^ self mirageOnInteger: anObject ].
	self ASSERT: false
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
parent
	^parent
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
parent: anInterpreter
	parent := anInterpreter
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
receiver
	^receiver
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
receiver: anObject
	receiver := anObject.
	returnValue := anObject
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
subjectOn: anObjectHandle
	^ anObjectHandle maneuverer
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
subjectOnBoolean: aBoolean in: aRuntime
	| t f |
	^ aBoolean
		ifTrue: [ t := aRuntime true. t oid = true ifTrue: [ t mirage] ifFalse: [ t maneuverer  ] ]
		ifFalse: [ f := aRuntime false. f oid = false ifTrue: [ f mirage ] ifFalse: [ f maneuverer]] 
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
subjectOnInteger: anInteger in: aRuntime
	^ (aRuntime integerHandle: anInteger) maneuverer
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
subjectOnObject: anObjectHandle
	^ anObjectHandle maneuverer
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
subjectOnObjectOk: anObjectHandle
	^ self maneuvererOn: anObjectHandle
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
temporaryAt: index in: anInteger
	| env |
	anInteger ifNil: [ ^ temporaries at: index ].
	env := self environmentFor: anInteger.
	^ env at: index
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
temporaryAt: index in: anInteger put: aValue
	| env |
	anInteger ifNil: [ ^ temporaries	at:index put: aValue ].
	env := self environmentFor: anInteger.
	^ env at: index put: aValue
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitArgument: anSIdentifier
	^arguments at: anSIdentifier binding index
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitAssignment: anSAssignment
	| result |
	result := anSAssignment expression acceptVisitor: self.
	anSAssignment assignees
		do: [ :identifier | identifier binding assign: result within: self ].
	^result
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitBlock: anSBlock
	| closure handle |
	closure := anSBlock isInlined
				   ifTrue: [ SCompiledBlock new newClosure home: self ]
				   ifFalse: [ self captureClosure: anSBlock ].
	blockAstcodes at: closure block put: anSBlock.
	self halt.
	"	handle := LocalHandle on: closure within: localRuntime."
	^ handle mirage
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitIdentifier: anSIdentifier
	^anSIdentifier binding valueWithin: self.

! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitMessage: anSMessage
	| msgReceiver msgArguments selector message |
	msgReceiver := anSMessage receiver acceptVisitor: self.
	msgArguments := anSMessage arguments
		collect: [ :code | code acceptVisitor: self ].
	selector := anSMessage selector.
	message := MessageSend
		receiver: msgReceiver
		selector: selector
		arguments: msgArguments.
	 (self isSpecial: selector)
		ifTrue: [ ^self dispatchSpecial: message ].
	anSMessage receiver isSuper ifTrue: [^self dispatchSuper: message to: msgReceiver].
	^self dispatch: message to: msgReceiver
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitMethod: anSMethod
	| primitive value |
	primitive := anSMethod primitive.
	primitive ifNotNil: [ ^ self visitPrimitive: primitive ].
	environment := Array new: method environmentCount.
	value := self visitScript: anSMethod.
	^returned ifTrue: [ value ] ifFalse: [ receiver ]
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitReturn: anSReturn
	returnValue := anSReturn expression acceptVisitor: self.
	returned := true.
	^returnValue
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitScript: anSScript
	| result |
	anSScript statements do: [:node | 
		result := node acceptVisitor: self.
		returned ifTrue: [^returnValue]
	].
	^result
! !

!SExpressionInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:19'!
visitTemporary: anSIdentifier
	^temporaries at: anSIdentifier binding index
! !

!SExpressionInterpreter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:19'!
evaluateClosure: aPClosure withArgs: anArray
	| oldArgs oldTemps oldEnv block sblock result |
	block := aPClosure block.
	sblock := blockAstcodes at: block.
	sblock isInlined ifTrue: [
			 anArray with: sblock inlinedArgs do: [:arg :i | temporaries at: i put: arg].
			^ self visitScript: sblock ].
	oldArgs := arguments.
	oldTemps := temporaries.
	oldEnv := environment.
	arguments := anArray.
	temporaries := Array new: block tempCount.
	environment := aPClosure.
	result := self visitScript: sblock.
	environment := oldEnv.
	temporaries := oldTemps.
	arguments := oldArgs.
	^ result
! !

!SExpressionInterpreter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
method: aCompiledMethod
	method := aCompiledMethod.
	temporaries := Array new: aCompiledMethod tempCount.
! !

!SExpressionInterpreter methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:19'!
printOn: aStream
	aStream
		nextPutAll: self class name withArticle;
		cr;
		print: method classBinding;
		nextPutAll: '>>';
		print: method selector;
		cr.
	aStream
		nextPutAll: 'rcvr -> ';
		print: receiver _gate handle;
		cr.
	arguments
		withIndexDo: [ :a :i | 
			aStream
				nextPutAll: 'arg ';
				print: i;
				nextPutAll: ' -> ';
				print: a _gate;
				cr ].
	aStream nextPutAll: method source
! !

!SExpressionInterpreter class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:19'!
new
	^self basicNew initialize
! !

!SExpressionInterpreter class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:19'!
on: receiverMirror with: arguments for: method
	^self new
		receiver: receiverMirror;
		arguments: arguments;
		method: method
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
dispatch: message to: msgReceiver
	^ msgReceiver _gate dispatch: message from: self
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
dispatchSpecial: message
	| selector mirror gate |
	selector := message selector.
	gate := message receiver _gate.
	mirror := gate mirror.
	selector == #_isSmallInteger
		ifTrue: [ ^ self subjectOnBoolean: gate handle isInteger in: gate handle runtime].
	selector == #_isLarge
		ifTrue: [ ^ self subjectOnBoolean: mirror reflectsLargeObject in: gate handle runtime].
	selector == #_smallSize
		ifTrue: [ ^ self subjectOnInteger: mirror smallSize in: gate handle runtime ].
	selector == #_largeSize
		ifTrue: [ ^ self subjectOnInteger: mirror largeSize in: gate handle runtime ].
	selector == #_basicFlags
		ifTrue: [ ^ self subjectOnInteger: mirror basicFlags in: gate handle runtime ].
	selector == #_basicHash
		ifTrue: [ ^ self subjectOnInteger: 0 in: gate handle runtime ].
	selector == #_basicHash:
		ifTrue: [ ^ message receiver ].
	self ASSERT: false
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
dispatchSuper: message to: msgReceiver
	^ msgReceiver _gate dispatchSuper: message from: self
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
falseLiteral
	^receiver _gate handle runtime false maneuverer.

! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
gateOnBlock: aPCompiledBlock
	| runtime closure handle |
	runtime := receiver _gate handle runtime.
	closure := aPCompiledBlock newClosure home: self.
	handle := LocalHandle on: closure within: localRuntime.
	^ closure mirage
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
initialize
	super initialize.
	localRuntime := Runtime forLocalPharo.

! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
isSpecial: selector
	^underprimitives includes: selector
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
literal: anObject
	| handle |
	handle := receiver _gate handleOn: anObject.
	^ self subjectOn: handle
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
mirageOnBlock: aPCompiledBlock
	| runtime handle |
	runtime := receiver _gate handle runtime.
	handle := runtime newClosureHandle: aPCompiledBlock.
	^ handle mirage
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
nilLiteral
	^receiver _gate handle runtime nil maneuverer.

! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
primitiveClosureValue
	| closure block sblock prev result interpreter next |
	closure := receiver _gate handle.
	block := closure mirror asClosureMirror block handle oid.
	interpreter := self.
	[ next := interpreter blocks. next includesKey: block] whileFalse: [ interpreter := interpreter parent ].
	sblock := next at: block.
	prev := environment.
	environment := closure.
	result := interpreter visitScript: sblock.
	environment := prev.
	^result
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
primitivePrimeFor
	| num result  |
	num := arguments first _gate handle asLocalInteger.
	result := #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 269 359 479 641 857 1151 1549 2069 2237 2423 2617 2797 2999 3167 3359 3539 3727 3911 4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853 8783 9601 10243 10867 11549 12239 12919 13679 14293 15013 15731 17569 19051 20443 21767 23159 24611 25847 27397 28571 30047 31397 35771 38201 40841 43973 46633 48989 51631 54371 57349 60139 62969)
		detect: [ :i | i >= num ].
	^ self subjectOnInteger: result in: receiver _gate handle runtime
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
trueLiteral
	^receiver _gate handle runtime true maneuverer.

! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
visitLiteral: anSLiteral
	| handle |
	anSLiteral value isInteger ifTrue: [ 
		^self subjectOnInteger: anSLiteral value in: receiver _gate handle runtime ].
	handle := localRuntime handleOn: anSLiteral value.
	^ handle mirage
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
visitPrimitive: primitive
	| gate new left right args rcvr runtime value class |
	returned := true.
	gate := receiver _gate.
	runtime := gate handle runtime.
	primitive = #Behavior
		ifTrue: [ class := runtime bridge objectNamed: gate handle oid spec name.
			^ returnValue := self
				subjectOn: (gate handleOn: class instanceBehavior) ].
	primitive = #UnderSize
		ifTrue:
			[ ^ returnValue := self subjectOnInteger: gate handle size in: runtime ].
	primitive = #Size
		ifTrue: [ ^ returnValue := self
				subjectOnInteger: gate handle arrayedSize
				in: runtime ].
	primitive = #At
		ifTrue:
			[ value := gate handle at: arguments first _gate handle asLocalInteger.
			^ returnValue := self subjectOn: value ].
	primitive = #AtPut
		ifTrue: [ value := arguments second.
			gate handle
				at: arguments first _gate handle asLocalInteger
				put: value _gate handle oid.
			^ returnValue := value ].
	primitive = #New
		ifTrue: [ new := gate handle runtime new: gate handle oid.
			^ returnValue := self subjectOn: new ].
	primitive = #NewSized
		ifTrue: [ new := gate handle runtime
				new: gate handle oid
				sized: arguments first _gate handle asLocalInteger.
			^ returnValue := self subjectOn: new ].
	primitive = #Equal
		ifTrue: [ left := receiver _gate handle oid.
			right := arguments first _gate handle oid.
			^ returnValue := self
				subjectOnBoolean: left == right
				in: localRuntime ].
	primitive = #SMIPlus
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self subjectOnInteger: left + right in: runtime ].
	primitive = #SMIMinus
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self subjectOnInteger: left - right in: runtime ].
	primitive = #SMITimes
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self subjectOnInteger: left * right in: runtime ].
	primitive = #SMIIntDiv
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self subjectOnInteger: left // right in: runtime ].
	primitive = #SMIIntQuot
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self subjectOnInteger: left \\ right in: runtime ].
	primitive = #SMIGreaterThan
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self
				subjectOnBoolean: left > right
				in: localRuntime ].
	primitive = #SmallIntegerBitAnd
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self
				subjectOnInteger: (left bitAnd: right)
				in: runtime ].
	primitive = #SMIGreaterEqualThan
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self
				subjectOnBoolean: left >= right
				in: localRuntime ].
	primitive = #SMIEqual
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self
				subjectOnBoolean: left = right
				in: localRuntime ].
	primitive = #SMINotEqual
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self
				subjectOnBoolean: left !!= right
				in: localRuntime ].
	primitive = #ClosureValue
		ifTrue: [ ^ self primitiveClosureValue ].
	primitive = #ReplaceFromTo
		ifTrue: [ rcvr := receiver _gate handle target.
			args := arguments collect: [ :arg | arg _gate asLocalCollection ].
			rcvr
				perform: #replaceFrom:to:with:startingAt:
				withArguments: args asArray.
			^ returnValue := receiver ].
	primitive = #PrimeFor
		ifTrue: [ ^ self primitivePrimeFor ].
	self ASSERT: false
! !

!SmalltalkInterpreter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
visitPrimitiveOld: primitive
	| gate new left right args rcvr |
	returned := true.
	gate := receiver _gate.
	primitive = #Size
		ifTrue: [ ^ returnValue := self mirageOnInteger: gate mirror size ].
	primitive = #New
		ifTrue: [ new := gate handle runtime new: gate handle oid.
			^ returnValue := self mirageOnObject: new ].
	primitive = #NewSized
		ifTrue: [ new := gate handle target new: arguments first _gate handle target.
			^ returnValue := self mirageOnObject: new ].
	primitive = #SmallIntegerMinus
		ifTrue: [ left := receiver _gate handle target.
			right := arguments first _gate handle target.
			^ returnValue := self mirageOnInteger: left - right ].
	primitive = #SmallIntegerPlus
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self mirageOnInteger: left + right ].
	primitive = #SmallIntegerBitAnd
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self mirageOnInteger: (left bitAnd: right) ].
	primitive = #SmallIntegerLessOrEqual
		ifTrue: [ left := receiver _gate handle target.
			right := arguments first _gate handle target.
			^ returnValue := self mirageOnBoolean: left <= right ].
	primitive = #SmallIntegerEqual
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self mirageOnBoolean: left = right ].
	primitive = #SmallIntegerNotEqual
		ifTrue: [ left := receiver _gate handle asLocalInteger.
			right := arguments first _gate handle asLocalInteger.
			^ returnValue := self mirageOnBoolean: left !!= right ].
	primitive = #ClosureValue
		ifTrue: [ ^ self primitiveClosureValue ].
	primitive = #ReplaceFromTo
		ifTrue: [ rcvr := receiver _gate handle target.
			args := arguments collect: [ :arg | arg _gate asLocalCollection ].
			rcvr
				perform: #replaceFrom:to:with:startingAt:
				withArguments: args asArray.
			^ returnValue := receiver ].
	self ASSERT: false
! !

!SmalltalkInterpreter class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:48:20'!
initialize
	"
	self initialize
	"

	underprimitives := #(_basicAt: #_basicAt:put: _byteAt: #_byteAt:put: _smallSize _largeSize _isSmallInteger _basicHash _basicHash:)
! !

!ShapeMap methodsFor: 'adding' stamp: 'KenD 11/22/2023 07:49:04'!
add: structure
	shapes at: structure name put: structure
! !

!ShapeMap methodsFor: 'adding' stamp: 'KenD 11/22/2023 07:49:04'!
at: type
	^shapes at: type
! !

!ShapeMap methodsFor: 'adding' stamp: 'KenD 11/22/2023 07:49:04'!
indexInCurrentOf: varname at: type
	| species slot |
	species := Smalltalk at: type asSymbol.
	slot := species slotNamed: varname.
	slot isNil
		ifTrue: [ self error: 'inst var ' , varname , ' not found' ].
	^ slot index
! !

!ShapeMap methodsFor: 'adding' stamp: 'KenD 11/22/2023 07:49:04'!
indexOf: varname at: type
	| shape |
	shape := shapes at: type ifAbsent: [
		^self indexInCurrentOf: varname at: type].
	^shape indexOf: varname
! !

!ShapeMap methodsFor: 'adding' stamp: 'KenD 11/22/2023 07:49:04'!
initialize
	shapes := Dictionary new
! !

!ShapeMap methodsFor: 'adding' stamp: 'KenD 11/22/2023 07:49:04'!
load: aClassDefinition
	| shape |
	shape := ObjectShape new loadFrom: aClassDefinition.
	self add: shape
! !

!ShapeMap class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:04'!
new
	^self basicNew initialize
! !

!Storage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:17'!
arrayedSlotOf: base at: index put: value
	^ self subclassResponsibility
! !

!Storage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:17'!
new: oid
	^self subclassResponsibility
! !

!Storage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:17'!
slotOf: base at: index
	^ self subclassResponsibility
! !

!Storage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:48:17'!
slotOf: base at: index put: value
	^self subclassResponsibility
! !

!BootstrapStorage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:49:02'!
arrayedSlotOf: oid at: index put: anotherOid
	"fixme: this message should be sent to ObjectFormat"
	^ oid at: index put: anotherOid
! !

!BootstrapStorage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:49:02'!
bootstrapper: aSmalltalkBootstrapper
	bootstrapper := aSmalltalkBootstrapper
! !

!BootstrapStorage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:49:02'!
new: oid
	| meta base behavior |
	meta := oid spec.
	self ASSERT: meta isMeta.
	base := meta baseClass.
	behavior := bootstrapper instanceBehaviorOfSpec: base.
	^ (ObjectMap new: base) behavior: behavior; atAllPut: bootstrapper nilObject
! !

!BootstrapStorage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:49:02'!
new: oid sized: anInteger
	| meta base behavior |
	meta := oid spec.
	self ASSERT: meta isMeta.
	base := meta baseClass.
	behavior := bootstrapper instanceBehaviorOfSpec: base.
	^ (ObjectMap new: base size: anInteger)
		behavior: behavior;
		atAllPut: bootstrapper nilObject
! !

!BootstrapStorage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:49:02'!
newClosure: anObjectHandle
	| size |
	size := anObjectHandle target size.
	^ bootstrapper new: #Closure sized: size
! !

!BootstrapStorage methodsFor: 'storage' stamp: 'KenD 11/22/2023 07:49:02'!
slotOf: anObjectMap at: index put: value
	index <= anObjectMap size
		ifTrue: [ anObjectMap slotAt: index put: value ]
		ifFalse: [ anObjectMap at: index put: value ].
	^ value
! !

!BootstrapStorage class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:02'!
on: aSmalltalkBootstrapper
	^ self new bootstrapper: aSmalltalkBootstrapper
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
bytes: aByteArray
	bytes := aByteArray
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
bytesAt: base sized: size
	^ bytes copyFrom: base + 1 to: base + size
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
slotOf: base at: index
	^ self uint64atOffset: base + (8 * (index - 1))
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
slotOf: base at: index put: value
	^ self uint64atOffset: base + ((index - 1) * 8) put: value
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
stringAt: base sized: size
	^ (self bytesAt: base sized: size) asString
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint16atOffset: anInteger
	^ bytes unsignedShortAt: anInteger + 1
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint16atOffset: anInteger put: value
	^ bytes unsignedShortAt: anInteger + 1 put: value
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint16of: base atOffset: offset
	^ self uint16atOffset: base + offset
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint32atOffset: anInteger
	^ bytes unsignedLongAt: anInteger + 1
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint32atOffset: anInteger put: value
	^ bytes unsignedLongAt: anInteger + 1 put: value
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint32of: base atOffset: offset
	^ self uint32atOffset: base + offset
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint64atOffset: anInteger
	^ bytes unsignedLongLongAt: anInteger + 1
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint64atOffset: anInteger put: value
	^ bytes unsignedLongLongAt: anInteger + 1 put: value
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint8atOffset: anInteger
	^ bytes unsignedByteAt: anInteger + 1
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint8atOffset: anInteger put: value
	^ bytes unsignedByteAt: anInteger + 1 put: value
! !

!ByteArrayAdapter methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:18'!
uint8of: base atOffset: offset
	^ self uint8atOffset: base + offset
! !

!ByteArrayAdapter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:18'!
wordSize
	^8
! !

!ByteArrayAdapter class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:18'!
on: aByteArray
	^self new bytes: aByteArray
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
asLocalInteger
	^handle asLocalInteger
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
associationMirrorOn: methodDictionaryHandle
	^AssociationMirror on: methodDictionaryHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
behaviorMirrorOn: behaviorHandle
	^BehaviorMirror on: behaviorHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
classMirrorOn: classHandle
	^ClassMirror on: classHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
closureMirrorOn: closureHandle
	^ ClosureMirror on: closureHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
compiledBlockMirrorOn: aCompiledBlockHandle
	^ CompiledBlockMirror on: aCompiledBlockHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
compiledMethodMirrorOn: methodDictionaryHandle
	^CompiledMethodMirror on: methodDictionaryHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
dictionaryMirrorOn: classHandle
	^DictionaryMirror on: classHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
handle
	^handle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
handle: anObjectHandle
	handle := anObjectHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
metaclassMirrorOn: classHandle
	^MetaclassMirror on: classHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
methodDictionaryMirrorOn: methodDictionaryHandle
	^MethodDictionaryMirror on: methodDictionaryHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
objectMirrorOn: objectHandle
	^ObjectMirror on: objectHandle
! !

!Mirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:49:12'!
speciesMirrorOn: classHandle
	^SpeciesMirror on: classHandle
! !

!Mirror class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:49:12'!
on: handle
	^self new handle: handle
! !

!ObjectMirror methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:48:14'!
= anObject
	^self class = anObject class and: [handle = anObject handle]
! !

!ObjectMirror methodsFor: 'comparing' stamp: 'KenD 11/22/2023 07:48:14'!
hash
	^ handle hash
! !

!ObjectMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:14'!
equals: anotherObject
	^ (anotherObject isKindOf: self class)
		and: [ handle = anotherObject handle ]
! !

!ObjectMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:14'!
lookup: aSelector
	^self reflectedBehavior compiledMethodFor: aSelector
! !

!ObjectMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:14'!
reflectsBytesObject
	^handle isBytes
! !

!ObjectMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:14'!
reflectsInteger
	^handle isInteger
! !

!ObjectMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:14'!
reflectsLargeObject
	^handle isLarge
! !

!ObjectMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:14'!
reflectsNil
	^handle = handle nilObject
! !

!ObjectMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:14'!
_gate
	^self
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asAssociationMirror
	^self associationMirrorOn: handle
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asBehaviorMirror
	^self behaviorMirrorOn: handle
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asBlockMirror
	^ self compiledBlockMirrorOn: handle
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asByteArray
	^self bytes
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asClassMirror
	^self classMirrorOn: handle
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asClosureMirror
	^ self closureMirrorOn: handle
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asDictionaryMirror
	^self dictionaryMirrorOn: handle
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asLocalArray
	| size |
	size := self size.
	^(1 to: size) collect: [:i | self slotAt: i]
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asLocalInteger
	^handle asLocalInteger
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asLocalString
	^handle asLocalString
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asMethodMirror
	^self compiledMethodMirrorOn: handle
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asSpeciesMirror
	^(self speciesMirrorOn: handle) reflectsMetaclass
		ifTrue: [self metaclassMirrorOn: handle]
		ifFalse: [self classMirrorOn: handle]
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asStringMirror
	^self
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
asSubject
	^handle mirage
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
bytes
	^handle asLocalBytes
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
dispatch: aMessage from: parentInterpreter
	| method interpreter |
	method := self lookup: aMessage selector.
	method ifNil: [ self ASSERT: false ].
	interpreter := parentInterpreter class
		on: self
		with: aMessage arguments
		for: method.
	^ interpreter
		parent: parentInterpreter;
		evaluate: method
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
do: aBlock
	1 to: self size do: [:index | | slot |
		slot := self slotAt: index.
		aBlock value: slot]
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
invoke: method with: arguments
	| interpreter |
	interpreter := SmalltalkInterpreter on: self with: arguments for: method.
	^ interpreter evaluate: method
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
localClassname
	^self reflectedClass localName
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
reflectedBehavior
	| behavior |
	behavior := handle getBehavior.
	^self behaviorMirrorOn: behavior
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
reflectedClass
	^handle getClass
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
slotAt: index
	| slot |
	slot := handle slotAt: index.
	^self objectMirrorOn: slot
! !

!ObjectMirror methodsFor: 'meta accessing' stamp: 'KenD 11/22/2023 07:48:14'!
slotAt: index put: value
	handle slotAt: index put: value _gate handle oid.
	^ value
! !

!ObjectMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:14'!
at: index
	| slot |
	slot := self reflectedClass instSize + index.
	^self slotAt: slot
! !

!ObjectMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:14'!
getInstVarAt: index
	^self slotAt: index
! !

!ObjectMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:14'!
getInstVarNamed: name
	| index |
	index := handle indexOf: name for: self.
	index = 0 ifTrue: [self error: 'instance variable not found'].
	^self slotAt: index
! !

!ObjectMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:14'!
setInstVarAt: index with: value
	^ self slotAt: index put: value
! !

!ObjectMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:14'!
slotOf: species named: name
	| index |
	index := handle indexOf: name inStructureOf: species name asSymbol.
	^self slotAt: index
! !

!ObjectMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:14'!
structure
	^handle structureOf: self structureType
! !

!ObjectMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:14'!
structureType
	^self subclassResponsibility
! !

!ObjectMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
basicFlags
	^handle basicFlags
! !

!ObjectMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
largeSize
	^handle largeSize
! !

!ObjectMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
localDeepCopy
	self reflectsInteger
		ifTrue: [ ^ self asLocalInteger ].
	^ (1 to: self size)
		collect: [ :i | | slot |
			slot := self slotAt: i.
			slot localDeepCopy ]
! !

!ObjectMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
reflectsMethodDictionary
	^false
! !

!ObjectMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
size
	^handle size - self reflectedClass instSize
! !

!ObjectMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
slotSize
	^ handle size
! !

!ObjectMirror methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:14'!
contains: anAddress
	^anAddress >= handle oid and: [anAddress < (handle oid + self size)]
! !

!ObjectMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:14'!
localDescription
	| class name |
	self reflectsInteger
		ifTrue: [ ^ 'int ' , self asLocalInteger printString ].
	^ [ class := self reflectedClass.
	name := class localName.
	(name = 'String' or: [ name = 'Symbol' ])
		ifTrue: [ ^ name , ' <' , self asLocalString , '>' ].
	name withArticle]
		on: StorageReadError
		do: [ self printString , '(could not be read)' ]
! !

!ObjectMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:14'!
printOn: aStream
	| description |
	self reflectsInteger
		ifTrue: [ ^ aStream
				nextPutAll: 'SMI (';
				print: self asLocalInteger;
				nextPut: $) ].
	description := [ self reflectedClass localName withArticle ]
		on: Error
		do: [ 'broken class' ].
	aStream
		nextPutAll:
			self class name withArticle , '(' , handle printString , ', '
				, description , ')'
! !

!ObjectMirror methodsFor: 'converting' stamp: 'KenD 11/22/2023 07:48:14'!
mirage
	^handle mirage
! !

!AssociationMirror methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:02'!
key
	^self getInstVarNamed: #key
! !

!AssociationMirror methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:02'!
value
	^self getInstVarNamed: #value
! !

!AssociationMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:02'!
structureType
	^#Association
! !

!BehaviorMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:50'!
at: i
	self ASSERT: false
! !

!BehaviorMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:50'!
classBinding
	| class |
	class := self getInstVarNamed: #class.
	^class asSpeciesMirror
! !

!BehaviorMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:50'!
instanceClass
	| behavior class |
	behavior := self.
	10
		timesRepeat: [ class := behavior classBinding.
			class reflectsNil
				ifFalse: [ ^ class ].
			behavior := self next.
			behavior reflectsNil 
				ifTrue: [ self error: 'behavior does not have a class' ] ].
	self error: 'could not find the class corresponding to this behavior'
! !

!BehaviorMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:50'!
methodDictionary
	| slot |
	slot := handle slotAt: 1.
	^self methodDictionaryMirrorOn: slot
! !

!BehaviorMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:50'!
next
	| slot |
	slot := handle slotAt: 2.
	^self behaviorMirrorOn: slot
! !

!BehaviorMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:50'!
compiledMethodFor: aSymbol
	| method next |
	method := self methodDictionary compiledMethodFor: aSymbol.
	method ifNotNil: [^method].
	next := self next.
	^next reflectsNil ifFalse: [next compiledMethodFor: aSymbol]
! !

!BehaviorMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:50'!
structureType
	^#Behavior
! !

!ClosureMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
block
	| block |
	block := self getInstVarNamed: #block.
	^ block asBlockMirror
! !

!ClosureMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
structureType
	^ #Closure
! !

!CompiledBlockMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:05'!
structureType
	^ #CompiledBlock
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
argumentCount
	^self flags asLocalInteger bitAnd: ArgCount
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
astcodes
	^self getInstVarNamed: #astcodes.
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
classBinding
	| class |
	class := self getInstVarNamed: #class.
	^class asSpeciesMirror
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
compiler
	^self ASSERT: false
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
decodedAstcodes
	| astcodes |
	astcodes := self astcodes localDeepCopy.
	^ AstcodeDecoder new
		stream: astcodes readStream;
		method: self;
		decodeMethod
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
flags
	^self getInstVarNamed: #flags
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
isExpression
	^false
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
nativeCodeBytes
	^self optimizedCode slotAt: 1
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
optimizedCode
	^self getInstVarNamed: #optimizedCode
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
readSourceFrom: encodedPosition
	self ASSERT: false
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
selector
	| selector |
	selector := self getInstVarNamed: #selector.
	^selector asStringMirror
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
source
	^self sourceCode
! !

!CompiledMethodMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:09'!
sourceCode
	| source |
	source := self getInstVarNamed: #source.
	source reflectsNil ifTrue: [^nil].
	source reflectsInteger ifFalse: [^source asString].
	^self readSourceFrom: source
! !

!CompiledMethodMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:09'!
at: index
	^ self slotAt: self fixedInstSize + index
! !

!CompiledMethodMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:09'!
size
	^ handle size - self fixedInstSize
! !

!CompiledMethodMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:09'!
currentVersion
	^self classBinding compiledMethodFor: self selector asLocalString asSymbol
! !

!CompiledMethodMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:09'!
isValid
	[^self reflectedClass localEquivalent inheritsFrom: CompiledMethod]
		on: Error
		do: [^false]
! !

!CompiledMethodMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:09'!
timestamp
	^nil
! !

!CompiledMethodMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:09'!
fixedInstSize
	^ self reflectedClass instSize
! !

!CompiledMethodMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:09'!
structureType
	^#CompiledMethod
! !

!CompiledMethodMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
fullName
	^self classBinding localName , '>>#' , self selector asLocalString
! !

!CompiledMethodMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
printOn: aStream
	| signature |
	signature := ([ self fullName ]
						on: StorageReadError
						do: [ handle printString ]).
	aStream
		nextPutAll:
			'a CMMirror ('
			; nextPutAll: signature; nextPut: $)
! !

!DictionaryMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
at: i
	^self contents at: i
! !

!DictionaryMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
contents
	^self getInstVarNamed: #table
! !

!DictionaryMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:54'!
contentsSize
	^self contents size
! !

!DictionaryMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:54'!
at: key using: transform
	self do: [:k :value | (transform value: k) = key ifTrue: [^value]].
	^nil
! !

!DictionaryMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:54'!
structureType
	^#Dictionary
! !

!DictionaryMirror methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:48:54'!
do: aBlock
	1 to: self contentsSize do: [:i | | current |
		current := self at: i.
		current reflectsNil ifFalse: [| mirror |
			mirror := current asAssociationMirror.
			aBlock value: mirror key value: mirror value]]
! !

!MethodDictionaryMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
at: i
	^self contents at: i
! !

!MethodDictionaryMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:49:11'!
compiledMethodFor: aSymbol
	| selector |
	selector := aSymbol asString.
	self do: [:sym :method | sym asLocalString = selector ifTrue: [^method]].
	^nil
! !

!MethodDictionaryMirror methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:11'!
contents
	^self getInstVarNamed: #table
! !

!MethodDictionaryMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
contentsSize
	^self contents size
! !

!MethodDictionaryMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
do: aBlock
	1 to: self contentsSize by: 2 do: [:i | | current |
		current := self at: i.
		current reflectsNil ifFalse: [| method |
			method := self at: i + 1.
			aBlock value: current value: method asMethodMirror]]
! !

!MethodDictionaryMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
reflectsMethodDictionary
	^true
! !

!MethodDictionaryMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
structureType
	^#MethodDictionary
! !

!MethodDictionaryMirror methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
tally
	^self getInstVarNamed: #tally
! !

!MethodDictionaryMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:11'!
printOn: aStream
	aStream nextPutAll: 'a MDMirror (' ; nextPutAll: handle printString ; nextPut: $)
! !

!SpeciesMirror methodsFor: 'behavior protocol' stamp: 'KenD 11/22/2023 07:48:58'!
allInstVarNames
	^(self withAllSuperclasses reversed gather: [:class | class instVarNames]) asArray
	

! !

!SpeciesMirror methodsFor: 'behavior protocol' stamp: 'KenD 11/22/2023 07:48:58'!
indexOfSlot: name
	| instVars |
	instVars := self allInstVarNames.
	^instVars indexOf: name ifAbsent: 0
! !

!SpeciesMirror methodsFor: 'behavior protocol' stamp: 'KenD 11/22/2023 07:48:58'!
instSize
	"optimize: 
	self isPointers
		ifTrue: [	(self getInstVarNamed: #format) asLocalInteger & InstSize ]
		ifFalse: [ 0 ]"

	| vars s parents |
	vars := self getInstVarNamed: #instanceVariables.
	s := self superclass.
	parents := s reflectsNil
		ifTrue: [ 0 ]
		ifFalse: [ s instSize ].
	^ parents + vars slotSize
! !

!SpeciesMirror methodsFor: 'behavior protocol' stamp: 'KenD 11/22/2023 07:48:58'!
instVarNames
	| instVars |
	instVars := self getInstVarNamed: #instanceVariables.
	instVars reflectsNil ifTrue: [^#()].
	^instVars reflectsBytesObject
		ifTrue: [instVars asLocalString substrings]
		ifFalse: [instVars asLocalArray collect: #asLocalString]
! !

!SpeciesMirror methodsFor: 'behavior protocol' stamp: 'KenD 11/22/2023 07:48:58'!
isPointers
	^ (self getInstVarNamed: #format) asLocalInteger anyMask: self pointersFlag
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
allSuperclasses
	| superclasses |
	superclasses := OrderedCollection new.
	self allSuperclassesDo: [:s | superclasses add: s].
	^superclasses
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
allSuperclassesDo: aBlock
	| superclass |
	superclass := self superclass.
	superclass reflectsNil ifTrue: [^self].
	aBlock value: superclass.
	superclass allSuperclassesDo: aBlock	

! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
instBehavior
	| name |
	name := self getInstVarNamed: #instanceBehavior.
	^name asBehaviorMirror
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
localName
	^self subclassResponsibility 
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
printOn: aStream
	| name | 
	super printOn: aStream.
	name := [self localName] on: Error do: ['Broken'].
	aStream nextPutAll: '[' , name , ']'
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
project
	^nil
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
structureType
	^#Species
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
superclass
	| name |
	name := self getInstVarNamed: #superclass.
	^name asSpeciesMirror
! !

!SpeciesMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:58'!
withAllSuperclasses
	^ OrderedCollection new
		add: self;
		addAll: self allSuperclasses; yourself
! !

!SpeciesMirror methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 07:48:58'!
compiledMethodFor: selector
	^self instBehavior compiledMethodFor: selector
! !

!SpeciesMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:58'!
reflectsMetaclass
	| metasize |
	metasize := 6.
	^handle size = metasize
! !

!ClassMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:02'!
classVariables
	| classVariables |
	classVariables := self getInstVarNamed: #classVariables.
	classVariables reflectsNil ifTrue: [^Dictionary new].
	^classVariables
! !

!ClassMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:02'!
instanceClass
	^self
! !

!ClassMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:02'!
localName
	^self name asLocalString
! !

!ClassMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:02'!
name
	| name |
	name := self getInstVarNamed: #name.
	^name asStringMirror
! !

!ClassMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:02'!
subclasses
	| subclasses |
	subclasses := self getInstVarNamed: #subclasses.
	^subclasses reflectsNil ifTrue: [Array new] ifFalse: [subclasses]
! !

!ClassMirror methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:49:02'!
localEquivalent
	^handle runtime objectModel at: self localName asSymbol
! !

!ClassMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:02'!
structureType
	^#Class
! !

!MetaclassMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:02'!
classVariables
	^self instanceClass classVariables
! !

!MetaclassMirror methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:02'!
subclasses
	| instance |
	instance := self instanceClass.
	^instance reflectsNil
		ifTrue: [#()]
		ifFalse: [instance subclasses collect: [:class | class class]]
! !

!MetaclassMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:02'!
instanceClass
	| class |
	class := self getInstVarNamed: #class.
	^class asClassMirror
! !

!MetaclassMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:02'!
localEquivalent
	^(handle runtime objectModel at: self instanceClass localName asSymbol) metaclass
! !

!MetaclassMirror methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:49:02'!
localName
	^self instanceClass localName , ' class'
! !

!MetaclassMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:02'!
structureType
	^#Metaclass
! !

!StackFrameMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:04'!
argumentAt: index
	^(handle slotAt: LastArgumentIndex - index + 1) mirror
! !

!StackFrameMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:04'!
method
	| mirror |
	mirror := (handle slotAt: MethodIndex) mirror asMethodMirror.
	^mirror isValid ifTrue: mirror
! !

!StackFrameMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:04'!
receiver
	^(handle slotAt: ReceiverIndex) mirror
! !

!StackFrameMirror methodsFor: 'private' stamp: 'KenD 11/22/2023 07:49:04'!
returnAddress
	^handle slotAt: ReturnAddressIndex
! !

!StackFrameMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:04'!
currentIp
	^handle currentIp
! !

!StackFrameMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:04'!
printOn: aStream
	aStream nextPutAll: 'SFMirror(' , String cr , handle printString , ')'
! !

!StackFrameMirror methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:04'!
slotAtTop
	^handle slotAtTop
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
argumentAt: index in: environment
	nativizer argumentAt: index in: environment 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
assembler: anAssembler
	assembler := anAssembler 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
failLabel
	^failed 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineBitAnd
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		andRwithA;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #bitAnd:.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineBitAnd: selector
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		andRwithA;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: selector.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineBitOr: selector
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		orRwithA;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: selector.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineBitXor
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		xorRwithA;
		setRintegerBit;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #bitXor:.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineEquals
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		loadTwithR;
		loadRwithTrue;
		compareTwithA;
		jumpIfEqualTo: done;
		loadRwithFalse;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #=.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineGreaterEqualThan
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		loadTwithR;
		loadRwithTrue;
		compareTwithA;
		jumpIfGreaterOrEqualSignedTo: done;
		loadRwithFalse;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #<.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineGreaterThan
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		loadTwithR;
		loadRwithTrue;
		compareTwithA;
		jumpIfGreaterSignedTo: done;
		loadRwithFalse;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #<.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineIdentityEquals
	done := assembler newLabel.
	self loadOperands.
	assembler loadTwithR; loadRwithTrue;
		compareTwithA;
		jumpIfEqualTo: done; loadRwithFalse; @ done
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineLessEqualThan
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		loadTwithR;
		loadRwithTrue;
		compareTwithA;
		jumpIfLessOrEqualSignedTo: done;
		loadRwithFalse;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #<.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineLessThan
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		loadTwithR;
		loadRwithTrue;
		compareTwithA;
		jumpIfLessSignedTo: done;
		loadRwithFalse;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #<.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineMessage
	| selector s |
	s := message selector.
	selector := s isSymbol
		ifTrue: [ s ]
		ifFalse: [ nativizer method at: s ].
	selector = #==
		ifTrue: [ ^ self inlineIdentityEquals ].
	selector = #=
		ifTrue: [ ^ self inlineEquals ].
	selector = #+
		ifTrue: [ ^ self inlinePlus ].
	selector = #<
		ifTrue: [ ^ self inlineLessThan ].
	selector = #<=
		ifTrue: [ ^ self inlineLessEqualThan ].
	selector = #>=
		ifTrue: [ ^ self inlineGreaterEqualThan ].
	selector = #>
		ifTrue: [ ^ self inlineGreaterThan ].
	selector = #-
		ifTrue: [ ^ self inlineMinus ].
	selector = #*
		ifTrue: [ ^ self inlineMultiply ].
	selector = #//
		ifTrue: [ ^ self inlineQuotient ].
	selector = #\\
		ifTrue: [ ^ self inlineRemainder ].
	selector = #|
		ifTrue: [ ^ self inlineBitOr: #| ].
	selector = #&
		ifTrue: [ ^ self inlineBitAnd: #& ].
	"	selector = #'>>' ifTrue: [^self inlineBitShiftLeft: #>>].
	selector = #'<<' ifTrue: [^self inlineBitShiftRight: #<<]."
	selector = #bitOr:
		ifTrue: [ ^ self inlineBitOr: #bitOr: ].
	selector = #bitAnd:
		ifTrue: [ ^ self inlineBitAnd: #bitAnd: ].
	selector = #bitXor:
		ifTrue: [ ^ self inlineBitXor ].
	"	selector = #bitShift: ifTrue: [^self inlineBitShift]."
	self ASSERT: false
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineMinus
	| overflow |
	done := assembler newLabel.
	failed := assembler newLabel.
	overflow := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		subAfromR;
		jumpIfOverflowTo: overflow;
		setRintegerBit;
		@ done.
	nativizer addFallback: [
		assembler
			@ overflow;
			addAtoR;
			@ failed;
			pushA.
		nativizer emitSend: #'-'.
		assembler jumpTo: done] 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineMultiply
	| overflow |
	done := assembler newLabel.
	failed := assembler newLabel.
	overflow := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		pushA;
		convertAtoNativeInteger;
		loadTwithR;
		clearRintegerBit;
		multiplyRbyAwideningToA;
		popA;
		jumpIfOverflowTo: overflow;
		setRintegerBit;
		@ done.
	nativizer
		addFallback: [ assembler
				@ overflow;
				loadRwithT;
				@ failed;
				pushA.
			nativizer emitSend: #*.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlinePlus
	| overflow |
	done := assembler newLabel.
	failed := assembler newLabel.
	overflow := assembler newLabel.
	self loadOperands.
	nativizer saveContextSwitchPoint.
	assembler
		clearRintegerBit;
		addAtoR;
		jumpIfOverflowTo: overflow;
		@ done.
	nativizer addFallback: [
		assembler
			@ overflow;
			subAfromR;
			setRintegerBit;
			@ failed;
			pushA.
		nativizer emitSend: #'+'.
		assembler jumpTo: done] 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineQuotient
	| |
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	assembler
		compareRwithSmallInteger: 0;
		jumpIfLessOrEqualSignedTo: failed.
	nativizer saveContextSwitchPoint.
	assembler
		convertRtoNativeInteger;
		convertAtoNativeInteger;
		loadTwithA;
		extendRtoAandDividebyT;
		convertRtoSmallInteger;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #//.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
inlineRemainder
	done := assembler newLabel.
	failed := assembler newLabel.
	self loadOperands.
	assembler
		compareRwithSmallInteger: 0;
		jumpIfLessOrEqualSignedTo: failed.
	nativizer saveContextSwitchPoint.
	assembler
		convertRtoNativeInteger;
		convertAtoNativeInteger;
		loadTwithA;
		extendRtoAandDividebyT;
		loadRwithA;
		convertRtoSmallInteger;
		@ done.
	nativizer
		addFallback: [ assembler
				@ failed;
				pushA.
			nativizer emitSend: #//.
			assembler jumpTo: done ]
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
loadAwithArgument: index in: environment
	nativizer loadAwithArgument: index in: environment 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
loadAwithTemporary: index in: environment
	nativizer loadAwithTemporary: index in: environment 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
loadOperands
	message opcodes
		do: [:hintcode | hintcode nativizeUsing: assembler for: self] 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
loadRvisitingArgument
	message arguments first acceptVisitor: nativizer
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
loadRvisitingReceiver
	message receiver acceptVisitor: nativizer 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
loadRwithTemporary: index env: environment
	nativizer temporaryAt: index in: environment
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
message: aMessageAstcode
	message := aMessageAstcode 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
method
	^nativizer method 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
methodLiteralAt: index
	^nativizer methodLiteralAt: index
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
nativizer: anAstcodeNativizer
	nativizer := anAstcodeNativizer 
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
popR
	^ nativizer popR
! !

!BinaryMessageNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:39'!
pushR
	^nativizer pushR
! !

!InlinedMessageNativizer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:40'!
assembler: anAssembler
	assembler := anAssembler 
! !

!InlinedMessageNativizer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:40'!
message: aMessageAstcode
	message := aMessageAstcode 
! !

!InlinedMessageNativizer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:40'!
nativizer: anAstcodeNativizer
	nativizer := anAstcodeNativizer 
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineAnd
	| skip conditions |
	skip := assembler newLabel.
	conditions := Array
		with: message receiver
		withAll: message arguments allButLast.
	conditions do: [ :c | self inlineAndCondition: c skip: skip ].
	message arguments last statements
		do: [ :s | s acceptVisitor: nativizer ].
	assembler @ skip
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineAndCondition: anSExpression skip: skip
	| retry failed |
	retry := assembler newLabel.
	failed := assembler newLabel.
	anSExpression acceptVisitor: nativizer.
	assembler
		@ retry;
		compareRwithFalse;
		jumpIfEqualTo: skip;
		compareRwithTrue;
		jumpIfNotEqualTo: failed.
	nativizer
		addFallback: [ assembler @ failed.
			nativizer sendMustBeBoolean.
			assembler jumpTo: retry ]
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineAndNot
	| skip conditions |
	skip := assembler newLabel.
	conditions := Array
		with: message receiver
		withAll: message arguments allButLast.
	conditions do: [ :c | self inlineAndCondition: c skip: skip ].
	message arguments last statements
		do: [ :s | s acceptVisitor: nativizer ].
	self negateBoolean.
assembler		@ skip
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineBinaryWhile: aBoolean
	| retry failed block continue |
	start := assembler newLabel.
	retry := assembler newLabel.
	failed := assembler newLabel.
	block := assembler newLabel.
	continue := assembler newLabel.
	assembler
		alignTo: 16;
		@ start.
	message receiver statements do: [ :s | s acceptVisitor: nativizer ].
	assembler
		@ retry;
		compareRwithBoolean: aBoolean;
		jumpIfEqualTo: block;
		compareRwithBoolean: aBoolean not;
		jumpIfNotEqualTo: failed;
		jumpTo: continue;
		@ block.
	message arguments first statements
		do: [ :s | s acceptVisitor: nativizer ].
	assembler
		jumpTo: start;
		@ continue.
	nativizer
		addFallback: [ assembler @ failed.
			nativizer sendMustBeBoolean.
			assembler jumpTo: retry ]
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineBranchIf: aBoolean
	| retry failed first second |
	retry := assembler newLabel.
	failed := assembler newLabel.
	end := assembler newLabel.
	message receiver acceptVisitor: nativizer.
	first := aBoolean not.
	second := aBoolean.
	assembler
		@ retry;
		loadAwithR;
		loadRwithNil;
		compareAwithBoolean: first;
		jumpIfEqualTo: end;
		compareAwithBoolean: second;
		jumpIfNotEqualTo: failed.
	message arguments first statements
		do: [ :s | s acceptVisitor: nativizer ].
	assembler @ end.
	nativizer
		addFallback: [ assembler @ failed; loadRwithA.
			nativizer sendMustBeBoolean.
			assembler jumpTo: retry ]
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineBranchIfNil: aBoolean

	end := assembler newLabel.
	message receiver acceptVisitor: nativizer.
	assembler
		compareRwithNil.
	aBoolean
		ifTrue: [ assembler jumpIfNotEqualTo: end ]
		ifFalse: [ assembler jumpIfEqualTo: end ].
	message arguments first acceptVisitor: nativizer.
	assembler @ end
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineBranchIfNilIfNotNil: aBoolean
	| second |
	second := assembler newLabel.
	end := assembler newLabel.
	message receiver acceptVisitor: nativizer.
	assembler compareRwithNil.
	aBoolean
		ifTrue: [ assembler jumpIfNotEqualTo: second ]
		ifFalse: [ assembler jumpIfEqualTo: second ].
	message arguments first acceptVisitor: nativizer.
	assembler
		jumpTo: end;
		@ second.
	message arguments first acceptVisitor: nativizer.
	assembler @ end
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineIfTrueIfFalse: aBoolean
	| retry other failed first second |
	retry := assembler newLabel.
	other := assembler newLabel.
	failed := assembler newLabel.
	end := assembler newLabel.
	message receiver acceptVisitor: nativizer.
	first := aBoolean not.
	second := aBoolean.
	assembler
		@ retry;
		compareRwithBoolean: first;
		jumpIfEqualTo: other;
		compareRwithBoolean: second;
		jumpIfNotEqualTo: failed.
	message arguments first statements
		do: [ :s | s acceptVisitor: nativizer ].
	assembler
		jumpTo: end;
		@ other.
	message arguments second statements
		do: [ :s | s acceptVisitor: nativizer ].
	assembler @ end.
	nativizer
		addFallback: [ assembler @ failed.
			nativizer sendMustBeBoolean.
			assembler jumpTo: retry ]
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineMessage
	| selector |
	selector := message selector.
	selector = #ifTrue:
		ifTrue: [ ^ self inlineBranchIf: true ].
	selector = #ifFalse:
		ifTrue: [ ^ self inlineBranchIf: false ].
	selector = #ifNil:
		ifTrue: [ ^ self inlineBranchIfNil: true ].
	selector = #ifNotNil:
		ifTrue: [ ^ self inlineBranchIfNil: false ].
	selector = #ifNil:ifNotNil:
		ifTrue: [ ^ self inlineBranchIfNilIfNotNil: true ].
	selector = #ifNil:ifNotNil:
		ifTrue: [ ^ self inlineBranchIfNilIfNotNil: false ].
	selector = #ifTrue:ifFalse:
		ifTrue: [ ^ self inlineIfTrueIfFalse: true ].
	selector = #ifFalse:ifTrue:
		ifTrue: [ ^ self inlineIfTrueIfFalse: false ].
	selector = #whileTrue
		ifTrue: [ ^ self inlineUnitaryWhile: true ].
	selector = #whileFalse
		ifTrue: [ ^ self inlineUnitaryWhile: false ].
	selector = #whileTrue:
		ifTrue: [ ^ self inlineBinaryWhile: true ].
	selector = #whileFalse:
		ifTrue: [ ^ self inlineBinaryWhile: false ].
	selector = #repeat
		ifTrue: [ ^ self inlineRepeat ].
	selector = #to:do:
		ifTrue: [ ^ self inlineToDo ].
	selector = #to:by:do:
		ifTrue: [ ^ self inlineToByDo].
	selector = #timesRepeat:
		ifTrue: [ ^ self inlineTimesRepeat ].
	(selector beginsWith: #or:)
		ifTrue: [ ^ self inlineOr ].
	(selector beginsWith: #and:)
		ifTrue: [ ^ self inlineAnd ].
	selector = #andNot:
		ifTrue: [ ^ self inlineAndNot ].
	selector = #orNot:
		ifTrue: [ ^ self inlineOrNot ].
	self ASSERT: false
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineOr
	| skip conditions |
	skip := assembler newLabel.
	conditions := Array
		with: message receiver
		withAll: message arguments allButLast.
	conditions do: [ :c | self inlineOrCondition: c skip: skip ].
	message arguments last statements
		do: [ :s | s acceptVisitor: nativizer ].
	assembler @ skip
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineOrBlock: b skip: skip
	| retry failed |
	retry := assembler newLabel.
	failed := assembler newLabel.
	b statements acceptVisitor: nativizer.
	assembler
		@ retry;
		compareRwithTrue;
		jumpIfEqualTo: skip;
		compareRwithFalse;
		jumpIfNotEqualTo: failed.
	nativizer
		addFallback: [ assembler @ failed.
			nativizer sendMustBeBoolean.
			assembler jumpTo: retry ]
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineOrCondition: anSExpression skip: skip
	| retry failed |
	retry := assembler newLabel.
	failed := assembler newLabel.
	
	anSExpression acceptVisitor: nativizer.
	assembler
		@ retry;
		compareRwithTrue;
		jumpIfEqualTo: skip;
		compareRwithFalse;
		jumpIfNotEqualTo: failed.
	nativizer
		addFallback: [ assembler @ failed.
			nativizer sendMustBeBoolean.
			assembler jumpTo: retry ]
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineOrNot
	| skip conditions |
	skip := assembler newLabel.
	conditions := Array
		with: message receiver
		withAll: message arguments allButLast.
	conditions do: [ :c | self inlineOrCondition: c skip: skip ].
	message arguments last statements
		do: [ :s | s acceptVisitor: nativizer ].
	self negateBoolean.
	assembler @ skip
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineRepeat
	start := assembler newLabel.
	assembler
		alignTo: 16;
		@ start.
	message receiver statements do: [ :s | s acceptVisitor: nativizer ].
	assembler jumpTo: start
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineTimesRepeat
	| head block continue nonInteger nonDecrementable current |
	head := assembler newLabel.
	block := assembler newLabel.
	continue := assembler newLabel.
	nonInteger := assembler newLabel.
	nonDecrementable := assembler newLabel.
	message receiver acceptVisitor: nativizer.
	current := nativizer pushR.
	assembler
		alignTo: 16;
		@ head;
		testIntegerBitOf: assembler regR;
		jumpIfZeroTo: nonInteger;
		compareRwithSmallInteger: 0;
		jumpIfLessOrEqualSignedTo: continue;
		@ block.
	message arguments first statements
		do: [ :s | s acceptVisitor: nativizer ].
	nativizer loadRwithStack: current.
	assembler
		testIntegerBitOf: assembler regR;
		jumpIfZeroTo: nonDecrementable;
		subFromRconstant: 2.
	nativizer storeRInStack: current.
	assembler
		jumpTo: head;
		@ continue.
	nativizer
		dropTos;
		addFallback: [ assembler
				@ nonDecrementable;
				pushSmallInteger: 1.
			nativizer
				emitSend: #-;
				storeRInStack: current.
			assembler jumpTo: head ];
		addFallback: [ assembler
				@ nonInteger;
				pushSmallInteger: 0.
			nativizer emitSend: #>.
			assembler
				compareRwithTrue;
				jumpIfEqualTo: block;
				jumpTo: continue ]

! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineToByDo
	| head block continue nonInteger nonIncrementable overflow current limit by increment |
	head := assembler newLabel.
	block := assembler newLabel.
	continue := assembler newLabel.
	nonInteger := assembler newLabel.
	nonIncrementable := assembler newLabel.
	overflow := assembler newLabel.
	message receiver acceptVisitor: nativizer.
	current := message arguments third inlinedArgs first.
	nativizer temporaryInStackAtPut: current.
	message arguments first acceptVisitor: nativizer.
	limit := nativizer pushR.
	assembler loadAwithR.
	nativizer temporaryInStackAt: current.
	assembler
		alignTo: 16;
		@ head;
		testIntegerBitOf: assembler regA;
		jumpIfZeroTo: nonInteger;
		testIntegerBitOf: assembler regR;
		jumpIfZeroTo: nonInteger;
		compareRwithA.
	by := message arguments second value.
	by > 0
		ifTrue: [ assembler jumpIfGreaterSignedTo: continue ]
		ifFalse: [ assembler jumpIfLessSignedTo: continue ].
	increment := (assembler smallInteger: by) - 1.
	assembler @ block.
	message arguments third statements
		do: [ :s | s acceptVisitor: nativizer ].
	nativizer temporaryInStackAt: current.
	assembler
		testIntegerBitOf: assembler regR;
		jumpIfZeroTo: nonIncrementable;
		addRwithImmediate: increment;
		jumpIfOverflowTo: overflow.
	nativizer
		temporaryInStackAtPut: current;
		loadAwithStack: limit.
	assembler
		jumpTo: head;
		@ continue.
	nativizer dropTos;
		addFallback: [ assembler
				@ overflow;
				subFromRconstant: increment;
				@ nonIncrementable;
				pushSmallInteger: 1.
			nativizer
				emitSend: #+;
				temporaryInStackAtPut: current;
				loadAwithStack: limit.
			assembler jumpTo: head ];
		addFallback: [ assembler
				@ nonInteger;
				pushA.
			nativizer emitSend: #<=.
			assembler
				compareRwithTrue;
				jumpIfEqualTo: block;
				jumpTo: continue ]

! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineToDo
	| head block continue nonInteger nonIncrementable overflow current limit |
	head := assembler newLabel.
	block := assembler newLabel.
	continue := assembler newLabel.
	nonInteger := assembler newLabel.
	nonIncrementable := assembler newLabel.
	overflow := assembler newLabel.
	message receiver acceptVisitor: nativizer.
	current := message arguments second inlinedArgs first.
	nativizer temporaryInStackAtPut: current.
	message arguments first acceptVisitor: nativizer.
	limit := nativizer pushR.
	assembler loadAwithR.
	nativizer temporaryInStackAt: current.
	assembler
		alignTo: 16;
		@ head;
		testIntegerBitOf: assembler regA;
		jumpIfZeroTo: nonInteger;
		testIntegerBitOf: assembler regR;
		jumpIfZeroTo: nonInteger;
		compareRwithA;
		jumpIfGreaterSignedTo: continue;
		@ block.
	message arguments second statements
		do: [ :s | s acceptVisitor: nativizer ].
	nativizer temporaryInStackAt: current.
	assembler
		testIntegerBitOf: assembler regR;
		jumpIfZeroTo: nonIncrementable;
		addRwithImmediate: 2;
		jumpIfOverflowTo: overflow.
	nativizer
		temporaryInStackAtPut: current;
		loadAwithStack: limit.
	assembler
		jumpTo: head;
		@ continue.
	nativizer dropTos;
		addFallback: [ assembler
				@ overflow;
				subFromRconstant: 2;
				@ nonIncrementable;
				pushSmallInteger: 1.
			nativizer
				emitSend: #+;
				temporaryInStackAtPut: current;
				loadAwithStack: limit.
			assembler jumpTo: head ];
		addFallback: [ assembler
				@ nonInteger;
				pushA.
			nativizer emitSend: #<=.
			assembler
				compareRwithTrue;
				jumpIfEqualTo: block;
				jumpTo: continue ]

! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
inlineUnitaryWhile: aBoolean
	| continue failed |
	start := assembler newLabel.
	continue := assembler newLabel.
	failed := assembler newLabel.
	assembler
		alignTo: 16;
		@ start.
	message receiver statements do: [ :s | s acceptVisitor: nativizer ].
	assembler
		compareRwithBoolean: aBoolean;
		jumpIfEqualTo: start;
		compareRwithBoolean: aBoolean not;
		jumpIfNotEqualTo: failed;
		@ continue.
	nativizer
		addFallback: [ assembler @ failed.
			nativizer sendMustBeBoolean.
			assembler jumpTo: continue ]
! !

!InlinedMessageNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:40'!
negateBoolean
		| retry failed done |
	retry := assembler newLabel.
	failed := assembler newLabel.
		done := assembler newLabel.
	assembler
		@ retry;
		loadAwithR;
		loadRwithFalse;
		compareRwithA;
		jumpIfEqualTo: done;
		loadRwithTrue;
		compareRwithA;
		jumpIfNotEqualTo: failed; @done.
	nativizer
		addFallback: [ assembler @ failed.
			nativizer sendMustBeBoolean.
			assembler jumpTo: retry ]
! !

!MessageLinker methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:59:42'!
canInline: aSymbol
	filter ifNil: [ ^true ].
	filter == aSymbol ifTrue: [ ^true ].
	^(filter includes: aSymbol)
! !

!MessageLinker methodsFor: 'testing' stamp: 'KenD 11/22/2023 13:59:42'!
filter: anObject
	filter := anObject.
	filter isCollection ifTrue: [filter := filter asIdentitySet]
! !

!CompositeMessageLinker methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:39'!
add: aMessageLinker
	candidates add: aMessageLinker
! !

!CompositeMessageLinker methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:39'!
dispatchLinkerFor: selector
	^candidates
		detect: [:linker | linker canInline: selector]
		ifNone: [self error: 'cannot dispatch ', selector storeString]
! !

!CompositeMessageLinker methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:39'!
emitSend: selector using: anAssembler
	| linker |
	linker := self dispatchLinkerFor: selector.
	linker emitSend: selector using: anAssembler

! !

!CompositeMessageLinker methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:39'!
emitSendSuper: selector from: aClass using: anAssembler
	| linker |
	linker := self dispatchLinkerFor: selector.
	linker emitSendSuper: selector from: aClass using: anAssembler
! !

!CompositeMessageLinker methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:39'!
initialize
	candidates := OrderedCollection new
! !

!HaltingSend methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:42'!
emitSend: aSymbol using: anAssembler
	anAssembler breakpoint
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleAsFloatInto
	#_asFloatInto:.
	assembler
		loadX0withRasDouble;
		storeLargeX0inA.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleAsNative
	| noninteger |
	#_asNative.
	noninteger := assembler labeledIntegerBitTestOfR.
	assembler
		convertRtoNativeInteger;
		@ noninteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleAsObject
	#_asObject.
	assembler clearSafeRintegerBit
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleAsPointer
	| nonInteger |
	#_asPointer.
	nonInteger := assembler labeledIntegerBitTestOfR.
	assembler
		convertRtoNativeInteger;
		@ nonInteger;
		setSafeRintegerBit
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleAsSmallInteger
	#_asSmallInteger.
	assembler convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicAt
	| oop |
	#_basicAt:.
	oop := assembler labeledIntegerNativizationOfA.
	assembler
		loadRwithRatA;
		@ oop
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicAtPut
	| nonInteger |
	#_basicAt:put:.
	nonInteger := assembler labeledIntegerNativizationOfA.
	assembler
		storeTinRatA;
		@ nonInteger;
		loadRwithT
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicCopyFromToWith
	#_basicCopyFrom:to:with:.
	assembler
		pushE;
		convertAtoNativeInteger;
		convertTtoNativeInteger;
		loadEwithAddressOfRatA;
		loadSwithAddressOfSatA;
		subAfromT;
		addTwithImmediate: 1;
		moveTslots;
		popE
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicFlags
	#_basicFlags.
	self emitByteAtOffset: _Flags
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicFlagsPut
	#_basicFlags:.
	self emitByteAtOffsetPut: _Flags
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicHash
	#_basicHash.
	assembler
		loadZeroExtendShortRwithRoffset: _Hash;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicHashPut
	| nonInteger |
	#_basicHash:.
	nonInteger := assembler labeledIntegerNativizationOfA.
	assembler
		storeShortAinRoffset: _Hash;
		@ nonInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicSize
	#_smallSize.
	self emitByteAtOffset: _SmallSize
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicSizePut
	#_smallSize:.
	self emitByteAtOffsetPut: _SmallSize
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicULongAt
	| nonInteger |
	#_basicULongAt:.
	nonInteger := assembler labeledIntegerNativizationOfA.
	assembler
		loadZeroExtendLongRwithRatA;
		@ nonInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBasicULongAtPut
	| nonInteger |
	#_basicULongAt:put:.
	nonInteger := assembler labeledIntegerNativizationOfA.
	assembler
		storeLongTinRatA;
		@ nonInteger;
		loadRwithT
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBeCurrent
	#_beCurrent.
	assembler
		loadRwithRindex: 1;
		clearSafeRintegerBit;
		loadFPwithR
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBeEnvironment
	#_beEnvironment.
	assembler loadEwithR
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBeFramePointer
	#_beFramePointer.
	assembler storeRinFPindex: 1
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBitShiftLeft
	| success |
	#_bitShiftLeft:.
	success := assembler newLabel.
	assembler
		loadTwithA;
		loadAwithR;
		clearSafeRintegerBit;
		convertTtoNativeInteger;
		shiftLeftRwithT;
		setSafeRintegerBit;
		pushR;
		shiftRightRwithT;
		setSafeRintegerBit;
		compareRwithA;
		popR;
		shortJumpIfEqualTo: success;
		loadRwithNil;
		@ success
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBitShiftRight
	#_bitShiftRight:.
	assembler
		move: assembler regA to: assembler regT;
		convertToNativeInteger: assembler regT;
		shiftRightArithmetic: assembler regR by: assembler regT b;
		setIntegerBit: assembler regR
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleBusyWait
	| loop |
	#_busyWait.
	loop := assembler newLabel.
	assembler
		loadTwithImmediate: 0;
		@ loop;
		exchangeRindirectWithT;
		compareTwithImmediate: 0;
		shortJumpIfEqualTo: loop
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleByteAt
	| nonInteger |
	#_byteAt:.
	nonInteger := assembler labeledIntegerNativizationOfA.
	assembler
		loadZeroExtendByteRwithRatA;
		convertRtoSmallInteger;
		@ nonInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleByteAtPut
	| nonInteger1 nonInteger2 |
	#_byteAt:put:.
	nonInteger1 := assembler labeledIntegerNativizationOfA.
	nonInteger2 := assembler labeledIntegerNativizationOfT.
	assembler
		storeByteTinRatA;
		@ nonInteger1;
		@ nonInteger2;
		loadRwithT;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleCDeclCallWithArguments
	#_cdeclCallWithArguments:.
	assembler
		loadZeroExtendByteTwithAindex: _SmallSize + 1;
		shiftTright: assembler wordSizeShift;
		pushS;
		saveCallerFrame;
		subTslotsToSP;
		assemble: 'and' with: assembler regSP with: -16;
		loopTtimes: [ assembler
				load: assembler regS
				fromMem: assembler memRefAatT;
				store: assembler regS
				intoMem: assembler memRefSPatT ].
	assembler addressSize = 8
		ifTrue: [ self loadArgumentsIntoRegisters ].
	assembler
		callR;
		restoreCallerFrame;
		popS
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleCallWithArguments
	#_stdcallWithArguments:.
	assembler
		loadZeroExtendByteTwithAindex: _SmallSize + 1;
		shiftTright: assembler wordSizeShift;
		loopTtimes: [ assembler pushAatToffset: 0 - assembler addressSize ].
	assembler addressSize = 8
		ifTrue: [ self loadArgumentsIntoRegisters ].
	assembler callR
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleEnvironment
	#_environment.
	assembler loadRwithE
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleExpandInStackSized
	#_expandInStackSized:.
	assembler
		convertAtoNativeInteger;
		loadTwithA;
		loopTtimes: [ assembler
				pushIndirectR;
				addRwithImmediate: assembler wordSize ]
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleExtendedSize
	#_largeSize.
	assembler
		loadZeroExtendLongRwithRindex: _ExtendedSize;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatEquals
	"
	first compare magnitudes to set error bit if NaN
	"
	#_floatEquals:.
	assembler
		pushR;
		loadLargeX0withRindirect;
		compareLessThanDoubleX0withAindirect;
		popR;
		loadLargeX0withRindirect;
		compareEqualDoubleX0withAindirect;
		moveX0toR;
		addRwithImmediate: 1;
		convertRtoSmallInteger.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatFractionPartInto
	#_floatFractionPartInto:.
	assembler
		loadLargeX0withRindirect;
		roundDoubleX0intoX1;
		subDoubleX1fromX0;
		storeLargeX0inA.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatLessThan
	#_floatLessThan:.
	assembler
		loadLargeX0withRindirect;
		compareLessThanDoubleX0withAindirect;
		moveX0toR;
		addRwithImmediate: 1;
		convertRtoSmallInteger.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatMinusInto
	#_floatMinus:into:.
	assembler
		loadLargeX0withRindirect;
		loadLargeX1withAindirect;
		subDoubleX1fromX0;
		storeLargeX0inT.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatMultiplyInto
	#_floatMultiply:into:.
	assembler
		loadLargeX0withRindirect;
		loadLargeX1withAindirect;
		multiplyDoubleX0byX1;
		storeLargeX0inT.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatPlusInto
	#_floatPlus:into:.
	assembler
		loadLargeX0withRindirect;
		loadLargeX1withAindirect;
		addDoubleX1toX0;
		storeLargeX0inT.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatQuotientInto
	#_floatQuotient:into:.
	assembler
		loadLargeX0withRindirect;
		loadLargeX1withAindirect;
		divideDoubleX0byX1;
		storeLargeX0inT.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatSqrtInto
	#_floatSqrtInto:.
	assembler
		loadLargeX0withRindirect;
		sqrtDoubleX0;
		storeLargeX0inA.
	self readFloatStatus
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFloatTruncated
	#_floatTruncated.
	assembler loadRconvertingDoublePointedByR.
	self readFloatStatus.
	assembler convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleFramePointer
	#_framePointer.
	assembler loadRwithFPindex: 1
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleGetTIBValue
	| nonInteger |
	#_getThreadInformationBlockValue.
	nonInteger := assembler labeledIntegerNativizationOfR.
	assembler
		loadRwithTIBatR;
		@ nonInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleGetThreadValue
	| nonInteger uninitialized |
		#_getThreadValue.
	nonInteger := assembler labeledIntegerNativizationOfR.
	uninitialized := assembler newLabel.
	assembler
		loadRwithThreadVariableAtR;
		compareRwithImmediate: 0;
		shortJumpIfEqualTo: uninitialized.
	assembler
		jumpOver: [ assembler
				@ uninitialized;
				@ nonInteger;
				loadRwithNil ]
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleHigh16
	#_high16.
	assembler wordSize > 4
		ifTrue: [ assembler clearRhigh32 ].
	assembler
		shiftRright: 15;
		setSafeRintegerBit
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleHigh32
	#_high32.
	assembler
		shiftLogicalRright: 31;
		setSafeRintegerBit
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleHoldRefererIfNeeded
	#_holdRefererIfNeeded:.
	assembler
		pushA;
		loadAwithGlobal: #WriteBarrier;
		callIndirectA;
		popA
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleIntegerMultiplyByInto
	#_integerMultiplyBy:into:.
	assembler
		convertRtoNativeInteger;
		convertAtoNativeInteger;
		multiplyRbyAwideningToA;
		storeRinTindex: 1;
		storeAinTindex: 2;
		loadRwithT
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleInvoke
	#_invoke:.
	assembler
		loadMwithA;
		callIndirectM
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleLeadingZeroBitCount
	#_leadingZeroBitCount.
	assembler
		convertRtoNativeInteger;
		leadingRzeroCount;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleLoadFloatStatusFrom
	#_status:.
	assembler loadMXCSRfromA
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleLow16
	#_low16.
	assembler
		andRwithImmediate: 16rFFFF;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleLow32
	#_low32.
	assembler wordSize > 4
		ifTrue: [ assembler
				andRwithImmediate: 16rFFFFFFFF;
				convertRtoSmallInteger ]
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleNativeHalt
	#_halt.
	assembler breakpoint
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleNilSlots
	#_nilSlots:.
	assembler
		pushE;
		loadEwithR;
		loadRwithNil;
		loadTwithA;
		convertTtoNativeInteger;
		writeTslots;
		popE
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleObjectAtOffset
	| nonInteger1 |
	#_objectAtOffset:.
	nonInteger1 := assembler labeledIntegerNativizationOfA.
	assembler
		loadRwithRatOffsetA;
		@ nonInteger1
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleObjectAtOffsetPut
	| oop |
	#_objectAtOffset:put:.
	oop := assembler labeledIntegerNativizationOfA.
	assembler
		storeTinRatOffsetA;
		@ oop;
		loadRwithT;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleOop
	#_oop.
	^ assembler convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleQuotientTowardZero
	#_quotientTowardZero:.
	assembler
		convertRtoNativeInteger;
		convertAtoNativeInteger;
		loadTwithA;
		extendRtoAandDividebyT;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleRelease
	#_release.
	assembler
		lock;
		decRindirect
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleRemainderTowardZero
	| adapt convert |
	#_remainderTowardZero:.
	adapt := assembler newLabel.
	convert := assembler newLabel.
	assembler
		convertRtoNativeInteger;
		convertAtoNativeInteger;
		loadTwithA;
		xorAwithR;
		jumpIfSignTo: adapt;
		extendRtoAandDividebyT;
		loadRwithA;
		jumpTo: convert;
		@ adapt;
		extendRtoAandDividebyT;
		loadRwithA;
		testRwithR;
		jumpIfZeroTo: convert;
		addTtoR;
		@ convert;
		convertRtoSmallInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleRestore
	#_restore.
	assembler loadEwithR
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleRestoreAndTransferControlWithContext
	#_restoreAndTransferControlWithContext:.
	assembler
		clearSafeRintegerBit;
		loadFPwithR;
		loadSPwithFP;
		loadRwithA;
		clearSafeRintegerBit;
		loadFPwithR;
		popR;
		loadEwithR;
		restoreCallerSelf;
		restoreCallerM;
		loadRwithS;
		return: 0
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleRestoreWithContext
	#_restoreWithContext:.
	assembler
		clearSafeRintegerBit;
		loadFPwithR;
		loadSPwithFP;
		loadRwithA;
		clearSafeRintegerBit;
		loadFPwithR
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleSaveCurrentEnvironment
	#_saveCurrentEnvironment.
	assembler
		clearSafeRintegerBit;
		pushE;
		popT;
		storeTinRindex: 1;
		setSafeRintegerBit
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleSetTIBValue
	#_setThreadInformationBlockValue:.
	assembler
		convertRtoNativeInteger;
		storeTIBatRwithA
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleSetThreadValue
	| nonInteger |
	#_setThreadValue:.
	nonInteger := assembler labeledIntegerNativizationOfR.
	assembler
		storeAinThreadVariableAtIndexR;
		convertRtoSmallInteger.
	assembler @ nonInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleSmallIntegerByteAt
	| nonInteger |
	#_smallIntegerByteAt:.
	nonInteger := assembler labeledIntegerNativizationOfA.
	assembler
		convertRtoNativeInteger;
		pushR;
		loadZeroExtendByteRwithSPatA;
		convertRtoSmallInteger;
		popA;
		@ nonInteger
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleStoreDoubleResult
	#_storeDoubleResult.
	assembler storeDoubleResultInRindirect
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleStoreFloatStatusInto
	#_readStatusOn:.
	assembler storeMXCSRintoA
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleTestSmallInteger
	| integer |
	#_isSmallInteger.
	integer := assembler newLabel.
	assembler
		testRintegerBit;
		loadRwithTrue;
		shortJumpIfNotZeroTo: integer;
		loadRwithFalse;
		@ integer
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleThisContext
	#_thisContext.
	assembler loadRwithFP setRintegerBit
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleTimesTwoPower
	#_timesTwoPower:.
	assembler clearFPUFlags scaleFloatOnRWithA clearFPUFlags
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleTransferControlDiscardingLastArgTo
	#_transferControlDiscardingLastArgTo:.
	assembler
		restoreCallerFrame;
		popSPindirect;
		loadMwithA;
		jumpToMindex: 1
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleTransferControlTo
	#_transferControlTo:.
	assembler restoreCallerFrame; loadMwithA; jumpToMindex: 1
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleULargeAtOffset
	| overflow1 overflow2 end |
	#_uLargeAtOffset:.
	overflow1 := assembler newLabel.
	overflow2 := assembler newLabel.
	end := assembler newLabel.
	assembler
		convertAtoNativeInteger;
		loadRwithRatOffsetA;
		shiftRleft: 1;
		shortJumpIfCarryTo: overflow1;
		shortJumpIfSignTo: overflow2;
		setRintegerBit;
		shortJumpTo: end.
	assembler
		@ overflow1;
		@ overflow2;
		loadRwithNil;
		@ end
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleULargeAtOffsetInto
	#_uLargeAtOffset:into:.
	assembler
		convertAtoNativeInteger;
		loadAwithRoffsetAtA;
		storeAinTindex: 1;
		loadRwithT
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleULargeAtOffsetPut
	| end notSmall |
	#_uLargeAtOffset:put:.
	notSmall := assembler
		convertAtoNativeInteger;
		labeledIntegerBitTestOfT.
	end := assembler newLabel.
	assembler
		convertTtoNativeInteger;
		shortJumpTo: end;
		@ notSmall;
		loadTwithTindex: 1;
		@ end;
		storeTinRatOffsetA
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleULongAtOffset
	| overflow1 overflow2 end |
	#_uLongAtOffset:.
	overflow1 := assembler newLabel.
	overflow2 := assembler newLabel.
	end := assembler newLabel.
	assembler
		convertAtoNativeInteger;
		loadLongRwithRatOffsetA;
		shiftRleft: 1;
		shortJumpIfCarryTo: overflow1;
		shortJumpIfSignTo: overflow2;
		setRintegerBit;
		shortJumpTo: end.
	assembler
		@ overflow1;
		@ overflow2;
		loadRwithNil;
		@ end
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleULongAtOffsetInto
	#_uLongAtOffset:into:.
	assembler
		convertAtoNativeInteger;
		loadLongRwithRatOffsetA;
		storeRinTindex: 1;
		loadRwithT
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleULongAtOffsetPut
	| end oop |
	#_uLongAtOffset:put:.
	oop := assembler
		convertAtoNativeInteger;
		labeledIntegerBitTestOfT.
	end := assembler newLabel.
	assembler
		convertTtoNativeInteger;
		shortJumpTo: end;
		@ oop;
		loadTwithTindex: 1;
		@ end;
		storeLongTinRatOffsetA
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleUShortAtOffsetPut
	| end notSmall |
	#_uShortAtOffset:put:.
	notSmall := assembler
		convertAtoNativeInteger;
		labeledIntegerBitTestOfT.
	end := assembler newLabel.
	assembler
		convertTtoNativeInteger;
		shortJumpTo: end.
	assembler
		@ notSmall;
		loadTwithTindex: 1;
		@ end;
		storeShortTinRatOffsetA
! !

!InlineMessageLinker methodsFor: 'private - assemble' stamp: 'KenD 11/22/2023 13:59:44'!
assembleZeroSlots
	#_zeroSlots:.
	assembler
		pushE;
		loadEwithR;
		loadRwithImmediate: 0;
		loadTwithA;
		convertTtoNativeInteger;
		writeTslots;
		popE
! !

!InlineMessageLinker methodsFor: 'private - helpers' stamp: 'KenD 11/22/2023 13:59:44'!
emitByteAtOffset: offset
	assembler
		loadZeroExtendByteRwithRindex: offset + 1;
		convertRtoSmallInteger 
! !

!InlineMessageLinker methodsFor: 'private - helpers' stamp: 'KenD 11/22/2023 13:59:44'!
emitByteAtOffsetPut: offset
	| nonInteger |
	nonInteger := assembler labeledIntegerNativizationOfA.
	assembler
		storeByteAinRindex: offset + 1;
		@ nonInteger 
! !

!InlineMessageLinker methodsFor: 'private - helpers' stamp: 'KenD 11/22/2023 13:59:44'!
loadArgumentsIntoRegisters
	| stack1 stack2 stack3 stack4 |
	stack1 :=assembler memRef: rsp indexImm: 1.
	stack2 :=assembler memRef: rsp indexImm: 2.
	stack3 :=assembler memRef: rsp indexImm: 3.
	stack4 :=assembler memRef: rsp indexImm: 4.
	assembler
		load: rcx fromMem: stack1;
		load: rdx fromMem: stack2;
		load: r8 fromMem: stack3;
		load: r9 fromMem: stack4;
		assemble: 'movq' with: xmm0 with: rcx;
		assemble: 'movq' with: xmm1 with: rdx;
		assemble: 'movq' with: xmm2 with: r8;
		assemble: 'movq' with: xmm3 with: r9
! !

!InlineMessageLinker methodsFor: 'private - helpers' stamp: 'KenD 11/22/2023 13:59:44'!
readFPUStatus
	assembler
		loadAwithKnown: #FloatStatus;
		readFPUStatusOnA
! !

!InlineMessageLinker methodsFor: 'private - helpers' stamp: 'KenD 11/22/2023 13:59:44'!
readFloatStatus
	assembler
		loadAwithKnown: #FloatStatus;
		storeMXCSRintoA
! !

!InlineMessageLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:44'!
emitSend: aSymbol using: anAssembler
	| arity selector | 
	assembler := anAssembler.
	arity := aSymbol arity. 
	arity > 2 ifTrue: [assembler pop: assembler regS].
	arity > 1 ifTrue: [assembler pop: assembler regT].
	arity > 0 ifTrue: [assembler pop: assembler regA].
	self ASSERT: arity <= 3 .
	selector := map at: aSymbol.
	self perform: selector
! !

!InlineMessageLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:44'!
emitSendDebuggable: aSymbol using: anAssembler
	self emitSend: aSymbol using: anAssembler 
! !

!InlineMessageLinker methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:44'!
initialize
	map := Dictionary new.
	self class supported do:[:each|map add: each].
	self filter: map keys asIdentitySet

	"
	InlineMessageLinker new
	"

! !

!InlineMessageLinker class methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:44'!
supported
	| selectors |
	selectors := self organization selectorsFor: #'private - assemble'.
	^selectors collect: [:selector | | cm key |
		cm := self >> selector.
		key := cm literals detect: [:each | each isSymbol and:[each first == $_ ]].
		key -> selector]. 

	"
	InlineMessageLinker supported
	"

! !

!InvokeLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:41'!
addMethod: aCompiledMethod
	self addMethod: aCompiledMethod for: aCompiledMethod selector
! !

!InvokeLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:41'!
addMethod: aCompiledMethod for: aSymbol
	| instructions send |
	filter add: aSymbol.
	instructions := invoker ifNil: [ aCompiledMethod nativeCode code ].
	send := SendSite new invoke: aCompiledMethod using: instructions.
	sends at: aSymbol put: send
! !

!InvokeLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:41'!
addMethods: aCollection
	aCollection do: [:m | self addMethod: m]
! !

!InvokeLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:41'!
emitSend: aSymbol using: anAssembler
	| send |
	send := sends at: aSymbol.
	anAssembler
		loadAwithLiteral: send;
		callIndirectA;
		discardArguments: aSymbol arity
! !

!InvokeLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:41'!
initialize
	super initialize.
	sends := Dictionary new.
	self filter: #()
! !

!InvokeLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:41'!
invoker: aNativeCode
	invoker := aNativeCode
! !

!LookupLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:42'!
emitSend: aSymbol using: anAssembler
	| send |
	send := SendSite new lookup: aSymbol using: lookup.
	anAssembler
		loadAwithLiteral: send;
		callIndirectA;
		discardArguments: aSymbol arity.
	^send
! !

!LookupLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:42'!
emitSendSuper: aSymbol from: aClass using: anAssembler
	| send behavior |
	send := SendSite new lookup: aSymbol using: lookupSuper; beSuperSend.
	behavior := aClass superclass map instanceBehavior.
	anAssembler
		loadAwithLiteral: send;
		loadTwithLiteral: behavior;
		callIndirectA;
		discardArguments: aSymbol arity.
	^send
! !

!LookupLinker methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
initializeFrom: aNativizationEnvironment
	lookup := aNativizationEnvironment lookupStub.
	lookupSuper := aNativizationEnvironment lookupSuperStub.

! !

!LookupLinker methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
lookup: aByteArray
	lookup := aByteArray
! !

!LookupLinker methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
lookupSuper: aByteArray
	lookupSuper := aByteArray
! !

!LazyLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:45'!
emitSend: aSymbol using: anAssembler
	| send |
	send := super emitSend: aSymbol using: anAssembler.
	sends add: send
! !

!LazyLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:45'!
initialize
	super initialize.
	sends := OrderedCollection new

! !

!LazyLinker methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:45'!
sends
	^sends

! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
abi
	^platform abi
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
addLinker: aLinker
	messageLinker add: aLinker
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
globalNamed: aSymbol
	| index |
	index := self class indexOfGlobal: aSymbol.
	^globals at: index
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
globalNamed: aSymbol put: anObject
	| index |
	index := self class indexOfGlobal: aSymbol.
	globals at: index put: anObject
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
globals
	^globals
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
globals: anArray
	globals := anArray
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
inlinedMethods
	^inlinedMethods
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
inlinedMethods: aCollection
	inlinedMethods := aCollection
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
invokeStub
	| index |
	index := self class indexOfGlobal: #Invoke.
	^(globals at: index) code
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
invokedMethods
	^invokedMethods
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
invokedMethods: aCollection
	invokedMethods := aCollection asOrderedCollection 
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
lookup
	| index |
	index := self class indexOfGlobal: #Lookup.
	^globals at: index
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
lookupDebuggableStub
	| index |
	index := self class indexOfGlobal: #DebuggableLookup.
	^(globals at: index) code
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
lookupStub
	| index |
	index := self class indexOfGlobal: #Lookup.
	^(globals at: index) code
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
lookupSuper
	| index |
	index := self class indexOfGlobal: #LookupSuper.
	^globals at: index
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
lookupSuperDebuggableStub
	| index |
	index := self class indexOfGlobal: #DebuggableLookupSuper.
	^(globals at: index) code
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
lookupSuperStub
	| index |
	index := self class indexOfGlobal: #LookupSuper.
	^(globals at: index) code
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
messageLinker
	^messageLinker
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
messageLinker: aLinker
	messageLinker := aLinker 
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
methodNativizer
	^cachedNativizer
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
optimizedMethods
	^optimizedMethods
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
optimizedMethods: aCollection
	optimizedMethods := aCollection
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
platform
	^platform
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
platform: aNativizationPlatform
	platform := aNativizationPlatform
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
safepoint
	| index |
	index := self class indexOfGlobal: #Safepoint.
	^(globals at: index) code
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
safepointCheck: anObject
	safepointCheck := anObject 
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
wordSize
	^self abi wordSize
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
wordSizeShift
	^self abi wordSizeShift
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
writeBarrier
	^writeBarrier
! !

!NativizationEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
writeBarrier: aCompiledMethod
	writeBarrier := aCompiledMethod.
	invokedMethods add: writeBarrier 
! !

!NativizationEnvironment methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:43'!
completeInitialization
	cachedNativizer := self newExpressionNativizer 
! !

!NativizationEnvironment methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:43'!
initialize
	busy := false.
	optimizedMethods := OrderedCollection new.
	invokedMethods := OrderedCollection new.
	inlinedMethods := OrderedCollection new.
	messageLinker := CompositeMessageLinker new.
	messageLinker add: InlineMessageLinker new.
	globals := Array new: self class globalNames size.
	self
		initializeGlobals;
		inlinedMethods: self class inlinedMethods;
		invokedMethods: self class invokedMethods;
		optimizedMethods: self class optimizedMethods
! !

!NativizationEnvironment methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:43'!
setupMessageLinkers
	| invoker dispatcher |
	invoker := InvokeLinker new invoker: self invokeStub; addMethods: invokedMethods.
	dispatcher := LookupLinker new initializeFrom: self.
	self
		addLinker: invoker;
		addLinker: dispatcher;
		completeInitialization
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
monomorphicCache
	| asm lookup next |
	asm := platform newAssembler.
	lookup := asm newLabel.
	asm
		loadTwithAindex: 3;
		loadSwithGlobal: #SmallIntegerBehavior.
	next := asm labeledNonIntegerBitTestOfR.
	asm
		loadLongSwithRindex: 0;
		@ next;
		compareSwithTindex: 1;
		shortJumpIfNotEqualTo: lookup;
		loadMwithTindex: 2;
		jumpToMindex: 1;
		@ lookup;
		loadMwithGlobal: #Lookup;
		jumpToMindex: 1;
		applyFixups.
	^asm nativeCode code
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
nativize: aCompiledMethod
	^(self shouldOptimize: aCompiledMethod)
		  ifTrue: [ self nativizeOptimizing: aCompiledMethod ]
		  ifFalse: [ self nativizeWithoutOptimizing: aCompiledMethod ] 
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
nativizeOptimizing: aCompiledMethod
	self optimizingNativizer
		method: aCompiledMethod;
		nativize
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
nativizeWithoutOptimizing: aCompiledMethod
	| method |
	method := self
		nativizerDuring: [ :nativizer | nativizer nativize: aCompiledMethod ].
	^method
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
nativizerDuring: aBlock
	^busy
		  ifFalse: [ 
			  busy := true.
			  [ aBlock value: cachedNativizer ] ensure: [ busy := false ] ]
		  ifTrue: [ 
			  | old |
			  old := cachedNativizer. 
			  [ 
			  cachedNativizer := self newExpressionNativizer.
			  aBlock value: cachedNativizer ] ensure: [ cachedNativizer := old ] ]
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
newExpressionNativizer
	^SExpressionNativizer new environment: self
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
optimizingNativizer
	^OptimizingNativizer new environment: self
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
polymorphicCache
	| asm smi case2 case3 case4 case5 case6 case7 lookup |
	asm := platform newAssembler.
	smi := asm newLabel.
	case2 := asm newLabel.
	case3 := asm newLabel.
	case4 := asm newLabel.
	case5 := asm newLabel.
	case6 := asm newLabel.
	case7 := asm newLabel.
	lookup := asm newLabel.
	asm loadTwithAindex: 3.
	smi := asm labeledNonIntegerBitTestOfR.
	asm
		loadLongSwithRindex: 0;
		compareSwithTindex: 1;
		shortJumpIfNotEqualTo: case2;
		loadMwithTindex: 2;
		jumpToMindex: 1;
		@ case2;
		compareSwithTindex: 3;
		shortJumpIfNotEqualTo: case3;
		loadMwithTindex: 4;
		jumpToMindex: 1;
		@ case3;
		compareSwithTindex: 5;
		shortJumpIfNotEqualTo: case4;
		loadMwithTindex: 6;
		jumpToMindex: 1;
		@ case4;
		compareSwithTindex: 7;
		shortJumpIfNotEqualTo: case5;
		loadMwithTindex: 8;
		jumpToMindex: 1;
		@ case5;
		compareSwithTindex: 9;
		shortJumpIfNotEqualTo: case6;
		loadMwithTindex: 10;
		jumpToMindex: 1;
		@ case6;
		compareSwithTindex: 11;
		shortJumpIfNotEqualTo: case7;
		loadMwithTindex: 12;
		jumpToMindex: 1;
		@ case7;
		compareSwithTindex: 13;
		shortJumpIfNotEqualTo: lookup;
		loadMwithTindex: 14;
		jumpToMindex: 1;
		@ lookup;
		loadMwithGlobal: #Lookup;
		jumpToMindex: 1;
		@ smi;
		loadMwithTindex: 15;
		jumpToMindex: 1;
		applyFixups.
	^asm nativeCode code
! !

!NativizationEnvironment methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:43'!
sexpressionOffsetsOf: code
	| method |
	method := code method.
	(self shouldOptimize: method) ifTrue: [ ^#(  ) ].
	^self nativizerDuring: [ :nativizer |
		  method nativeCode ifNotNil: [ method := method copy ].
		  nativizer compile: method.
		  nativizer sexpressionOffsetsOf: code ]
! !

!NativizationEnvironment methodsFor: 'printing & storing' stamp: 'KenD 11/22/2023 13:59:43'!
printOn:aStream
	"append a printed representation of the receiver to the argument, aStream"

	super printOn:aStream.
	aStream nextPutAll:'(platform: '.
	platform name printOn:aStream.
	aStream nextPut:$)
! !

!NativizationEnvironment methodsFor: 'queries' stamp: 'KenD 11/22/2023 13:59:43'!
shouldInline: aSymbol
	^inlinedMethods anySatisfy: [ :m | m selector = aSymbol ]
! !

!NativizationEnvironment class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
globalNames
	^#(Lookup LookupSuper WriteBarrier Safepoint SmallIntegerBehavior Invoke DebuggableLookup DebuggableLookupSuper)
! !

!NativizationEnvironment class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
indexOfGlobal: aSymbol
	^self globalNames
		indexOf: aSymbol
		ifAbsent: [self error: 'global not found']
! !

!NativizationEnvironment class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
inlinedMethods
	| map |
	map := {
		(ProtoObject -> #(#objectAtValid: #objectAtValid:put: #behavior #class #primitiveAt: #_cachedLookup: #_cachedLookup:in:)).
		(Object -> #(#byteAtValid: #byteAtValid:put: #basicObjectIndexOf: #at:put:)).
		(Species -> #(#instSize #_instancesAreArrayed #_instancesHavePointers #memory #instanceBehavior #primitiveNew #primitiveNew:)).
		(CompiledMethod -> #(#prepareForExecution #isNativized #nativeCode #blockCount #literalIndexFrom:)).
		(CompiledBlock -> #(#argumentCount #blockNumber #blockCode #method)).
		(NativeCode -> #(#code)).
		(GCSpace -> #(#commitedLimit #nextFree #nextFree:)).
		(CharacterArray -> #(#characterAtValid:))}.
	^self undermethods , (self methodSubset: map)
! !

!NativizationEnvironment class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
invokedMethods
	| map |
	map := {
		(ProtoObject -> #(behavior class primitiveAt: #initializeExtended:contentSize:)).
		(Object -> #(#_replaceFrom:to:with:)).
		(Species -> #(#allocate:size: instanceBehavior _instancesAreArrayed _instancesHavePointers #nil:slotsOf: memory primitiveNewBytes: primitiveNewPointers: #zero:bytesOf:))}.
	^self undermethods , (self methodSubset: map)
! !

!NativizationEnvironment class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
methodSubset: aDictionary
	| result |
	result := OrderedCollection new.
	aDictionary keysAndValuesDo: [ :species :selectors | 
		selectors collect: [:sel | | m | species >> sel ifNil: [self ASSERT: false] ] into: result].
	^result
! !

!NativizationEnvironment class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:43'!
optimizedMethods
	| map |
	map := {
		(ProtoObject -> #(behavior class primitiveAt: #primitiveAt:put: #initializeExtended:contentSize:)).
		(Object -> #(at: #at:put: basicByteAt: #basicByteAt:put: byteAtValid: #byteAtValid:put:
					 basicObjectAt: #basicObjectAt:put: #replaceBytesForwardFrom:to:with:startingAt:)).
		(SendSite -> #(_dispatchOn: #_dispatchOn:startingAt: _dispatchDebuggableOn: #_dispatchDebuggableOn:startingAt:)).
		(Species -> #(#allocate:size: primitiveNew primitiveNew: instSize primitiveNewBytes: primitiveNewPointers:)).
		('Float class' -> #(new)).
		(CompiledBlock -> #(argumentCount arity blockCode method)).
		(Closure -> #(value value: #value:value:)).
		(CompiledMethod -> #(blockCount isNativized)).
		(String -> #(at: #at:put: byteAt: #byteAt:put:)).
		(GCSpace -> #(lockedAllocateIfPossible: lockedAllocateUnsafe: shallowCopy:)).
		(Memory -> #(shallowCopy:))}.
	^self undermethods , (self methodSubset: map)
! !

!NativizationPlatform methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
abi
	self ASSERT: abi notNil.  
	^ abi
! !

!NativizationPlatform methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
name
	self ASSERT: name notNil.
	^ name
! !

!NativizationPlatform methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
wordSize
	self ASSERT: wordSize notNil.
	^ wordSize
! !

!NativizationPlatform methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
wordSizeShift
	^ #(0 0 0 2 0 0 0 3) at: self wordSize
! !

!NativizationPlatform methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:42'!
abi: anABI
	self ASSERT: abi isNil.
	self ASSERT: anABI notNil.

	abi := anABI.
! !

!NativizationPlatform methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:42'!
codeGeneratorClass: aClass
	self ASSERT: codeGeneratorClass isNil.
	self ASSERT: aClass notNil.

	codeGeneratorClass := aClass.
! !

!NativizationPlatform methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:42'!
initialize
	"super initialize.   -- commented since inherited method does nothing"
! !

!NativizationPlatform methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:42'!
name: aString
	self ASSERT: name isNil.
	self ASSERT: aString notNil.

	name := aString.
! !

!NativizationPlatform methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:42'!
wordSize: anInteger
	self ASSERT: wordSize isNil.
	self ASSERT:(anInteger == 8 or:[ anInteger == 4]).

	wordSize := anInteger.
! !

!NativizationPlatform methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:42'!
newAssembler
	^ Assembler new platform: self
! !

!NativizationPlatform methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:42'!
newCodeGenerator
	self ASSERT: codeGeneratorClass notNil.

	^ codeGeneratorClass new platform: self.
! !

!NativizationPlatform methodsFor: 'printing & storing' stamp: 'KenD 11/22/2023 13:59:42'!
printOn: aStream
	super printOn:aStream.
	aStream nextPut: $(.
	name printOn:aStream.
	aStream nextPut: $).
! !

!NativizationPlatform class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
default
	"Return the default platform to use for tests. Defaults to host.

	 NEVER, EVER use this for anything but testing!!"

	^ Default ifNil: [ self host ]
! !

!NativizationPlatform class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
default: aNativizationPlatform
	"Set the default platform to use in tests."

	Default := aNativizationPlatform.
! !

!NativizationPlatform class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
host
	"Return platform for the machine this code is running on."

	| host |

	host := Smalltalk host.
	host = 'x86_64-linux-gnu' ifTrue:[ ^ self x86_64_linux_gnu ].
	host = 'x86_64-darwin' ifTrue:[ ^ self x86_64_darwin ].
	host = 'x86_64-win32' ifTrue:[ ^self x86_64_win32 ].

	host = 'riscv64-linux-gnu' ifTrue:[ ^ self riscv64_linux_gnu ].

	self error:'Unssuported host: ', host.
! !

!NativizationPlatform class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
x86_64_darwin
	^ self new
		name: 'x86_64-darwin';
		wordSize: 8;
		abi: SysVX64ABI new;
		codeGeneratorClass: AMD64CodeGenerator;
		yourself
! !

!NativizationPlatform class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
x86_64_linux_gnu
	^ self new
		name: 'x86_64-linux-gnu';
		wordSize: 8;
		abi: SysVX64ABI new;
		codeGeneratorClass: AMD64CodeGenerator;   
		yourself
! !

!NativizationPlatform class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
x86_64_win32
	^ self new
		name: 'x86_64-win32';
		wordSize: 8;
		abi: WinX64ABI new;
		codeGeneratorClass: AMD64CodeGenerator;   
		yourself
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
addFallback: aBlock
	fallbacks add: aBlock
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
argumentAt: index in: envIndex
	envIndex ifNil: [ ^ self argumentInStackAt: index ].
	envIndex < 0
		ifTrue: [ self argumentInlinedAt: index ]
		ifFalse: [ self argumentInEnvironmentAt: index ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
argumentCount
	^activeScript argumentCount
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
argumentInEnvironmentAt: index
	ir loadRwithEindex: index + SClosure instSize
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
argumentInStackAt: index
	| args end |
	args := self argumentCount.
	method hasFrame ifTrue: [ 
		end := 3 + args.
	ir loadRwithFPindex: end - index ] ifFalse: [ 
		end := 2 + args.
		ir  loadRwithSPindex: end - index
	 ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
argumentInlinedAt: index
	self temporaryInStackAt: index
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
associationValueAt: anInteger
	| literal |
	literal := self methodLiteralAt: anInteger.
	ir
		loadRwithLiteral: literal;
		loadRwithRindex: 2
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
associationValueAt: anInteger put: dummy
	| literal |
	literal := self methodLiteralAt: anInteger.
	ir
		loadAwithLiteral: literal;
		storeRinAindex: 2;
		pushA.
	self emitWriteBarrier 
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
captureClosure: anSBlock
	| slot variables |
	self instantiateClosure: anSBlock.
	slot := 3.
	variables := anSBlock capturedVariables readStream.
	[ variables atEnd ]
		whileFalse: [ self captureVariable: variables index: slot.
			slot := slot + 1 ].
	anSBlock capturesHome
		ifTrue: [ self emitSend: #saveHomeFrame ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
captureVariable: stream index: anInteger
	| type pos |
	type := stream next.
	type = nil ifTrue: [^self].
	type = Self ifTrue: [^ir storeSinRindex: anInteger].
	type = Environment ifTrue: [^ir storeEinRindex: anInteger].
	pos := stream next.
	type = LocalArgument ifTrue: [
		ir
			loadTwithFPindex: pos + 2;
			storeTinRindex: anInteger].
	type = EnvironmentValue
		ifTrue: [ir loadTwithEindex: pos; storeTinRindex: anInteger]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
constPoolValueAt: anInteger
	| literal |
	literal := self methodLiteralAt: anInteger.
	ir loadRwithLiteral: literal
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
dropTos
	ir dropTos: 1.
	^stackCount := stackCount - 1
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitBlockPrologue: anSBlock
	ir saveCallerFrame.
	self
		loadBlockSelf: anSBlock compiledCode;
		loadBlockNativeCode;
		pushNativeCode;
		pushEnvironments;
		initializeTemporaries: anSBlock tempCount
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitCallbackEpilogue
	ir restoreCallerFrame.
	environment abi
		restoreContext: method descriptor with: ir
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitCallbackPrologue
	| retaddr |
	environment abi emitEntrypoint: method descriptor with: ir.
	retaddr := 0.
	ir
		pushImm: retaddr;
		xorFPwithFP;
		loadLongMwithIPoffset: 0 - ir currentAddress + ImageSegmentWriter behaviorOffset;
		loadMwithMindex: SCallbackMethod behaviorNativeCodeSlot;
		loadGwithLiteral: environment globals;
		loadNilWithLiteral: nil;
		loadTrueWithLiteral: true;
		loadFalseWithLiteral: false;
		loadEwithNil;
		loadRwithMindex: (NativeCode indexOfSlot: 'compiledCode');
		loadRwithRindex: (SCallbackMethod indexOfSlot: 'receiver')
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitEpilogue
	method hasBlocks
		ifTrue: [ ir restoreCallerEnvironment ].
	method isCallback
		ifTrue: [ ^ self emitCallbackEpilogue ].
	method isFrameless
		ifFalse: [ ir restoreCallerFrame ].
	ir
		restoreCallerSelf;
		restoreCallerM;
		return
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitFFICall
	self loadObject: method.
	ir pushR; pushS.
	self emitSend: #_ffiCall:.
	ir
		restoreCallerFrame;
		restoreCallerSelf;
		restoreCallerM;
		return
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitFallbacks
	fallbacks do: [:block | block value]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitFramedMethodPrologue
	ir
		saveCallerFrame;
		pushR;
		initializeS.
	method isCalloutMethod
		ifTrue: [ self emitFFICall ]
		ifFalse: [ self
				pushNativeCode;
				initializeMethodEnvironment;
				initializeMethodTemporaries;
				emitSafepointCheck ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitFramelessMethodPrologue
	method capturesSelf
		ifTrue: [ ir initializeS ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitMethodPrologue
	method isCallback
		ifTrue: [ ^self
				emitCallbackPrologue;
				emitFramedMethodPrologue ].
	method isFrameless
		ifTrue: [ self emitFramelessMethodPrologue ]
		ifFalse: [ self emitFramedMethodPrologue ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitSafepointCheck
	
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitSend: selector
 	| linker |
	linker := environment messageLinker.
	method isDebuggable
		ifTrue: [ linker emitSendDebuggable: selector using: ir ]
		ifFalse: [ linker emitSend: selector using: ir ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitSend: selector super: aBoolean
	| linker |
	linker := environment messageLinker.
	
	method isDebuggable
		ifTrue: [ aBoolean ifTrue: [linker emitSendSuperDebuggable: selector from: method classBinding using: ir] ifFalse: [linker emitSendDebuggable: selector using: ir ]]
		ifFalse: [ aBoolean ifTrue: [linker emitSendSuper: selector from: method classBinding using: ir ] ifFalse: [linker emitSend: selector using: ir ]]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
emitWriteBarrier
	ir
		loadAwithGlobal: #WriteBarrier;
		callIndirectA;
		discardArguments: 1
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
falseLiteral
	ir loadRwithFalse
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
initializeMethodEnvironment
	method hasBlocks
		ifFalse: [ ^ self ].
	ir pushE.
	method hasEnvironment
		ifTrue: [ ir
				pushSmallInteger: method environmentCount;
				loadRwithM.
			self emitSend: #newEnvironment:.
			ir
				loadEwithR;
				pushE ]
		ifFalse: [ ir pushNil ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
initializeMethodTemporaries
	self initializeTemporaries: method tempCount
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
initializeTemporaries: count
	count = 0
		ifTrue: [ ^ self ].
	count <= 6
		ifTrue: [ count timesRepeat: [ ir pushNil ] ]
		ifFalse: [ ir
				loop: [ ir pushNil ] times: count ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
instanceVarAt: index
	ir loadRwithSindex: index
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
instanceVarAt: index put: value
	ir storeRinSindex: index; pushS.
	self emitWriteBarrier
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
instantiateClosure: anSBlock
	self loadLiteralAt: anSBlock index; emitSend: #newClosure
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithArgument: index in: envIndex
	envIndex
		ifNil: [ ^ self loadAwithArgumentInStackAt: index ]. envIndex < 0
		ifTrue: [ self loadAwithArgumentInlinedAt: index ]
		ifFalse: [ self loadAwithArgumentInEnvironment: envIndex at: index ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithArgumentInEnvironment: envIndex at: index
	| offset |
	envIndex = 0
		ifTrue: [ ir loadAwithEindex: index + SClosure instSize ]
		ifFalse: [ offset := activeScript offsetOfEnvironment: envIndex.
			ir
				loadAwithEindex: envIndex + SClosure instSize;
				loadAwithAindex: index + offset ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithArgumentInStackAt: index
		| end |
	end := 3 + self argumentCount.
			ir loadAwithFPindex: end - index

! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithArgumentInlinedAt: index
	self loadAwithTemporaryInStackAt: index

! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithStack: anInteger
	ir loadAwithFPindex: 1 - anInteger
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithTemporary: index in: envIndex

	envIndex
		ifNil: [ self loadAwithTemporaryInStackAt: index ]
		ifNotNil: [ 
		self loadAwithTemporaryInEnvironment: envIndex at: index ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithTemporaryInEnvironment: envIndex at: index
	| offset |
	envIndex = 0
		ifTrue: [offset := activeScript offsetOfCurrentEnvironment. ir loadAwithEindex: index + offset ]
		ifFalse: [ offset := activeScript offsetOfEnvironment: envIndex.
			ir
				loadAwithEindex: envIndex + SClosure instSize;
				loadAwithAindex: index + offset ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadAwithTemporaryInStackAt: index
			| start |
	start := self pushesEnvironments
					 ifTrue: [ -3 ]
					 ifFalse: [ -1 ].
		^ ir loadAwithFPindex: start - index

! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadBlockNativeCode
	| block nativeCode |
	block := SClosure indexOfSlot: 'block'.
	nativeCode := SCompiledBlock indexOfSlot: 'nativeCode'.
	ir
		loadMwithRindex: block;
		loadMwithMindex: nativeCode
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadBlockSelf: aCompiledBlock
	| offset | 
	aCompiledBlock capturesSelf
		ifTrue: [ offset := aCompiledBlock capturesHome
				ifTrue: [ 1 ]
				ifFalse: [ 0 ].
			ir loadSwithRindex: SClosure instSize + 1 + offset ]
		ifFalse: [ ir loadSwithNil ].
	ir pushS
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadLiteralAt: anInteger
	| literal |
	literal := self methodLiteralAt: anInteger.
	ir loadRwithLiteral: literal
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadObject: anObject
	ir 	 loadRwithLiteral:  anObject
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadRwithStack: anInteger
	ir loadRwithFPindex: 1 - anInteger
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
loadTwithStack: anInteger
	ir loadTwithFPindex: 1 - anInteger
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
methodLiteralAt: anInteger
	^ method at: anInteger
	
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
methodLiteralFrom: anInteger
	^ method at: anInteger
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
nativeCode
	^mainCode
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
nativize
	method sexpressions acceptVisitor: self.
	[remainingBlocks isEmpty]
		whileFalse: [self nativizeBlock: remainingBlocks removeFirst]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
nativize: aCompiledMethod
	self
		resetFor: aCompiledMethod;
		nativize.
	^ aCompiledMethod nativeCode: mainCode
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
nativizeBlock: anSBlock
	| statements |
	self resetForBlock: anSBlock.
	activeScript := anSBlock.
	self emitBlockPrologue: anSBlock.
	statements := anSBlock statements.
	statements do: [:s | s acceptVisitor: self].
	self saveContextSwitchPoint.
	(statements isEmpty orNot: [statements last isReturn])
		ifTrue: [self emitEpilogue].
	self emitFallbacks.
	anSBlock compiledCode nativeCode: ir applyFixups nativeCode
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
nilLiteral
	ir loadRwithNil
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
popR
	ir popR.
	stackCount := stackCount - 1
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
pushEnvironments
	ir pushE; loadEwithR; pushE
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
pushNativeCode
	ir pushM
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
pushR
	ir pushR.
	^stackCount := stackCount + 1
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
pushesEnvironments
	^method hasBlocks
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
receiver
	ir loadRwithS
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
resetFor: aCompiledMethod
	| fixed |
	method := aCompiledMethod.
	fallbacks := OrderedCollection new.
	remainingBlocks := OrderedCollection new.
	fixed := aCompiledMethod hasBlocks ifTrue: [4] ifFalse: [2].
	stackCount := aCompiledMethod tempCount + fixed.
	ir reset
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
resetForBlock: anSBlock
	fallbacks := OrderedCollection new.
	stackCount := anSBlock tempCount + 4.
	ir reset
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
saveContextSwitchPoint
	method isDebuggable
		ifFalse: [ ^ self ].
	ir
		pushA;
		pushT;
		pushR.
	environment messageLinker emitSend: #signalStep using: ir.
	ir
		popR;
		popT;
		popA
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
saveMethodCode
	mainCode := ir
					applyFixups;
					nativeCode
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
storeRInStack: index
	ir storeRinFPindex: 1 - index
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
temporaryAt: index in: envIndex
	envIndex ifNil: [ self temporaryInStackAt: index ]
ifNotNil: [ self temporaryInEnvironment: envIndex at: index ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
temporaryAt: index in: envIndex put: dummy
	envIndex ifNil: [self temporaryInStackAtPut: index ] ifNotNil: [ 
	self temporaryInEnvironment: envIndex atPut: index]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
temporaryInEnvironment: envIndex at: index
	| offset |
	envIndex = 0
		ifTrue: [offset := activeScript offsetOfCurrentEnvironment. ir loadRwithEindex: index + offset ]
		ifFalse: [ 
			offset := activeScript offsetOfEnvironment: envIndex.
			ir
				loadRwithEindex: envIndex + SClosure instSize ;
				loadRwithRindex: index + offset]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
temporaryInEnvironment: envIndex atPut: index
	| offset |
	envIndex = 0
		ifTrue: [ offset := activeScript offsetOfCurrentEnvironment.
			ir
				storeRinEindex: index + offset;
				pushE ]
		ifFalse: [ offset := activeScript offsetOfEnvironment: envIndex.
			ir
				loadTwithEindex: envIndex + SClosure instSize ;
				storeRinTindex: index + offset;
				pushT ].
	self emitWriteBarrier
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
temporaryInStackAt: index
		| start |
	start := self pushesEnvironments
					 ifTrue: [ -3 ]
					 ifFalse: [ -1 ].
		^ ir loadRwithFPindex: start - index .

! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
temporaryInStackAtPut: index
			| start |
	start := self pushesEnvironments
						 ifTrue: [ -3 ]
						 ifFalse: [ -1 ].
			ir storeRinFPindex: start - index

! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
trueLiteral
	ir loadRwithTrue
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitAssignment: anSAssignment
	anSAssignment expression acceptVisitor: self.
	anSAssignment assignees do: [ :a | 
		a binding assign: nil within: self ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitBlock: anSBlock
	anSBlock isInlined
		ifTrue: [ ^ anSBlock statements do: [ :s | s acceptVisitor: self ] ].
	remainingBlocks add: anSBlock.
	self captureClosure: anSBlock 
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitCascade: anSCascade
	| receiver index |
	receiver := anSCascade receiver.
	receiver acceptVisitor: self.
	index := self pushR.
	anSCascade messages
		do: [ :m | self visitCascadeMessage: m receiver: index super: receiver isSuper ].
	self dropTos
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitCascadeMessage: anSCascadeMessage receiver: index super: aBoolean
	| arguments |
	arguments := anSCascadeMessage arguments.
	arguments
		do: [ :node | 
			node acceptVisitor: self.
			self pushR ].
	self
		loadRwithStack: index;
		emitSend: anSCascadeMessage selector super: aBoolean.
	stackCount := stackCount - arguments size
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitIdentifier: anSIdentifier
	anSIdentifier binding valueWithin: self
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitInlinedMessage: anSMessage
	| nativizer |
	nativizer := InlinedMessageNativizer new
		message: anSMessage;
		assembler: ir;
		nativizer: self.
	nativizer inlineMessage
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitLiteral: anSLiteral
	| value |
	value := anSLiteral value.
	value isSmallInteger
		ifTrue: [ ir loadRwithSmallInteger: value ]
		ifFalse: [ self loadLiteralAt: anSLiteral index ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitMessage: anSMessage
	| arguments index |
	anSMessage isInlined
		ifTrue: [ ^ self visitInlinedMessage: anSMessage ].
	anSMessage isOptimized
		ifTrue: [ ^ self visitOptimizedMessage: anSMessage ].
	anSMessage receiver acceptVisitor: self.
	arguments := anSMessage arguments.
	arguments isEmpty
		ifFalse: [ index := self pushR.
			arguments
				do: [ :node | 
					node acceptVisitor: self.
					self pushR ].
			self loadRwithStack: index ].
	self emitSend: anSMessage selector super: anSMessage receiver isSuper.
	stackCount := stackCount - arguments size.
	arguments isEmpty
		ifFalse: [ self dropTos ]
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitMethod: anSMethod
	| statements returned |
	activeScript := anSMethod.
	self emitMethodPrologue.
	statements := anSMethod statements.
	statements do: [ :s | s acceptVisitor: self ].
	(statements notEmpty andNot: [ statements last isReturn ])
		ifTrue: [ ir loadRwithS ].
	returned := statements notEmpty and: [ 	
	statements last isReturn].
	returned ifFalse: [ self emitEpilogue ].
	self
		emitFallbacks;
		saveMethodCode
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitOptimizedMessage: anSMessage
	| nativizer |
	nativizer := BinaryMessageNativizer new
		message: anSMessage;
		assembler: ir;
		nativizer: self.
	nativizer inlineMessage
! !

!SExpressionNativizer methodsFor: 'services' stamp: 'KenD 11/22/2023 13:59:38'!
visitReturn: anSReturn
  anSReturn expression acceptVisitor: self.
  anSReturn local ifTrue: [ self emitEpilogue ] ifFalse: [ ir
		   pushR;
		   loadRwithE.
		self emitSend: #_return: ] 
! !

!SExpressionNativizer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:38'!
environment: aNativizationEnvironment
	environment := aNativizationEnvironment.
	ir := environment platform newAssembler
! !

!SExpressionNativizer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:38'!
method
	^method
! !

!SExpressionNativizer methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:38'!
initialize
	super initialize.
! !

!SExpressionNativizer methodsFor: 'templates' stamp: 'KenD 11/22/2023 13:59:38'!
sendMustBeBoolean
	self emitSend: #mustBeBoolean
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyFor: aCompiledMethod
	^ NativizationEnvironment forTesting
		newExpressionNativizer nativize: aCompiledMethod
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForBlock
	^self assemblyForSource: 'foo [1] value'
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForIfTrue
	^self assemblyForSource: 'foo x ifTrue: [1]' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForMessage
	^self assemblyForSource: 'foo self bar'
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForMessageCascade
	^self assemblyForSource: 'foo self bar; baz'
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForMethod: aCompiledMethod

^	self
		assemblyForSource: aCompiledMethod sourceCode
		in: aCompiledMethod classBinding value.

! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForPoint_1_plus_y
	^self assemblyForSource: 'foo 1 + y' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForPoint_ret_x_eq_1
	^ self assemblyForSource: 'foo ^x = 1' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForPoint_x
	^ self assemblyForMethod: Point >> #x
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForPoint_x_eq_1
	^self assemblyForSource: 'foo x = 1' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForPoint_x_eq_eq_1
	^self assemblyForSource: 'foo x == 1' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForPoint_x_plus_1
	^self assemblyForSource: 'foo x + 1' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForPoint_x_plus_y
	^self assemblyForSource: 'foo x + y' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForSource: aString
	^self assemblyForSource: aString in: UndefinedObject
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForSource: aString in: aSpecies
	| method |
	method := SCompiler compile: aString in: aSpecies.
	^self assemblyFor: method
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForSourceOrig: aString
	^self assemblyForSourceOrig: aString in: UndefinedObject
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForSourceOrig: aString in: aSpecies
	| method |
	method := SCompiler compile: aString in: aSpecies.
	^self assemblyOrigFor: method
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyForWhileTrue
	^self assemblyForSource: 'foo [x := x + 1. true] whileTrue' in: Point
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
assemblyOrigFor: aCompiledMethod
	^ NativizationEnvironment forTesting nativize:
		  aCompiledMethod
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
methodBasicAdd
	| source |
	source := 'basicAdd: anObject
	end = contents size ifTrue: [self makeRoomBehind].
	end := end + 1.
	contents at: end put: anObject.
	^anObject'.
	^self methodForSource: source in: OrderedCollection
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
methodForSource: aString
	^self methodForSource: aString in: UndefinedObject
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
methodForSource: aString in: aSpecies
	| method |
	method := SCompiler compile: aString in: aSpecies.
	^self nativize: method
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
methodWithBlock
	^self methodForSource: 'foo [1] value'
! !

!SExpressionNativizer class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:38'!
nativize: aCompiledMethod

	^ NativizationEnvironment forTesting newExpressionNativizer
		nativize: aCompiledMethod
! !

!SendSite methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
beSuperSend
	format := format bitOr: IsSuperSend
! !

!SendSite methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
initialize
	tally := 0.
	format := 0
! !

!SendSite methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
instructions: aByteArray
	instructions := aByteArray
! !

!SendSite methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
isSuperSend
	^(format bitAnd: IsSuperSend) == IsSuperSend
! !

!SendSite methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
selector
	^selector
! !

!SendSite methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:42'!
selector: aSymbol
	selector := aSymbol
! !

!SendSite methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:59:42'!
invoke: aCompiledMethod using: invokeInstructions
	instructions := invokeInstructions.
	selector := aCompiledMethod selector.
	cache := aCompiledMethod
! !

!SendSite methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 13:59:42'!
lookup: aSymbol using: lookupInstructions
	instructions := lookupInstructions.
	selector := aSymbol
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
bindingTypeOf: id
	^ BindingTypes at: id
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeArgument
	^ SArgumentBinding new
		index: self nextInteger;
		environment: self nextEnvironment
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeAssignment
	| assignment assignees |
	assignment := SAssignment new.
	
	assignees := self nextExpressionArray.
	assignment expression: self nextExpression.
	assignees do: [ :identifier | assignment assign: identifier ].
	^ assignment
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeBlock

	| expression inlined block index code |
	expression := SBlock new.
	inlined := self nextBoolean.
	inlined
		ifTrue: [ expression inlinedArgs: self nextArray ]
		ifFalse: [ 
			index := self nextInteger.
			block := self literalAt: index.
			builder ifNotNil: [ 
				code := builder newExecutableCodeFor: expression.
				builder blockExecutableCode: block put: code ].
			expression
				compiledCode: block;
				index: index;
				capturedVariables: self nextArray ].
	expression statements: self nextExpressionArray.
	^ expression
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeCascade
	| cascade receiver messages message count |
	cascade := SCascade new.
	receiver := self nextExpression.
	count := self nextInteger.
	messages := (1 to: count)
		collect: [ :i | 
			message := SCascadeMessage decodeUsing: self.
			message cascade: cascade ].
	^ cascade
		receiver: receiver;
		messages: messages
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeCascadeMessage
	| selector arguments |
	selector := self nextSymbol.
	arguments := self nextExpressionArray.
	^ SCascadeMessage new
		selector: selector;
		arguments: arguments
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeDynamicVar
	^ SDynamicBinding new name: self nextSymbol
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeIdentifier
	| type binding |
	type := self bindingTypeOf: self nextInteger.
	binding := type decodeUsing: self.
	^ SIdentifier new binding: binding
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeLiteral
	| index value |
	index := self nextInteger.
	value := index = 0
		ifTrue: [ self nextLiteralInteger ]
		ifFalse: [ self literalAt: index ].
	^ SLiteral new
		index: index;
		value: value
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeMessage
	| inlined selector receiver arguments |
	inlined := self nextBoolean.
	selector := self nextSymbol.
	receiver := self nextExpression.
	arguments := self nextExpressionArray.
	^ SMessage new
		receiver: receiver;
		selector: selector;
		arguments: arguments;
		inlined: inlined
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeMethod
	| type node next pragma |
	type := stream next.
	type !!= MethodId
		ifTrue: [ self error: 'method astcode expected' ].
	node := SMethod new.
	next := stream peek.
	next = PragmaId
		ifTrue: [ stream next.
			pragma := SPragma new name: self nextSymbolOrNil.
			node pragma: pragma ].
	node
		compiledCode: method;
		statements: self nextExpressionArray.
	^ node
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeNestedDynamicVar
	^ SNestedDynamicBinding new
		name:
			self nextSymbol.

! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeReturn
	| expression local |
	local := self nextBoolean.
	expression := self nextExpression.
	^ SReturn new
		local: local;
		expression: expression
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
decodeTemporary
	^ STemporaryBinding new
		index: self nextInteger;
		environment: self nextEnvironment
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
nextArray
	| count |
	count := self nextInteger.
	^ stream next: count
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
nextEnvironment
	| value |
	value := self nextInteger.
	^ value !!= -2
		ifTrue: [ value ]
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
nextExpression
	| type |
	type := self nodeTypeOf: stream next.
	^type decodeUsing: self.

! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
nextExpressionArray
	| count |
	count := self nextInteger.
	^(1 to: count) collect: [ :arg | self nextExpression ]
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
nextSymbol
	| index |
	index := self nextInteger.
	^ self literalAt: index
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
nextSymbolOrNil
	| index |
	index := self nextInteger.
	^index !!= 0 ifTrue: [ self literalAt: index]
! !

!AstcodeDecoder methodsFor: 'public' stamp: 'KenD 11/22/2023 07:48:47'!
nodeTypeOf: id
	^NodeTypes at: id
! !

!AstcodeDecoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
builder: aRuntime
	builder := aRuntime
! !

!AstcodeDecoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
method: aMethod
	method := aMethod
! !

!AstcodeDecoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
stream: aStream
	stream := aStream
! !

!AstcodeDecoder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:47'!
literalAt: anInteger
	^ builder ifNil: [method at: anInteger] ifNotNil: [builder method: method literalAt: anInteger]
! !

!AstcodeDecoder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:47'!
nextLiteralInteger
	| value |
	value := self nextInteger.
	^ builder
		ifNil: [ value ]
		ifNotNil: [ builder newInteger: value ]
! !

!AstcodeDecoder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
nextBoolean
	^ stream next = 1
! !

!AstcodeDecoder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
nextInteger
	| value |
	value := stream next.
	value = 16r80
		ifTrue: [ ^ stream int64 ].
	^ value <= 127
		ifTrue: [ value ]
		ifFalse: [ value - 16r100 ]
! !

!AstcodeDecoder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:47'!
nextUnsignedInteger
	| value |
	value := self nextByte.
	^value < 128
		ifTrue: [value]
		ifFalse: [value - 128 + (self nextUnsignedInteger bitShift: 7)]
! !

!AstcodeDecoder class methodsFor: 'class initialization' stamp: 'KenD 11/22/2023 07:48:47'!
initialize
	NodeTypes := Dictionary new.
	BindingTypes := Dictionary new.
	NodeTypes
		at: AssignmentId put: SAssignment;
		at: BlockId put: SBlock;
		at: CascadeId put: SCascade;
		at: LiteralId put: SLiteral;
		at: IdentifierId put: SIdentifier;
		at: MessageId put: SMessage;
		at: ReturnId put: SReturn.
	BindingTypes
		at: NilId put: SNilBinding;
		at: TrueId put: STrueBinding;
		at: FalseId put: SFalseBinding;
		at: ArgumentId put: SArgumentBinding;
		at: TemporaryId put: STemporaryBinding;
		at: SelfId put: SSelfBinding;
		at: SuperId put: SSuperBinding;
		at: DynamicVarId put: SDynamicBinding;
		at: NestedDynamicVarId put: SNestedDynamicBinding
! !

!AstcodeDecoder class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:47'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
assign: value within: aPowertalkRuntime
	^ self subclassResponsibility
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isArgument
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isAssociation
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isClassBinding
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isClassVar
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isDynamic
	^ false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isInstVar
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isLiteral
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isPoolVar
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isSelf
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isSuper
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
isTemporary
	^false
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
name
	^self printString
! !

!SBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:11'!
valueWithin: anEvaluationContext
	^ self subclassResponsibility
! !

!SBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:49:11'!
decodeUsing: anAstcodeDecoder
	^self subclassResponsibility
! !

!SAssociationBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:55'!
assign: value within: anEvaluationContext
	anEvaluationContext storeAssociation: association value: value
! !

!SAssociationBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:55'!
index
	^ index
! !

!SAssociationBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:55'!
index: anInteger
	 index := anInteger 
! !

!SAssociationBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:55'!
isAssociation
	^true
! !

!SAssociationBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:55'!
isConstant
	^ false
! !

!SAssociationBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:55'!
valueWithin: anEvaluationContext
	^ anEvaluationContext loadAssociationValue: association
! !

!SAssociationBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
association
	^association
! !

!SAssociationBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
association: anAssociation
	association := anAssociation
! !

!SDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
assign: value within: anEvaluationContext
	cache ifNil: [ self lookupWithin: anEvaluationContext ].
	cache assign: value within: anEvaluationContext
! !

!SDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
isDynamic
	^true
! !

!SDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
lookupWithin: anEvaluationContext
	cache := anEvaluationContext staticBindingFor: name
! !

!SDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
name
	name
! !

!SDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
name: aSymbol
	name := aSymbol
! !

!SDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
printOn: aStream
	aStream
		nextPutAll: 'DinamicVarId. ';
		nextPutAll: name printString
! !

!SDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:49'!
valueWithin: anEvaluationContext
	cache ifNil: [ self lookupWithin: anEvaluationContext ].
	^ cache valueWithin: anEvaluationContext
! !

!SDynamicBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:49'!
decodeUsing: anAstcodeDecoder
	^ anAstcodeDecoder decodeDynamicVar
! !

!SNestedDynamicBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
lookupWithin: anEvaluationContext
	cache := anEvaluationContext staticBindingForNested: name
! !

!SNestedDynamicBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:48'!
decodeUsing: anAstcodeDecoder
	^ anAstcodeDecoder decodeNestedDynamicVar
! !

!SInstVarBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
assign: value within: anEvaluationContext
	anEvaluationContext instanceVarAt: index put: value
! !

!SInstVarBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
isInstVar
	^true
! !

!SInstVarBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:14'!
printOn: aStream
	aStream nextPutAll: 'InstVarId. '; nextPutAll: index printString
! !

!SInstVarBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:14'!
index
	^index
! !

!SInstVarBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:14'!
index: anInteger
	index := anInteger
! !

!SInstVarBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:14'!
valueWithin: anEvaluationContext
	^ anEvaluationContext instanceVarAt: index
! !

!SInstVarBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:14'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeInstVar
! !

!SLiteralBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:05'!
isLiteral
	^true
! !

!SLiteralBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:49:05'!
decodeUsing: anAstcodeDecoder
	^self new
! !

!SFalseBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:44'!
printOn: aStream
	aStream nextPutAll: 'FalseId'
! !

!SFalseBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:44'!
value
	^false
! !

!SFalseBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:44'!
valueWithin: anEvaluationContext
	^ anEvaluationContext false
! !

!SNilBinding methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:48:17'!
printOn: aStream
	aStream nextPutAll: 'NilId'
! !

!SNilBinding methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:48:17'!
value
	^nil
! !

!SNilBinding methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:48:17'!
valueWithin: anEvaluationContext
	^ anEvaluationContext nil
! !

!STrueBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:03'!
printOn: aStream
	aStream nextPutAll: 'TrueId'
! !

!STrueBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:03'!
value
	^true
! !

!STrueBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:03'!
valueWithin: anEvaluationContext
	^ anEvaluationContext true
! !

!SLocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:16'!
environment
	^environment
! !

!SLocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:16'!
environment: anInteger
	environment := anInteger
! !

!SLocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:16'!
index
	^position
! !

!SLocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:16'!
index: anInteger
	position := anInteger
! !

!SLocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:16'!
isInStack
	self ASSERT: false.
	^ environment = 0
! !

!SArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:56'!
assign: value within: anEvaluationContext
	self halt
! !

!SArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:56'!
isArgument
	^true
! !

!SArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:56'!
isInlined
	^ environment = -1
! !

!SArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:56'!
printOn: aStream
	aStream
		nextPutAll: 'SArgument ';
		print: position;
		nextPutAll: ' @ env ';
		print: environment
! !

!SArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:56'!
valueWithin: anEvaluationContext
	^ anEvaluationContext argumentAt: position in: environment
! !

!SArgumentBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:56'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeArgument
! !

!STemporaryBinding methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
assign: value within: anEvaluationContext
	anEvaluationContext temporaryAt: position in: environment put: value
! !

!STemporaryBinding methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
printOn: aStream
	aStream
		nextPutAll: 'STemporary ';
		print: position;
		nextPutAll: ' @ env ';
		print: environment
! !

!STemporaryBinding methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
valueWithin: anEvaluationContext
	^ anEvaluationContext temporaryAt: position in: environment
! !

!STemporaryBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:51'!
isInCurrentEnvironment
	^environment = 1
! !

!STemporaryBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:51'!
isTemporary
	^true
! !

!STemporaryBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeTemporary
! !

!SSelfBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:09'!
isSelf
	^true
! !

!SSelfBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:09'!
valueWithin: anEvaluationContext
	^ anEvaluationContext receiver
! !

!SSelfBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
printOn: aStream
	aStream nextPutAll: 'SelfId'
! !

!SSelfBinding class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:49:09'!
decodeUsing: anAstcodeDecoder
	^self new
! !

!SSuperBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
isSelf
	^false
! !

!SSuperBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
isSuper
	^true
! !

!SSuperBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:43'!
printOn: aStream
	aStream nextPutAll: 'SuperId'
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
acceptVisitor: visitor
	^self subclassResponsibility
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isAssignment
	^false
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isCascade
	^false
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isCascadeMessage
	^false
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isIdentifier
	^false
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isLiteral
	^false
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isMessage
	^false
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isReturn
	^false
! !

!SExpression methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:12'!
isSuper
	^ false
! !

!SExpression methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:12'!
isInstVar
	^false
! !

!SExpression methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:12'!
isMethod
	^false
! !

!SExpression methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:12'!
printOn: aStream
	self printOn: aStream indent: 0
! !

!SExpression methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:12'!
printOn: aStream indent: anInteger
	super printOn: aStream
! !

!SAssignment methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
acceptVisitor: visitor
	^visitor visitAssignment: self
! !

!SAssignment methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
assignees
	^assignees
! !

!SAssignment methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
expression
	^expression
! !

!SAssignment methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
expression: anSExpression
	expression := anSExpression
! !

!SAssignment methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
initialize
	assignees := OrderedCollection new
! !

!SAssignment methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:50'!
assign: anSIdentifier
	assignees add: anSIdentifier
! !

!SAssignment methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:50'!
isAssignment
	^true
! !

!SAssignment methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:50'!
printOn: aStream indent: anInteger
	aStream tab: anInteger; nextPutAll: '{AssignmentId.'.
	assignees
		do: [:identifier | 
			aStream cr.
			identifier printOn: aStream indent: anInteger + 1]
		separatedBy: [aStream nextPutAll: '.'].
	aStream nextPutAll: '.'; cr.
	expression printOn: aStream indent: anInteger + 1.
	aStream nextPutAll: '}'
! !

!SAssignment class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:50'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeAssignment
! !

!SAssignment class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:50'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SCascade methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:55'!
acceptVisitor: visitor
	^visitor visitCascade: self
! !

!SCascade methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:55'!
isCascade
	^true
! !

!SCascade methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
messages
	^messages
! !

!SCascade methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
messages: aCollection
	messages := aCollection
! !

!SCascade methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
receiver
	^receiver
! !

!SCascade methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:55'!
receiver: anSExpression
	receiver := anSExpression
! !

!SCascade class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:55'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeCascade
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
acceptVisitor: visitor
	^ visitor visitCascadeMessage: self
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
argumentCount
	^arguments size
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
arguments
	^arguments
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
arguments: aCollection
	arguments := aCollection
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
cache: anSCompiledMethod when: type
	cache ifNil: [ ^ cache := Array with: type with: anSCompiledMethod ].
	cache := cache , (Array with: type with: anSCompiledMethod)
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
cacheUndermessage: aBlockClosure
	cache := aBlockClosure
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
cachedUndermessage
	^ cache isBlock
		ifTrue: [ cache ]
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
cascade
	cascade
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
cascade: anSCascade
	cascade := anSCascade
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
flushCache
	cache := nil
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
isCascadeMessage
	^true
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
methodFor: requiredType
	| type |
	cache ifNil: [ ^ nil ].
	1 to: cache size by: 2 do: [ :i | 
		type := cache at: i.
		type == requiredType
			ifTrue: [ ^ cache at: i + 1 ] ].
	^ nil
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
receiver
	^cascade receiver
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
registerCacheWith: runtime
	cache ifNil: [ runtime registerCache: self for: selector ]
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
selector
	^selector
! !

!SCascadeMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:16'!
selector: aSymbol
	selector := aSymbol
! !

!SCascadeMessage class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:16'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeCascadeMessage
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
acceptVisitor: visitor
	^visitor visitIdentifier: self
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
binding: aBinding
	binding := aBinding
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isArgument
	^binding isArgument
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isAssociation
	^binding isAssociation
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isIdentifier
	^true
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isInstVar
	^binding isInstVar
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isLiteral
	^binding isLiteral
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isSelf
	^binding isSelf
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isSelfOrSuper
	^binding isSelf or: [binding isSuper]
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isSuper
	^binding isSuper
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isTemporary
	^binding isTemporary
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
isVariable
	^true
! !

!SIdentifier methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:50'!
printOn: aStream indent: anInteger
	aStream
		tab: anInteger;
		nextPutAll: '{IdentifierId. ';
		print: binding;
		nextPutAll: '}'
! !

!SIdentifier methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:50'!
binding
	^binding
! !

!SIdentifier class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:50'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeIdentifier
! !

!SLiteralVar methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:18'!
index
	^index
! !

!SLiteralVar methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:18'!
index: anInteger
	index := anInteger
! !

!SLiteral methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:45'!
acceptVisitor: visitor
	^ visitor visitLiteral: self
! !

!SLiteral methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:45'!
isLiteral
	^true
! !

!SLiteral methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:45'!
value
	^value
! !

!SLiteral methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:45'!
value: anObject
	value := anObject
! !

!SLiteral methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:48:45'!
printOn: aStream indent: anInteger
	aStream
		tab: anInteger;
		nextPutAll: '{LiteralId. ';
		print: value;
		nextPutAll: '}'
! !

!SLiteral class methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:48:45'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeLiteral
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
acceptVisitor: visitor
	^visitor visitMessage: self
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
arguments
	^arguments
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
arguments: aCollection
	arguments := aCollection
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
cache: anSCompiledMethod when: type
	cache
		ifNil: [ ^ cache := Array with: type with:
			anSCompiledMethod].
	cache := cache
		,
			(Array with: type with: 
			anSCompiledMethod)
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
cacheUndermessage: aBlockClosure
	cache := aBlockClosure
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
cachedUndermessage
	^cache isBlock ifTrue: [ cache ]
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
flushCache
	cache := nil
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
initialize
	super initialize.
	arguments := #().
	inlined := false
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
isInlined
	^ inlined
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
isMessage
	^true
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
methodFor: requiredType
	| type |
	cache ifNil: [ ^ nil ].
	1 to: cache size by: 2 do: [ :i | 
		type := cache at: i.
		type == requiredType
			ifTrue: [ ^ cache at: i + 1 ] ].
	^ nil
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
printOn: aStream indent: anInteger
	aStream tab: anInteger; nextPutAll: '{MessageId. '; print: selector; nextPutAll: '. '; cr.
	receiver printOn: aStream indent: anInteger + 1.
	aStream nextPutAll: '.'; cr.
	arguments
		do: [:statement | statement printOn: aStream indent: anInteger + 1]
		separatedBy: [aStream nextPutAll: '. '; cr].
	aStream nextPutAll: '}'
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
receiver
	^receiver
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
receiver: anSExpression
	receiver := anSExpression
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
registerCacheWith: runtime
	cache ifNil: [ runtime registerCache: self for: selector ]
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
selector
	^selector
! !

!SMessage methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:46'!
selector: aSelector
	selector := aSelector
! !

!SMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:46'!
argumentCount
	^arguments size
! !

!SMessage methodsFor: 'private' stamp: 'KenD 11/22/2023 07:48:46'!
inlined: aBoolean
	inlined := aBoolean
! !

!SMessage class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:46'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeMessage
! !

!SMessage class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:46'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SOpJump methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:09'!
acceptVisitor: visitor
	^ visitor visitOpJump: self
! !

!SOpJump methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:09'!
printOn: aStream
	aStream nextPutAll: self class name withArticle; nextPutAll: ' after '; print: target
! !

!SOpJump methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:09'!
target
	^target
! !

!SOpJump methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:09'!
target: anInteger
	 target := anInteger
! !

!SOpJumpFalse methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:54'!
acceptVisitor: visitor
	^ visitor visitOpJumpFalse: self
! !

!SOpJumpTrue methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:20'!
acceptVisitor: visitor
	^ visitor visitOpJumpTrue: self
! !

!SOpLoadRfromFrame methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
acceptVisitor: visitor
	^ visitor visitOpLoadRfromFrame: self
! !

!SOpLoadRfromFrame methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
index
^	index
! !

!SOpLoadRfromFrame methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:19'!
index: anInteger
	index := anInteger
! !

!SOpPopR methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:10'!
acceptVisitor: visitor
	^ visitor visitOpPopR: self
! !

!SOpStoreRintoFrame methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:57'!
acceptVisitor: visitor
	^ visitor visitOpStoreRintoFrame: self
! !

!SOpStoreRintoFrame methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:57'!
index
	^ index
! !

!SOpStoreRintoFrame methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:57'!
index: anInteger
	index := anInteger
! !

!SOpAssign methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
acceptVisitor: visitor
	^ visitor visitOpAssign: self
! !

!SOpAssign methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
assignees
	^assignees
! !

!SOpAssign methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:47'!
assignees: aCollection
	assignees := aCollection
! !

!SOpDispatchMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
acceptVisitor: visitor
	^ visitor visitOpDispatchMessage: self
! !

!SOpDispatchMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
message
	^ message
! !

!SOpDispatchMessage methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:44'!
message: anSMessage
	message := anSMessage
! !

!SOpDropToS methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:11'!
acceptVisitor: visitor
	^ visitor visitOpDropToS: self
! !

!SOpDropToS methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:11'!
count
	^count
! !

!SOpDropToS methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:11'!
count: anInteger
	count := anInteger 
! !

!SOpLoadRfromStack methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
acceptVisitor: visitor
	^ visitor visitOpLoadRfromStack: self
! !

!SOpLoadRfromStack methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
index
	^index
! !

!SOpLoadRfromStack methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
index: anInteger
	index := anInteger
! !

!SOpLoadRwithNil methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:06'!
acceptVisitor: visitor
	^ visitor visitOpLoadRwithNil: self
! !

!SOpLoadRwithSelf methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:06'!
acceptVisitor: visitor
	^ visitor visitOpLoadRwithSelf: self
! !

!SOpPrimitive methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:17'!
acceptVisitor: visitor
	^ visitor visitOpPrimitive: self
! !

!SOpPrimitive methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
block
	^block
! !

!SOpPrimitive methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:17'!
block: aBlockClosure
	block := aBlockClosure
! !

!SOpPushR methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:16'!
acceptVisitor: visitor
	^ visitor visitOpPushR: self
! !

!SOpRestart methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:52'!
acceptVisitor: visitor
	^ visitor visitOpRestart: self
! !

!SOpReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:44'!
acceptVisitor: visitor
	^ visitor visitOpReturn: self
! !

!SOpNonLocalReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:57'!
acceptVisitor: visitor
	^ visitor visitOpNonLocalReturn: self
! !

!SPragma methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
name
	^ name
! !

!SPragma methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:06'!
name: aString
	name := aString
! !

!SReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:51'!
acceptVisitor: visitor
	^visitor visitReturn: self
! !

!SReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:51'!
expression
	^expression
! !

!SReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:51'!
expression: anSExpression
	expression := anSExpression
! !

!SReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:51'!
isReturn
	^true
! !

!SReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:51'!
local
	^local
! !

!SReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:51'!
local: aBoolean
	local := aBoolean
! !

!SReturn methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:48:51'!
printOn: aStream indent: anInteger
	aStream tab: anInteger; nextPutAll: '{ReturnId.'; cr.
	expression printOn: aStream indent: anInteger + 1.
	aStream nextPutAll: '}'
! !

!SReturn class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:48:51'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeReturn
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
argumentCount
	^compiledCode argumentCount
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
compiledCode
	^compiledCode
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
compiledCode: anObject
	compiledCode := anObject
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
initialize
	statements := #()
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
printOn: aStream indent: anInteger
	statements
		do: [:statement | statement printOn: aStream indent: anInteger + 1]
		separatedBy: [aStream nextPutAll: '.'; cr]
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
statements
	^statements
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
statements: aCollection
	statements := aCollection
! !

!SScript methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:48:48'!
tempCount
	^compiledCode tempCount
! !

!SScript methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:48:48'!
optimizedCode: anObject
	^ self compiledCode optimizedCode: anObject
! !

!SScript class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:48:48'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SBlock methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:11'!
acceptVisitor: visitor
	^visitor visitBlock: self
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
capturedVariables
	^capturedVariables
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
capturedVariables: aCollection
	capturedVariables := aCollection
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
capturesHome
	^compiledCode capturesHome
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
index
	^index
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
index: anInteger
	index := anInteger
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
inlinedArgs
	^ inlinedArgs
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
inlinedArgs: anArray
	inlinedArgs:= anArray 
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
offsetOfCurrentEnvironment
	^ 2
! !

!SBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:11'!
optimizedCode
	^compiledCode optimizedCode
! !

!SBlock methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:11'!
initialize
	capturedVariables := #()
! !

!SBlock methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:11'!
isBlock
	^true
! !

!SBlock methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:49:11'!
isInlined
	^ compiledCode isNil
! !

!SBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:49:11'!
printOn: aStream indent: anInteger
	aStream
		tab: anInteger;
		nextPutAll: '{BlockId. capturedVariables: ';
		print: capturedVariables;
		cr.
	super printOn: aStream indent: anInteger.
	aStream nextPutAll: '}'
! !

!SBlock class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:49:11'!
decodeUsing: anAstcodeDecoder
	^anAstcodeDecoder decodeBlock
! !

!SMethod methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:49:09'!
acceptVisitor: visitor
	^visitor visitMethod: self
! !

!SMethod methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:49:09'!
isMethod
	^true
! !

!SMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
offsetOfCurrentEnvironment
	^ 0
! !

!SMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
offsetOfEnvironment: anInteger
	^0
! !

!SMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
pragma
	^pragma
! !

!SMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
pragma: anSPragma
	pragma := anSPragma
! !

!SMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
primitive
	^pragma ifNotNil: [ pragma name ]
! !

!SMethod methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:49:09'!
printOn: aStream indent: anInteger
	aStream nextPutAll: '{MethodId. '; cr.
	pragma ifNotNil: [ (pragma isKindOf: SExpression) ifTrue: [ pragma printOn: aStream indent: anInteger + 1] ifFalse: [ aStream tab: anInteger + 1; print: pragma ] ].
	super printOn: aStream indent: anInteger.
	aStream nextPutAll: '}'
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
activationRecord
	^self firstInstruction
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
add: instruction
	^lastInstruction beforeInsert: instruction
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
addFront: instruction
	^firstInstruction afterInsert: instruction
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
addPredecessor: aBasicBlock
	predecessors add: aBasicBlock
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
allDominators
	| result all changed |
	result := Dictionary new.
	all := self withSuccessorsPostOrder.
	all do: [:block | result at: block put: (Set with: block)].
	changed := true.
	[changed] whileTrue: [| current |
		changed := false.
		all reverseDo: [:block | | incoming |
			incoming := block predecessors collect: [:pred | result at: pred].
			current := incoming isEmpty ifTrue: [Set new] ifFalse: [
				incoming
					inject: incoming first
					into: [:intersection :doms | doms intersection: intersection]].
			current add: block.
			current size !!= (result at: block) size ifTrue: [
				result at: block put: current.
				changed := true]]].
	^result
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
allLoopHeads
	| loops doms |
	loops := Dictionary new.
	doms := self allDominators.
	self withSuccessorsPostOrder do: [:block | 
		block successors
			do: [:succ | ((doms at: block) includes: succ)
				ifTrue: [loops add: succ -> block]]].
	^loops
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
allLoops
	| result |
	result := Dictionary new.
	self allLoopHeads
		keysAndValuesDo: [:head :tail | result
			at: head
			put: (tail withPredecessorsUntil: head)].
	^result
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
asArray
	^self asReversePostOrderInstructionsCollection asArray
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
asReversePostOrderInstructionsCollection
	| collection |
	collection := OrderedCollection new.
	self
		instructionsWithReversePostOrderSuccessorsDo: [:inst | collection
			add: inst].
	^collection
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
cleanPredecessors
	predecessors := OrderedCollection new
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
computeLiveOutInto: liveOut andLiveInInto: liveIn
	| blocks changed |
	blocks := self withSuccessorsPostOrder.
	blocks reverseDo: [:block | | in out |
		in := OrderedCollection new.
		out := OrderedCollection new.
		liveOut at: block put: out.
		liveIn at: block put: in].
	changed := true.
	[changed] whileTrue: [
		changed := false.
		blocks reverseDo: [:block | | live out size |
			live := block successors gather: [:succ | liveIn at: succ].
			out := liveOut at: block.
			size := out size.
			out := out addAll: live; withoutDuplicates.
			changed := changed or: [out size !!= size].
			block lastInstruction reverseDo: [:instruction | 
				instruction operandsDo: [:argument | 
					live addIfAbsent: argument.
					live removeIfPresent: instruction].
				liveIn at: block put: live]]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
dissolveIfUnreachable
	predecessors isEmpty ifTrue: [
		self lastValue
			ifNotNil: [:last | last reverseDo: [:instruction | instruction dissolve]]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
dominanceFrontiers
	| idoms |
	idoms := self dominatorTree allImmediateDominators.
	^self dominanceFrontiersUsing: idoms
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
dominanceFrontiersUsing: idoms
	| blocks result |
	blocks := self withSuccessorsPostOrder.
	result := Dictionary new.
	blocks do: [:block | result at: block put: OrderedCollection new].
	blocks do: [:block | 
		block predecessors size > 1 ifTrue: [
			block predecessors do: [:predecessor | | runner end |
				runner := predecessor.
				end := idoms at: block.
				[runner !!= end] whileTrue: [| frontiers |
					frontiers := result at: runner.
					(frontiers includes: block) ifFalse: [frontiers add: block].
					runner := idoms at: runner]]]].
	^result
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
dominatorTree
	| all root idoms indices intersect changed |
	all := self updatePredecessors withSuccessorsPostOrder reversed.
	idoms := Array new: all size.
	idoms at: 1 put: 1.
	root := all first.
	indices := Dictionary new.
	all withIndexDo: [:block :index | indices at: block put: index].
	intersect := [:index1 :index2 | | finger1 finger2 |
		finger1 := index1.
		finger2 := index2.
		[finger1 !!= finger2] whileTrue: [
			finger1 > finger2
				ifTrue: [finger1 := idoms at: finger1]
				ifFalse: [finger2 := idoms at: finger2]].
		finger1].
	changed := true.
	[changed] whileTrue: [
		changed := false.
		(all copyFrom: 2)
			withIndexDo: [:block :index | | processed initial intersection |
				processed := block predecessors select: [:predecessor | | i |
					i := indices at: predecessor.
					(idoms at: i) notNil].
				initial := indices at: processed first.
				intersection := processed
					inject: initial
					into: [:actual :predecessor | | candidate |
						candidate := indices at: predecessor.
						intersect value: actual value: candidate].
				intersection !!= (idoms at: index + 1) ifTrue: [
					idoms at: index + 1 put: intersection.
					changed := true]]].
	^ODominatorTree from: root with: all dominators: idoms
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
endWith: jumpType to: target skipping: skipped if: compare
	| jump |
	jump := jumpType variable: compare target: target implicitTarget: skipped.
	compare addUse: jump at: #variable.
	self lastInstruction afterInsert: jump
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
endWithJumpFalseTo: target skipping: skipped if: condition
	self endWith: OJumpFalse to: target skipping: skipped if: condition
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
endWithJumpTo: target
	| jump |
	jump := OJump to: target.
	self lastInstruction afterInsert: jump
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
endWithJumpTrueTo: target skipping: skipped if: condition
	self endWith: OJumpTrue to: target skipping: skipped if: condition
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
firstInstruction
	^firstInstruction next
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
firstNonPhi
	^self firstInstruction firstNonPhi
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
fullyRemovePredecessor: predecessor
	self
		removePredecessor: predecessor;
		phisDo: [:phi | phi removeBlock: predecessor].
	predecessors isEmpty
		ifTrue: [self successors do: [:succ | succ fullyRemovePredecessor: self]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
hasMultiplePredecessors
	^predecessors size > 1
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
hasMultipleSuccessors
	^self lastInstruction isConditionalJump
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
hasSuccessors
	^self lastInstruction isJump
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
ifHasExplicitSuccesor: explicitBlock ifHasImplicitSuccesor: implicitBlock
	| last |
	last := self lastInstruction.
	last isJump ifFalse: [^self].
	explicitBlock value: last target.
	last isConditionalJump ifTrue: [implicitBlock value: last implicitTarget]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
incorporatePhisFrom: predecessor
	| index |
	predecessors size = 1 ifTrue: [^predecessor movePhisTo: self].
	self phisDo: [:phi | | source parents vars |
		index := phi blocks indexOf: predecessor.
		source := phi variables at: index.
		parents := predecessor predecessors.
		vars := (predecessor phis includes: source)
			ifTrue: [source variables copy]
			ifFalse: [OrderedCollection new: parents size withAll: source].
		vars withIndexDo: [:var :i | | pred |
			pred := parents at: i.
			phi addVariable: var from: pred].
		phi removeVariable: source at: index]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
indexOf: anInstruction
	| current |
	current := 1.
	self instructionsDo: [:instruction | 
		instruction == anInstruction ifTrue: [^current].
		current := current + 1].
	self error: 'instruction not found'
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
initialize
	firstInstruction := OInstruction empty.
	lastInstruction := firstInstruction next.
	predecessors := OrderedCollection new
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
initializeWith: anInstruction
	firstInstruction := anInstruction cutPrevious.
	lastInstruction := firstInstruction last next.
	predecessors := OrderedCollection new
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
inline: inlined replacing: aMessageSend
	| returned return join last |
	last := inlined lastBlock.
	return := last lastValue.
	returned := return source.
	aMessageSend replaceAllUsesWith: returned.
	return dissolve.
	inlined successors isEmpty ifFalse: [
		join := self splitAfter: aMessageSend.
		join addPredecessor: last.
		last endWithJumpTo: join].
	aMessageSend dissolveReplacingWithAll: inlined firstInstruction.
	self replaceAsPredecessor: inlined.
	^join ifNil: [self]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
insertPhiOf: block1 and: block2 replacing: operation
	| value1 value2 |
	value1 := block1 lastValue.
	value2 := block2 lastValue.
	(value1 == nil or: [value2 == nil]) ifTrue: [^operation dissolve].
	self
		insertPhiOf: value1
		at: block1
		and: value2
		at: block2
		replacing: operation
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
insertPhiOf: value1 at: block1 and: value2 at: block2 replacing: operation
	| phi |
	phi := OPhi with: value1 from: block1 with: value2 from: block2.
	self firstInstruction beforeInsert: phi.
	operation replaceAllUsesWith: phi; dissolve
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
insertPhiOf: value1 at: block1 and: block2 replacing: operation
	| value2 |
	value2 := block2 lastValue.
	value2 == nil ifTrue: [^operation dissolve].
	self
		insertPhiOf: value1
		at: block1
		and: value2
		at: block2
		replacing: operation
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
instructionsAfter: first withReversePostOrderSuccessorsDo: aBlock
	first do: aBlock.
	self withSuccessorsPostOrder
		removeLast;
		reverseDo: [:block | block instructionsDo: aBlock]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
instructionsAsCollection
	| collection |
	collection := OrderedCollection new.
	self instructionsDo: [:inst | collection add: inst].
	^collection
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
instructionsDo: aBlock
	^firstInstruction do: aBlock
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
instructionsReverseDo: aBlock
	^end reverseDo: aBlock
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
instructionsSelect: condition thenDo: aBlock
	^firstInstruction
		do: [:next | (condition value: next) ifTrue: [aBlock value: next]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
instructionsWithPostOrderSuccessorsDo: aBlock
	self postOrderDo: [:block | block instructionsDo: aBlock]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
instructionsWithReversePostOrderSuccessorsDo: aBlock
	self reversePostOrderDo: [:block | block instructionsDo: aBlock]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
instructionsWithSuccessorsDo: aBlock
	self withSuccessorsDo: [:block | block instructionsDo: aBlock]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
isEmptyBranch
	self instructionsDo: [:instruction | ^instruction isConditionalJump]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
isEmptyJump
	self instructionsDo: [:instruction | ^instruction isUnconditionalJump]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
isEmptyPhiBranch
	self instructionsDo: [:instruction | | empty |
		empty := instruction isPhi and: [| next |
			next := instruction next.
			next isConditionalJump
				and: [next variable == instruction and: [instruction isUsedJustOnce]]].
		^empty]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
isOnlyPhiBranch
	| last |
	last := self lastInstruction.
	last isConditionalJump ifFalse: [^false].
	self instructionsDo: [:instruction | 
		instruction = last ifTrue: [^true].
		instruction isPhi ifFalse: [^false]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
isPhiArgument: instruction
	self phisDo: [:phi | (phi variables includes: instruction) ifTrue: [^true]].
	^false
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
iteratedDominanceFrontiersOf: blocks using: frontiers
	| result changed |
	result := (blocks gather: [:block | frontiers at: block]) asSet.
	changed := true.
	[changed] whileTrue: [| size more |
		size := result size.
		more := result gather: [:block | frontiers at: block].
		result addAll: more.
		changed := size !!= result size].
	^result
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
lastBlock
	^self postOrderDo: [:block | ^block]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
lastInstruction
	^lastInstruction prev
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
lastPhi
	^self firstInstruction lastPhi
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
lastValue
	| last |
	last := lastInstruction lastValue.
	^last = firstInstruction
		ifTrue: [predecessors size = 1 ifTrue: [predecessors first lastValue]]
		ifFalse: [last]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
length
	| current |
	current := 0.
	self instructionsDo: [:instruction | current := current + 1].
	^current
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
moveAllTo: block
	self moveAllTo: block after: block lastInstruction
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
moveAllTo: block after: instruction
	block replace: self asPredecessorIn: self successors.
	next == end ifTrue: [^self].
	end prev afterConnect: instruction next.
	instruction afterConnect: next.
	self afterConnect: end
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
movePhisTo: otherBlock
	| inst dest |
	inst := self firstInstruction.
	dest := otherBlock firstInstruction prev.
	[inst isPhi] whileTrue: [| next |
		next := inst next.
		dest afterInsert: inst.
		dest := inst.
		inst := next]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
name
	^'#' , self hash printString
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
nilUnitializedTemporaries
	| stack uninitialized nilval |
	stack := self activationRecord.
	stack hasFrame ifFalse: [^nil].
	uninitialized := stack uninitializedTemporariesIn: self.
	uninitialized isEmpty ifTrue: [^nil].
	nilval := OLoadConstant valued: nil.
	stack next afterInsert: nilval.
	uninitialized do: [:index | | store |
		store := OStoreOperation base: stack slotAtImm: index put: nilval.
		nilval afterInsert: store].
	^nilval
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
operandsDo: aBlock
	
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
phiValuesComingFrom: block
	^self phis collect: [:phi | phi atOperand: block]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
phiWithArgument: instruction
	self phisDo: [:phi | (phi variables includes: instruction) ifTrue: [^phi]].
	self error: 'not found'
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
phis
	| result |
	result := OrderedCollection new.
	self
		instructionsDo: [:instr | instr isPhi
			ifTrue: [result add: instr]
			ifFalse: [^result]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
phisDo: aBlock
	self
		instructionsDo: [:instr | instr isPhi
			ifTrue: [aBlock value: instr]
			ifFalse: [^self]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
postOrder: result seen: seen
	seen add: self.
	self
		ifHasExplicitSuccesor: [:next | (seen includes: next)
			ifFalse: [next postOrder: result seen: seen]]
		ifHasImplicitSuccesor: [:next | (seen includes: next)
			ifFalse: [next postOrder: result seen: seen]].
	result add: self
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
postOrderDo: aBlock
	self withSuccessorsPostOrder do: [:block | aBlock value: block]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
predecessors
	^predecessors
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
printAll
	| stream |
	stream := '' writeStream.
	self reversePostOrderDo: [:block | 
		block printOn: stream.
		stream cr].
	^stream contents
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
printAllNamed
	| stream names vars blocks |
	stream := '' writeStream.
	names := Dictionary new.
	vars := 0.
	blocks := 0.
	self reversePostOrderDo: [:block | 
		block instructionsDo: [:inst | 
			names at: inst put: 'v' , vars printString.
			vars := vars + 1].
		names at: block put: 'B' , blocks printString.
		blocks := blocks + 1].
	self reversePostOrderDo: [:block | 
		block printOn: stream using: names.
		stream cr].
	^stream contents
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
printOn: aStream
	aStream
		nextPutAll: '<=== ' , self name , String cr , firstInstruction asString
			, '===>'
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
printOn: aStream using: names
	| string |
	string := names at: self.
	aStream nextPutAll: '<=== ' , string , ' [' , self hash printString , '] \'.
	predecessors size > 0 ifTrue: [
		predecessors allButLast
			do: [:pred | aStream
				nextPutAll: (names at: pred ifAbsent: 'missing') , ' | '].
		aStream nextPutAll: (names at: predecessors last ifAbsent: 'missing')].
	aStream
		nextPutAll: '/' , String cr , (firstInstruction printStringUsing: names)
			, '===>'
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
realInstructionsDo: aBlock
	| current |
	current := self firstInstruction.
	[current isPhi] whileTrue: [current := current next].
	current do: aBlock
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
removePredecessor: aBasicBlock
	predecessors remove: aBasicBlock
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
replace: old asPredecessorIn: successors
	successors do: [:succ | succ replacePredecessor: old with: self]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
replaceAsPredecessor: old
	self successors do: [:succ | succ replacePredecessor: old with: self]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
replacePredecessor: old with: new
	self phisDo: [:phi | phi replaceBlock: old with: new].
	predecessors replace: old with: new
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
reversePostOrderDo: aBlock
	self withSuccessorsPostOrder reverseDo: [:block | aBlock value: block]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
sortPhiVariables
	self phisDo: [:phi | phi sortAfter: predecessors]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
split
	^self class new
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
splitAfter: anInstruction
	| next |
	next := self class newStartingWith: anInstruction next.
	lastInstruction := anInstruction cutFollowing.
	next replaceAsPredecessor: self.
	^next
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
splitAllCriticalEdges
	self withSuccessorsPostOrder
		do: [:block | block splitIncomingCriticalEdges]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
splitBefore: anInstruction
	^self splitAfter: anInstruction prev
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
splitEdgeIfCriticalTo: succ
	^(self successors size > 1 and: [succ predecessors size > 1])
		ifTrue: [self splitEdgeTo: succ]
		ifFalse: [succ]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
splitEdgeTo: block
	| middle jump branch |
	middle := self class new.
	jump := OJump to: block.
	middle add: jump.
	branch := self lastInstruction.
	branch target = block
		ifTrue: [branch target: middle]
		ifFalse: [branch implicitTarget: middle].
	middle addPredecessor: self.
	block replacePredecessor: self with: middle.
	^middle
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
splitIncomingCriticalEdges
	predecessors size > 1 ifTrue: [
		predecessors
			do: [:pred | pred successors size > 1 ifTrue: [pred splitEdgeTo: self]]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
successors
	^lastInstruction prev targets
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
successorsDo: aBlock
	| last |
	last := self lastInstruction.
	last !!== self ifTrue: [ last successorsDo: aBlock]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
successorsPostOrder
	| seen result |
	seen := Set new.
	result := OrderedCollection new: 10.
	self
		ifHasExplicitSuccesor: [:next | (seen includes: next)
			ifFalse: [next postOrder: result seen: seen]]
		ifHasImplicitSuccesor: [:next | (seen includes: next)
			ifFalse: [next postOrder: result seen: seen]].
	^result
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
unifyReturns
	| all last extra ret prev end jump phi |
	all := self withSuccessorsPostOrder.
	last := all removeFirst.
	extra := OrderedCollection new.
	all do: [:block | | potential |
		potential := block lastInstruction prev.
		potential class = OReturn ifTrue: [extra add: potential -> block]].
	extra size = 0 ifTrue: [^self].
	ret := last lastInstruction.
	prev := ret prev.
	(prev isPhi and: prev = last firstInstruction)
		ifTrue: [
			end := last.
			phi := prev]
		ifFalse: [
			end := last splitAfter: prev.
			end addPredecessor: last.
			jump := OJump to: end.
			prev afterInsert: jump.
			phi := OPhi new.
			phi
				addVariable: ret source from: last;
				addUse: ret at: #source.
			ret source removeUse: ret at: #source.
			ret source: phi; beforeInsert: phi].
	extra do: [:assoc | | tail block |
		tail := assoc key.
		block := assoc value.
		phi addVariable: tail source from: block.
		end addPredecessor: block.
		jump := tail next.
		jump target removePredecessor: block.
		jump target: end.
		tail dissolve]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
updatePredecessors
	self
		postOrderDo: [:block | block cleanPredecessors];
		postOrderDo: [:block | block successors
			do: [:successor | successor addPredecessor: block]];
		postOrderDo: [:block | block sortPhiVariables]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
usesResultOf: anInstruction
	firstInstruction
		detect: [:instruction | instruction usesResultOf: anInstruction]
		ifNone: [^false].
	^true
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:59'!
validateCFG
	self withSuccessorsDo: [:block | 
		block successors
			do: [:successor | self _ASSERT: (successor predecessors includes: block)].
		block predecessors
			do: [:predecessor | self _ASSERT: (predecessor successors includes: block)]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
verifyAllInstructionsSanity
	self withSuccessorsDo: [:block | | forward current backwards |
		forward := OrderedCollection new.
		current := block instVarNamed: #firstInstruction.
		[current == nil] whileFalse: [
			forward add: current.
			current := current next].
		backwards := OrderedCollection new.
		current := forward last.
		[current == nil] whileFalse: [
			backwards add: current.
			current := current prev].
		self ASSERT: forward = backwards reversed]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
verifyAllPredecessorsSanity
	self withSuccessorsDo: [:block | 
		block successors
			do: [:successor | self ASSERT: (successor predecessors includes: block)].
		block predecessors
			do: [:predecessor | self ASSERT: (predecessor successors includes: block)]]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
withPredecessors
	| result incoming |
	result := OrderedCollection new.
	incoming := OrderedCollection with: self.
	[
		result addAll: incoming.
		incoming := incoming gather: #predecessors.
		incoming removeAllSuchThat: [:pred | result includes: pred].
		incoming isEmpty] whileFalse.
	^result
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
withPredecessorsUntil: block
	| result incoming |
	result := OrderedCollection new.
	incoming := OrderedCollection with: self.
	[
		result addAll: incoming.
		incoming := incoming gather: #predecessors.
		incoming
			removeAllSuchThat: [:pred | pred == block or: [result includes: pred]].
		incoming isEmpty] whileFalse.
	^result
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
withSuccessorsDo: aBlock
	| done remaining |
	done := Set new.
	remaining := OrderedCollection new: 10.
	remaining add: self.
	[remaining notEmpty] whileTrue: [| block more |
		block := remaining removeFirst.
		aBlock value: block.
		done add: block.
		more := block successors
			reject: [:succesor | (done includes: succesor)
				or: [remaining includes: succesor]].
		remaining addAll: more]
! !

!OBasicBlock methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
withSuccessorsPostOrder
	| seen result |
	seen := Set new.
	result := OrderedCollection new: 10.
	self postOrder: result seen: seen.
	^result
! !

!OBasicBlock methodsFor: 'adding / removing' stamp: 'KenD 11/22/2023 07:52:59'!
addFrom: first to: last
	end prev afterInsert: first to: last
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
allReturnsWithBlocks
	"
	last block ends in a return, but other blocks are the result of inlining,
	hence they end in a jump to the next block, and the return is the instruction
	before that jump
	"
	| result blocks last |
	result := OrderedCollection new.
	blocks := self withSuccessorsPostOrder.
	last := blocks removeFirst.
	result add: last lastInstruction -> last.
	blocks do: [:block | | potential |
		self _ASSERT: block lastInstruction isReturn not.
		potential := block lastInstruction prev.
		potential isReturn ifTrue: [result add: potential -> block]].
	^result
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
asOrderedCollection
	^OrderedCollection withAll: self
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
collect: aBlock in: aCollection
	self do: [:inst | | collected |
		collected := aBlock value: inst.
		aCollection add: collected].
	^aCollection
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
copyTo: copy with: map
	| copyend |
	copy afterConnect: (next duplicateWith: map).
	copyend := map at: end.
	(end prev duplicateWith: map) afterConnect: copyend.
	copy predecessors: (predecessors collect: [:pred | pred duplicateWith: map])
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
dissolveAllInstructions
	| value |
	[
		value := self lastValue.
		value notNil]
		whileTrue: [value dissolveDeep]
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
duplicate
	^self duplicateWith: IdentityDictionary new
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
duplicateWith: map
	| copy |
	map at: self ifPresent: [:c | ^c].
	copy := self class new.
	map
		at: self put: copy;
		at: end put: copy next.
	prev ifNotNil: [copy prev: (prev duplicateWith: map)].
	next ifNotNil: [copy next: (next duplicateWith: map)].
	self copyTo: copy with: map.
	^copy
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
nodesSelect: aBlock
	| seen work result visit |
	seen := IdentitySet with: self.
	work := OrderedCollection with: self.
	result := OrderedCollection new.
	visit := [:inst | 
		(seen includes: inst) ifFalse: [
			seen add: inst.
			work add: inst]].
	[work isEmpty] whileFalse: [| node |
		node := work removeLast.
		(aBlock value: node) ifTrue: [result add: node].
		node class = OBlockClosure ifTrue: [visit value: node firstBlock].
		node class = OBasicBlock ifTrue: [
			node do: [:inst | visit value: inst].
			node successors do: [:succ | visit value: succ]].
		node operandsDo: [:input | visit value: input]].
	^result
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
predecessors: aCollection
	predecessors := aCollection
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
primitivePrintOn: aStream
	aStream nextPutAll: '<=== '; print: self name; cr.
	next printForwardOn: aStream.
	aStream nextPutAll: '===>'
! !

!OBasicBlock methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
size
	| result |
	result := 0.
	next do: [:inst | result := result + 1].
	^result
! !

!OBasicBlock methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:52:59'!
isReachableFrom: aBasicBlock
	| seen work |
	seen := Set withAll: predecessors.
	work := OrderedCollection withAll: predecessors.
	[work isEmpty] whileFalse: [| block |
		block := work removeFirst.
		block == aBasicBlock ifTrue: [^true].
		block predecessors do: [:p | 
			(seen includes: p) ifFalse: [
				seen add: p.
				work add: p]]].
	^false
! !

!OBasicBlock methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:52:59'!
printAllNamedOn: aStream
	| names vars blocks |

	names := Dictionary new.
	vars := 0.
	blocks := 0.
	self
		reversePostOrderDo: [ :block | 
			block
				instructionsDo: [ :inst | 
					names at: inst put: 'v' , vars printString.
					vars := vars + 1 ].
			names at: block put: 'B' , blocks printString.
			blocks := blocks + 1 ].
	self
		reversePostOrderDo: [ :block | 
			block printOn: aStream using: names.
			aStream cr ]
! !

!OBasicBlock methodsFor: 'validation' stamp: 'KenD 11/22/2023 07:52:59'!
validateAllInstructions
	| all blocks |
	self withSuccessorsDo: [:block | | forward current backwards |
		forward := OrderedCollection new.
		current := block.
		[current notNil] whileTrue: [
			forward add: current.
			current := current next].
		backwards := OrderedCollection new.
		current := forward last.
		[current notNil] whileTrue: [
			backwards add: current.
			current := current prev].
		self ASSERT: forward = backwards reversed].
	all := Set new.
	blocks := OrderedCollection new.
	blocks add: self.
	[blocks isEmpty] whileFalse: [| block |
		block := blocks removeFirst.
		block instructionsWithSuccessorsDo: [:inst | 
			all add: inst.
			inst
				operandsDo: [:o | o isBlockClosure ifTrue: [blocks add: o firstBlock]]]].
	self instructionsWithSuccessorsDo: [:inst | 
		inst
			validateUses;
			usesDo: [:operand | self _ASSERT: (all includes: operand instruction)]]
! !

!OBasicBlock class methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:59'!
decorator
	^Smalltalk at: #CollectionDecorator
! !

!OBasicBlock class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
new
	^self basicNew initialize
! !

!OBasicBlock class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:05'!
newStartingWith: anInstruction
	^self basicNew initializeWith: anInstruction
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
addDominated: aTree
	dominated add: aTree
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
allImmediateDominators
	| result remaining |
	result := Dictionary new.
	remaining := OrderedCollection with: self.
	[remaining isEmpty] whileFalse: [| current |
		current := remaining removeLast.
		current dominated do: [:child | result at: child block put: current block].
		remaining addAll: current dominated].
	^result
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
block
	^block
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
block: aBasicBlock
	block := aBasicBlock
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
dominated
	^dominated
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
dominators
	^dominators
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
dominators: aTreeCollection
	dominators := aTreeCollection
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
initialize
	dominated := OrderedCollection new
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
isImmediateDominatorOf: aBasicBlock
	^block == self or: [block successors includes: aBasicBlock]
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
noticeDominators
	dominators
		select: [:tree | tree isImmediateDominatorOf: self]
		thenDo: [:dominator | dominator addDominated: self]
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
printAtLevel: level on: aStream
	level > 8 ifTrue: [self halt].
	level timesRepeat: [aStream nextPutAll: '--'].
	aStream nextPutAll: block name , String cr.
	dominated
		reject: [:tree | tree == self]
		thenDo: [:tree | tree printAtLevel: level + 1 on: aStream]
! !

!ODominatorTree methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
printOn: aStream
	self printAtLevel: 1 on: aStream
! !

!ODominatorTree class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
from: root with: aBlocksCollection dominators: dominators
	| trees |
	trees := Array
		withAll: (aBlocksCollection collect: [:block | self new block: block]).
	(dominators copyFrom: 2)
		withIndexDo: [:dominator :correspondingIndex | | imm child |
			imm := trees at: dominator.
			child := trees at: correspondingIndex + 1.
			imm addDominated: child].
	^trees first
! !

!ODominatorTree class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
new
	^self basicNew initialize
! !

!OLiveRange methodsFor: 'testing' stamp: 'KenD 11/22/2023 14:00:11'!
isUsedBy: anInstruction
	^self allDefinitions
		anySatisfy: [:definition | anInstruction usesResultOf: definition]
! !

!OLiveRange class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
new
	^self basicNew initialize
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
add: range
	ranges add: range
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
addAll: range
	ranges addAll: range
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
allDefinitions
	^ranges gather: #allDefinitions
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
allUses
	^ranges gather: #allUses
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
anyDefinition
	^ranges last anyDefinition
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
definitionsWithBlocksDo: aBlock
	^ranges do: [:range | range definitionsWithBlocksDo: aBlock]
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
endsAt: operation
	^false
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
expirationPoints
	| definitions uses |
	definitions := self allDefinitions.
	uses := ranges gather: #usesWithBlocks.
	^uses
		select: [:use | definitions
			noneSatisfy: [:def | def livesAfter: use key orOutOf: use value]]
		thenCollect: #key
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
initialize
	ranges := OrderedCollection new
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
isLiveAt: aBlock
	^self allDefinitions
		anySatisfy: [:def | def
			livesAfter: aBlock firstInstruction prev
			orOutOf: aBlock]
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
isSpilled
	^ranges anySatisfy: #isSpilled
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
printOn: aStream
	| rangesStrings |
	rangesStrings := (ranges collect: #printString) gather: [:x | x , String cr].
	aStream nextPutAll: 'CLR: ' , String cr , rangesStrings
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
simpleRanges
	^ranges
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
startsAt: operation
	^ranges anySatisfy: [:range | range startsAt: operation]
! !

!OComposedLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
usesWithBlocksDo: aBlock
	^ranges do: [:range | range usesWithBlocksDo: aBlock]
! !

!OComposedLiveRange class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
new
	^self basicNew initialize
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
addUseFrom: operation at: block
	uses add: operation -> block
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
allDefinitions
	^OrderedCollection with: definition
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
allUses
	^uses collect: #key
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
anyDefinition
	^definition
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
beSpilled
	isSpilled := true
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
clearUses
	uses := OrderedCollection new
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
definedAt: operation in: block
	definition := operation.
	definitionBlock := block
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
definition: operation
	definition := operation
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
definitionAndUses
	^OrderedCollection with: definition -> definitionBlock withAll: uses
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
definitionsWithBlocksDo: aBlock
	aBlock value: definition value: definitionBlock
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
endsAt: operation
	^uses isEmpty
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
expirationPoints
	| associations |
	associations := uses
		reject: [:operation | definition
			livesAfter: operation key
			orOutOf: operation value].
	^associations collect: #key
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
initialize
	uses := OrderedCollection new.
	isSpilled := false
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
isLiveAt: aBlock
	^definition livesAfter: aBlock firstInstruction prev orOutOf: aBlock
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
isSpilled
	^isSpilled
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
isUnused
	^uses isEmpty
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
printOn: aStream
	aStream nextPutAll: 'LR of: ' , definition printString
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
simpleRanges
	^OrderedCollection with: self
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
startsAt: operation
	^definition == operation
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
uses
	^uses
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
usesWithBlocks
	^uses
! !

!OSimpleLiveRange methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
usesWithBlocksDo: aBlock
	uses
		do: [:association | aBlock value: association key value: association value]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
addUse: anOperand
	self DENY: self == anOperand.
	nextUse ifNil: [nextUse := anOperand] ifNotNil: [nextUse addUse: anOperand]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
asOperand
	self halt
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
definition
	^instruction atOperand: name
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
disolveReplacingWith: otherInstruction
	self definition removeUse: instruction.
	instruction atOperand: name put: otherInstruction.
	otherInstruction addUse: instruction at: name
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:10'!
duplicateWith: map
	| copy |
	map at: self ifPresent: [:i | ^i].
	copy := self class new.
	map at: self put: copy.
	instruction ifNotNil: [copy instruction: (instruction duplicateWith: map)].
	copy name: name.
	nextUse ifNotNil: [copy nextUse: (nextUse duplicateWith: map)].
	^copy
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
instruction
	^instruction
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
instruction: anInstruction
	instruction := anInstruction
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
name
	^name
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
name: operandName
	name := operandName
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
nextUse
	^nextUse
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:10'!
nextUse: anOOperand
	nextUse := anOOperand
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
printOn: aStream
	aStream
		nextPutAll: '[op #' , name printString , '@' , instruction printString
			, ']'
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
removeUse: anInstruction
	nextUse instruction == anInstruction
		ifTrue: [nextUse := nextUse nextUse]
		ifFalse: [nextUse removeUse: anInstruction]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
removeUse: anInstruction at: aName
	(nextUse instruction == anInstruction and: [nextUse name = aName])
		ifTrue: [nextUse := nextUse nextUse]
		ifFalse: [nextUse removeUse: anInstruction at: aName]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:10'!
removeUseBy: anInstruction
	nextUse instruction == anInstruction
		ifTrue: [nextUse := nextUse nextUse]
		ifFalse: [nextUse removeUseBy: anInstruction]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
replaceAllUsesWith: otherInstruction
	self replaceUseWith: otherInstruction.
	nextUse ifNotNil: [nextUse replaceAllUsesWith: otherInstruction]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
replaceUseWith: otherInstruction
	self DENY: otherInstruction class == OOperand.
	instruction atOperand: name put: otherInstruction
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:10'!
replaceUsesBy: user with: otherInstruction
	| following |
	following := nextUse.
	instruction == user ifTrue: [self transferUseTo: otherInstruction].
	following ifNotNil: [following replaceUsesBy: user with: otherInstruction]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:10'!
transferUseTo: otherInstruction
	self DENY: otherInstruction class == OOperand.
	self definition removeUse: self.
	instruction atOperand: name put: otherInstruction.
	otherInstruction addUse: self
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
user
	^instruction
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
usesDo: aBlock
	aBlock value: self.
	nextUse ifNotNil: [nextUse usesDo: aBlock]
! !

!OOperand methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:10'!
validate
	| set op |
	set := IdentitySet new.
	op := self.
	[op notNil] whileTrue: [
		(set includes: op) ifTrue: [self error: 'invalid operand'].
		set add: op.
		op := op nextUse]
! !

!OOperand class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
at: anInstruction named: operandName
	^self new instruction: anInstruction; name: operandName
! !

!OOperand class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
valued: anInstruction
	^self new value: anInstruction
! !

!OOperand class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
valued: anInstruction in: containingInstruction
	^self new value: anInstruction; instruction: containingInstruction
! !

!OTiling methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
beUsed
	used := true
! !

!OTiling methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
initialize
	used := false
! !

!OTiling methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
instruction
	^instruction
! !

!OTiling methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
instruction: anInstruction
	instruction := anInstruction
! !

!OTiling methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
isUsed
	^used = true
! !

!OTiling methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
printOn: aStream
	aStream nextPutAll: self printString
! !

!OTiling methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
printString
	^'<tiling of ' , instruction printString , ' >'
! !

!OTiling class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
for: instruction
	^self new instruction: instruction
! !

!OTiling class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
new
	^self basicNew initialize
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
acceptVisitor: aVisitor
	| following current |
	current := self.
	[
		following := current next.
		current isEnd]
		whileFalse: [
			current basicAcceptVisitor: aVisitor.
			current := current next ifNil: [following]]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
addLast: anInstruction
	next addLast: anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
addNext: anInstruction
	^self afterInsert: anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
addUse: new
	firstUse ifNil: [firstUse := new] ifNotNil: [firstUse addUse: new]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
addUse: user at: name
	| operand |
	operand := OOperand at: user named: name.
	self addUse: operand
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
afterConnect: anInstruction
	anInstruction prev: self.
	next := anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
afterInsert: anInstruction
	anInstruction next: next.
	anInstruction prev: self.
	next prev: anInstruction.
	next := anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
afterInsert: start to: end
	end afterConnect: next.
	self afterConnect: start
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
afterInsertAll: anInstruction
	| last |
	last := anInstruction last.
	last next: next.
	anInstruction prev: self.
	next prev: last.
	next := anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
allUses
	| result following |
	result := OrderedCollection new.
	following := firstUse.
	[following notNil] whileTrue: [
		result add: following.
		following := following nextUse].
	^result
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
assureBoundBy: binder
	
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
atOperand: name
	^self subclassResponsibility
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
atOperand: operandName put: instruction
	^self subclassResponsibility
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
basicPrintString
	^self primitivePrintString
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
beforeInsert: anInstruction
	anInstruction next: self.
	anInstruction prev: prev.
	prev next: anInstruction.
	prev := anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
beforeInsertAll: anInstruction
	| last |
	last := anInstruction "last".
	last next: self.
	anInstruction prev: prev.
	prev next: anInstruction.
	prev := last.
	self shouldBeImplemented
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
changeUseFrom: anInstruction to: anotherInstruction at: operand
	anotherInstruction addUse: self at: operand.
	anInstruction removeUse: self at: operand
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
cutFollowing
	| end |
	end := OEndInstruction new.
	end prev: self.
	next := end.
	^end
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
cutPrevious
	| begin |
	begin := OBeginInstruction new.
	begin next: self.
	prev := begin.
	^begin
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
detect: aBlock
	^self detect: aBlock ifNone: [self errorAbsentObject]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
detect: aBlock ifNone: absentBlock
	(aBlock value: self)
		ifTrue: [^self]
		ifFalse: [^next detect: aBlock ifNone: absentBlock]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
dissolve
	self untie; operandsDo: [:instruction | instruction removeUse: self]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
dissolveDeep
	prev ifNil: [^self].
	self
		remove;
		operandsDo: [:instruction | instruction
			removeUseBy: self;
			dissolveIfUseless]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
dissolveIfUnused
	self isUsed ifFalse: [self dissolve]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
dissolveIfUseless
	self isUseless ifTrue: [self dissolveDeep]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
dissolveReplacingWith: anInstruction
	prev next: anInstruction.
	next prev: anInstruction.
	anInstruction prev: prev.
	anInstruction next: next.
	prev := next := nil.
	self operandsDo: [:instruction | instruction removeUse: self].
	self replaceAllUsesWith: anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
dissolveReplacingWithAll: instructions
	| last |
	last := instructions last.
	prev next: instructions.
	instructions prev: prev.
	last next: next.
	next prev: last.
	prev := next := nil.
	self operandsDo: [:instruction | instruction removeUse: self].
	self replaceAllUsesWith: last
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
do: aBlock
	| following |
	following := next.
	aBlock value: self.
	next ifNil: [following do: aBlock] ifNotNil: [next do: aBlock]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
duplicateWith: map
	| copy |
	map at: self ifPresent: [:c | ^c].
	copy := self class new.
	map at: self put: copy.
	prev ifNotNil: [copy prev: (prev duplicateWith: map)].
	next ifNotNil: [copy next: (next duplicateWith: map)].
	self copyTo: copy with: map.
	^copy
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
firstNonPhi
	| current |
	current := self.
	[current isPhi] whileTrue: [current := current next].
	^current
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
firstUse
	^firstUse
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
hasNext
	^true
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
hasPrev
	^true
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
insertCopyBefore: anInstruction
	| copy |
	copy := self newCopy.
	anInstruction beforeInsert: copy.
	^copy
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
insertPushBefore: anInstruction
	| push |
	push := OUnaryOperation receiver: self name: #push.
	self addUse: push at: #receiver.
	anInstruction beforeInsert: push.
	^push
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isActivation
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isBlockClosure
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isBlockStart
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isBoolean
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isComparison
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isConditionalJump
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isConstant
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isDefineArgument
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isDefinedAt: aBlock
	aBlock instructionsDo: [:instruction | instruction == self ifTrue: [^true]].
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isEnd
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isGenericMessage
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isInstruction
	^true
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isJump
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isLoad
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isLoadImplicit
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isMemoryOperation
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isMessageSend
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isPhi
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isReturn
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isStore
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isStoreVariable
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isUnconditionalJump
	^self isJump andNot: [self isConditionalJump]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isUsed
	^firstUse notNil
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isUsedJustOnce
	^firstUse notNil and: [firstUse nextUse isNil]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
isUsedOnlyBy: instruction
	^self isUsedJustOnce and: [firstUse user == instruction]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
isUseless
	^firstUse isNil andNot: [self canHaveSideEffects]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
last
	^next last
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
lastPhi
	| current |
	current := self.
	[current next isPhi] whileTrue: [current := current next].
	^current
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
lastValue
	| last |
	last := self last.
	^last isJump ifTrue: [last prev] ifFalse: [last]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
livesAfter: anInstruction
	anInstruction
		nextDetect: [:instruction | instruction usesResultOf: self]
		ifNone: [^false].
	^true
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
livesAfter: anInstruction orOutOf: aBasicBlock
	^(self livesAfter: anInstruction) or: [self livesOutOfBlock: aBasicBlock]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
livesOutOfBlock: aBasicBlock
	aBasicBlock successorsPostOrder
		reverseDo: [:block | (block usesResultOf: self) ifTrue: [^true]].
	^false
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
newCopy
	| copy |
	copy := OUnaryOperation receiver: self name: #copy.
	self addUse: copy at: #receiver.
	^copy
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
next
	^next
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
next: anInstruction
	self DENY: (self isJump and: [anInstruction isEnd not]).
	next := anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
nextDetect: aBlock ifNone: absentBlock
	^next detect: aBlock ifNone: absentBlock
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
operands
	| result |
	result := OrderedCollection new.
	self operandsDo: [:o | result add: o].
	^result select: #isInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
operandsDo: aBlock
	self subclassResponsibility
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
prev
	^prev
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
prev: anInstruction
	prev := anInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
primitivePrintString
	^self class name
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
printBackwardOn: aStream
	aStream size > 1000 ifTrue: [
		aStream nextPutAll: '...'.
		^self].
	prev printBackwardOn: aStream.
	aStream nextPutAll: self basicPrintString; cr
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
printForwardOn: aStream
	aStream size > 100000 ifTrue: [
		aStream nextPutAll: '...'.
		^self].
	aStream nextPutAll: self basicPrintString; cr.
	next printForwardOn: aStream
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
printForwardOn: aStream using: names
	aStream size > 100000 ifTrue: [
		aStream nextPutAll: '...'.
		^self].
	aStream
		nextPutAll: (names at: self) , ' := ' , (self printStringUsing: names);
		cr.
	next printForwardOn: aStream using: names
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
printOn: aStream
	"
	prev printBackwardOn: aStream.
	aStrem nextPutAll: '-> '
	"
	aStream
		nextPutAll: self basicPrintString
	"	next printForwardOn: aStream cr"
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
printStringUsing: names
	^names at: self ifAbsent: ['?']
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
realReverseDo: aBlock
	| following |
	following := prev.
	aBlock value: self.
	prev
		ifNil: [following realReverseDo: aBlock]
		ifNotNil: [prev realReverseDo: aBlock]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
remove
	prev afterConnect: next.
	prev := next := nil
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
removeUse: instruction
	firstUse instruction == instruction
		ifTrue: [firstUse := firstUse nextUse]
		ifFalse: [firstUse removeUse: instruction]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
removeUse: instruction at: name
	(firstUse instruction == instruction and: [firstUse name = name])
		ifTrue: [firstUse := firstUse nextUse]
		ifFalse: [firstUse removeUse: instruction at: name]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
removeUseBy: instruction
	firstUse instruction == instruction
		ifTrue: [firstUse := firstUse nextUse]
		ifFalse: [firstUse removeUseBy: instruction]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
replaceAllUsesWith: anInstruction
	self == anInstruction ifTrue: [^self].
	firstUse ifNotNil: [
		firstUse replaceAllUsesWith: anInstruction.
		anInstruction addUse: firstUse.
		firstUse := nil]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
replaceOperand: name with: instruction
	| previous |
	previous := self atOperand: name.
	previous removeUse: self.
	self atOperand: name put: instruction.
	instruction addUse: self at: name
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
replaceUsesBy: anInstruction with: anotherInstruction
	firstUse
		ifNotNil: [firstUse replaceUsesBy: anInstruction with: anotherInstruction].
	^anotherInstruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
replaceUsesOf: value with: instruction
	self operandsDo: [:operand | 
		operand = value ifTrue: [
			operand
				usesDo: [:use | use user = self
					ifTrue: [use disolveReplacingWith: instruction]]]]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
replaceWithCopyOf: value
	| instruction |
	instruction := ((value isUsedOnlyBy: self) andNot: [value isPhi])
		ifTrue: [value untie]
		ifFalse: [value newCopy].
	self dissolveReplacingWith: instruction.
	^instruction
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
reverseDo: aBlock
	| following |
	following := prev.
	aBlock value: self.
	prev
		ifNil: [following reverseDo: aBlock]
		ifNotNil: [prev reverseDo: aBlock]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
targets
	^OrderedCollection new
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
untie
	prev next: next.
	next prev: prev.
	prev := next := nil
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
updateUser: instruction named: oldName with: newName
	self usesDo: [:use | 
		(use instruction == instruction and: [use name == oldName])
			ifTrue: [use name: newName]]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
useDistanceTo: value
	| count |
	count := 0.
	self do: [:instruction | 
		(instruction usesResultOf: value) ifTrue: [^count].
		count := count + 1].
	^Number infinity
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
usesDo: aBlock
	firstUse ifNotNil: [firstUse usesDo: aBlock]
! !

!OInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
validateUses
	| found |
	found := Set new.
	self allUses do: [:use | 
		self _ASSERT: use definition == self.
		self _DENY: (found includes: use instruction -> use name).
		found add: use instruction -> use name]
! !

!OInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:52:54'!
canHaveSideEffects
	^true
! !

!OInstruction methodsFor: 'testing' stamp: 'KenD 11/22/2023 14:00:02'!
isPrimitiveOperation
	^false
! !

!OInstruction methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:54'!
copyTo: copy with: map
	
! !

!OInstruction methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:54'!
successorsDo: aBlock
	
! !

!OInstruction class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
empty
	| begin last |
	begin := OBeginInstruction new.
	last := OEndInstruction new.
	begin next: last.
	last prev: begin.
	^begin
! !

!OBeginInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
basicAcceptVisitor: aVisitor
	
! !

!OBeginInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:54'!
detect: aBlock ifNone: absentBlock
	^next detect: aBlock ifNone: absentBlock
! !

!OBeginInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
do: aBlock
	next do: aBlock
! !

!OBeginInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
hasPrev
	^false
! !

!OBeginInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
printBackwardOn: aStream
	
! !

!OBeginInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:06'!
usesResultOf: anInstruction
	^false
! !

!OBeginInstruction methodsFor: 'printing' stamp: 'KenD 11/22/2023 14:00:06'!
printOn: aStream
	aStream nextPutAll: '[' , self basicHash printString , '] '.
	next printForwardOn: aStream
! !

!OBeginInstruction methodsFor: 'printing' stamp: 'KenD 11/22/2023 14:00:06'!
printOn: aStream using: names
	aStream nextPutAll: '[' , self basicHash printString , '] '.
	next printForwardOn: aStream using: names
! !

!OBeginInstruction methodsFor: 'printing' stamp: 'KenD 11/22/2023 14:00:06'!
printStringUsing: names
	| stream |
	stream := '' writeStream.
	next printForwardOn: stream using: names.
	^stream contents
! !

!OBeginInstruction methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 14:00:06'!
realReverseDo: aBlock
	
! !

!OBeginInstruction methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 14:00:06'!
reverseDo: aBlock
	
! !

!OBlockClosure methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:11'!
copyTo: copy with: map
	| first |
	super copyTo: copy with: map.
	first := firstBlock duplicateWith: map.
	copy firstBlock: first
! !

!OBlockClosure methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:04'!
operandsDo: aBlock
	
! !

!OBlockClosure methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:11'!
dissolveDeep
	firstBlock withSuccessorsDo: [:block | block dissolveAllInstructions].
	super dissolveDeep
! !

!OBlockClosure methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
firstBlock
	^firstBlock
! !

!OBlockClosure methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
firstBlock: basicBlock
	firstBlock := basicBlock
! !

!OBlockClosure methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:11'!
isBlockClosure
	^true
! !

!OBlockClosure methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:11'!
isUseless
	^firstUse isNil
! !

!OBlockClosure methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
lastBlock
	^firstBlock lastBlock
! !

!OBlockClosure methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
lastValue
	^firstBlock lastBlock lastValue
! !

!OBlockClosure class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
containing: initialBlock
	^self new firstBlock: initialBlock
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
basicAcceptVisitor: aVisitor
	^aVisitor visitDefineArgument: self
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
basicPrintString
	^'[define arg ' , name , ']'
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
isDefineArgument
	^true
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
name
	^name
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
name: aSymbol
	name := aSymbol
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
operandsDo: aBlock
	
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
primitivePrintString
	^'{' , name , '}'
! !

!ODefineArgument methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
printStringUsing: names
	^'define arg ' , name
! !

!ODefineArgument class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
named: aSymbol
	^self new name: aSymbol
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
acceptVisitor: aVisitor
	
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
addLast: anInstruction
	prev next: anInstruction.
	anInstruction prev: prev.
	anInstruction next: self.
	prev := anInstruction
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
detect: aBlock ifNone: absentBlock
	^absentBlock value
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
do: aBlock
	
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
hasNext
	^false
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
isEnd
	^true
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
last
	^prev
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
printForwardOn: aStream
	
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
printForwardOn: aStream using: names
	
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
printOn: aStream
	"
	prev printBackwardOn: aStream
	"
	
! !

!OEndInstruction methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
replace: one with: other
	
! !

!OEndInstruction methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 14:00:10'!
reverseDo: aBlock
	prev reverseDo: aBlock
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:08'!
afterConnect: anInstruction
	self _ASSERT: anInstruction isEnd.
	^super afterConnect: anInstruction
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
basicAcceptVisitor: aVisitor
	^aVisitor visitJump: self
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
basicPrintString
	^'[jump to ' , target name , ']'
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
isJump
	^true
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
primitivePrintString
	^'{jump}'
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
printStringUsing: names
	^'jump to ' , (names at: target)
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
retargetFrom: aBasicBlock to: otherBasicBlock
	target := otherBasicBlock
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
target
	^target
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
target: aBasicBlock
	target := aBasicBlock
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
targets
	^OrderedCollection with: target
! !

!OJump methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
usesResultOf: anInstruction
	^false
! !

!OJump methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:08'!
copyTo: copy with: map
	super copyTo: copy with: map.
	copy target: (target duplicateWith: map)
! !

!OJump methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:03'!
operandsDo: aBlock
	
! !

!OJump methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:08'!
successorsDo: aBlock
	aBlock value: target
! !

!OJump class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
to: aDestination
	^self new target: aDestination
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
atOperand: name
	^variable
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
atOperand: name put: instruction
	variable := instruction
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
implicitTarget
	^implicitTarget
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
implicitTarget: aBasicBlock
	implicitTarget := aBasicBlock
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
isConditionalJump
	^true
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
isJump
	^true
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
operandsDo: aBlock
	aBlock value: variable
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
replaceWithUnconditional: condition in: basicBlock
	| fixed removed jump |
	self isJumpTrue == condition
		ifTrue: [
			fixed := target.
			removed := implicitTarget]
		ifFalse: [
			fixed := implicitTarget.
			removed := target].
	jump := OJump to: fixed.
	self dissolveReplacingWith: jump.
	removed fullyRemovePredecessor: basicBlock
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
retargetFrom: aBasicBlock to: otherBasicBlock
	target == aBasicBlock ifTrue: [target := otherBasicBlock].
	implicitTarget == aBasicBlock ifTrue: [implicitTarget := otherBasicBlock]
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
target
	^target
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
target: aBasicBlock
	target := aBasicBlock
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
targets
	^OrderedCollection with: implicitTarget with: target
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
usesResultOf: anInstruction
	^variable == anInstruction
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
variable
	^variable
! !

!OJumpConditional methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
variable: operand
	variable := operand
! !

!OJumpConditional methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:12'!
copyTo: copy with: map
	super copyTo: copy with: map.
	copy
		target: (target duplicateWith: map);
		implicitTarget: (implicitTarget duplicateWith: map);
		variable: (variable duplicateWith: map)
! !

!OJumpConditional methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:12'!
successorsDo: aBlock
	aBlock value: target.
	aBlock value: implicitTarget
! !

!OJumpConditional class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:04'!
variable: operation target: explicitTarget implicitTarget: implicitTarget
	^self new
		variable: operation;
		target: explicitTarget;
		implicitTarget: implicitTarget
! !

!OJumpFalse methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicAcceptVisitor: aVisitor
	^aVisitor visitJumpFalse: self
! !

!OJumpFalse methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicPrintString
	^'[jump false ' , variable primitivePrintString , ' to ' , target name
		, ' or fall to '
		, implicitTarget name
		, ']'
! !

!OJumpFalse methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
isJumpFalse
	^true
! !

!OJumpFalse methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
isJumpTrue
	^false
! !

!OJumpFalse methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
primitivePrintString
	^'{jump false}'
! !

!OJumpFalse methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
printStringUsing: names
	^'jump false ' , (names at: variable ifAbsent: ['missing']) , ' to '
		, (names at: target ifAbsent: 'missing')
		, ' or fall to '
		, (names at: implicitTarget ifAbsent: 'missing')
! !

!OJumpTrue methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicAcceptVisitor: aVisitor
	^aVisitor visitJumpTrue: self
! !

!OJumpTrue methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicPrintString
	^'[jump true ' , variable primitivePrintString , ' to ' , target name
		, ' or fall to '
		, implicitTarget name
		, ']'
! !

!OJumpTrue methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
isJumpFalse
	^false
! !

!OJumpTrue methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
isJumpTrue
	^true
! !

!OJumpTrue methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
primitivePrintString
	^'{jump true}'
! !

!OJumpTrue methodsFor: 'printing' stamp: 'KenD 11/22/2023 14:00:08'!
printStringUsing: names
	^'jump true ' , (names at: variable) , ' to ' , (names at: target)
		, ' or fall to '
		, (names at: implicitTarget)
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
basicAcceptVisitor: aVisitor
	^aVisitor visitLoadConstant: self
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
basicPrintString
	^'[load cst ' , constant printString , ']'
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:11'!
canHaveSideEffects
	^false
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:11'!
isBoolean
	^constant isBoolean
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
isConstant
	^true
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
operandsDo: aBlock
	constant isInstruction ifTrue: [
		self halt.
		aBlock value: constant]
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
primitivePrintString
	^'{' , constant printString , '}'
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
printStringUsing: names
	^'load cst ' , constant printString
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
usesResultOf: anInstruction
	^false
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
value
	^constant
! !

!OLoadConstant methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
value: value
	constant := value
! !

!OLoadConstant methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:11'!
copyTo: copy with: map
	super copyTo: copy with: map.
	copy value: constant
! !

!OLoadConstant methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:01'!
newCopy
	^self class valued: constant
! !

!OLoadConstant class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
valued: value
	^self new value: value
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
atOperand: operandName put: instruction
	source := instruction
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
basicAcceptVisitor: aVisitor
	^aVisitor visitLoadImplicit: self
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
basicPrintString
	^'[load implicit #' , name printString , ']'
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
isLoadImplicit
	^true
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
name
	^name
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
name: aSymbol
	name := aSymbol
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
operandsDo: aBlock
	source isInstruction ifTrue: [aBlock value: source]
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
primitivePrintString
	"
	^'<#' , source value printString , '>'
	"
	^'{#' , name printString , '}'
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
printStringUsing: names
	^'#' , name printString
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
source
	^source
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
source: operand
	source := operand
! !

!OLoadImplicit methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
usesResultOf: anInstruction
	^false
! !

!OLoadImplicit methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:10'!
copyTo: copy with: map
	super copyTo: copy with: map.
	copy name: name; register: register
! !

!OLoadImplicit methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:10'!
register
	^register
! !

!OLoadImplicit methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:10'!
register: aRegister
	register := aRegister.
	register isInstruction ifTrue: [self halt]
! !

!OLoadImplicit class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
named: aSymbol
	^self new name: aSymbol
! !

!OLoadImplicit class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
self
	^self new name: #self
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:52:55'!
arguments
	| result |
	result := OrderedCollection new.
	self usesDo: [:use | | user |
		user := use user.
		(user isLoad and: [user index > 0]) ifTrue: [result add: user]].
	^result
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:09'!
doSavePreviousSelf
	storesPreviousSelf := true
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:09'!
hasFrame
	^hasFrame
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:09'!
haveFrame
	hasFrame := true
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:52:55'!
implicitLoads
	| result |
	result := OrderedCollection new.
	next
		do: [:inst | inst isLoadImplicit
			ifTrue: [result add: inst]
			ifFalse: [^result]].
	^result
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:09'!
initialize
	hasFrame := false.
	storesPreviousSelf := false
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:52:55'!
isActivation
	^true
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:52:55'!
receiver
	self _ASSERT: (next isLoadImplicit and: [next name = #self]).
	^next
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:09'!
savesPreviousSelf
	^storesPreviousSelf
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:09'!
temporaries
	^temporaries
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:09'!
temporaries: aNumber
	temporaries := aNumber.
	aNumber > 0 ifTrue: [self haveFrame]
! !

!OActivationContext methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:52:55'!
uninitializedTemporariesIn: aBasicBlock
	| uninitialized |
	uninitialized := Set new: temporaries.
	1 to: temporaries do: [:i | uninitialized add: -1 - i].
	aBasicBlock instructionsDo: [:inst | | base index |
		inst isMessageSend ifTrue: [^uninitialized].
		inst isStore ifTrue: [
			base := inst base.
			(base == self and: [
				index := inst index.
				index isInteger])
				ifTrue: [uninitialized remove: index ifAbsent: nil]]].
	^uninitialized
! !

!OActivationContext class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 14:00:09'!
new
	^self basicNew initialize
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
arguments
	^arguments
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
arguments: operands
	arguments := operands
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
atOperand: named
	^named == #receiver ifTrue: [receiver] ifFalse: [arguments at: named]
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
atOperand: name put: instruction
	name = #receiver
		ifTrue: [receiver := instruction]
		ifFalse: [arguments at: name put: instruction]
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicAcceptVisitor: aVisitor
	^aVisitor visitMessageSend: self
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicPrintString
	| string |
	string := arguments size > 0
		ifTrue: [' with: '
			, (arguments gather: [:arg | arg primitivePrintString , ' '])]
		ifFalse: [''].
	^'[send #' , selector , ' to ' , receiver primitivePrintString
		, string trimTrailingBlanks
		, ']'
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
isMessageSend
	^true
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
operandsDo: aBlock
	aBlock value: receiver.
	arguments do: aBlock
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
primitivePrintString
	^'{#' , selector , '}'
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
printStringUsing: names
	| string |
	string := arguments size > 0
		ifTrue: [' with: '
			, (arguments gather: [:arg | (names at: arg ifAbsent: ['missing']) , ' '])]
		ifFalse: [''].
	^'send #' , selector , ' to ' , (names at: receiver ifAbsent: ['missing'])
		, string trimTrailingBlanks
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
receiver
	^receiver
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
receiver: operand
	receiver := operand
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
selector
	^selector
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
selector: aSymbol
	selector := aSymbol
! !

!OMessageSend methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
usesResultOf: anInstruction
	^receiver == anInstruction
		or: [arguments anySatisfy: [:argument | argument == anInstruction]]
! !

!OMessageSend methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:56'!
copyTo: copy with: map
	| args |
	super copyTo: copy with: map.
	copy
		selector: selector;
		receiver: (receiver duplicateWith: map).
	args := arguments collect: [:a | a duplicateWith: map].
	copy arguments: args
! !

!OMessageSend class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
receiver: receiver selector: selector arguments: arguments
	^self new
		receiver: receiver;
		selector: selector;
		arguments: arguments;
		yourself
! !

!OMessageSend class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
selector: selector
	^self new selector: selector
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
addVariable: value from: block
	self DENY: (blocks includes: block).
	variables add: value.
	blocks add: block.
	value addUse: self at: block
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
atOperand: name
	| index |
	index := blocks indexOf: name.
	^variables at: index
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
atOperand: name put: instruction
	| index |
	index := blocks indexOf: name.
	variables at: index put: instruction
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
basicAcceptVisitor: aVisitor
	^aVisitor visitPhi: self
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
basicPrintString
	| sources |
	sources := variables size > 0
		ifTrue: [
			(variables
				with: blocks
				collect: [:var :block | block name , '->' , var primitivePrintString])
				gather: [:x | x , ', ']]
		ifFalse: ['  '].
	^'[phi(' , (sources allButLast: 2) , ')]'
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
blocks: aCollection
	blocks := aCollection
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
clearVariables
	variables := OrderedCollection new.
	blocks := OrderedCollection new
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
initialize
	variables := OrderedCollection new.
	blocks := OrderedCollection new
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
isPhi
	^true
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
operandsDo: aBlock
	variables do: aBlock
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
primitivePrintString
	^'{#phi}'
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
printStringUsing: names
	| sources |
	sources := variables size > 0
		ifTrue: [
			(variables
				with: blocks
				collect: [:var :block | (names at: block ifAbsent: ['missing']) , '->'
					, (names at: var ifAbsent: ['missing'])])
				gather: [:x | x , ', ']]
		ifFalse: ['  '].
	^'phi(' , (sources allButLast: 2) , ')'
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
removeBlock: removed
	| index variable |
	index := blocks indexOf: removed.
	variable := variables at: index.
	variable removeUse: self at: removed.
	variables removeIndex: index.
	blocks removeIndex: index.
	variables size = 1 ifTrue: [
		self replaceAllUsesWith: variables first; dissolve.
		^variables first].
	^self
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:08'!
removeIfPossible
	variables size = 1
		ifTrue: [self replaceAllUsesWith: variables first; dissolve]
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
removeVariable: removed at: index
	| block |
	block := blocks at: index.
	removed removeUse: self at: block.
	variables removeIndex: index.
	blocks removeIndex: index.
	variables size = 1
		ifTrue: [self replaceAllUsesWith: variables first; dissolve]
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
sortAfter: predecessors
	| indices |
	indices := predecessors collect: [:pred | blocks indexOf: pred].
	variables := indices collect: [:index | variables at: index].
	blocks := predecessors copy
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
usesResultOf: anInstruction
	^variables includes: anInstruction
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
variables
	^variables
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
variables: aCollection
	variables := aCollection
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:08'!
variables: aCollection blocks: anotherCollection
	blocks := anotherCollection.
	variables := aCollection.
	variables with: blocks do: [:var :block | var addUse: self at: block]
! !

!OPhi methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
variablesWithBlocksDo: aBlock
	variables with: blocks do: aBlock
! !

!OPhi methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:08'!
basicVariables: aCollection blocks: anotherCollection
	blocks := anotherCollection.
	variables := aCollection
! !

!OPhi methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:08'!
copyTo: copy with: map
	| b v |
	super copyTo: copy with: map.
	b := blocks collect: [:block | block duplicateWith: map].
	v := variables collect: [:variable | variable duplicateWith: map].
	copy variables: v blocks: b
! !

!OPhi methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:08'!
isBoolean
	^variables conform: [:v | v isBoolean]
! !

!OPhi methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 14:00:09'!
blocks
	^blocks
! !

!OPhi methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 14:00:09'!
realReverseDo: aBlock
	
! !

!OPhi methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 14:00:09'!
replaceBlock: original with: new
	blocks withIndexDo: [:block :i | | source |
		block == original ifTrue: [
			source := variables at: i.
			source updateUser: self named: original with: new.
			blocks at: i put: new]]
! !

!OPhi methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:53:08'!
canHaveSideEffects
	^false
! !

!OPhi methodsFor: 'printing' stamp: 'KenD 11/22/2023 14:00:09'!
shortPrintString
	| sources |
	sources := variables size > 0
		ifTrue: [(variables collect: #primitivePrintString) gather: [:x | x , ', ']]
		ifFalse: ['  '].
	^'[phi(' , (sources allButLast: 2) , ')]'
! !

!OPhi class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
new
	^self basicNew initialize
! !

!OPhi class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
with: operation1 from: block1 with: operation2 from: block2
	^self new
		addVariable: operation1 from: block1;
		addVariable: operation2 from: block2
! !

!OPhi class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
withAll: operations in: blocks
	^self new variables: operations; blocks: blocks copy
! !

!OPrimitiveOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
basicPrintString
	^self primitivePrintString
! !

!OPrimitiveOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
name
	^name
! !

!OPrimitiveOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
name: selector
	name := selector
! !

!OPrimitiveOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
primitivePrintString
	^'{#' , name , '}'
! !

!OPrimitiveOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
printStringUsing: names
	^self primitivePrintString
! !

!OPrimitiveOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:04'!
copyTo: copy with: map
	super copyTo: copy with: map.
	copy name: name
! !

!OPrimitiveOperation methodsFor: 'testing' stamp: 'KenD 11/22/2023 14:00:11'!
isPrimitiveOperation
	^true
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
atOperand: named
	^named == #left ifTrue: [left] ifFalse: [right]
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
atOperand: operandName put: instruction
	operandName = #left
		ifTrue: [left := instruction]
		ifFalse: [right := instruction]
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:52'!
canHaveSideEffects
	^name = #_transferControlTo:
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:52'!
copyTo: copy with: map
	super copyTo: copy with: map.
	left isInstruction ifTrue: [copy left: (left duplicateWith: map)].
	right isInstruction ifTrue: [copy right: (right duplicateWith: map)]
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
invertOperation
	name == #'<' ifTrue: [^name := #'>'].
	name == #'<=' ifTrue: [^name := #'>='].
	name == #'>' ifTrue: [^name := #'<'].
	name == #'>=' ifTrue: [^name := #'<='].
	name == #'==' ifTrue: [^name].
	self halt
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:52'!
isBoolean
	^self isComparison
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:52'!
isComparison
	^#(< <= = == !!= >= >) includes: name
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
left
	^left
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
left: anInstruction
	left := anInstruction
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
negateOperation
	name == #'<' ifTrue: [^name := #'>='].
	name == #'<=' ifTrue: [^name := #'>'].
	name == #'>' ifTrue: [^name := #'<='].
	name == #'>=' ifTrue: [name := #'<']
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
right
	^right
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
right: anInstruction
	right := anInstruction
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
swapOperands
	| temp |
	left removeUse: self.
	right removeUse: self.
	temp := left.
	left := right.
	right := temp.
	left addUse: self at: #left.
	right addUse: self at: #right
! !

!OBinaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
usesResultOf: anInstruction
	^left == anInstruction or: [right == anInstruction]
! !

!OBinaryOperation class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:02'!
left: left right: right name: selector
	^self new
		left: left;
		right: right;
		name: selector
! !

!OBinaryConstantOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
basicAcceptVisitor: aVisitor
	^aVisitor visitBinaryWithConstant: self
! !

!OBinaryConstantOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
basicPrintString
	^'[' , left primitivePrintString , ' ' , name , ' '
		, right primitivePrintString
		, ']'
! !

!OBinaryConstantOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
isBinaryConstantOperation
	^true
! !

!OBinaryConstantOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
operandsDo: aBlock
	aBlock value: left
! !

!OBinaryConstantOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:03'!
printStringUsing: names
	^(names at: left ifAbsent: 'missing') , ' ' , name , ' ' , right printString
! !

!OBinaryConstantOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:10'!
right: anInteger
	right := anInteger
! !

!OBinaryVariableOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
basicAcceptVisitor: aVisitor
	^aVisitor visitBinaryWithVariable: self
! !

!OBinaryVariableOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
basicPrintString
	^'[' , left primitivePrintString , ' ' , name , ' '
		, right primitivePrintString
		, ']'
! !

!OBinaryVariableOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
isBinaryVariableOperation
	^true
! !

!OBinaryVariableOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
operandsDo: aBlock
	aBlock value: left.
	aBlock value: right
! !

!OBinaryVariableOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:09'!
printStringUsing: names
	^(names at: left ifAbsent: 'missing') , ' ' , name , ' ' , (names at: right)
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
atOperand: named
	^named == #receiver
		ifTrue: [receiver]
		ifFalse: [named == #left ifTrue: [left] ifFalse: [right]]
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
atOperand: operandName put: instruction
	operandName = #receiver ifTrue: [receiver := instruction] ifFalse: [
		operandName = #left
			ifTrue: [left := instruction]
			ifFalse: [right := instruction]]
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
basicAcceptVisitor: aVisitor
	^aVisitor visitTernary: self
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
basicPrintString
	^'['
		, (receiver isInstruction
			ifTrue: [receiver primitivePrintString]
			ifFalse: [receiver printString]) , ' ' , name , ' '
		, left primitivePrintString
		, ', '
		, right primitivePrintString
		, ']'
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
isTernaryOperation
	^true
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
left
	^left
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
left: value
	left := value
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
printStringUsing: names
	^(receiver isInstruction
		ifTrue: [names at: receiver]
		ifFalse: [receiver printString]) , ' ' , name , ' '
		, (left isInstruction ifTrue: [names at: left] ifFalse: [left printString])
		, ', '
		, (right isInstruction
			ifTrue: [names at: right]
			ifFalse: [right printString])
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
receiver
	^receiver
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
receiver: value
	receiver := value
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
right
	^right
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
right: value
	right := value
! !

!OTernaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
usesResultOf: anInstruction
	^receiver == anInstruction
		or: [left == anInstruction or: [right == anInstruction]]
! !

!OTernaryOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:10'!
operandsDo: aBlock
	aBlock value: receiver.
	left isInstruction ifTrue: [aBlock value: left].
	aBlock value: right
! !

!OTernaryOperation class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:10'!
receiver: receiver left: left right: right name: selector
	^self new
		receiver: receiver;
		left: left;
		right: right;
		name: selector
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
atOperand: operandName
	^receiver
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
atOperand: operandName put: instruction
	receiver := instruction
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicAcceptVisitor: aVisitor
	^aVisitor visitUnary: self
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
basicPrintString
	^'['
		, (receiver isInstruction
			ifTrue: [receiver primitivePrintString]
			ifFalse: [receiver printString]) , ' ' , name , ']'
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
isUnaryOperation
	^true
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
operandsDo: aBlock
	aBlock value: receiver
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
printStringUsing: names
	^(receiver isInstruction
		ifTrue: [names at: receiver]
		ifFalse: [receiver printString]) , ' ' , name
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
receiver
	^receiver
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
receiver: operation
	receiver := operation
! !

!OUnaryOperation methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
usesResultOf: anInstruction
	^receiver == anInstruction
! !

!OUnaryOperation methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:52:58'!
canHaveSideEffects
	^name == #push or: [name == #pop]
! !

!OUnaryOperation methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:52:58'!
isBoolean
	^name == #_isSmallInteger or: [name == #copy and: [receiver isBoolean]]
! !

!OUnaryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:52:58'!
copyTo: copy with: map
	super copyTo: copy with: map.
	copy receiver: (receiver duplicateWith: map)
! !

!OUnaryOperation class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:08'!
receiver: receiver name: aString
	^self new name: aString; receiver: receiver
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
atOperand: operandName
	^operandName == #base ifTrue: [base] ifFalse: [index]
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
atOperand: operandName put: instruction
	operandName == #base
		ifTrue: [base := instruction]
		ifFalse: [index := instruction]
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
base
	^base
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
base: anInstruction
	base := anInstruction.
	anInstruction addUse: self at: #base
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
copyTo: copy with: map
	| i |
	super copyTo: copy with: map.
	copy base: (base duplicateWith: map).
	index isInstruction
		ifTrue: [
			i := index duplicateWith: map.
			copy index: i]
		ifFalse: [copy indexImm: index]
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
index
	^index
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
index: anInstruction
	index := anInstruction.
	anInstruction addUse: self at: #index
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
indexImm: anInteger
	index := anInteger
! !

!OMemoryOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
isMemoryOperation
	^true
! !

!OMemoryOperation methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:53:03'!
usesResultOf: anInstruction
	^base == anInstruction or: [index == anInstruction]
! !

!OLoadOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:01'!
basicAcceptVisitor: aVisitor
	^aVisitor visitLoad: self
! !

!OLoadOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:01'!
basicPrintString
	^'[' , base primitivePrintString , ' ' , name , ' '
		, index primitivePrintString
		, ']'
! !

!OLoadOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:01'!
canHaveSideEffects
	^false
! !

!OLoadOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:01'!
isLoad
	^true
! !

!OLoadOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:01'!
operandsDo: aBlock
	aBlock value: base.
	index isInstruction ifTrue: [aBlock value: index]
! !

!OLoadOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:01'!
printStringUsing: names
	| b i |
	b := names at: base ifAbsent: ['?'].
	i := index isInstruction
		ifTrue: [names at: index ifAbsent: ['?']]
		ifFalse: [index printString].
	^'{#' , b , ' ' , name , ', ' , i , '}'
! !

!OLoadOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:01'!
base: anInstruction byteAt: anInteger
	^self new
		name: #_byteAt:;
		base: anInstruction;
		index: anInteger
! !

!OLoadOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:01'!
base: anInstruction byteAtImm: anInteger
	^self new
		name: #_byteAt:;
		base: anInstruction;
		indexImm: anInteger
! !

!OLoadOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:01'!
base: anInstruction longSlotAt: anInteger
	^self new
		name: #_longSlotAt:;
		base: anInstruction;
		index: anInteger
! !

!OLoadOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:01'!
base: anInstruction longSlotAtImm: anInteger
	^self new
		name: #_longSlotAt:;
		base: anInstruction;
		indexImm: anInteger
! !

!OLoadOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:01'!
base: anInstruction slotAt: anInteger
	^self new
		name: #_basicAt:;
		base: anInstruction;
		index: anInteger
! !

!OLoadOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:01'!
base: anInstruction slotAtImm: anInteger
	^self new
		name: #_basicAt:;
		base: anInstruction;
		indexImm: anInteger
! !

!OLoadOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:01'!
base: anInstruction uLongAtImm: anInteger
	^self new
		name: #_uLongAt:;
		base: anInstruction;
		indexImm: anInteger
! !

!OStoreOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:09'!
atOperand: operandName
	operandName = #value ifTrue: [^value].
	^super atOperand: operandName
! !

!OStoreOperation methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:09'!
atOperand: operandName put: instruction
	operandName = #value
		ifTrue: [value := instruction]
		ifFalse: [super atOperand: operandName put: instruction]
! !

!OStoreOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:09'!
basicAcceptVisitor: aVisitor
	^aVisitor visitStore: self
! !

!OStoreOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:09'!
basicPrintString
	| b |
	b := base isInstruction
		ifTrue: [base primitivePrintString]
		ifFalse: [base printString].
	^'[' , b , ' ' , name , ' ' , index primitivePrintString , ', '
		, value primitivePrintString
		, ']'
! !

!OStoreOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:09'!
copyTo: copy with: map
	| v |
	super copyTo: copy with: map.
	v := value isInstruction
		ifTrue: [value duplicateWith: map]
		ifFalse: [value].
	copy value: v
! !

!OStoreOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:09'!
operandsDo: aBlock
	aBlock value: base.
	index isInstruction ifTrue: [aBlock value: index].
	aBlock value: value
! !

!OStoreOperation methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:09'!
printStringUsing: names
	| b i v |
	b := names at: base ifAbsent: '?'.
	i := index isInstruction
		ifTrue: [names at: index ifAbsent: '?']
		ifFalse: [index printString].
	v := value isInstruction
		ifTrue: [names at: value ifAbsent: '?']
		ifFalse: [value printString].
	^'{#' , b , ' ' , name , ', ' , i , ',' , v , '}'
! !

!OStoreOperation methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:53:09'!
isStore
	^true
! !

!OStoreOperation methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:53:09'!
usesResultOf: anInstruction
	^value == anInstruction or: [super usesResultOf: anInstruction]
! !

!OStoreOperation methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:53:09'!
value
	^value
! !

!OStoreOperation methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:53:09'!
value: anInstruction
	value := anInstruction.
	anInstruction addUse: self at: #value
! !

!OStoreOperation methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:53:09'!
valueImm: anObject
	value := anObject
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction byteAt: indexInstruction put: anotherInstruction
	^self new
		name: #_byteAt:put:;
		base: anInstruction;
		index: indexInstruction;
		value: anotherInstruction
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction byteAtImm: anInteger put: anotherInstruction
	^self new
		name: #_byteAt:put:;
		base: anInstruction;
		indexImm: anInteger;
		value: anotherInstruction
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction longSlotAt: indexInstruction put: anotherInstruction
	^self new
		name: #_longSlotAt:put:;
		base: anInstruction;
		index: indexInstruction;
		value: anotherInstruction
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction longSlotAtImm: indexInstruction put: anotherInstruction
	^self new
		name: #_longSlotAt:put:;
		base: anInstruction;
		indexImm: indexInstruction;
		value: anotherInstruction
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction slotAt: anInteger put: anotherInstruction
	^self new
		name: #_basicAt:put:;
		base: anInstruction;
		index: anInteger;
		value: anotherInstruction
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction slotAtImm: anInteger put: anotherInstruction
	^self new
		name: #_basicAt:put:;
		base: anInstruction;
		indexImm: anInteger;
		value: anotherInstruction
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction uLongAt: anInteger put: anotherInstruction
	^self new
		name: #_uLongAt:put:;
		base: anInstruction;
		index: anInteger;
		value: anotherInstruction
! !

!OStoreOperation class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:53:09'!
base: anInstruction uLongAtImm: indexInstruction put: anotherInstruction
	^self new
		name: #_uLongAt:put:;
		base: anInstruction;
		indexImm: indexInstruction;
		value: anotherInstruction
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
argumentsCount
	^argumentsCount
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
argumentsCount: anInteger
	argumentsCount := anInteger
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
atOperand: name
	^name == #source ifTrue: [source] ifFalse: [frame]
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
atOperand: name put: instruction
	^name == #source
		ifTrue: [source := instruction]
		ifFalse: [frame := instruction]
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
basicAcceptVisitor: aVisitor
	^aVisitor visitReturn: self
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
basicPrintString
	^'[ret ' , source primitivePrintString , ']'
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
frame: anInstruction
	frame := anInstruction
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
isReturn
	^true
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
operandsDo: aBlock
	aBlock value: source.
	aBlock value: frame
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
primitivePrintString
	^'{ret}'
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
printStringUsing: names
	^'ret ' , (names at: source ifAbsent: 'missing') , ''
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
source
	^source
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
source: anInstruction
	source := anInstruction
! !

!OReturn methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:12'!
usesResultOf: anInstruction
	^source == anInstruction or: [frame == anInstruction]
! !

!OReturn methodsFor: 'private' stamp: 'KenD 11/22/2023 07:52:53'!
copyTo: copy with: map
	super copyTo: copy with: map.
	copy
		source: (source duplicateWith: map);
		frame: (frame duplicateWith: map)
! !

!OUseVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
binding
	^binding
! !

!OUseVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
binding: aBinding
	binding := aBinding
! !

!OReadVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
atOperand: name put: instruction
	source := instruction
! !

!OReadVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
basicAcceptVisitor: aVisitor
	^aVisitor visitReadVariable: self
! !

!OReadVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
basicPrintString
	^'[read var #' , (binding ifNil: ['#error'] ifNotNil: [binding name]) , ']'
! !

!OReadVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
operandsDo: aBlock
	source ifNotNil: [aBlock value: source]
! !

!OReadVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
primitivePrintString
	^'{#' , (binding ifNil: ['#error'] ifNotNil: [binding name]) , ' read}'
! !

!OReadVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
source
	^source
! !

!OReadVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
source: anInstruction
	source := anInstruction
! !

!OReadVariable methodsFor: 'printing' stamp: 'KenD 11/22/2023 14:00:07'!
printStringUsing: names
	^self basicPrintString
! !

!OReadVariable class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
binding: binding
	^self new binding: binding
! !

!OReadVariable class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:07'!
source: identifier
	^self new source: identifier
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
atOperand: name put: instruction
	source := instruction
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
basicAcceptVisitor: aVisitor
	^aVisitor visitWriteVariable: self
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
basicPrintString
	| sourceString |
	sourceString := source isInstruction
		ifTrue: [source primitivePrintString]
		ifFalse: [self halt].
	^'[write ' , self name printString , ' with ' , sourceString , ' ]'
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
isStoreVariable
	^true
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
name
	^binding name
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
operandsDo: aBlock
	aBlock value: source
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
primitivePrintString
	^'{write ' , self name printString , ' }'
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
printStringUsing: names
	| sourceString |
	sourceString := source isInstruction
		ifTrue: [names at: source]
		ifFalse: [self halt].
	^'write ' , self name printString , ' with ' , sourceString
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
source
	^source
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
source: operation
	source := operation
! !

!OWriteVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
usesResultOf: anOperand
	^source == anOperand
! !

!OWriteVariable class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:11'!
binding: aBinding valued: operation
	^self new binding: aBinding; source: operation
! !

!OVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
assureBoundBy: aVariableBinder
	binding isPoolVariableBinding
		ifTrue: [^aVariableBinder bindPoolVariable: self with: binding].
	binding isTemporary
		ifTrue: [^aVariableBinder bindTemporary: self with: binding].
	(binding isLiteral or: [binding isPseudo])
		ifTrue: [^aVariableBinder bindSpecial: self with: binding].
	self halt
! !

!OVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
binding: aBinding
	binding := aBinding
! !

!OVariable methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
isConstant
	^false
! !

!OVariable class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:01'!
source: aParseNode
	^self new binding: aParseNode binding
! !

!OptimizingBlockInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:01'!
canBeInlined
	^true
! !

!OptimizingBlockInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:01'!
duplicateClosure: anOCompiledBlock
	| closure activation implicits |
	closure := anOCompiledBlock firstBlock duplicate.
	activation := closure activationRecord.
	implicits := inlinerActivation implicitLoads.
	activation implicitLoads do: [:load | | replacement |
		replacement := implicits detect: [:candidate | candidate name = load name].
		load replaceAllUsesWith: replacement; dissolve].
	activation replaceAllUsesWith: inlinerActivation; dissolve.
	^closure
! !

!OptimizingBlockInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:01'!
inlineValue: message in: block
	| closure entry exit after result |
	closure := message receiver.
	closure isBlockClosure ifFalse: [^block].
	entry := self duplicateClosure: closure.
	exit := entry lastBlock.
	after := block splitAfter: message.
	block endWithJumpTo: entry.
	exit endWithJumpTo: after.
	result := exit lastValue.
	message replaceAllUsesWith: result; dissolve.
	closure isUseless ifTrue: [closure firstBlock dissolveAllInstructions].
	^result -> after
! !

!OptimizingBlockInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:01'!
inlineValue_: message in: block
	| closure args arg1 entry exit after closureArgs result |
	closure := message receiver.
	closure isBlockClosure ifFalse: [^block].
	args := message arguments.
	arg1 := args first.
	entry := self duplicateClosure: closure.
	exit := entry lastBlock.
	closureArgs := self closureArgumentsIn: entry count: 1.
	closureArgs first replaceAllUsesWith: arg1; dissolve.
	after := block splitAfter: message.
	block endWithJumpTo: entry.
	exit endWithJumpTo: after.
	result := exit lastValue.
	message replaceAllUsesWith: result; dissolve.
	closure isUseless ifTrue: [closure firstBlock dissolveAllInstructions].
	^result -> after
! !

!OptimizingBlockInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:01'!
inlineWhileTrue_: message in: block
	| antecedent consequent firstAntecedent firstConsequent lastAntecedent lastConsequent join |
	antecedent := message receiver.
	consequent := message arguments first.
	firstAntecedent := antecedent firstBlock.
	firstConsequent := consequent firstBlock.
	lastAntecedent := firstAntecedent lastBlock.
	lastConsequent := firstConsequent lastBlock.
	join := block splitAfter: message.
	block endWithJumpTo: firstAntecedent.
	lastAntecedent
		endWithJumpFalseTo: join
		skipping: firstConsequent
		if: lastAntecedent lastValue.
	lastConsequent endWithJumpTo: firstAntecedent.
	message dissolve.
	^antecedent -> join
! !

!OptimizingBlockInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:01'!
inlinerActivation: anOActivationRecord
	inlinerActivation := anOActivationRecord
! !

!OptimizingBlockInliner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:01'!
closureArgumentsIn: aBasicBlock count: anInteger
	| result remaining |
	result := OrderedCollection new.
	remaining := anInteger.
	aBasicBlock instructionsDo: [:i | 
		remaining = 0 ifTrue: [^result].
		result add: i.
		remaining := remaining - 1].
	^result
! !

!OptimizingBlockInliner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:59'!
performInlinerFor: messageSend in: block
	| selector inliner |
	selector := messageSend selector asString copyWithout: $:.
	inliner := #inline , selector capitalized , ':in:'.
	^self perform: inliner asSymbol with: messageSend with: block
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
doInline
	self inlineInnerBlocksOf: firstBlock
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inline: aMessageSend in: block
	^self performInlinerFor: aMessageSend in: block
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineAnd: message in: block
	| closure firstSkipped lastSkipped join |
	closure := message arguments first.
	firstSkipped := closure firstBlock.
	self inlineInnerBlocksOf: firstSkipped.
	lastSkipped := firstSkipped lastBlock.
	join := block splitAfter: message.
	join
		insertPhiOf: message receiver
		at: block
		and: lastSkipped
		replacing: message.
	block endWithJumpFalseTo: join skipping: firstSkipped if: message receiver.
	lastSkipped endWithJumpTo: join.
	firstSkipped addPredecessor: block.
	join addPredecessor: block; addPredecessor: lastSkipped.
	^join
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineIfFalse: message in: block
	| closure firstSkipped lastSkipped join |
	closure := message arguments first.
	firstSkipped := closure firstBlock.
	self inlineInnerBlocksOf: firstSkipped.
	lastSkipped := firstSkipped lastBlock.
	join := block splitAfter: message.
	block endWithJumpTrueTo: join skipping: firstSkipped if: message receiver.
	lastSkipped endWithJumpTo: join.
	firstSkipped addPredecessor: block.
	join addPredecessor: lastSkipped; addPredecessor: block.
	message dissolve.
	^join
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineIfTrue: message in: block
	| closure firstSkipped lastSkipped join |
	closure := message arguments first.
	firstSkipped := closure firstBlock.
	self inlineInnerBlocksOf: firstSkipped.
	lastSkipped := firstSkipped lastBlock.
	join := block splitAfter: message.
	block endWithJumpFalseTo: join skipping: firstSkipped if: message receiver.
	lastSkipped endWithJumpTo: join.
	firstSkipped addPredecessor: block.
	join addPredecessor: lastSkipped; addPredecessor: block.
	message dissolve.
	^join
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineIfTrueifFalse: message in: block
	| positive negative firstTrue firstFalse lastTrue lastFalse join |
	positive := message arguments first.
	negative := message arguments second.
	firstTrue := positive firstBlock.
	firstFalse := negative firstBlock.
	self inlineInnerBlocksOf: firstTrue and: firstFalse.
	lastTrue := firstTrue lastBlock.
	lastFalse := firstFalse lastBlock.
	join := block splitAfter: message.
	join insertPhiOf: lastTrue and: lastFalse replacing: message.
	block
		endWithJumpFalseTo: firstFalse
		skipping: firstTrue
		if: message receiver.
	lastTrue endWithJumpTo: join.
	lastFalse endWithJumpTo: join.
	firstTrue addPredecessor: block.
	firstFalse addPredecessor: block.
	join addPredecessor: lastTrue; addPredecessor: lastFalse.
	^join
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineInnerBlocksOf: basicBlock
	| currentBlock |
	currentBlock := basicBlock.
	basicBlock instructionsDo: [:instruction | 
		(self shouldInline: instruction)
			ifTrue: [currentBlock := self inline: instruction in: currentBlock]]
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineInnerBlocksOf: basicBlock1 and: basicBlock2
	self inlineInnerBlocksOf: basicBlock1; inlineInnerBlocksOf: basicBlock2
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineInnerBlocksOf: basicBlock1 and: basicBlock2 and: basicBlock3
	self
		inlineInnerBlocksOf: basicBlock1;
		inlineInnerBlocksOf: basicBlock2;
		inlineInnerBlocksOf: basicBlock3
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineOr: message in: block
	| closure firstSkipped lastSkipped join |
	closure := message arguments first.
	firstSkipped := closure firstBlock.
	self inlineInnerBlocksOf: firstSkipped.
	lastSkipped := firstSkipped lastBlock.
	join := block splitAfter: message.
	join
		insertPhiOf: message receiver
		at: block
		and: lastSkipped
		replacing: message.
	block endWithJumpTrueTo: join skipping: firstSkipped if: message receiver.
	lastSkipped endWithJumpTo: join.
	firstSkipped addPredecessor: block.
	join addPredecessor: block; addPredecessor: lastSkipped.
	^join
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineWhileTrue: message in: block
	| antecedent consequent firstAntecedent firstConsequent lastAntecedent lastConsequent join |
	antecedent := message receiver.
	consequent := message arguments first.
	firstAntecedent := antecedent firstBlock.
	firstConsequent := consequent firstBlock.
	self inlineInnerBlocksOf: firstAntecedent and: firstConsequent.
	lastAntecedent := firstAntecedent lastBlock.
	lastConsequent := firstConsequent lastBlock.
	join := block splitAfter: message.
	block endWithJumpTo: firstAntecedent.
	lastAntecedent
		endWithJumpFalseTo: join
		skipping: firstConsequent
		if: lastAntecedent lastValue.
	lastConsequent endWithJumpTo: firstAntecedent.
	message dissolve.
	firstAntecedent addPredecessor: block; addPredecessor: lastConsequent.
	firstConsequent addPredecessor: lastAntecedent.
	join addPredecessor: lastAntecedent.
	^join
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inliners
	^#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue: and: or: to:do: whileTrue:)
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
on: block
	firstBlock := block
! !

!OptimizingBlockInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
shouldInline: anInstruction
	^anInstruction isMessageSend
		and: [self inliners includes: anInstruction selector]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
activationRecord
	^firstBlock firstInstruction
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
allocationEntry
	^allocationEntry
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
amountOfRegisters
	^amountOfRegisters
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
amountOfRegisters: amount
	amountOfRegisters := amount
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
areEqual: last and: distances
	last size = distances size ifFalse: [^false].
	last keysAndValuesDo: [:key :value | | other |
		other := distances at: key ifAbsent: [^false].
		other = value ifFalse: [^false]].
	^true
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
clobbersOneRegister: inst
	^((inst isJump or: [inst isUnaryOperation and: [inst name == #push]])
		or: [inst isTernaryOperation and: [inst name = #_basicAt:put:]]) not
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
computeEntryRegistersOf: block
	(self isLoopHead: block)
		ifTrue: [self initLoopHeader: block]
		ifFalse: [self initUsual: block]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
computeLiveness
	liveness := OptimizingLivenessAnalysis new
		firstBlock: firstBlock;
		loops: loops;
		analyzeLiveness
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
computeLoops
	loops := firstBlock allLoops
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
computeTemporaryIndexes
	| index |
	index := 1.
	scheduledSpills do: [:value | 
		temporaries at: value put: index.
		index := index + 1].
	self activationRecord temporaries: index - 1
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
computeUseDistanceOf: instruction number: index using: distances
	instruction operandsDo: [:operand | distances at: operand put: index].
	distances removeKey: instruction ifAbsent: []
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
computeUseDistances
	| distancesEntry changed |
	distancesEntry := IdentityDictionary new.
	changed := true.
	[changed] whileTrue: [
		changed := false.
		firstBlock withSuccessorsPostOrder
			do: [:block | changed := (self
				computeUseDistancesOf: block
				using: distancesEntry)
				or: changed]]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
computeUseDistancesOf: block using: distancesEntry
	| distances index length |
	distances := IdentityDictionary new.
	length := block length.
	block successors do: [:succ | | incoming |
		incoming := distancesEntry at: succ ifAbsent: [Dictionary new].
		incoming keysAndValuesDo: [:operand :distance | | previous |
			previous := distances at: operand ifAbsent: Number infinity.
			distances at: operand put: (previous min: distance + length)].
		succ phisDo: [:phi | | operand previous |
			operand := phi atOperand: block.
			previous := distances at: operand ifAbsent: Number infinity.
			distances at: operand put: (previous min: length)]].
	distancesExit
		at: block
		ifPresent: [:last | (self areEqual: last and: distances) ifTrue: [^false]].
	distancesExit at: block put: distances copy.
	index := block indexOf: block lastInstruction.
	block lastInstruction realReverseDo: [:instruction | 
		self computeUseDistanceOf: instruction number: index using: distances.
		index := index - 1].
	distancesEntry at: block put: distances.
	^true
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
couple: block withPredecessor: predecessor
	| predecessors wentry oldSentry predWexit predSexit newSentry difference |
	predecessors := block predecessors intersection: blocksDone.
	predecessors removeIfPresent: block.
	wentry := allocationEntry at: block.
	oldSentry := (predecessors gather: [:pred | spillExit at: pred])
		intersection: wentry.
	predWexit := allocationExit at: predecessor.
	predSexit := spillExit at: predecessor.
	newSentry := (oldSentry , predSexit) withoutDuplicates intersection: wentry.
	(wentry rejectAll: predWexit) do: [:value | 
		(block phis includes: value)
			ifFalse: [self scheduleReload: value before: predecessor lastInstruction]].
	(newSentry rejectAll: predSexit) do: [:value | self scheduleSpillFor: value].
	difference := newSentry rejectAll: oldSentry.
	predecessors do: [:pred | | sexit |
		sexit := spillExit at: pred.
		(difference rejectAll: sexit) do: [:value | self scheduleSpillFor: value]]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
coupleWithPredecessors: block
	| predecessors |
	predecessors := block predecessors intersection: blocksDone.
	currentlySpilled := (predecessors gather: [:pred | spillExit at: pred])
		intersection: currentlyAvailable.
	predecessors do: [:pred | | wexit sexit |
		wexit := allocationExit at: pred.
		(currentlyAvailable rejectAll: wexit) do: [:value | 
			(block phis includes: value)
				ifFalse: [self scheduleReload: value before: pred lastInstruction]].
		sexit := spillExit at: pred.
		(currentlySpilled rejectAll: sexit)
			do: [:value | self scheduleSpillFor: value]]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
deferCouplingOf: block
	deferredCouplings add: block
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
doAllocation
	| redefinitions |
	self computeLoops; computeLiveness; computeUseDistances.
	firstBlock withSuccessorsPostOrder reverseDo: [:block | 
		currentBlock := block.
		self
			computeEntryRegistersOf: block;
			coupleWithPredecessors: block;
			spillAsBeladyIn: block.
		blocksDone add: block.
		block successors
			do: [:succ | (blocksDone includes: succ)
				ifTrue: [self couple: succ withPredecessor: block]]].
	redefinitions := self computeTemporaryIndexes; insertSpillsAndReloads.
	self reconstructSSA: redefinitions
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
firstBlock
	^firstBlock
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
firstBlock: aBlock
	firstBlock := aBlock
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
initLoopHeader: block
	| loop available candidates liveThrough pressure freeLoop extra |
	loop := loops at: block.
	available := (block phis , (self liveInOf: block)) withoutDuplicates.
	candidates := self subsetOf: available usedIn: loop.
	liveThrough := available rejectAll: candidates.
	candidates size < self amountOfRegisters
		ifTrue: [
			pressure := self maxPressureIn: loop.
			freeLoop := self amountOfRegisters - pressure + liveThrough size.
			self sortByUseDistance: liveThrough in: block firstInstruction.
			extra := liveThrough copyTo: freeLoop]
		ifFalse: [
			self sortByUseDistance: candidates in: block firstInstruction.
			candidates := candidates copyTo: self amountOfRegisters.
			extra := OrderedCollection new].
	currentlyAvailable := (candidates , extra) withoutDuplicates.
	allocationEntry at: block put: currentlyAvailable copy
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
initUsual: block
	| frequencies take max chosen candidates |
	frequencies := Dictionary new.
	take := OrderedCollection new.
	candidates := OrderedCollection new.
	max := block predecessors size.
	block predecessors do: [:pred | | wend |
		wend := allocationExit at: pred.
		wend do: [:value | | previous var |
			var := (block isPhiArgument: value)
				ifTrue: [
					(self is: value liveAt: block firstNonPhi) ifTrue: [
						previous := frequencies at: value ifAbsent: [0].
						frequencies at: value put: previous + 1.
						candidates addIfAbsent: value.
						(frequencies at: value) = max ifTrue: [
							candidates removeIfPresent: value.
							take addIfAbsent: value]].
					block phiWithArgument: value]
				ifFalse: [value].
			previous := frequencies at: var ifAbsent: [0].
			frequencies at: var put: previous + 1.
			candidates addIfAbsent: var.
			(frequencies at: var) = max ifTrue: [
				candidates removeIfPresent: var.
				take addIfAbsent: var]]].
	candidates := self selectAliveIn: candidates at: block firstInstruction.
	self sortByUseDistance: candidates in: block firstInstruction.
	take := self selectAliveIn: take at: block firstInstruction.
	chosen := candidates truncateTo: self amountOfRegisters - take size.
	take addAll: chosen.
	currentlyAvailable := take withoutDuplicates.
	allocationEntry at: block put: currentlyAvailable copy
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
initialize
	currentlyAvailable := OrderedCollection new.
	currentlySpilled := OrderedCollection new.
	amountOfRegisters := 5.
	scheduledReloads := OrderedCollection new.
	scheduledSpills := OrderedCollection new.
	blocksDone := Set new.
	allocationEntry := Dictionary new.
	allocationExit := Dictionary new.
	distancesExit := IdentityDictionary new.
	spillExit := Dictionary new.
	temporaries := Dictionary new.
	deferredCouplings := Set new
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
insertReloadOf: value before: user
	| stack index reload |
	stack := self activationRecord.
	index := self temporaryIndexOf: value.
	reload := OBinaryConstantOperation
		left: stack
		right: index
		name: #_basicAt:.
	stack addUse: reload at: #left.
	user
		beforeInsert: reload;
		replaceUsesOf: value with: reload.
	^reload
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
insertSpillOf: value
	| stack index store |
	stack := self activationRecord.
	index := self temporaryIndexOf: value.
	store := OTernaryOperation
		receiver: stack
		left: index
		right: value
		name: #_basicAt:put:.
	stack addUse: store at: #receiver.
	value addUse: store at: #right.
	value lastPhi afterInsert: store.
	liveness kill: store at: store
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
insertSpillsAndReloads
	| redefinitions |
	scheduledSpills do: [:value | self insertSpillOf: value].
	redefinitions := Dictionary new.
	scheduledReloads do: [:association | | value user reload collection |
		value := association key.
		user := association value.
		reload := self insertReloadOf: value before: user.
		collection := redefinitions at: value ifAbsentPut: [OrderedCollection new].
		collection add: reload].
	^redefinitions
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
is: value liveAt: instruction
	^(self useDistanceFrom: instruction to: value) !!= Number infinity
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
isLoopHead: block
	^loops includesKey: block
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
limitAt: inst to: limit
	| stack |
	self sortByUseDistance: currentlyAvailable in: inst.
	stack := self activationRecord.
	(currentlyAvailable includes: stack)
		ifTrue: [currentlyAvailable remove: stack; addFirst: stack].
	currentlyAvailable from: limit + 1 to: currentlyAvailable size do: [:value | 
		((currentlySpilled includes: value) not
			and: [(self useDistanceFrom: inst to: value) !!= Number infinity])
			ifTrue: [self scheduleSpillFor: value].
		currentlySpilled removeIfPresent: value].
	currentlyAvailable := currentlyAvailable truncateTo: limit
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
liveInOf: block
	^liveness liveInOf: block
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
maxPressureIn: loop
	^liveness maxPressureIn: loop
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
reconstructSSA: reloads
	| reconstructor |
	reconstructor := OptimizingSSAReconstructor new firstBlock: firstBlock.
	reloads
		keysAndValuesDo: [:variable :redefinitions | reconstructor
			setupFor: variable with: redefinitions;
			reconstructSSA]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
scheduleReload: value before: user
	self haltWhen: value printString = '[send #classField to {#_basicAt:}]'.
	scheduledReloads add: value -> user
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
scheduleSpillFor: value
	scheduledSpills addIfAbsent: value
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
selectAliveIn: collection at: instruction
	^collection select: [:value | self is: value liveAt: instruction]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
sortByUseDistance: candidates in: inst
	| stack |
	candidates
		sortBy: [:a :b | (self useDistanceFrom: inst to: a)
			< (self useDistanceFrom: inst to: b)].
	stack := self activationRecord.
	(candidates includes: stack)
		ifTrue: [candidates remove: stack; addFirst: stack]
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
spillAsBeladyIn: block
	| k |
	k := self amountOfRegisters.
	block realInstructionsDo: [:inst | | missing |
		missing := (inst operands rejectAll: currentlyAvailable)
			select: [:arg | self clobbersOneRegister: arg].
		missing do: [:use | 
			currentlyAvailable addIfAbsent: use.
			currentlySpilled addIfAbsent: use].
		self limitAt: inst to: k.
		inst isMessageSend ifTrue: [self limitAt: inst to: 1].
		(self clobbersOneRegister: inst) ifTrue: [
			self limitAt: inst next to: k - 1.
			currentlyAvailable add: inst].
		missing do: [:value | self scheduleReload: value before: inst]].
	allocationExit at: block put: currentlyAvailable copy.
	spillExit at: block put: currentlySpilled copy
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
subsetOf: available usedIn: loop
	"
	todo
	"
	^available
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
temporaryIndexOf: value
	^-1 - (temporaries at: value)
! !

!OptimizingBraunAllocator methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
useDistanceFrom: inst to: anotherInst
	| near distances |
	near := inst useDistanceTo: anotherInst.
	^near = Number infinity
		ifTrue: [
			distances := distancesExit at: currentBlock.
			distances at: anotherInst ifAbsent: [Number infinity]]
		ifFalse: [near]
! !

!OptimizingBraunAllocator methodsFor: 'accessing' stamp: 'KenD 11/22/2023 14:00:00'!
liveness
	^liveness
! !

!OptimizingBraunAllocator class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 14:00:00'!
new
	^self basicNew initialize
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
allRegistersByPreference
	^self wordSize = 4
		ifTrue: [
			Array
				with: ebp
				with: eax
				with: edx
				with: ecx
				with: esi]
		ifFalse: [
			OrderedCollection new
				add: rbp;
				add: rax;
				add: rdx;
				add: rcx;
				add: rsi;
				add: r8;
				add: r9;
				add: r10;
				add: r11;
				add: rbx;
				add: r12;
				add: r13;
				add: r14;
				add: r15;
				yourself]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
assignRegisterTo: instruction
	| register |
	self enforceConstraints: instruction.
	instruction operandsDo: [:operand | 
		(self clobbersOneRegister: operand) ifTrue: [
			(self does: operand dieAt: instruction) ifTrue: [
				register := assignments at: operand.
				occupied removeKey: register]]].
	(self clobbersOneRegister: instruction) ifTrue: [
		self getRegisterFor: instruction.
		(self does: instruction dieAt: instruction) ifTrue: [
			register := assignments at: instruction.
			occupied removeKey: register]]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
assignRegisters
	self
		computeLiveness;
		computeClusters;
		purgeAllocationEntry;
		preinitializePreferences;
		integrateABIPreferences;
		doAssignRegisters.
	^assignments
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
clobbersOneRegister: inst
	^((inst isJump or: [inst isUnaryOperation and: [inst name == #push]])
		or: [inst isTernaryOperation and: [inst name = #_basicAt:put:]]) not
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
colorBlock: block
	"
	Determine initial register occupation and color φ-nodes
	"
	| incoming initial |
	incoming := liveness liveInOf: block.
	initial := incoming collect: [:value | (assignments at: value) -> value].
	occupied := Dictionary withAll: initial.
	block phisDo: [:phi | self getRegisterFor: phi].
	block predecessors do: [:pred | 
		(processed includes: pred)
			ifTrue: [self insertParallelCopiesFrom: pred to: block]].
	"Assign registers"
	block firstNonPhi do: [:instruction | self assignRegisterTo: instruction].
	processed add: block.
	block successors do: [:succ | 
		(processed includes: succ)
			ifTrue: [self insertParallelCopiesFrom: block to: block successors first]]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
computeClusters
	firstBlock withSuccessorsPostOrder do: [:block | 
		block phisDo: [:phi | | cluster |
			cluster := clusters at: phi ifAbsentPut: [OrderedCollection with: phi].
			phi operandsDo: [:value | 
				cluster addIfAbsent: value.
				clusters at: value put: cluster]]]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
computeLiveness
	liveness analyzeLiveness
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
computePreferences: block
	| argument |
	argument := firstBlock firstInstruction next next.
	argument do: [:instr | | reg index pref |
		instr isLoadImplicit ifFalse: [^self].
		reg := instr source.
		index := self indexOf: reg.
		pref := preferences at: instr.
		pref at: index put: (pref at: index) + 1]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
doAssignRegisters
	self preallocateImplicitVariables.
	firstBlock withSuccessorsPostOrder
		reverseDo: [:block | self colorBlock: block]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
does: operand dieAt: instruction
	^liveness does: operand dieAt: instruction
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
enforceConstraints: instruction
	
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
from: allocator
	firstBlock := allocator firstBlock.
	allocationEntry := allocator allocationEntry
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
getRegisterFor: var
	| prefs candidates cluster reg |
	assignments at: var ifPresent: [:preset | reg := preset].
	reg == nil ifTrue: [
		var isMessageSend ifTrue: [reg := self getRegisterForSend: var] ifFalse: [
			prefs := preferences at: var.
			candidates := self registersByPreference: prefs.
			cluster := clusters at: var ifAbsent: nil.
			cluster ifNotNil: [
				assignments
					at: cluster
					ifPresent: [:best | candidates remove: best; addFirst: best]].
			reg := candidates
				detect: [:register | (occupied includesKey: register) not]]].
	occupied at: reg put: var.
	assignments at: var put: reg.
	cluster ifNotNil: [assignments at: cluster put: reg].
	^reg
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
getRegisterForSend: send
	| receiver copy |
	receiver := send receiver.
	copy := receiver insertCopyBefore: send.
	copy addUse: send at: #receiver.
	receiver removeUse: send at: #receiver.
	liveness kill: copy at: send.
	assignments at: copy put: eax.
	^eax
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
indexOf: register
	| regs |
	regs := self wordSize = 4
		ifTrue: #(ebp eax edx ecx esi)
		ifFalse: [#(rbp rax rdx rcx rsi r8 r9 r10 r11 rbx r12 r13 r14 r15)].
	^regs indexOf: register name
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
initialize
	processed := OrderedCollection new.
	preferences := Dictionary new.
	assignments := Dictionary new.
	clusters := Dictionary new
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
insertCopyTo: dest for: phi at: pred
	| value copy |
	value := phi atOperand: pred.
	copy := value insertCopyBefore: pred lastInstruction.
	assignments at: copy put: dest.
	value removeUse: phi at: pred.
	phi atOperand: pred put: copy
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
insertParallelCopiesFrom: pred to: block
	| phis sources destinations saved |
	phis := block phis.
	sources := phis collect: [:phi | | value |
		value := phi atOperand: pred.
		assignments at: value].
	destinations := phis collect: [:phi | assignments at: phi].
	"remove nops"
	phis size to: 1 by: -1 do: [:i | 
		(sources at: i) = (destinations at: i) ifTrue: [
			sources removeIndex: i.
			destinations removeIndex: i.
			phis removeIndex: i]].
	"schedule copies"
	saved := OrderedCollection new.
	[
		self scheduleCopyingOf: phis from: pred.
		phis size > 0]
		whileTrue: [| free |
			free := phis first.
			self insertPushOf: (free atOperand: pred) at: pred.
			saved add: free.
			phis removeIndex: 1.
			sources removeIndex: 1.
			destinations removeIndex: 1].
	[saved isEmpty] whileFalse: [| var |
		var := saved removeLast.
		self insertPopOf: var at: pred]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
insertPopOf: var at: pred
	| pop reg |
	pop := OUnaryOperation receiver: nil name: #pop.
	pred lastInstruction beforeInsert: pop.
	reg := assignments at: var.
	assignments at: pop put: reg
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
insertPushOf: var at: pred
	var insertPushBefore: pred lastInstruction
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
integrateABIPreferences
	firstBlock withSuccessorsPostOrder
		do: [:block | self computePreferences: block]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
liveInOf: block
	^liveness liveInOf: block
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
liveness: aLivenessAnalysis
	liveness := aLivenessAnalysis
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
preallocateImplicitVariables
	| in |
	in := OrderedCollection new.
	firstBlock instructionsDo: [:inst | | register |
		inst isLoadImplicit ifTrue: [
			register := inst source.
			register ifNotNil: [
				in add: inst.
				assignments at: inst put: register]]].
	(liveness liveInOf: firstBlock) addAll: in
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
preinitializePreferences
	firstBlock instructionsWithSuccessorsDo: [:instruction | | array |
		array := #[0 0 0 0 0 0 0 0].
		preferences at: instruction put: array copy]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
purgeAllocationEntry
	firstBlock withSuccessorsPostOrder do: [:block | | alive available |
		alive := self liveInOf: block.
		available := allocationEntry at: block.
		available
			removeAllSuchThat: [:var | (block phis includes: var)
				or: [(alive includes: var) not]]]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
registersByPreference: prefs
	| all indexes |
	all := self allRegistersByPreference.
	indexes := (1 to: all size) asOrderedCollection.
	indexes sortBy: [:i :j | (prefs at: i) > (prefs at: j) or: [i < j]].
	^indexes collect: [:index | all at: index]
! !

!OptimizingBraunAssigner methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:55'!
scheduleCopyingOf: phis from: pred
	| destinations changed sources |
	sources := phis collect: [:phi | | value |
		value := phi atOperand: pred.
		assignments at: value].
	destinations := phis collect: [:phi | assignments at: phi].
	"schedule copies"
	changed := true.
	[phis size > 0 and: changed] whileTrue: [
		changed := false.
		phis size to: 1 by: -1 do: [:i | | dest phi |
			dest := destinations at: i.
			(sources includes: dest) ifFalse: [
				phi := phis at: i.
				self insertCopyTo: dest for: phi at: pred.
				sources removeIndex: i.
				destinations removeIndex: i.
				phis removeIndex: i.
				changed := true]]]
! !

!OptimizingBraunAssigner class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:55'!
new
	^self basicNew initialize
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
addPredecessor: predecessor like: middle to: final
	final phisDo: [:phi | | source |
		source := phi atOperand: middle.
		phi addVariable: source from: predecessor].
	final addPredecessor: predecessor.
	^final
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
cleanFrom: aBlock
	| all |
	firstBlock := aBlock.
	all := firstBlock successorsPostOrder.
	[
		firstBlock updatePredecessors.
		self simplify]
		whileTrue: [all do: [:block | block dissolveIfUnreachable]]
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
hoistBranchIn: succ to: pred
	| jump branch condition new target1 target2 |
	jump := pred lastInstruction.
	branch := succ lastInstruction.
	condition := branch variable.
	succ
		phisDo: [:phi | 
			condition := phi atOperand: pred.
			phi removeBlock: pred];
		removePredecessor: pred.
	target1 := self addPredecessor: pred like: succ to: branch target.
	target2 := self addPredecessor: pred like: succ to: branch implicitTarget.
	new := branch class
		variable: condition
		target: target1
		implicitTarget: target2.
	condition addUse: new at: #variable.
	jump dissolveReplacingWith: new
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
simplify
	| changed |
	changed := false.
	firstBlock postOrderDo: [:block | 
		changed := (self tryFoldingRedundantBranch: block) or: changed.
		(self tryRemovingEmptyBlock: block) ifTrue: [changed := true] ifFalse: [
			changed := (self tryCombining: block) or: changed.
			changed := (self tryHoistingBranch: block) or: changed]].
	^changed
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
tryCombining: block
	| last following |
	last := block lastInstruction.
	(last isUnconditionalJump and: [
		following := last target.
		following predecessors size = 1])
		ifTrue: [
			following successors do: [:successor | 
				successor
					addPredecessor: block;
					removePredecessor: following;
					phisDo: [:phi | phi replaceBlock: following with: block]].
			last afterInsertAll: following firstInstruction; dissolve.
			^true].
	^false
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
tryFoldingRedundantBranch: block
	| last |
	last := block lastInstruction.
	(last isConditionalJump and: [last target == last implicitTarget])
		ifTrue: [| jump |
			jump := OJump to: last target.
			last dissolveReplacingWith: jump.
			^true].
	(last isConditionalJump and: [last variable isConstant]) ifTrue: [
		last replaceWithUnconditional: last variable value in: block.
		^true].
	^false
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
tryHoistingBranch: block
	| last following |
	last := block lastInstruction.
	(last isUnconditionalJump and: [
		following := last target.
		following isEmptyBranch or: [following isEmptyPhiBranch]])
		ifTrue: [
			self hoistBranchIn: following to: block.
			^true].
	^false
! !

!OptimizingCFGSimplifier methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
tryRemovingEmptyBlock: block
	| following |
	block isEmptyJump ifTrue: [
		following := block lastInstruction target.
		following incorporatePhisFrom: block; removePredecessor: block.
		block predecessors do: [:predecessor | 
			predecessor lastInstruction retargetFrom: block to: following.
			following addPredecessor: predecessor].
		^true].
	^false
! !

!OptimizingCSSATransformer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:55'!
applyTransformation
	self splitPhis; coalescePhis
! !

!OptimizingCSSATransformer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:55'!
coalescePhis
	"
	to do
	"
	
! !

!OptimizingCSSATransformer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:55'!
firstBlock: block
	firstBlock := block
! !

!OptimizingCSSATransformer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:05'!
insertionPointFor: anOBasicBlock
	| instruction prev |
	instruction := anOBasicBlock lastInstruction.
	instruction isConditionalJump ifFalse: [^instruction].
	prev := instruction prev.
	^prev == instruction variable ifTrue: [prev] ifFalse: [instruction]
! !

!OptimizingCSSATransformer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:05'!
liftPhi: phi
	phi variablesWithBlocksDo: [:var :pred | | copy insertion |
		insertion := self insertionPointFor: pred.
		copy := var insertCopyBefore: insertion.
		phi atOperand: pred put: copy.
		var removeUse: phi at: pred; dissolveIfUseless.
		copy addUse: phi at: pred]
! !

!OptimizingCSSATransformer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:55'!
liftPhisIn: block
	block phisDo: [:phi | 
		phi variablesWithBlocksDo: [:var :pred | | copy |
			copy := var insertCopyBefore: pred lastInstruction.
			phi atOperand: pred put: copy.
			var removeUse: phi at: pred; dissolveIfUnused.
			copy addUse: phi at: pred]]
! !

!OptimizingCSSATransformer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:55'!
splitPhis
	firstBlock withSuccessorsPostOrder do: [:block | self liftPhisIn: block]
! !

!OptimizingCodeEmitter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:57'!
abi: anAbi
	abi := anAbi.
	assembler wordSize: anAbi wordSize
! !

!OptimizingCodeEmitter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:57'!
method: aCompiledMethod
	method := aCompiledMethod
! !

!OptimizingCodeEmitter methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:57'!
savesPreviousSelf
	^self activationRecord savesPreviousSelf
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
activationRecord
	^firstBlock firstInstruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
allocation: anAllocation
	allocation := anAllocation
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleAsNative: asNativeSend
	| src dst |
	src := allocation at: asNativeSend receiver.
	dst := allocation at: asNativeSend.
	self ASSERT: src == dst.
	assembler convertToNativeInteger: src
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleAsObject: asNativeSend
	| src dst |
	src := allocation at: asNativeSend receiver.
	dst := allocation at: asNativeSend.
	self ASSERT: src == dst.
	assembler clearIntegerBit: src
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleAsPointer: asNativeSend
	| src dst oop |
	src := allocation at: asNativeSend receiver.
	dst := allocation at: asNativeSend.
	self ASSERT: src == dst.
	oop := assembler newLabel.
	assembler
		testIntegerBit: src;
		jumpIfZeroTo: oop;
		convertToNativeInteger: src;
		@ oop;
		setIntegerBit: src
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleAsSmallInteger: asNativeSend
	| src dst |
	src := allocation at: asNativeSend receiver.
	dst := allocation at: asNativeSend.
	self ASSERT: src == dst.
	assembler convertToSmallInteger: src
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicAtPut: instruction
	| base value index |
	index := instruction left value.
	index isInteger ifTrue: [^self assembleBasicAtPutConstant: instruction].
	base := allocation at: instruction receiver.
	value := allocation at: instruction right.
	index := allocation at: index.
	assembler
		convertToNativeInteger: index;
		store: value in: base indexAt: index;
		convertToSmallInteger: index
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicAtPutConstant: instruction
	| base value position |
	base := allocation at: instruction receiver.
	value := allocation at: instruction right.
	position := instruction left value.
	assembler store: value in: base index: position
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBitAnd: instruction
	| left right |
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	assembler and: left with: right
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBitAndConstant: instruction
	| left value |
	left := allocation at: instruction.
	value := instruction right * 2 + 1.
	assembler and: left with: value
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBitOr: instruction
	| left right |
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	assembler or: left with: right
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBitOrConstant: instruction
	| left value |
	left := allocation at: instruction.
	value := instruction right * 2 + 1.
	assembler or: left with: value
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBitShift: instruction
	| src offset |
	src := allocation at: instruction left.
	instruction right isConstant
		ifTrue: [self assembleBitShift: src by: instruction right value]
		ifFalse: [
			offset := allocation at: instruction right.
			offset halt]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBitShift: src by: amount
	amount > 0
		ifTrue: [
			assembler
				convertToNativeInteger: src;
				shiftLeft: src by: amount + 1;
				convertToSmallInteger: src]
		ifFalse: [
			assembler
				shiftRight: src by: 0 - amount;
				setIntegerBit: src]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBitShiftConstant: instruction
	| src amount |
	src := allocation at: instruction left.
	amount := instruction right.
	self assembleBitShift: src by: amount
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleByteAt: index put: instruction
	self assembleByteAtOffset: index - 1 put: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleByteAtOffset: offset put: instruction
	| base value |
	base := allocation at: instruction left.
	value := allocation at: instruction right.
	assembler
		convertToNativeInteger: value;
		renameByteRegisterIfNeeded: value
		preserving: base
		during: [:final | assembler storeByte: final byte in: base offset: offset];
		convertToSmallInteger: value
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleByteAtPut: instruction
	| index base value |
	base := allocation at: instruction receiver.
	index := allocation at: instruction left.
	value := allocation at: instruction right.
	assembler
		convertToNativeInteger: index;
		convertToNativeInteger: value;
		renameByteRegisterIfNeeded: value
		preserving: base
		preserving: index
		during: [:final | assembler store: final byte in: base indexAt: index];
		convertToSmallInteger: value;
		convertToSmallInteger: index
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleCompare: instruction
	| left right |
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	assembler compare: left with: right
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleCompareConstant: instruction jumpTrue: trueBlock jumpFalse: falseBlock
	| left value |
	left := allocation at: instruction left.
	instruction right isSmallInteger
		ifTrue: [
			value := instruction right * 2 + 1.
			assembler compare: left with: value]
		ifFalse: [
			value := instruction right.
			assembler compare: left withPointer: value].
	self assembleJumpTrue: trueBlock orJumpFalse: falseBlock in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleEquals: instruction
	self
		assembleCompare: instruction;
		assembleJumpTrue: [:label | assembler jumpIfEqualTo: label]
		orJumpFalse: [:label | assembler jumpIfNotEqualTo: label]
		in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleEqualsConstant: instruction
	self
		assembleCompareConstant: instruction
		jumpTrue: [:label | assembler jumpIfEqualTo: label]
		jumpFalse: [:label | assembler jumpIfNotEqualTo: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleFrom: aBasicBlock
	firstBlock := aBasicBlock.
	blocks := firstBlock withSuccessorsPostOrder reversed.
	self doAssemble
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleGenericMessageSend: instruction
	self assembleLookup: instruction selector
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleGreater: instruction
	self
		assembleCompare: instruction;
		assembleJumpTrue: [:label | assembler jumpIfGreaterSignedTo: label]
		orJumpFalse: [:label | assembler jumpIfLessOrEqualSignedTo: label]
		in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleGreaterConstant: instruction
	self
		assembleCompareConstant: instruction
		jumpTrue: [:label | assembler jumpIfGreaterSignedTo: label]
		jumpFalse: [:label | assembler jumpIfLessOrEqualSignedTo: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleGreaterEqual: instruction
	self
		assembleCompare: instruction;
		assembleJumpTrue: [:label | assembler jumpIfGreaterOrEqualSignedTo: label]
		orJumpFalse: [:label | assembler jumpIfLessSignedTo: label]
		in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleGreaterEqualConstant: instruction
	self
		assembleCompareConstant: instruction
		jumpTrue: [:label | assembler jumpIfGreaterOrEqualSignedTo: label]
		jumpFalse: [:label | assembler jumpIfLessSignedTo: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleIsSmallInteger: instruction
	| src |
	src := allocation at: instruction receiver.
	assembler testIntegerBit: src.
	self
		assembleJumpTrue: [:label | assembler jumpIfNotZeroTo: label]
		orJumpFalse: [:label | assembler jumpIfZeroTo: label]
		in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleJumpIfEqualTo: target
	| label |
	label := jumpDestinations at: target.
	assembler jumpIfEqualTo: label
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleJumpTo: target
	| label index |
	label := jumpDestinations at: target.
	index := blocks indexOf: target.
	^((index - currentBlockIndex) abs > 18 or: true)
		ifTrue: [assembler jumpTo: label]
		ifFalse: [assembler shortJumpTo: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleJumpTrue: blockJumpTrue orJumpFalse: blockJumpFalse in: instruction
	| next end result label loadFalse |
	next := instruction next.
	(next isConditionalJump and: [instruction allUses size = 1])
		ifTrue: [
			label := jumpDestinations at: next target.
			next isJumpTrue
				ifTrue: [blockJumpTrue value: label]
				ifFalse: [blockJumpFalse value: label].
			self nextBlock !!= next implicitTarget
				ifTrue: [self assembleJumpTo: next implicitTarget]]
		ifFalse: [
			result := allocation at: instruction.
			loadFalse := assembler newLabel.
			end := assembler newLabel.
			blockJumpFalse value: loadFalse.
			self assembleLoadConstant: true to: result.
			assembler shortJumpTo: end; @ loadFalse.
			self assembleLoadConstant: false to: result.
			assembler @ end]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleLookup: selector
	self haltWhen: selector = #'&'.
	messageLinker emitSend: selector using: assembler
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleLower: instruction
	self
		assembleCompare: instruction;
		assembleJumpTrue: [:label | assembler jumpIfLessSignedTo: label]
		orJumpFalse: [:label | assembler jumpIfGreaterOrEqualSignedTo: label]
		in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleLowerConstant: instruction
	self
		assembleCompareConstant: instruction
		jumpTrue: [:label | assembler jumpIfLessSignedTo: label]
		jumpFalse: [:label | assembler jumpIfGreaterOrEqualSignedTo: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleLowerEqual: instruction
	self
		assembleCompare: instruction;
		assembleJumpTrue: [:label | assembler jumpIfLessOrEqualSignedTo: label]
		orJumpFalse: [:label | assembler jumpIfGreaterSignedTo: label]
		in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleLowerEqualConstant: instruction
	self
		assembleCompareConstant: instruction
		jumpTrue: [:label | assembler jumpIfLessOrEqualSignedTo: label]
		jumpFalse: [:label | assembler jumpIfGreaterSignedTo: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleMinus: instruction
	| left right |
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	assembler
		add: 1 to: left;
		subtract: right from: left
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleMinusConstant: instruction
	| left value |
	left := allocation at: instruction left.
	value := instruction right * 2.
	assembler subtract: value from: left
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleNegate: instruction
	| src dst |
	src := allocation at: instruction receiver.
	dst := allocation at: instruction.
	self ASSERT: dst = src.
	assembler
		negate: src;
		add: 2 to: dst
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleNotEqualConstant: instruction
	self
		assembleCompareConstant: instruction
		jumpTrue: [:label | assembler jumpIfNotEqualTo: label]
		jumpFalse: [:label | assembler jumpIfEqualTo: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleObjectAtOffsetPut: instruction
	| base value offset |
	base := allocation at: instruction receiver.
	value := allocation at: instruction right.
	offset := instruction left value.
	assembler storePointer: value in: base offset: offset
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assemblePlus: instruction
	| left right |
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	assembler
		clearIntegerBit: left;
		add: right to: left
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assemblePlusConstant: instruction
	| left value |
	left := allocation at: instruction left.
	value := instruction right * 2.
	assembler add: value to: left
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assemblePop: instruction
	| register |
	register := allocation at: instruction.
	assembler pop: register
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assemblePush: instruction
	| register |
	register := allocation at: instruction receiver.
	assembler push: register
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleRestorePreviousContext: instruction
	assembler restoreCallerFrame
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
assembleTimesConstant: instruction
	| left value shift |
	left := allocation at: instruction left.
	value := instruction right.
	self ASSERT: (value == 4 or: [value == 8]).
	shift := value == 4 ifTrue: [2] ifFalse: [3].
	assembler
		clearIntegerBit: left;
		shiftLeft: left by: shift;
		setIntegerBit: left
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
currentBlock
	^blocks at: currentBlockIndex
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
doAssemble
	self labelBlocks.
	blocks withIndexDo: [:block :index | | label |
		currentBlockIndex := index.
		label := jumpDestinations at: block.
		assembler @ label.
		block firstInstruction acceptVisitor: self].
	assembler applyFixups
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
initialize
	jumpDestinations := Dictionary new.
	self initializeLowLevelAssembler; initializeAssemblers
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
initializeAssemblers
	assemblers := Dictionary new
		at: #'+' put: #Plus;
		at: #'-' put: #Minus;
		at: #'*' put: #Times;
		at: #'=' put: #Equals;
		at: #'==' put: #Equals;
		at: #'~=' put: #NotEqual;
		at: #'!!=' put: #NotEqual;
		at: #'<' put: #Lower;
		at: #'<=' put: #LowerEqual;
		at: #'>=' put: #GreaterEqual;
		at: #'>' put: #Greater;
		at: #'&' put: #BitAnd;
		at: #bitAnd: put: #BitAnd;
		at: #bitOr: put: #BitOr;
		at: #bitShift: put: #BitShift;
		at: #_asNative put: #AsNative;
		at: #_asObject put: #AsObject;
		at: #_asPointer put: #AsPointer;
		at: #_asSmallInteger put: #AsSmallInteger;
		at: #_byteAt: put: #ByteAt;
		at: #_basicAt: put: #BasicAt;
		at: #_basicULongAt: put: #BasicULongAt;
		at: #_byteAt:put: put: #ByteAtPut;
		at: #_basicAt:put: put: #BasicAtPut;
		at: #_basicULongAt:put: put: #BasicULongAtPut;
		at: #_objectAtOffset:put: put: #ObjectAtOffsetPut;
		at: #_basicFlags put: #BasicFlags;
		at: #_basicFlags: put: #BasicFlagsPut;
		at: #_smallSize put: #BasicSize;
		at: #_smallSize: put: #BasicSizePut;
		at: #_largeSize put: #ExtendedSize;
		at: #_largeSize: put: #ExtendedSizePut;
		at: #_isSmallInteger put: #IsSmallInteger;
		at: #_transferControlTo: put: #TransferControlTo;
		at: #negate put: #Negate;
		at: #push put: #Push;
		at: #pop put: #Pop;
		at: #copy put: #Copy;
		at: #copyResult put: #CopyResult;
		yourself
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
initializeLowLevelAssembler
	assembler := JITAssembler64 on: #[] writeStream
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
jumpWasAssembledInComparison: aConditionalJump
	| prev |
	prev := aConditionalJump prev.
	prev == aConditionalJump variable ifFalse: [^false].
	prev allUses size !!= 1 ifTrue: [^false].
	prev class == OMessageSend ifTrue: [^false].
	prev class == OPhi ifTrue: [^false].
	(prev isKindOf: OBinaryOperation) ifTrue: [
		(#(< <= = == !!= >= >) includes: prev name) ifTrue: [^true].
		(#(_basicAt:) includes: prev name) ifTrue: [^false]].
	prev class == OUnaryOperation ifTrue: [
		(#(_isSmallInteger) includes: prev name) ifTrue: [^true].
		(#(copy) includes: prev name) ifTrue: [^false]].
	self halt
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
labelBlocks
	blocks do: [:block | | label |
		label := assembler newLabel.
		jumpDestinations at: block put: label]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
messageLinker: aMessageLinker
	messageLinker := aMessageLinker
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
nativeCode
	^assembler nativeCode
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
nextBlock
	^blocks at: currentBlockIndex + 1 ifAbsent: [nil]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
selectorFor: instruction
	^assemblers at: instruction name
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitBinaryWithConstant: instruction
	| selector |
	selector := #assemble , (self selectorFor: instruction) , #Constant:.
	self perform: selector asSymbol with: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitBinaryWithVariable: instruction
	| selector |
	selector := #assemble , (self selectorFor: instruction) , #':'.
	self perform: selector asSymbol with: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitBranch: branch comparing: aBoolean
	| reg |
	(self jumpWasAssembledInComparison: branch) ifTrue: [^self].
	reg := allocation at: branch variable.
	assembler compare: reg withPointer: aBoolean.
	self assembleJumpIfEqualTo: branch target.
	branch implicitTarget !!= self nextBlock
		ifTrue: [self assembleJumpTo: branch implicitTarget]
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitJump: aJump
	aJump target == self nextBlock ifTrue: [^self].
	self assembleJumpTo: aJump target
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitJumpFalse: aJumpFalse
	self visitBranch: aJumpFalse comparing: false
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitJumpTrue: aJumpTrue
	self visitBranch: aJumpTrue comparing: true
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitLoadConstant: aLoadConstant
	| register value |
	register := allocation
		at: aLoadConstant
		ifAbsent: [aLoadConstant isUsed ifTrue: [self halt] ifFalse: [^self]].
	value := aLoadConstant value.
	self assembleLoadConstant: value to: register
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitMessageSend: aMessageSend
	self assembleGenericMessageSend: aMessageSend.
	firstBlock activationRecord haveFrame
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitNullary: instruction
	| selector |
	selector := #assemble , (self selectorFor: instruction) , #':'.
	self perform: selector asSymbol with: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitPhi: phiInstruction
	
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitTernary: instruction
	| selector |
	selector := #assemble , (self selectorFor: instruction) , #':'.
	self perform: selector asSymbol with: instruction
! !

!OptimizingCodeEmitter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
visitUnary: instruction
	| selector |
	selector := #assemble , (self selectorFor: instruction) , #':'.
	self perform: selector asSymbol with: instruction
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicAt: instruction
	| base index result |
	base := allocation at: instruction left.
	index := allocation at: instruction right.
	result := allocation at: instruction.
	assembler
		convertToNativeInteger: index;
		load: result from: base atIndexAt: index.
	result !!= index ifTrue: [assembler convertToSmallInteger: index]
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicAtConstant: instruction
	| src dst index |
	src := allocation at: instruction left.
	dst := allocation at: instruction ifAbsent: [^self].
	index := instruction right.
	assembler load: dst from: src atIndex: index
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleBasicAtConstantPut: instruction
	| base value |
	base := allocation at: instruction base.
	value := allocation at: instruction value.
	assembler store: value in: base index: instruction index value
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicFlags: basicFlagsSend
	| base dst |
	base := allocation at: basicFlagsSend receiver.
	dst := allocation at: basicFlagsSend.
	assembler
		loadZeroExtendByte: dst from: base atOffset: _Flags;
		convertToSmallInteger: dst
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicFlagsPut: basicFlagsPut
	self assembleByteAtOffset: _Flags put: basicFlagsPut
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicSize: basicSizeSend
	| base dst |
	base := allocation at: basicSizeSend receiver.
	dst := allocation at: basicSizeSend.
	assembler
		loadZeroExtendByte: dst from: base atOffset: _SmallSize;
		convertToSmallInteger: dst
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicSizePut: basicSizePut
	self assembleByteAtOffset: _SmallSize put: basicSizePut
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicSizePutConstant: basicFlagsPutSend
	| base value |
	base := allocation at: basicFlagsPutSend left.
	value := basicFlagsPutSend right.
	assembler storeByte: value in: base offset: _SmallSize
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicULongAt: instruction
	| base index result |
	base := allocation at: instruction left.
	index := allocation at: instruction right.
	result := allocation at: instruction.
	assembler
		convertToNativeInteger: index;
		load: result e from: base atIndexAt: index.
	result !!= index ifTrue: [assembler convertToSmallInteger: index]
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicULongAtConstant: instruction
	| src dst index |
	src := allocation at: instruction left.
	dst := allocation at: instruction ifAbsent: [^self].
	index := instruction right.
	assembler load: dst e from: src atIndex: index
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicULongAtPut: instruction
	| base value index |
	index := instruction left value.
	index isInteger
		ifTrue: [^self assembleBasicULongAtPutConstant: instruction].
	base := allocation at: instruction receiver.
	value := allocation at: instruction right.
	index := allocation at: index.
	assembler
		convertToNativeInteger: index;
		store: value e in: base indexAt: index;
		convertToSmallInteger: index
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleBasicULongAtPutConstant: instruction
	| base value position |
	base := allocation at: instruction receiver.
	value := allocation at: instruction right.
	position := instruction left value.
	assembler store: value e in: base index: position
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleByteAt: instruction
	| base index dst |
	base := allocation at: instruction left.
	index := allocation at: instruction right.
	dst := allocation at: instruction.
	assembler
		convertToNativeInteger: index;
		loadZeroExtendByte: dst from: base atIndexAt: index;
		convertToSmallInteger: dst.
	index !!= dst ifTrue: [assembler convertToSmallInteger: index]
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleByteAtConstant: instruction
	| base index dst |
	base := allocation at: instruction left.
	index := instruction right.
	dst := allocation at: instruction.
	assembler
		loadZeroExtendByte: dst from: base atIndex: index;
		convertToSmallInteger: dst
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleByteAtConstantPut: instruction
	| base value |
	base := allocation at: instruction base.
	value := allocation at: instruction value.
	assembler
		convertToNativeInteger: value;
		renameByteRegisterIfNeeded: value
		preserving: base
		during: [:final | assembler
			storeByte: final byte
			in: base
			offset: instruction index value - 1];
		convertToSmallInteger: value
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleCompare: instruction jumpTrue: trueBlock jumpFalse: falseBlock
	| left right |
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	assembler compare: left with: right.
	self assembleJumpTrue: trueBlock orJumpFalse: falseBlock in: instruction
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleCompareConstant: left with: right
	right isSmallInteger ifTrue: [^assembler compare: left with: right * 2 + 1].
	right ifNil: [^assembler compareWithNil: left].
	right = false ifTrue: [^assembler compareWithFalse: left].
	right = true ifTrue: [^assembler compareWithTrue: left].
	assembler compare: left withPointer: right
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleCopy: instruction
	| source target |
	target := allocation at: instruction.
	source := allocation at: instruction receiver.
	self assembleCopyIfNeeded: source to: target
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleCopyIfNeeded: source to: dest
	source = dest ifTrue: [^self].
	assembler move: source to: dest
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleCopyResult: instruction
	| dest |
	dest := allocation at: instruction ifAbsent: [^self].
	self assembleCopyIfNeeded: abi regR to: dest
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleExtendedSize: extendedSizeSend
	| base dst |
	base := allocation at: extendedSizeSend receiver.
	dst := allocation at: extendedSizeSend.
	assembler
		load: dst e from: base atIndex: _ExtendedSize;
		convertToSmallInteger: dst
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleLoadConstant: value to: register
	| constant |
	value isSmallInteger
		ifTrue: [
			constant := value * 2 + 1.
			assembler load: register withImmediate: constant]
		ifFalse: [assembler load: register withPointer: value]
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleLongSlotAt: instruction
	| base index result |
	index := instruction index value.
	index isInteger ifTrue: [^self assembleLongSlotAtConstant: instruction].
	base := allocation at: instruction base.
	index := allocation at: index.
	result := allocation at: instruction.
	assembler
		convertToNativeInteger: index;
		load: result e from: base atIndexAt: index.
	result !!= index ifTrue: [assembler convertToSmallInteger: index]
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleLongSlotAtConstant: instruction
	| src dst |
	src := allocation at: instruction base.
	dst := allocation at: instruction ifAbsent: [^self].
	assembler load: dst e from: src atIndex: instruction index value
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleLongSlotAtConstantPut: instruction
	| base value |
	base := allocation at: instruction base.
	value := allocation at: instruction value.
	assembler store: value e in: base index: instruction index value
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleLongSlotAtPut: instruction
	| base value index |
	index := instruction index value.
	index isInteger ifTrue: [^self assembleLongSlotAtConstantPut: instruction].
	base := allocation at: instruction base.
	value := allocation at: instruction value.
	index := allocation at: index.
	assembler
		convertToNativeInteger: index;
		store: value e in: base indexAt: index;
		convertToSmallInteger: index
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:57'!
assembleTransferControlTo: instruction
	| code receiver |
	receiver := allocation at: instruction left.
	code := allocation at: instruction right.
	receiver == assembler regA ifTrue: [
		code == assembler regT
			ifTrue: [
				assembler move: assembler regA to: assembler regR.
				receiver := assembler regR]
			ifFalse: [
				assembler move: assembler regA to: assembler regT.
				receiver := assembler regT]].
	self assembleCopyIfNeeded: code to: assembler regA.
	self assembleCopyIfNeeded: receiver to: assembler regR.
	self activationRecord savesPreviousSelf
		ifTrue: [assembler pop: assembler regS].
	assembler restoreCallerFrame; jumpToReg: assembler regA
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleULongAt: instruction
	| result |
	self assembleLongSlotAt: instruction.
	result := allocation at: instruction.
	assembler convertToSmallInteger: result
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
assembleULongAtPut: instruction
	| value |
	value := allocation at: instruction value.
	assembler convertToNativeInteger: value.
	self assembleLongSlotAtPut: instruction.
	assembler convertToSmallInteger: value
! !

!OptimizingCodeEmitter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:02'!
loadMifNeeded
	method selector == #_dispatchOn:
		ifTrue: [^assembler loadMwithGlobal: #Lookup].
	method selector == #_dispatchOn:startingAt:
		ifTrue: [^assembler loadMwithGlobal: #LookupSuper].
	method selector == #_dispatchDebuggableOn:
		ifTrue: [^assembler loadMwithGlobal: #DebuggableLookup].
	method selector == #_dispatchDebuggableOn:startingAt:
		ifTrue: [^assembler loadMwithGlobal: #DebuggableLookupSuper]
! !

!OptimizingCodeEmitter methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:53:02'!
tryOptimizing: comparison jumpTrue: blockJumpTrue jumpFalse: blockJumpFalse
	| inst label |
	comparison isUsedJustOnce ifFalse: [^false].
	inst := comparison next.
	inst isConditionalJump ifFalse: [^false].
	label := jumpDestinations at: inst target.
	inst isJumpTrue
		ifTrue: [blockJumpTrue value: label]
		ifFalse: [blockJumpFalse value: label].
	self nextBlock !!= inst implicitTarget
		ifTrue: [self assembleJumpTo: inst implicitTarget].
	^true
! !

!OptimizingCodeEmitter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:53:02'!
visitGeneric: instruction
	| selector |
	selector := #assemble , (self selectorFor: instruction) , #':'.
	self perform: selector asSymbol with: instruction
! !

!OptimizingCodeEmitter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:53:02'!
visitLoad: instruction
	self visitGeneric: instruction
! !

!OptimizingCodeEmitter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 13:59:57'!
visitLoadImplicit: instruction
	| frame |
	instruction name == #activationRecord ifTrue: [^assembler buildFrame].
	instruction name == #self ifTrue: [
		frame := instruction prev.
		^frame hasFrame ifTrue: [
			assembler
				reserveStackSlots: frame temporaries + 2;
				store: assembler regR in: assembler regFP index: 0;
				loadVwithPointer: method;
				store: assembler regV in: assembler regFP index: -1.
			self savesPreviousSelf ifTrue: [assembler push: assembler regS]]]
! !

!OptimizingCodeEmitter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 13:59:57'!
visitReturn: aReturnInstruction
	| source |
	source := allocation at: aReturnInstruction source.
	self assembleCopyIfNeeded: source to: assembler regR.
	self savesPreviousSelf
		ifTrue: [assembler pop: assembler regS; restoreCallerFrame]
		ifFalse: [
			assembler
				restoreCallerFrame;
				load: assembler regS from: assembler regFP atIndex: 0].
	assembler return
! !

!OptimizingCodeEmitter methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:53:02'!
visitStore: instruction
	self visitGeneric: instruction
! !

!OptimizingCodeEmitter class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:57'!
new
	^self basicNew initialize
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
doFragment
	firstBlock
		reversePostOrderDo: [:block | self fragmentInstructionsOf: block]
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentBinaryNonCommutative: instruction
	| left right |
	left := instruction receiver.
	right := instruction arguments first.
	right isConstant
		ifTrue: [^self replace: instruction withBinary: left withConstant: right].
	self replace: instruction withVariable: left with: right
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentBitsAt: instruction
	| receiver constant stretch and shift |
	receiver := instruction receiver.
	constant := instruction arguments first.
	self _ASSERT: constant isConstant.
	stretch := constant value.
	and := OBinaryConstantOperation
		left: receiver
		right: stretch mask
		name: #bitAnd:.
	shift := OBinaryConstantOperation
		left: and
		right: stretch shift
		name: #bitShift:.
	instruction beforeInsert: and; dissolveReplacingWith: shift
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentLoadByte: instruction
	| base index new |
	base := instruction receiver.
	index := instruction arguments first.
	new := index isConstant
		ifTrue: [OLoadOperation base: base byteAtImm: index value]
		ifFalse: [OLoadOperation base: base byteAt: index].
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentLoadFlags: instruction
	| base new |
	base := instruction receiver.
	new := OLoadOperation base: base byteAtImm: _Flags + 1.
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentLoadLargeSize: instruction
	| base new |
	base := instruction receiver.
	new := OLoadOperation base: base uLongAtImm: _ExtendedSize.
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentLoadLongSlot: instruction
	| base index new |
	base := instruction receiver.
	index := instruction arguments first.
	new := index isConstant
		ifTrue: [OLoadOperation base: base longSlotAtImm: index value]
		ifFalse: [OLoadOperation base: base longSlotAt: index].
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentLoadSlot: instruction
	| base index new |
	base := instruction receiver.
	index := instruction arguments first.
	new := index isConstant
		ifTrue: [OLoadOperation base: base slotAtImm: index value]
		ifFalse: [OLoadOperation base: base slotAt: index].
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentLoadSmallSize: instruction
	| base new |
	base := instruction receiver.
	new := OLoadOperation base: base byteAtImm: _SmallSize + 1.
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentLoadULong: instruction
	| base index new |
	base := instruction receiver.
	index := instruction arguments first.
	new := index isConstant
		ifTrue: [OLoadOperation base: base uLongAtImm: index value]
		ifFalse: [OLoadOperation base: base slotAt: index].
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentSpecialABIArgumentsIn: aBasicBlock
	| literals i actual next load |
	literals := method literals.
	literals size = 0 ifTrue: [^self].
	(literals at: 1) == #savePreviousSelf ifTrue: [
		aBasicBlock activationRecord doSavePreviousSelf.
		load := aBasicBlock firstInstruction detect: [:inst | inst isConstant].
		load dissolve.
		literals := literals copyFrom: 2].
	literals size = 0 ifTrue: [^self].
	(literals at: 1) == #specialABIBegin ifFalse: [^self].
	i := 2.
	[(literals at: i) == #specialABIEnd]
		whileFalse: [| name register implicit argument receiver regname |
			name := literals at: i.
			regname := literals at: i + 1.
			register := self registerNamed: regname.
			name = #self
				ifTrue: [
					receiver := aBasicBlock firstInstruction
						detect: [:instruction | instruction isLoadImplicit
							and: [instruction name = #self]].
					receiver source: register]
				ifFalse: [
					implicit := (OLoadImplicit named: name) source: register.
					argument := aBasicBlock firstInstruction
						detect: [:instruction | instruction isDefineArgument
							and: [instruction name = name]].
					argument dissolveReplacingWith: implicit].
			i := i + 2].
	actual := aBasicBlock firstInstruction detect: [:inst | inst isConstant].
	[
		next := actual next.
		actual dissolve.
		actual isConstant and: [actual value == #specialABIEnd]]
		whileFalse: [actual := next]
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentStoreByte: instruction
	| base index new value |
	base := instruction receiver.
	index := instruction arguments first.
	value := instruction arguments second.
	new := index isConstant
		ifTrue: [OStoreOperation base: base byteAtImm: index value put: value]
		ifFalse: [OStoreOperation base: base byteAt: index put: value].
	instruction replaceAllUsesWith: value; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentStoreFlags: instruction
	| base value new |
	base := instruction receiver.
	value := instruction arguments first.
	new := OStoreOperation base: base byteAtImm: _Flags + 1 put: value.
	instruction replaceAllUsesWith: value; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentStoreLargeSize: instruction
	| base value new |
	base := instruction receiver.
	value := instruction arguments first.
	new := OStoreOperation base: base uLongAtImm: _ExtendedSize put: value.
	instruction replaceAllUsesWith: value; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentStoreLongSlot: instruction
	| base index new value |
	base := instruction receiver.
	index := instruction arguments first.
	value := instruction arguments second.
	new := index isConstant
		ifTrue: [OStoreOperation base: base longSlotAtImm: index value put: value]
		ifFalse: [OStoreOperation base: base longSlotAt: index put: value].
	instruction replaceAllUsesWith: value; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentStoreSlot: instruction
	| base index new value |
	base := instruction receiver.
	index := instruction arguments first.
	value := instruction arguments second.
	new := index isConstant
		ifTrue: [OStoreOperation base: base slotAtImm: index value put: value]
		ifFalse: [OStoreOperation base: base slotAt: index put: value].
	instruction replaceAllUsesWith: value; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentStoreSmallSize: instruction
	| base value new |
	base := instruction receiver.
	value := instruction arguments first.
	new := OStoreOperation base: base byteAtImm: _SmallSize + 1 put: value.
	instruction replaceAllUsesWith: value; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:06'!
fragmentStoreULong: instruction
	| base index new value |
	base := instruction receiver.
	index := instruction arguments first.
	value := instruction arguments second.
	new := index isConstant
		ifTrue: [OStoreOperation base: base uLongAtImm: index value put: value]
		ifFalse: [OStoreOperation base: base uLongAt: index put: value].
	instruction replaceAllUsesWith: value; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'private' stamp: 'KenD 11/22/2023 14:00:00'!
registerNamed: regname
	^abi perform: regname
! !

!OptimizingInstructionFragmenter methodsFor: 'initialization' stamp: 'KenD 11/22/2023 14:00:00'!
initializeMessages
	messages := Dictionary new
		at: #'+' put: #BinaryCommutative:;
		at: #'-' put: #BinaryNonCommutative:;
		at: #'*' put: #BinaryCommutative:;
		at: #'<' put: #BinaryCompare:;
		at: #'<=' put: #BinaryCompare:;
		at: #'=' put: #BinaryCompare:;
		at: #'==' put: #BinaryCompare:;
		at: #'~=' put: #BinaryCompare:;
		at: #'!!=' put: #BinaryCompare:;
		at: #'>=' put: #BinaryCompare:;
		at: #'>' put: #BinaryCompare:;
		at: #'&' put: #BinaryCommutative:;
		at: #_asNative put: #Unary:;
		at: #_asObject put: #Unary:;
		at: #_asPointer put: #Unary:;
		at: #_asSmallInteger put: #Unary:;
		at: #bitAnd: put: #BinaryCommutative:;
		at: #bitOr: put: #BinaryCommutative:;
		at: #bitShift: put: #BinaryNonCommutative:;
		at: #_byteAt: put: #BinaryNonCommutative:;
		at: #_basicAt: put: #BinaryNonCommutative:;
		at: #_basicULongAt: put: #BinaryNonCommutative:;
		at: #_byteAt:put: put: #Ternary:;
		at: #_basicAt:put: put: #Ternary:;
		at: #_basicULongAt:put: put: #Ternary:;
		at: #_objectAtOffset:put: put: #Ternary:;
		at: #_basicFlags put: #Unary:;
		at: #_basicFlags: put: #BinaryNonCommutative:;
		at: #_smallSize put: #Unary:;
		at: #_smallSize: put: #BinaryNonCommutative:;
		at: #_largeSize put: #Unary:;
		at: #_largeSize: put: #BinaryNonCommutative:;
		at: #_isSmallInteger put: #Unary:;
		at: #_transferControlTo: put: #TransferControlTo:;
		at: #_callSite put: #CallSite:;
		at: #_patchIndirectCallSiteTo: put: #PatchIndirectCallSiteTo:;
		at: #not put: #Not:;
		yourself
! !

!OptimizingInstructionFragmenter methodsFor: 'visitor protocol' stamp: 'KenD 11/22/2023 07:53:06'!
visitLoad: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'visitor protocol' stamp: 'KenD 11/22/2023 07:53:06'!
visitStore: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
abi: anAbi
	abi := anAbi
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
activationRecord
	^firstBlock firstInstruction
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
firstBlock: aBasicBlock
	firstBlock := aBasicBlock
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentActivationRecordDeclarationIn: aBasicBlock
	| declaration implicit |
	declaration := aBasicBlock firstInstruction.
	implicit := OActivationContext named: #activationRecord.
	implicit source: abi regFP.
	declaration dissolveReplacingWith: implicit
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentArgumentsIn: aBasicBlock with: aCompiledMethod
	method := aCompiledMethod.
	self
		fragmentActivationRecordDeclarationIn: aBasicBlock;
		fragmentSelfDeclarationIn: aBasicBlock;
		fragmentSpecialABIArgumentsIn: aBasicBlock;
		fragmentNormalArgumentsIn: aBasicBlock
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentBinaryCommutative: instruction
	| left right |
	left := instruction receiver.
	right := instruction arguments first.
	right isConstant
		ifTrue: [^self replace: instruction withBinary: left withConstant: right].
	left isConstant
		ifTrue: [^self replace: instruction withBinary: right withConstant: left].
	self replace: instruction withVariable: left with: right
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentBinaryCompare: instruction
	| left right new |
	left := instruction receiver.
	right := instruction arguments first.
	right isConstant
		ifTrue: [^self replace: instruction withBinary: left withConstant: right].
	left isConstant ifTrue: [
		new := self replace: instruction withBinary: right withConstant: left.
		^new invertOperation].
	self replace: instruction withVariable: left with: right
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentCallSite: instruction
	| callsite |
	callsite := OBinaryConstantOperation
		left: self activationRecord
		right: 2
		name: #_basicAt:.
	self activationRecord addUse: callsite at: #left.
	instruction dissolveReplacingWith: callsite
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentGenericMessage: instruction
	| arguments new |
	arguments := instruction arguments.
	new := arguments
		collect: [:argument | self insertPush: argument before: instruction].
	instruction arguments: new.
	arguments
		do: [:argument | argument removeUse: instruction; dissolveIfUnused].
	firstBlock activationRecord haveFrame
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentInstructionsFrom: aBasicBlock
	self firstBlock: aBasicBlock.
	aBasicBlock
		reversePostOrderDo: [:block | self fragmentInstructionsOf: block]
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentInstructionsOf: block
	block firstInstruction acceptVisitor: self
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentNormalArgumentsIn: aBasicBlock
	| count argument position context |
	count := 0.
	context := aBasicBlock firstInstruction.
	argument := context next next.
	[argument isDefineArgument] whileTrue: [
		argument := argument next.
		count := count + 1].
	argument := argument prev.
	position := 0.
	[position < count] whileTrue: [| new next |
		argument isUsed
			ifTrue: [
				new := OBinaryConstantOperation
					left: context
					right: position + 3
					name: #_basicAt:.
				context addUse: new at: #left.
				argument dissolveReplacingWith: new.
				argument := new prev]
			ifFalse: [
				next := argument prev.
				argument dissolve.
				argument := next].
		position := position + 1]
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentNot: instruction
	| negated |
	negated := instruction receiver halt shallowCopy.
	negated negateOperation.
	negated left addUse: negated at: #left.
	negated right addUse: negated at: #right.
	instruction dissolveReplacingWith: negated.
	instruction receiver dissolveIfUnused
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentPatchIndirectCallSiteTo: instruction
	| nativeCode callsite patch |
	nativeCode := instruction arguments first.
	callsite := OBinaryConstantOperation
		left: self activationRecord
		right: 2
		name: #_basicAt:.
	patch := OTernaryOperation
		receiver: callsite
		left: 0
		right: nativeCode
		name: #_basicAt:put:.
	self activationRecord addUse: callsite at: #left.
	callsite addUse: patch at: #receiver.
	nativeCode addUse: patch at: #right.
	instruction dissolveReplacingWith: patch.
	patch beforeInsert: callsite
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentSelfDeclarationIn: aBasicBlock
	| declaration implicit |
	declaration := aBasicBlock firstInstruction next.
	implicit := OLoadImplicit named: #self.
	declaration dissolveReplacingWith: implicit
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentTernary: instruction
	| receiver left right new |
	receiver := instruction receiver.
	left := instruction arguments first.
	right := instruction arguments second.
	new := OTernaryOperation
		receiver: receiver
		left: left
		right: right
		name: instruction selector.
	receiver addUse: new at: #receiver.
	left addUse: new at: #left.
	right addUse: new at: #right.
	self
		ASSERT: (#(_basicAt:put: _basicULongAt:put:	_byteAt:put: _objectAtOffset:put:)
			includes: new name).
	instruction replaceAllUsesWith: right; dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentTransferControlTo: instruction
	| receiver machine |
	receiver := instruction receiver.
	machine := instruction arguments first.
	self replace: instruction withVariable: receiver with: machine
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
fragmentUnary: instruction
	| receiver new |
	receiver := instruction receiver.
	"	receiver isConstant ifTrue: [self halt]."
	new := OUnaryOperation new receiver: receiver; name: instruction selector.
	receiver addUse: new at: #receiver.
	instruction dissolveReplacingWith: new
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
initialize
	self initializeMessages
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
insertCopyResultAfter: anInstruction
	| copy |
	copy := OUnaryOperation receiver: anInstruction name: #copyResult.
	anInstruction
		afterInsert: copy;
		replaceAllUsesWith: copy;
		addUse: copy at: #receiver
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
insertPush: anInstruction before: instruction
	| push |
	push := OUnaryOperation receiver: anInstruction name: #push.
	anInstruction addUse: push at: #receiver.
	instruction beforeInsert: push.
	^push
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
replace: instruction withBinary: left withConstant: right
	| constant new |
	constant := right value.
	new := OBinaryConstantOperation
		left: left
		right: constant
		name: instruction selector.
	left addUse: new at: #left.
	instruction dissolveReplacingWith: new.
	right dissolveIfUnused.
	^new
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
replace: instruction withVariable: left with: right
	| new |
	new := OBinaryVariableOperation
		left: left
		right: right
		name: instruction selector.
	left addUse: new at: #left.
	right addUse: new at: #right.
	instruction dissolveReplacingWith: new.
	^new
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
selectorFor: name
	^(#fragment , (messages at: name ifAbsent: [#GenericMessage:])) asSymbol
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitBinaryWithConstant: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitBinaryWithVariable: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitDefineArgument: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitJump: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitJumpFalse: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitJumpTrue: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitLoadConstant: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitLoadImplicit: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitMessageSend: instruction
	| selector |
	selector := self selectorFor: instruction selector.
	self perform: selector with: instruction
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitPhi: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitReturn: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitTernary: instruction
	
! !

!OptimizingInstructionFragmenter methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
visitUnary: instruction
	
! !

!OptimizingInstructionFragmenter class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 14:00:00'!
new
	^self basicNew initialize
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
doSelection
	self numberArguments.
	firstBlock reversePostOrderDo: [:block | self generateTilingFor: block].
	self removeUnused
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
firstBlock: aBasicBlock
	firstBlock := aBasicBlock
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
generateTilingFor: block
	block firstInstruction acceptVisitor: self
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
initialize
	tiles := IdentityDictionary new.
	self initializeMessages
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
initializeMessages
	messages := Dictionary new
		at: #'+' put: #CommutativeBinary:;
		at: #'-' put: #Minus:;
		at: #'*' put: #CommutativeBinary:;
		at: #'<' put: #Compare:;
		at: #'<=' put: #Compare:;
		at: #'=' put: #Compare:;
		at: #'==' put: #Compare:;
		at: #'~=' put: #Compare:;
		at: #'!!=' put: #Compare:;
		at: #'>=' put: #Compare:;
		at: #'>' put: #Compare:;
		at: #'&' put: #CommutativeBinary:;
		at: #bitAnd: put: #CommutativeBinary:;
		at: #_byteAt: put: #Binary:;
		at: #_basicAt: put: #Binary:;
		at: #_byteAt:put: put: #Ternary:;
		at: #_basicAt:put: put: #Ternary:;
		at: #_basicFlags put: #Unary:;
		at: #_smallSize put: #Unary:;
		at: #_largeSize put: #Unary:;
		at: #_isSmallInteger put: #Unary:;
		at: #_transferControlTo: put: #Binary:;
		at: #not put: #Not:;
		yourself
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
insertCopyResultAfter: anInstruction
	| copy |
	copy := OUnaryOperation receiver: anInstruction name: #copyResult.
	anInstruction
		afterInsert: copy;
		replaceAllUsesWith: copy;
		addUse: copy at: #receiver
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
insertPush: anInstruction before: instruction
	| push tile |
	push := OUnaryOperation receiver: anInstruction name: #push.
	anInstruction addUse: push at: #receiver.
	instruction beforeInsert: push.
	tile := self newTile: push.
	self tile: push as: tile beUsed.
	^push
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
newTile: instruction
	^OTiling for: instruction
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
numberArguments
	| count instruction i |
	count := 0.
	instruction := firstBlock firstInstruction next.
	[instruction next isLoadImplicit] whileTrue: [
		instruction := instruction next.
		count := count + 1].
	i := 0.
	[i < count] whileTrue: [
		instruction name: i + 3.
		instruction := instruction prev.
		i := i + 1]
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
removeUnused
	firstBlock instructionsWithSuccessorsDo: [:instruction | | tile |
		tile := self tileOf: instruction.
		(tile instruction == instruction and: [tile isUsed])
			ifFalse: [instruction replaceAllUsesWith: tile instruction; dissolve]]
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
selectorFor: name
	^(#send , (messages at: name ifAbsent: [#GenericMessage:])) asSymbol
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
send: instruction left: left commutativeRight: right
	right isConstant
		ifTrue: [^self tile: instruction using: left toConstant: right value].
	left isConstant
		ifTrue: [^self tile: instruction using: right toConstant: left value].
	self tile: instruction using: left to: right
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
send: instruction left: left comparedTo: right
	right isConstant
		ifTrue: [^self tile: instruction using: left toConstant: right value].
	left isConstant
		ifTrue: [^(self tile: instruction using: right toConstant: left value) invertOperation].
	self tile: instruction using: left to: right
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
send: instruction left: left minusRight: right
	right isConstant
		ifTrue: [^self tile: instruction using: left toConstant: right value].
	left isConstant
		ifTrue: [^(self doesntWork
			tile: instruction
			using: right
			toConstant: 0 - left value)
			invert].
	self tile: instruction using: left to: right
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
send: instruction left: left right: right
	right isConstant
		ifTrue: [^self tile: instruction using: left toConstant: right value].
	left isConstant
		ifTrue: [^self tile: instruction using: right toConstant: left value].
	self tile: instruction using: left to: right
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
send: instruction receiver: receiver
	receiver isConstant ifTrue: [^self tile: instruction toConstant: receiver].
	self tile: instruction receiver: receiver
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
send: instruction receiver: receiver left: left right: right
	"
	right isConstant
		ifTrue: [^self tile: instruction using: left toConstant: right value].
	left isConstant
		ifTrue: [^self tile: instruction using: right toConstant: left value].
	"
	self
		tile: instruction
		using: receiver
		left: left
		right: right
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendBinary: instruction
	self
		send: instruction
		left: instruction receiver
		right: instruction arguments first
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendCommutativeBinary: instruction
	self
		send: instruction
		left: instruction receiver
		commutativeRight: instruction arguments first
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendCompare: instruction
	self
		send: instruction
		left: instruction receiver
		comparedTo: instruction arguments first
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendGenericMessage: instruction
	| arguments values tile new |
	arguments := instruction arguments.
	values := Array with: instruction receiver withAll: arguments.
	new := arguments
		collect: [:argument | self insertPush: argument before: instruction].
	instruction arguments: new.
	arguments do: [:argument | argument removeUse: instruction].
	values do: [:value | (self tileOf: value) beUsed].
	tile := self newTile: instruction.
	self
		tile: instruction as: tile beUsed;
		insertCopyResultAfter: instruction
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendMinus: instruction
	self
		send: instruction
		left: instruction receiver
		minusRight: instruction arguments first
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendNot: instruction
	| negated tile |
	negated := (self tileOf: instruction receiver) beUsed.
	negated instruction negateOperation.
	tile := self newTile: instruction.
	self tile: instruction as: tile.
	^instruction
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendTernary: instruction
	self
		send: instruction
		receiver: instruction receiver
		left: instruction arguments first
		right: instruction arguments second
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
sendUnary: instruction
	self send: instruction receiver: instruction receiver
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
tile: instruction as: tile
	tiles at: instruction put: tile
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
tile: instruction receiver: receiver
	| receivertile new tile |
	receivertile := (self tileOf: receiver) beUsed.
	new := OUnaryOperation new receiver: receiver; name: instruction selector.
	receiver addUse: new at: #receiver.
	instruction beforeInsert: new.
	tile := self newTile: new.
	self
		tile: new as: tile;
		tile: instruction as: tile.
	^new
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
tile: instruction using: receiver left: left right: right
	| lefttile righttile receivertile tile new |
	receivertile := (self tileOf: receiver) beUsed.
	lefttile := (self tileOf: left) beUsed.
	righttile := (self tileOf: right) beUsed.
	new := OTernaryOperation
		receiver: receiver
		left: left
		right: right
		name: instruction selector.
	receiver addUse: new at: #receiver.
	left addUse: new at: #left.
	right addUse: new at: #right.
	instruction beforeInsert: new.
	tile := self newTile: new.
	self
		tile: new as: tile beUsed;
		tile: instruction as: righttile "for at:put:".
	^new
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
tile: instruction using: left to: right
	| lefttile righttile tile new |
	lefttile := (self tileOf: left) beUsed.
	righttile := (self tileOf: right) beUsed.
	new := OBinaryVariableOperation
		left: left
		right: right
		name: instruction selector.
	left addUse: new at: #left.
	right addUse: new at: #right.
	instruction beforeInsert: new.
	tile := self newTile: new.
	self
		tile: new as: tile;
		tile: instruction as: tile.
	^new
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
tile: instruction using: left toConstant: value
	| lefttile new tile |
	lefttile := (self tileOf: left) beUsed.
	new := OBinaryConstantOperation
		left: left
		right: value
		name: instruction selector.
	left addUse: new at: #left.
	instruction beforeInsert: new.
	tile := self newTile: new.
	self
		tile: new as: tile;
		tile: instruction as: tile.
	^new
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
tileOf: instruction
	^tiles at: instruction
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitJump: instruction
	| new |
	new := self newTile: instruction.
	self tile: instruction as: new beUsed
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitJumpFalse: instruction
	| tile new |
	tile := self tileOf: instruction variable.
	tile beUsed.
	new := self newTile: instruction.
	self tile: instruction as: new beUsed
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitJumpTrue: instruction
	| tile new |
	tile := self tileOf: instruction variable.
	tile beUsed.
	new := self newTile: instruction.
	self tile: instruction as: new beUsed
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitLoadConstant: instruction
	| tile |
	tile := self newTile: instruction.
	self tile: instruction as: tile
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitLoadImplicit: instruction
	| tile sourcetile new |
	instruction name isSmallInteger
		ifTrue: [
			sourcetile := (self tileOf: instruction source) beUsed.
			new := OBinaryConstantOperation
				left: instruction source
				right: instruction name
				name: #_basicAt:.
			instruction source addUse: new at: #left.
			instruction beforeInsert: new; replaceAllUsesWith: new; dissolve.
			tile := self newTile: new.
			self tile: new as: tile]
		ifFalse: [
			tile := self newTile: instruction.
			self tile: instruction as: tile.
			instruction name == #activationRecord ifTrue: [tile beUsed]]
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitMessageSend: instruction
	| selector |
	selector := self selectorFor: instruction selector.
	self perform: selector with: instruction
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitPhi: instruction
	| tile |
	instruction variables
		collect: [:source | self tileOf: source]
		thenDo: #beUsed.
	tile := self newTile: instruction.
	self tile: instruction as: tile
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitReturn: instruction
	| tile new |
	tile := self tileOf: instruction source.
	tile beUsed.
	new := self newTile: instruction.
	self tile: instruction as: new beUsed
! !

!OptimizingInstructionSelector methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitUnary: instruction
	| tile new |
	tile := self tileOf: instruction receiver.
	tile beUsed.
	new := self newTile: instruction.
	self tile: instruction as: new beUsed
! !

!OptimizingInstructionSelector class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
new
	^self basicNew initialize
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
analyzeLiveness
	| changed all |
	liveIn := Dictionary new.
	pressures := Dictionary new.
	expirations := Dictionary new.
	changed := true.
	all := firstBlock withSuccessorsPostOrder.
	[changed] whileTrue: [
		changed := false.
		all do: [:block | changed := (self analyzeLivenessOf: block) or: changed]].
	all do: [:block | self computeExpirationsAt: block]
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
analyzeLivenessOf: block
	| alive last changed pressure |
	self haltWhen: block hash = 46528.
	alive := self gatherAliveAfter: block.
	self
		haltWhen: (alive
			anySatisfy: [:value | value printString
				beginsWith: '[53422] [jump to #45650]']).
	pressure := pressures at: block ifAbsentPut: [0].
	last := block lastInstruction.
	last realReverseDo: [:instr | | presure |
		instr operandsDo: [:value | 
			self haltWhen: (value printString beginsWith: '[53422] [jump to #45650]').
			alive addIfAbsent: value].
		alive removeIfPresent: instr.
		pressure := presure max: alive size].
	block phis reverseDo: [:phi | alive removeIfPresent: phi].
	pressures at: block put: pressure.
	changed := true.
	liveIn
		at: block ifPresent: [:prev | changed := prev size !!= alive size];
		at: block put: alive.
	^changed
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
computeExpirationsAt: block
	| alive last |
	alive := self gatherAliveAfter: block.
	last := block lastInstruction.
	last isConditionalJump ifTrue: [
		block successors do: [:succ | | real leftover |
			real := liveIn at: succ.
			leftover := alive rejectAll: real.
			leftover do: [:val | self kill: val at: succ firstInstruction]]].
	last realReverseDo: [:instr | self computeExpirationsAt: instr with: alive]
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
computeExpirationsAt: instruction with: alive
	instruction operandsDo: [:value | 
		(alive includes: value) ifFalse: [self kill: value at: instruction].
		alive addIfAbsent: value].
	(alive includes: instruction)
		ifTrue: [alive remove: instruction]
		ifFalse: [self kill: instruction at: instruction]
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
does: operand dieAt: instruction
	| dying |
	dying := expirations at: instruction ifAbsent: [^false].
	^dying includes: operand
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
firstBlock: aBlock
	firstBlock := aBlock
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
gatherAliveAfter: block
	| incoming extra |
	incoming := block successors
		gather: [:succ | liveIn at: succ ifAbsent: [OrderedCollection new]].
	extra := block successors gather: [:succ | succ phiValuesComingFrom: block].
	^(incoming , extra) withoutDuplicates
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
initialize
	
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
kill: value at: instruction
	| collection |
	collection := expirations
		at: instruction
		ifAbsentPut: [OrderedCollection new].
	collection addIfAbsent: value
! !

!OptimizingLivenessAnalysis methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:53'!
loops: aDictionary
	loops := aDictionary
! !

!OptimizingLivenessAnalysis methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:53'!
liveInOf: block
	^liveIn at: block
! !

!OptimizingLivenessAnalysis methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:53'!
maxPressureIn: loopBlocks
	| all |
	all := loopBlocks collect: [:block | pressures at: block].
	^all max
! !

!OptimizingLivenessAnalysis class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 13:59:53'!
new
	^self basicNew initialize
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
abi: anAbi
	abi := anAbi
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
bindArgumentsOf: firstBlockInlined with: aMessageSend
	| inlined args |
	inlined := firstBlockInlined activationRecord.
	args := aMessageSend arguments.
	inlined arguments do: [:arg | | passed index |
		index := args size - arg index + 3.
		passed := args at: index.
		arg replaceAllUsesWith: passed; dissolve].
	inlined receiver replaceAllUsesWith: aMessageSend receiver; dissolve
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
bindTemporariesOf: inlinedFrame into: inlinerFrame
	| current added |
	current := inlinerFrame temporaries.
	added := inlinedFrame temporaries.
	"added > 0 ifTrue: [self halt]."
	inlinerFrame temporaries: current + added.
	inlinedFrame
		usesDo: [:operand | | user |
			user := operand instruction.
			user isMemoryOperation
				ifTrue: [
					"only temps remain, arguments have been dissolved"
					self _ASSERT: user index < 0.
					user indexImm: user index - current]
				ifFalse: [self _ASSERT: user isReturn]];
		replaceAllUsesWith: inlinerFrame;
		dissolve
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
bindVariablesOf: initialBlock with: aMessageSend
	| values |
	values := OrderedCollection
		with: aMessageSend receiver
		withAll: aMessageSend arguments.
	initialBlock instructionsDo: [:instruction | 
		instruction isDefineArgument ifFalse: [^self].
		instruction name == #activationRecord ifFalse: [
			instruction replaceAllUsesWith: values first.
			values removeFirst].
		instruction dissolve]
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
blockInliner
	^OptimizingBlockInliner new inlinerActivation: firstBlock activationRecord
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
dynamicDispatch
	^self newDispatcher
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
firstBlock: aBasicBlock
	firstBlock := aBasicBlock
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
initialize
	methods := Dictionary new
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
inlineAllMessages
	firstBlock withSuccessorsPostOrder do: [:block | | current |
		current := block.
		block instructionsAsCollection do: [:instruction | 
			(self shouldInline: instruction)
				ifTrue: [current := self inlineMethod: instruction in: current]]]
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
inlineMessages
	self inlineMessagesIn: firstBlock
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
inlineMethod: aMessageSend in: block
	| method nativizer initialBlock |
	method := self inlinedMethodFor: aMessageSend.
	nativizer := OptimizingNativizer on: method.
	initialBlock := nativizer
		abi: abi;
		inlinedMethods: methods;
		decompose;
		firstBlock.
	self bindVariablesOf: initialBlock with: aMessageSend.
	^block inline: initialBlock replacing: aMessageSend
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
inlinedMethodFor: aMessageSend
	^methods detect: [:m | m selector == aMessageSend selector]
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
isBooleanMessage: selector
	^#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue: #and: #or:)
		includes: selector
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
methods: methodsToInline
	methods := methodsToInline
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
newDispatcher
	^ODispatchInliner new methodInliner: self
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
selectors
	^methods collect: #selector
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
shouldInline: instruction
	^instruction isMessageSend
		and: [self selectors includes: instruction selector]
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
staticInliner: method
	^self newDispatcher types: {nil -> method}
! !

!OptimizingMethodInliner methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
tryOptimizingSend: aMessageSend in: aBasicBlock
	| inliner |
	inliner := self lookup: aMessageSend.
	^inliner canBeInlined
		ifTrue: [
			changed := true.
			inliner inline: aMessageSend in: aBasicBlock]
		ifFalse: [aMessageSend -> aBasicBlock]
! !

!OptimizingMethodInliner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:07'!
bindTemporariesOf: inlinedFrame
	| inlinerFrame current added |
	inlinerFrame := firstBlock activationRecord.
	current := inlinerFrame temporaries.
	added := inlinedFrame temporaries.
	inlinerFrame temporaries: current + added.
	inlinedFrame
		usesDo: [:operand | | user |
			user := operand instruction.
			user isMemoryOperation
				ifTrue: [
					"only temps remain, arguments have been dissolved"
					self _ASSERT: user index < 0.
					user indexImm: user index - current]
				ifFalse: [self _ASSERT: user isReturn]];
		replaceAllUsesWith: inlinerFrame;
		dissolve
! !

!OptimizingMethodInliner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:07'!
booleanInliner: selector
	| dispatcher types |
	dispatcher := self newDispatcher.
	types := {true. false} collect: [:bool | | method |
		method := bool behavior findMethodFor: selector.
		bool -> method].
	^dispatcher types: types
! !

!OptimizingMethodInliner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:07'!
lookup: selector for: constant
	| behavior method |
	behavior := constant behavior.
	method := behavior findMethodFor: selector.
	(method isNil or: [method primitiveNumber > 0])
		ifTrue: [^self dynamicDispatch].
	^self newDispatcher types: {behavior -> method}
! !

!OptimizingMethodInliner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:07'!
methodForSelector: selector
	^methods at: selector ifAbsent: nil
! !

!OptimizingMethodInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:07'!
environment
	^environment
! !

!OptimizingMethodInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:07'!
environment: aNativizationEnvironment
	environment := aNativizationEnvironment.
	self methods: environment inlinedMethods
! !

!OptimizingMethodInliner methodsFor: 'json' stamp: 'KenD 11/22/2023 07:53:07'!
lookup: aMessageSend
	| receiver selector |
	receiver := aMessageSend receiver.
	selector := aMessageSend selector.
	receiver isBlockClosure ifTrue: [^self blockInliner].
	receiver isConstant ifTrue: [^self lookup: selector for: receiver value].
	(self isBooleanMessage: selector) ifTrue: [^self booleanInliner: selector].
	(self methodForSelector: selector)
		ifNotNil: [:method | ^self staticInliner: method].
	^self dynamicDispatch
! !

!OptimizingMethodInliner class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
on: basicBlock
	^self basicNew firstBlock: basicBlock
! !

!OptimizingNativizer methodsFor: 'allocation' stamp: 'KenD 11/22/2023 13:59:59'!
allocate
	| allocator |
	allocator := OptimizingRegisterAllocator new
		abi: abi;
		firstBlock: firstBlock.
	^allocator doAllocation
! !

!OptimizingNativizer methodsFor: 'allocation' stamp: 'KenD 11/22/2023 13:59:59'!
transformToCSSA
	| transformer |
	transformer := OptimizingCSSATransformer new firstBlock: firstBlock.
	transformer applyTransformation
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
abi: anAbi
	abi := anAbi
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
assembleUsing: allocation
	| assembler |
	assembler := OptimizingCodeEmitter new
		method: method;
		abi: abi;
		allocation: allocation;
		messageLinker: messageLinker.
	assembler assembleFrom: firstBlock.
	^assembler nativeCode
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
bindVariables
	| binder |
	binder := OptimizingVariableBinder new abi: abi.
	binder doBindingFrom: firstBlock
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
decompose
	self
		inlineBlocks;
		verifyPredecessors;
		inlineMethods;
		verifyPredecessors;
		unifyReturns;
		verifyPredecessors;
		bindVariables
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
eliminateDeadPhis
	OptimizingPhiSimplification new processFrom: firstBlock
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
enforceTwoAddressCodeUsing: allocation
	| enforcer |
	enforcer := OptimizingTwoAddressEnforcer new
		allocation: allocation;
		firstBlock: firstBlock.
	^enforcer doEnforce
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
firstBlock
	^firstBlock
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
fragmentInstructions
	| binder |
	binder := OptimizingInstructionFragmenter new abi: abi.
	binder
		fragmentArgumentsIn: firstBlock with: method;
		fragmentInstructionsFrom: firstBlock
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
initialize
	inlinedMethods := self defaultInlinedMethods
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineBlocks
	OptimizingBlockInliner new on: firstBlock; doInline
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
inlineMethods
	(OptimizingMethodInliner on: firstBlock)
		abi: abi;
		methods: self inlinedMethods;
		inlineAllMessages
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
irFor: aCompiledMethod
	| visitor ir cm |
	visitor := OptimizingVisitor new.
	cm := (BeeNativizationEnvironment isUndermethod: aCompiledMethod selector)
		ifTrue: [ProtoObject >> aCompiledMethod selector]
		ifFalse: [aCompiledMethod].
	ir := visitor visit: cm parseTree.
	^ir
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
messageLinker: aMessageLinker
	messageLinker := aMessageLinker
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
method: aCompiledMethod
	method := aCompiledMethod.
	firstBlock := self irFor: aCompiledMethod
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
nativeCode
	^self nativize
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
removeRedundantCode
	OptimizingValueNumbering new workFrom: firstBlock
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
selectInstructions
	| allocator |
	allocator := OptimizingInstructionSelector new firstBlock: firstBlock.
	^allocator doSelection
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
simplifyCFG
	OptimizingCFGSimplifier new cleanFrom: firstBlock
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
splitCriticalEdges
	firstBlock splitAllCriticalEdges
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
unifyReturns
	firstBlock unifyReturns
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:53'!
validateAllInstructions
	firstBlock validateAllInstructions
! !

!OptimizingNativizer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
verifyPredecessors
	firstBlock verifyAllPredecessorsSanity
! !

!OptimizingNativizer methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:52:53'!
environment: aNativizationEnvironment
	environment := aNativizationEnvironment
! !

!OptimizingNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:59'!
defaultInlinedMethods
	^BeeNativizationEnvironment primitiveObjectMethods , ((OrderedCollection new
		add: Object >> #byteAtValid:;
		add: Object >> #byteAtValid:put:;
		add: ProtoObject >> #objectAtValid:;
		add: ProtoObject >> #objectAtValid:put:;
		add: Object >> #basicObjectIndexOf:;
		add: Object >> #primitiveAt:put:;
		add: ProtoObject >> #behavior;
		add: ProtoObject >> #class;
		add: Species >> #instSize;
		add: Species >> #_instancesAreArrayed;
		add: Species >> #_instancesHavePointers;
		add: Species >> #memory;
		add: Species >> #instanceBehavior;
		add: Species >> #primitiveNew;
		add: Species >> #primitiveNew:;
		add: ProtoObject >> #primitiveAt:;
		add: ProtoObject >> #_cachedLookup:;
		add: ProtoObject >> #_cachedLookup:in:;
		add: CompiledMethod >> #prepareForExecution;
		add: CompiledMethod >> #isNativized;
		add: CompiledMethod >> #nativeCode;
		add: CompiledMethod >> #blockCount;
		add: CompiledMethod >> #literalIndexFrom:;
		add: CompiledBlock >> #argumentCount;
		add: CompiledBlock >> #blockNumber;
		add: CompiledBlock >> #blockCode;
		add: CompiledBlock >> #method;
		add: NativeCode >> #code;
		add: NativeCode >> #isFresh;
		add: CharacterArray >> #characterAtValid:;
		add: GCSpace >> #commitedLimit;
		add: GCSpace >> #nextFree;
		add: GCSpace >> #nextFree:;
		yourself)
		collect: [:cm | cm dmrVersion ifNil: [cm]])
! !

!OptimizingNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:59'!
inlinedMethods
	^inlinedMethods
! !

!OptimizingNativizer methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:59'!
inlinedMethods: aCollection
	inlinedMethods := aCollection
! !

!OptimizingNativizer methodsFor: 'nativizing' stamp: 'KenD 11/22/2023 13:59:59'!
nativize
	| allocation |
	allocation := self
		decompose;
		fragmentInstructions;
		simplifyCFG;
		removeRedundantCode;
		simplifyCFG;
		splitCriticalEdges;
		transformToCSSA;
		allocate.
	^self
		enforceTwoAddressCodeUsing: allocation;
		simplifyCFG;
		assembleUsing: allocation
! !

!OptimizingNativizer class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
new
	^self basicNew initialize
! !

!OptimizingNativizer class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:59'!
on: aCompiledMethod
	^self new method: aCompiledMethod
! !

!OptimizingPhiSimplification methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
initialize
	marks := Set new
! !

!OptimizingPhiSimplification methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
isMarked: instruction
	^marks includes: instruction
! !

!OptimizingPhiSimplification methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
mark: instruction
	^marks add: instruction
! !

!OptimizingPhiSimplification methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
process: aBasicBlock
	| instruction |
	instruction := aBasicBlock firstInstruction.
	[instruction isPhi] whileTrue: [| vars next |
		next := instruction next.
		vars := instruction variables.
		vars size to: 1 by: -1 do: [:i | | var |
			var := vars at: i.
			(self isMarked: var) ifFalse: [instruction removeVariable: var]].
		instruction := next]
! !

!OptimizingPhiSimplification methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
processFrom: firstBlock
	firstBlock instructionsWithSuccessorsDo: [:inst | self mark: inst].
	firstBlock reversePostOrderDo: [:block | self process: block]
! !

!OptimizingPhiSimplification class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
new
	^self basicNew initialize
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
abi: anAbi
	abi := anAbi.
	free := OrderedCollection new.
	free
		add: abi regS;
		add: abi regT;
		add: abi regA;
		add: abi regR;
		add: abi regFP
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
activationRecord
	^firstBlock firstInstruction
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
addLiveRangesOf: block
	block
		instructionsDo: [:instruction | self
			assureLiveRangeStartingAt: instruction
			in: block]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
allocation
	^allocation
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
assign: register to: aRange
	((free includes: register) not and: [(used at: register) !!= aRange])
		ifTrue: [self error: 'register ' , register , ' is not free'].
	allocation at: aRange put: register.
	free remove: register ifAbsent: [].
	used at: register put: aRange
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
assignRegisterTo: instruction in: aRange
	| register |
	register := allocation at: aRange ifAbsent: [
		free isEmpty
			ifTrue: [self spillALiveRangeInUseAfter: instruction]
			ifFalse: [free last]].
	"register == edx ifTrue: [self halt]."
	self assign: register to: aRange
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
assureLiveRangeOf: operand startingAt: anInstruction
	| range |
	range := self assureLiveRangeStartingAt: anInstruction in: currentBlock.
	liveRanges at: operand put: range
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
assureLiveRangeStartingAt: anInstruction
	^self assureLiveRangeStartingAt: anInstruction in: currentBlock
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
assureLiveRangeStartingAt: anInstruction in: block
	| range |
	range := OSimpleLiveRange new definedAt: anInstruction in: block.
	liveRanges at: anInstruction put: range.
	^range
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
computeExpirationOf: instruction
	| range |
	range := self unifiedLiveRangeOf: instruction.
	range expirationPoints do: [:operation | self kill: range at: operation]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
computeExpirations
	firstBlock
		instructionsWithSuccessorsDo: [:instruction | self
			computeExpirationOf: instruction]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
computeInterferenceGraph
	liveRanges do: [:range | self computeInterferencesOf: range]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
computeInterferencesOf: range
	range instructionsDo: [:instruction | | other |
		other := self liveRangeOf: instruction.
		self range: range interferes: other]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
computeLiveRanges
	firstBlock
		reversePostOrderDo: [:block | self addLiveRangesOf: block];
		reversePostOrderDo: [:block | self
			currentBlock: block;
			computeLiveRangesOf: block].
	self computeExpirations
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
computeLiveRangesOf: block
	block firstInstruction acceptVisitor: self
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
currentBlock: aBasicBlock
	currentBlock := aBasicBlock
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
doAllocation
	| record |
	"	record := self activationRecord.
	record isLoadImplicit ifFalse: [free remove: ebp]."
	self computeLiveRanges; allocateLiveRanges; reserveSpaceForLocals.
	^allocation
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
firstBlock: aBasicBlock
	firstBlock := aBasicBlock
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
free: range
	| register |
	register := allocation at: range ifAbsent: [^self].
	(free includes: register) ifTrue: [^self].
	(used at: register) == range ifFalse: [^self].
	"register == ecx ifTrue: [self halt]."
	free add: register.
	used removeKey: register.
	^register
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
initialize
	allocation := IdentityDictionary new.
	liveRanges := IdentityDictionary new.
	unifiedLiveRanges := IdentityDictionary new.
	expirations := IdentityDictionary new.
	locals := 2.
	used := Dictionary new.
	usedOut := Dictionary new
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
insertCopyResultAfter: messageSend
	| copy range |
	copy := OUnaryOperation receiver: messageSend name: #copyResult.
	messageSend
		afterInsert: copy;
		replaceAllUsesWith: copy;
		addUse: copy at: #receiver.
	range := self liveRangeOf: messageSend.
	range definition: copy.
	liveRanges at: copy put: range.
	unifiedLiveRanges
		at: messageSend
		ifPresent: [:unified | unifiedLiveRanges at: copy put: unified]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
insertCopyToR: anInstruction before: inst
	| copy range |
	copy := OUnaryOperation receiver: anInstruction name: #copy.
	anInstruction addUse: copy at: #receiver.
	inst beforeInsert: copy.
	range := self unifiedLiveRangeOf: anInstruction.
	liveRanges at: copy put: range.
	allocation at: copy put: abi regR
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
insertLoadBefore: use at: block changing: operand
	| stack load range definition |
	use isPhi ifTrue: [
		range := self liveRangeOf: use.
		range beSpilled.
		^self].
	stack := used at: abi regFP.
	load := OBinaryConstantOperation
		left: stack anyDefinition
		right: 1 - locals
		name: #_basicAt:.
	stack anyDefinition addUse: load at: #left.
	use beforeInsert: load.
	definition := operand definition.
	operand replaceUseWith: load.
	load addUse: use at: operand name.
	range := self assureLiveRangeStartingAt: load.
	range addUseFrom: use at: block.
	self kill: range at: use.
	allocation
		at: definition
		ifPresent: [:register | allocation at: load put: register]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
insertLoadBeforeUse: operand
	| stack load use range definition predecessor |
	stack := used at: abi regFP.
	load := OLoadOperation base: stack anyDefinition slotAtImm: 1 - locals.
	use := operand instruction.
	use isPhi
		ifTrue: [
			predecessor := operand name.
			predecessor lastValue beforeInsert: load.
			range := self assureLiveRangeStartingAt: load in: predecessor]
		ifFalse: [
			use beforeInsert: load.
			range := self assureLiveRangeStartingAt: load in: currentBlock].
	definition := operand definition.
	operand transferUseTo: load.
	range addUseFrom: use at: currentBlock.
	self kill: range at: use.
	allocation
		at: definition
		ifPresent: [:register | allocation at: load put: register]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
insertPop: anInstruction to: register after: messageSend
	| pop range |
	pop := OUnaryOperation receiver: nil name: #pop.
	messageSend afterInsert: pop.
	range := self unifiedLiveRangeOf: anInstruction.
	liveRanges at: pop put: range.
	allocation at: pop put: register
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
insertPush: anInstruction before: inst
	| push |
	push := OUnaryOperation receiver: anInstruction name: #push.
	anInstruction addUse: push at: #receiver.
	inst beforeInsert: push
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
insertStoreAfter: definition at: block
	| stack store range |
	unifiedLiveRanges removeKey: definition ifAbsent: [].
	definition isPhi ifTrue: [^self].
	stack := used at: abi regFP.
	store := OTernaryOperation
		receiver: stack anyDefinition
		left: 1 - locals
		right: definition
		name: #_basicAt:put:.
	stack anyDefinition addUse: store at: #receiver.
	definition addUse: store at: #right.
	definition afterInsert: store.
	range := self assureLiveRangeStartingAt: definition.
	range addUseFrom: store at: block.
	stack addUseFrom: store at: block.
	self kill: range at: store.
	range := self assureLiveRangeStartingAt: store.
	self kill: range at: store
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
insertStoreAfter: definition with: aLiveRange at: block
	| stack store range reg |
	unifiedLiveRanges removeKey: definition ifAbsent: [].
	definition isPhi ifTrue: [^self].
	stack := used at: abi regFP.
	store := OStoreOperation
		base: stack anyDefinition
		slotAtImm: 1 - locals
		put: definition.
	definition afterInsert: store.
	range := self assureLiveRangeStartingAt: definition.
	range addUseFrom: store at: block.
	stack addUseFrom: store at: block.
	self kill: range at: store.
	range := self assureLiveRangeStartingAt: store.
	self kill: range at: store.
	usedOut at: block ifPresent: [:map | 
		reg := map keyAtValue: aLiveRange ifAbsent: nil.
		reg ifNotNil: [map removeKey: reg]]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
isFree: register
	^free includes: register
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
isSpilled: register
	^false
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
kill: range at: instruction
	| expiring |
	(range class = OSimpleLiveRange or: [range class == OComposedLiveRange])
		ifFalse: [self halt].
	expiring := expirations
		at: instruction
		ifAbsentPut: [OrderedCollection new].
	expiring add: range
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
liveRangeOf: value
	^liveRanges at: value
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
preallocateImplicitVariables
	firstBlock instructionsDo: [:inst | | range register |
		inst isLoadImplicit ifFalse: [^self].
		range := self unifiedLiveRangeOf: inst.
		register := inst source.
		register ifNotNil: [allocation at: range put: register]]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
rangesEndingAt: instruction
	^expirations at: instruction ifAbsent: [OrderedCollection new]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
repairToRespectABI: messageSend with: range
	| result clobbered receiver spillPoint |
	result := allocation at: messageSend ifAbsent: nil.
	clobbered := (used copy
		removeKey: abi regFP ifAbsent: [];
		removeKey: result ifAbsent: [];
		yourself) associations.
	spillPoint := messageSend arguments size > 0
		ifTrue: [messageSend arguments first]
		ifFalse: [messageSend].
	clobbered do: [:assoc | 
		self
			insertPush: assoc value anyDefinition before: spillPoint;
			insertPop: assoc value anyDefinition to: assoc key after: messageSend].
	receiver := allocation at: messageSend receiver.
	receiver == abi regR
		ifFalse: [self insertCopyToR: messageSend receiver before: messageSend].
	(result !!= nil and: [result !!= abi regR])
		ifTrue: [self insertCopyResultAfter: messageSend]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
reserveSpaceForLocals
	self activationRecord temporaries: locals - 2
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
spillALiveRangeInUseAfter: instruction
	| freed register |
	freed := self usedRangeReadLastAfter: instruction.
	locals := locals + 1.
	self splitRange: freed.
	register := self free: freed.
	^register
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
splitRange: aLiveRange
	| real |
	real := self unifiedLiveRangeOfRange: aLiveRange.
	real definitionsWithBlocksDo: [:definition :block | 
		definition allUses
			do: [:operand | self
				insertLoadBefore: operand instruction
				at: nil
				changing: operand].
		self insertStoreAfter: definition at: block]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
unifiedLiveRangeOf: anInstruction
	^unifiedLiveRanges
		at: anInstruction
		ifAbsent: [liveRanges at: anInstruction]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
unifiedLiveRangeOfRange: aLiveRange
	^unifiedLiveRanges at: aLiveRange ifAbsent: [aLiveRange]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
unify: anInstruction liveRangeTo: unified
	| range |
	range := self unifiedLiveRangeOf: anInstruction.
	range = unified ifTrue: [^self].
	unified addAll: range simpleRanges.
	unified allDefinitions
		do: [:instruction | unifiedLiveRanges at: instruction put: unified]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
use: operand from: anInstruction
	self use: operand from: anInstruction in: currentBlock
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
use: operand from: anInstruction in: block
	| range |
	range := self liveRangeOf: operand.
	range addUseFrom: anInstruction at: block
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
usedRangeLessAccessed
	| ranges |
	ranges := (used copy removeKey: abi regFP) values asOrderedCollection.
	^ranges
		min: [:range | (range allDefinitions , range allUses reject: #isPhi) size]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
usedRangeReadLast
	| ranges |
	ranges := (used copy removeKey: abi regFP) values asOrderedCollection.
	currentBlock
		instructionsWithReversePostOrderSuccessorsDo: [:instruction | | candidate |
			candidate := ranges first.
			ranges removeAllSuchThat: [:range | 
				range allDefinitions
					anySatisfy: [:definition | instruction usesResultOf: definition]].
			ranges size = 1 ifTrue: [^ranges first].
			ranges size = 0 ifTrue: [^candidate]].
	self ASSERT: false
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
usedRangeReadLastAfter: first
	| ranges |
	ranges := (used copy removeKey: abi regFP) values asOrderedCollection.
	currentBlock
		instructionsAfter: first
		withReversePostOrderSuccessorsDo: [:instruction | | candidate |
			candidate := ranges first.
			ranges removeAllSuchThat: [:range | range isUsedBy: instruction].
			ranges size = 1 ifTrue: [^ranges first].
			ranges size = 0 ifTrue: [^candidate]].
	^ranges first
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitBinaryWithConstant: instruction
	self use: instruction left from: instruction
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitBinaryWithVariable: instruction
	self
		use: instruction left from: instruction;
		use: instruction right from: instruction
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitJump: instruction
	
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitJumpFalse: instruction
	self use: instruction variable from: instruction
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitJumpTrue: instruction
	self use: instruction variable from: instruction
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
visitLoad: load
	| index |
	self use: load base from: load.
	index := load index.
	(index isInstruction andNot: [index isConstant])
		ifTrue: [self use: index from: load]
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitLoadConstant: instruction
	
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitLoadImplicit: instruction
	
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitMessageSend: instruction
	self
		use: instruction receiver
		from: instruction
	"instruction arguments
		do: [:operation | self use: operation from: instruction]"
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitNullary: instruction
	
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitPhi: instruction
	| unified |
	unified := OComposedLiveRange new.
	instruction variables do: [:source | 
		self
			use: source from: instruction;
			unify: source liveRangeTo: unified].
	self unify: instruction liveRangeTo: unified
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitReturn: instruction
	self
		use: instruction source from: instruction;
		use: self activationRecord from: instruction
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:53:07'!
visitStore: store
	self use: store base from: store.
	store index isInteger ifFalse: [self use: store index from: store].
	self use: store value from: store
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitTernary: instruction
	self use: instruction receiver from: instruction.
	instruction left isInteger
		ifFalse: [self use: instruction left from: instruction].
	self use: instruction right from: instruction
! !

!OptimizingRegisterAllocator methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
visitUnary: instruction
	self use: instruction receiver from: instruction
! !

!OptimizingRegisterAllocator methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:52'!
allocateFor: inst
	| range register starts ends |
	(self rangesEndingAt: inst) reverseDo: [:ending | self free: ending].
	range := self unifiedLiveRangeOf: inst.
	starts := range startsAt: inst.
	ends := range endsAt: inst.
	(ends not and: [range isSpilled not]) ifTrue: [
		starts ifTrue: [self assignRegisterTo: inst in: range].
		register := allocation at: range.
		allocation at: inst put: register].
	inst isMessageSend ifTrue: [self repairToRespectABI: inst with: range]
! !

!OptimizingRegisterAllocator methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:52'!
allocateLiveRanges
	self preallocateImplicitVariables.
	firstBlock reversePostOrderDo: [:block | 
		currentBlock := block.
		self recalculateRegisterUsage.
		block instructionsDo: [:inst | self allocateFor: inst].
		usedOut at: block put: used copy]
! !

!OptimizingRegisterAllocator methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:52'!
recalculateRegisterUsage
	| incoming recalculated |
	currentBlock predecessors size = 0 ifTrue: [^self].
	incoming := (currentBlock predecessors
		select: [:block | usedOut includesKey: block])
		collect: [:block | usedOut at: block].
	recalculated := incoming first.
	used := recalculated select: [:assoc | assoc value isLiveAt: currentBlock].
	free := OrderedCollection new: 10.
	free
		add: abi regS;
		add: abi regT;
		add: abi regA;
		add: abi regR;
		add: abi regFP;
		removeAll: used keys
! !

!OptimizingRegisterAllocator class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:52'!
new
	^self basicNew initialize
! !

!OptimizingSSAReconstructor methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:58'!
definitionInBlockFrom: instruction
	instruction
		reverseDo: [:current | (variable == current
			or: [reloads includes: current])
			ifTrue: [^current]].
	^nil
! !

!OptimizingSSAReconstructor methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:58'!
firstBlock: block
	firstBlock := block.
	idoms := firstBlock dominatorTree allImmediateDominators
! !

!OptimizingSSAReconstructor methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:58'!
insertPhiAt: block
	^insertedPhis at: block ifAbsentPut: [| arguments phi predecessors |
		predecessors := block predecessors.
		arguments := predecessors collect: [:pred | | search |
			search := pred lastInstruction.
			self reachingDefinitionFrom: search at: pred].
		phi := OPhi withAll: arguments in: predecessors.
		arguments with: predecessors do: [:var :pred | var addUse: phi at: pred].
		block addFront: phi.
		phi]
! !

!OptimizingSSAReconstructor methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:58'!
reachingDefinitionFrom: instruction at: block
	| current search |
	current := block.
	search := instruction.
	[| def |
		def := self definitionInBlockFrom: search.
		def ifNotNil: [^def].
		(iteratedFrontiers includes: current) ifTrue: [^self insertPhiAt: current].
		current := idoms at: current.
		search := current lastInstruction] repeat
! !

!OptimizingSSAReconstructor methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:58'!
reconstructSSA
	| frontiers reloadBlocks uses |
	frontiers := firstBlock dominanceFrontiersUsing: idoms.
	reloadBlocks := reloads collect: [:reload | blocks at: reload].
	iteratedFrontiers := firstBlock
		iteratedDominanceFrontiersOf: reloadBlocks
		using: frontiers.
	uses := variable allUses.
	uses do: [:use | | search block def user |
		user := use user.
		user isPhi
			ifTrue: [
				block := use name.
				search := use name lastInstruction]
			ifFalse: [
				block := blocks at: user.
				search := user prev].
		def := self reachingDefinitionFrom: search at: block.
		use disolveReplacingWith: def]
! !

!OptimizingSSAReconstructor methodsFor: 'initialization' stamp: 'KenD 11/22/2023 13:59:58'!
setupFor: anInstruction with: redefinitions
	| users |
	insertedPhis := Dictionary new.
	variable := anInstruction.
	reloads := redefinitions.
	blocks := Dictionary new.
	users := variable allUses collect: #user.
	firstBlock withSuccessorsDo: [:block | 
		block instructionsDo: [:instr | 
			((reloads includes: instr) or: [users includes: instr])
				ifTrue: [blocks at: instr put: block]]]
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
allocation: aDictionary
	allocation := aDictionary
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
convert: instruction copyingLeftInto: dest
	| load |
	load := OUnaryOperation receiver: instruction left name: #copy.
	instruction left addUse: load at: #receiver.
	instruction beforeInsert: load; left: load.
	allocation at: load put: dest
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
convert: instruction copyingReceiverInto: dest
	| load |
	load := OUnaryOperation receiver: instruction receiver name: #copy.
	instruction receiver
		addUse: load at: #receiver;
		removeUse: instruction.
	instruction beforeInsert: load; receiver: load.
	allocation at: load put: dest
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
doEnforce
	firstBlock
		withSuccessorsDo: [:block | block firstInstruction acceptVisitor: self]
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
firstBlock: block
	firstBlock := block
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
insertCopy: instruction rightInto: dest
	| load |
	load := OUnaryOperation receiver: instruction right name: #copy.
	instruction addUse: load at: #receiver.
	instruction afterInsert: load.
	allocation at: load put: dest
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
invertMinus: minus with: left with: right
	| negate |
	negate := OUnaryOperation receiver: minus right name: #negate.
	minus beforeInsert: negate.
	allocation at: negate put: right.
	minus right
		removeUse: minus;
		addUse: negate at: #receiver.
	negate addUse: minus at: #right.
	minus right: negate; name: #'+'; swapOperands
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitBinaryWithConstant: instruction
	| left dest |
	(#(_basicAt: _smallSize:) includes: instruction name) ifTrue: [^self].
	left := allocation at: instruction left.
	dest := allocation at: instruction.
	left == dest ifTrue: [^self].
	self convert: instruction copyingLeftInto: dest
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitBinaryWithVariable: instruction
	| left right dest temp |
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	dest := allocation at: instruction ifAbsent: [^self].
	left == dest ifTrue: [^self].
	right == dest ifTrue: [
		(#(< <= = == > >= _transferControlTo: _basicAt: _byteAt: _basicFlags: _smallSize: _extendedFlags:)
			includes: instruction name)
			ifTrue: [^self].
		instruction name == #'-'
			ifTrue: [^self invertMinus: instruction with: left with: right].
		(#(+ bitAnd: bitOr: &  ) includes: instruction name)
			ifTrue: [
				temp := instruction left.
				instruction left: instruction right.
				^instruction right: temp]
			ifFalse: [self halt]].
	self convert: instruction copyingLeftInto: dest
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitJump: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitJumpFalse: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitJumpTrue: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitLoadConstant: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitLoadImplicit: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitMessageSend: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitNullary: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitPhi: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitReturn: instruction
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 07:52:56'!
visitStore: store
	
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitTernary: instruction
	| receiver left right dest |
	(#(_basicAt:put: _basicULongAt:put: _byteAt:put: _objectAtOffset:put:)
		includes: instruction name)
		ifTrue: [^self].
	receiver := allocation at: instruction receiver.
	left := allocation at: instruction left.
	right := allocation at: instruction right.
	dest := allocation at: instruction.
	right == dest ifTrue: [^self halt].
	self insertCopy: instruction rightInto: dest
! !

!OptimizingTwoAddressEnforcer methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitUnary: instruction
	| receiver dest |
	(#(_asNative _asObject _asPointer _asSmallInteger)
		includes: instruction name)
		ifFalse: [^self].
	receiver := allocation at: instruction receiver.
	dest := allocation at: instruction.
	receiver == dest ifTrue: [^self].
	self convert: instruction copyingReceiverInto: dest
! !

!OptimizingTwoAddressEnforcer methodsFor: 'visitor protocol' stamp: 'KenD 11/22/2023 07:52:56'!
visitLoad: load
	
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
verify: definition usedBy: user
	definition isInteger ifTrue: [^self].
	definition usesDo: [:use | use instruction == user ifTrue: [^self]].
	self error: 'Corrupted instruction usage'
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
verifyFrom: firstBlock
	firstBlock
		instructionsWithSuccessorsDo: [:instruction | instruction
			acceptVisitor: self]
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitBinaryWithConstant: instruction
	self verify: instruction left usedBy: instruction
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitBinaryWithVariable: instruction
	self
		verify: instruction left usedBy: instruction;
		verify: instruction right usedBy: instruction
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitJump: instruction
	
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitJumpFalse: instruction
	self verify: instruction variable usedBy: instruction
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitJumpTrue: instruction
	self verify: instruction variable usedBy: instruction
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitLoadConstant: instruction
	
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitLoadImplicit: instruction
	
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitMessageSend: instruction
	self verify: instruction receiver usedBy: instruction
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitNullary: instruction
	
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitPhi: instruction
	instruction variables
		do: [:operation | self verify: operation usedBy: instruction]
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitReturn: instruction
	self verify: instruction source usedBy: instruction
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitTernary: instruction
	self
		verify: instruction receiver usedBy: instruction;
		verify: instruction left usedBy: instruction;
		verify: instruction right usedBy: instruction
! !

!OptimizingUsesVerifier methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:53'!
visitUnary: instruction
	self verify: instruction receiver usedBy: instruction
! !

!OptimizingValueNumbering methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:54'!
addNewName: instruction
	^names at: instruction put: '{v' , names size printString , '}'
! !

!OptimizingValueNumbering methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:05'!
coalesce: instruction as: hash
	hashes
		at: hash
		ifPresent: [:value | ^instruction replaceAllUsesWith: value; dissolveDeep].
	hashes at: hash put: instruction
! !

!OptimizingValueNumbering methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:05'!
tryMoving: variable justBeforeBranch: branch
	| node inserted |
	node := branch prev.
	node == variable ifTrue: [^self].
	[
		node isConstant ifFalse: [^self].
		node := node prev.
		node == variable] whileFalse.
	inserted := variable isPhi
		ifTrue: [variable replaceUsesBy: branch with: variable newCopy]
		ifFalse: [variable remove].
	branch beforeInsert: inserted
! !

!OptimizingValueNumbering methodsFor: 'private' stamp: 'KenD 11/22/2023 07:53:05'!
updateMemory: store as: storeHash andLoads: loadHash
	"
	easy: hashes at: storeHash ifPresent: [:mapping | (mapping value livesInSameBlockThan: store)  ifTrue: [mapping value dissolve]]
	hard: hashes at: storeHash ifPresent: [:mapping | postDominatorTree does: blockOf dominate: currentBlock ifTrue: [mapping value dissolve]]
	"
	hashes at: loadHash put: store
! !

!OptimizingValueNumbering methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:54'!
valueOf: hash be: instruction
	hashes at: hash ifPresent: [:value | | copy |
		copy := instruction replaceWithCopyOf: value.
		self addNewName: copy.
		^copy == value ifFalse: [
			(copy isUnaryOperation and: [copy name = #copy])
				ifTrue: [hashes at: (self hashOfUnary: copy) put: instruction].
			copy isConstant
				ifTrue: [hashes at: (self hashOfLoadConstant: copy) put: instruction]]].
	hashes at: hash put: instruction
! !

!OptimizingValueNumbering methodsFor: 'visitor protocol' stamp: 'KenD 11/22/2023 07:53:05'!
visitLoad: load
	| base index indexHash hash |
	base := self nameOf: load base.
	index := load index.
	indexHash := index isInstruction
		ifTrue: [self nameOf: index]
		ifFalse: [index printString].
	hash := base , load name , indexHash.
	self coalesce: load as: hash
! !

!OptimizingValueNumbering methodsFor: 'visitor protocol' stamp: 'KenD 11/22/2023 07:53:05'!
visitStore: store
	| receiver index indexHash value valueHash hash load selector |
	receiver := self nameOf: store base.
	index := store index.
	indexHash := index isInstruction
		ifTrue: [self nameOf: index]
		ifFalse: [index printString].
	value := store value.
	valueHash := self nameOf: value.
	hash := receiver , store name , indexHash , valueHash.
	selector := store name allButLast: 4.
	load := receiver , selector , indexHash.
	self updateMemory: value as: hash andLoads: load
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
hashOfLoadConstant: instruction
	^[instruction value printString] on: Error do: [^nil]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
hashOfUnary: instruction
	| receiver |
	receiver := self nameOf: instruction receiver.
	^receiver , instruction name
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
isCommutative: name
	^name = #'+' or: [name = #'*']
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
isStillAlive: block
	^block withPredecessors includes: firstBlock
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
nameOf: instruction
	^names at: instruction
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
processMemoryStore: value as: storeHash andLoads: loadHash
	hashes
		at: loadHash
		put: value
	"facil hashes at: storeHash ifPresent: [:mapping | (mapping value livesInSameBlockThan: store)  ifTrue: [mapping value dissolve]]"
	"dificil hashes at: storeHash ifPresent: [:mapping | postDominatorTree does: blockOf dominate: currentBlock ifTrue: [mapping value dissolve]]"
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
resultOfBinaryWithConstants: aBinaryInstruction
	| operation left right |
	operation := aBinaryInstruction name.
	left := aBinaryInstruction left value.
	right := aBinaryInstruction right value.
	operation = #'+' ifTrue: [^left + right].
	operation = #'-' ifTrue: [^left - right].
	operation = #'*' ifTrue: [^left * right].
	operation = #'//' ifTrue: [^left // right].
	operation = #'=' ifTrue: [^left = right].
	self halt
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
unifyPredecessorHashes
	| incoming any |
	hashes := Dictionary new.
	currentBlock predecessors size = 0 ifTrue: [^self].
	incoming := currentBlock predecessors
		collect: [:pred | hashesOut at: pred ifAbsent: [Dictionary new]].
	any := incoming removeLast.
	any keysAndValuesDo: [:hash :value | | unanimous |
		unanimous := incoming
			conform: [:dict | dict
				at: hash
				ifAbsent: false
				ifPresent: [:prev | prev = value]].
		unanimous ifTrue: [hashes at: hash put: value]]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
valueBranchTo: aBasicBlock
	| source last comparison hash name |
	aBasicBlock predecessors size !!= 1 ifTrue: [^self].
	source := aBasicBlock predecessors first.
	last := source lastInstruction.
	last isConditionalJump ifFalse: [^self].
	comparison := last variable.
	name := self nameOf: comparison.
	hash := 'branch' , name.
	last target == aBasicBlock
		ifTrue: [hashes at: hash put: last isJumpTrue]
		ifFalse: [hashes at: hash put: last isJumpFalse]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitBinaryWithConstant: instruction
	| left right hash selector load temp value replacement |
	left := self nameOf: instruction left.
	right := instruction right printString.
	(self isCommutative: instruction name) ifTrue: [
		left > right ifTrue: [
			temp := left.
			left := right.
			right := temp]].
	hash := left , instruction name , right.
	(#(_basicFlags: _extendedFlags:) includes: instruction name)
		ifTrue: [
			selector := instruction name allButLast: 1.
			load := left , selector.
			self processMemoryStore: instruction right as: hash andLoads: load]
		ifFalse: [
			(instruction left isConstant and: instruction name !!= #_basicAt:) ifTrue: [
				value := self resultOfBinaryWithConstants: instruction.
				replacement := OLoadConstant valued: value.
				instruction dissolveReplacingWith: replacement.
				^self
					addNewName: replacement;
					visitLoadConstant: replacement;
					valueOf: hash be: replacement].
			self valueOf: hash be: instruction]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitBinaryWithVariable: instruction
	| left right hash selector load temp |
	left := self nameOf: instruction left.
	right := self nameOf: instruction right.
	(self isCommutative: instruction name) ifTrue: [
		left > right ifTrue: [
			temp := left.
			left := right.
			right := temp]].
	hash := left , instruction name , right.
	(#(_basicFlags: _extendedFlags:) includes: instruction name)
		ifTrue: [
			selector := instruction name allButLast: 1.
			load := left , selector.
			self processMemoryStore: instruction right as: hash andLoads: load]
		ifFalse: [self valueOf: hash be: instruction]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitBranch: branch
	| hash receiver |
	receiver := self nameOf: branch variable.
	hash := 'branch' , receiver.
	hashes at: hash ifPresent: [:outcome | 
		outcome isBoolean
			ifTrue: [branch replaceWithUnconditional: outcome in: currentBlock]]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitJump: aJumpInstruction
	
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitJumpFalse: branch
	self visitBranch: branch
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitJumpTrue: branch
	self visitBranch: branch
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitLoadConstant: instruction
	| hash |
	hash := self hashOfLoadConstant: instruction.
	hash ifNil: [self].
	self valueOf: hash be: instruction
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitLoadImplicit: instruction
	
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitMessageSend: instruction
	| loads |
	loads := names keys select: [:instr | 
		instr isPrimitiveOperation
			and: [#(_basicAt: _byteAt: _basicFlags) includes: instr name]].
	loads do: [:load | hashes removeAllSuchThat: [:value | value = load]]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitNullary: instruction
	
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitPhi: instruction
	
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitReturn: instruction
	
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitTernary: instruction
	| receiver operand left right hash load |
	receiver := self nameOf: instruction receiver.
	operand := instruction left.
	left := operand isInstruction
		ifTrue: [self nameOf: operand]
		ifFalse: [operand printString].
	right := self nameOf: instruction right.
	hash := receiver , instruction name , left , right.
	(#(_basicAt:put: _byteAt:put:) includes: instruction name)
		ifTrue: [| selector |
			selector := instruction name allButLast: 4.
			load := receiver , selector , left.
			self processMemoryStore: instruction right as: hash andLoads: load]
		ifFalse: [^self valueOf: hash be: instruction]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
visitUnary: instruction
	| hash |
	(#(push) includes: instruction name) ifTrue: [^self].
	hash := self hashOfUnary: instruction.
	self valueOf: hash be: instruction
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
workFrom: aBasicBlock
	| count |
	hashes := Dictionary new.
	hashesOut := Dictionary new.
	names := Dictionary new.
	firstBlock := aBasicBlock.
	count := 0.
	aBasicBlock instructionsWithSuccessorsDo: [:inst | 
		names at: inst put: '{v' , count printString , '}'.
		count := count + 1].
	aBasicBlock withSuccessorsPostOrder
		reverseDo: [:block | self workOn: block]
! !

!OptimizingValueNumbering methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:54'!
workOn: aBlock
	(self isStillAlive: aBlock) ifFalse: [^self].
	currentBlock := aBlock.
	self unifyPredecessorHashes.
	self valueBranchTo: aBlock.
	currentBlock firstInstruction acceptVisitor: self.
	hashesOut at: aBlock put: hashes copy
! !

!OptimizingVariableBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:56'!
abi: anAbi
	abi := anAbi
! !

!OptimizingVariableBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:56'!
wordSize
	^abi wordSize
! !

!OptimizingVariableBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 13:59:56'!
wordSizeShift
	^abi wordSizeShift
! !

!OptimizingVariableBinder methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:56'!
define: value as: name in: block
	| here |
	here := definitions at: block ifAbsentPut: [Dictionary new].
	here at: name put: value
! !

!OptimizingVariableBinder methodsFor: 'private' stamp: 'KenD 11/22/2023 13:59:56'!
resolve: aReadVariable asAssociationValue: binding
	| global read value name load |
	name := binding association key.
	(name == #WordSize or: [name == #WordSizeShift]) ifTrue: [
		value := name == #WordSize
			ifTrue: [abi wordSize]
			ifFalse: [abi wordSizeShift].
		load := OLoadConstant valued: value.
		^aReadVariable dissolveReplacingWith: load].
	binding isPoolVariableBinding
		ifTrue: [
			load := OLoadConstant valued: binding association value.
			aReadVariable dissolveReplacingWith: load]
		ifFalse: [
			global := OLoadConstant valued: binding association.
			read := OBinaryConstantOperation left: global right: 1 name: #_basicAt:.
			global addUse: read at: #left.
			aReadVariable beforeInsert: global; dissolveReplacingWith: read]
! !

!OptimizingVariableBinder methodsFor: 'visitor protocol' stamp: 'KenD 11/22/2023 07:53:06'!
visitLoad: instruction
	
! !

!OptimizingVariableBinder methodsFor: 'visitor protocol' stamp: 'KenD 11/22/2023 07:53:06'!
visitStore: instruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
define: value as: name
	self define: value as: name in: currentBlock
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
definitionOf: name
	^self definitionOf: name from: currentBlock
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
definitionOf: name before: block
	| instruction current |
	instruction := block firstInstruction.
	[instruction isPhi] whileTrue: [
		instruction variables first = name ifTrue: [^instruction].
		instruction := instruction next].
	current := block.
	[
		current := immediateDominators
			at: current
			ifAbsent: [self error: 'undefined variable <' , name , '>'].
		current notNil]
		whileTrue: [
			definitions
				at: current
				ifPresent: [:here | here at: name ifPresent: [:value | ^value]]]
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
definitionOf: name from: block
	| current |
	current := block.
	[current notNil] whileTrue: [
		definitions
			at: current
			ifPresent: [:here | here at: name ifPresent: [:value | ^value]].
		current := immediateDominators
			at: current
			ifAbsent: [^block lastValue
			"BMNullaryOperation
				name: 'nop'
				self error: 'undefined variable <' , name , '>'"]]
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
definitionOf: name in: block
	definitions
		at: block
		ifPresent: [:here | here at: name ifPresent: [:value | ^value]].
	^nil
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
doBindingFrom: firstBlock
	dominatorTree := firstBlock dominatorTree.
	immediateDominators := dominatorTree allImmediateDominators.
	dominanceFrontiers := firstBlock
		dominanceFrontiersUsing: immediateDominators.
	firstBlock reversePostOrderDo: [:block | 
		currentBlock := block.
		block firstInstruction acceptVisitor: self].
	self resolvePendingReads; rewritePhis
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
initialize
	definitions := Dictionary new.
	pendingReads := OrderedCollection new.
	pendingPhis := OrderedCollection new
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
insertPhiOf: name at: block
	| size variables phi |
	(self definitionOf: name in: block) ifNotNil: [^self].
	size := block predecessors size.
	variables := (Array new: size)
		atAllPut: name;
		asOrderedCollection.
	phi := OPhi withAll: variables in: block predecessors.
	block firstInstruction beforeInsert: phi.
	pendingPhis add: phi -> block.
	self define: phi as: name in: block
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
instructionsForWriting: aWriteVariable
	| binding |
	binding := aWriteVariable binding.
	binding isTemporary
		ifTrue: [^self instructionsForWriting: aWriteVariable toTemporary: binding].
	binding isInstVar
		ifTrue: [^self
			instructionsForWriting: aWriteVariable
			toInstanceVariable: binding].
	binding refersToAssoc
		ifTrue: [^self
			instructionsForWriting: aWriteVariable
			toAssociation: binding].
	self halt
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
instructionsForWriting: aWriteVariable toAssociation: binding
	| global write |
	global := OLoadConstant valued: binding association.
	write := OTernaryOperation
		receiver: global
		left: 1
		right: aWriteVariable source
		name: #_basicAt:put:.
	global addUse: write at: #receiver.
	aWriteVariable source addUse: write at: #right.
	aWriteVariable beforeInsert: global; dissolveReplacingWith: write
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
instructionsForWriting: aWriteVariable toInstanceVariable: binding
	| this write |
	this := self definitionOf: #self.
	write := OTernaryOperation
		receiver: this
		left: binding index
		right: aWriteVariable source
		name: #_basicAt:put:.
	this addUse: write at: #receiver.
	aWriteVariable source addUse: write at: #right.
	aWriteVariable dissolveReplacingWith: write
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
instructionsForWriting: aWriteVariable toTemporary: binding
	self define: aWriteVariable source as: binding name asSymbol.
	aWriteVariable dissolve.
	(dominanceFrontiers at: currentBlock)
		do: [:block | self insertPhiOf: binding name asSymbol at: block]
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
resolve: aReadVariable asArgument: binding
	| source |
	source := self definitionOf: binding name asSymbol.
	aReadVariable replaceAllUsesWith: source; dissolve
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
resolve: aReadVariable asInstanceVar: binding
	| receiver index load |
	receiver := self definitionOf: #self.
	"	index := method classField indexOfSlot: name."
	index := binding index.
	load := OBinaryConstantOperation
		left: receiver
		right: index
		name: #_basicAt:.
	receiver addUse: load at: #left.
	aReadVariable dissolveReplacingWith: load
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
resolve: aReadVariable asLiteral: binding
	| name value constant |
	name := binding name asSymbol.
	value := self valueOfSpecial: name.
	constant := OLoadConstant valued: value.
	aReadVariable dissolveReplacingWith: constant
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
resolve: aReadVariable asTemporary: binding
	| source |
	source := self definitionOf: binding name asSymbol in: currentBlock.
	source
		ifNil: [pendingReads add: aReadVariable -> currentBlock]
		ifNotNil: [aReadVariable replaceAllUsesWith: source; dissolve]
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
resolvePendingReads
	pendingReads do: [:association | | read block source |
		read := association key.
		block := association value.
		source := self definitionOf: read binding name asSymbol before: block.
		read replaceWithCopyOf: source]
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
resolveSelf: aReadVariable
	| receiver |
	receiver := self definitionOf: #self.
	^aReadVariable replaceAllUsesWith: receiver; dissolve
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
rewritePhis
	pendingPhis do: [:association | | phi block |
		phi := association key.
		block := association value.
		(phi livesAfter: phi orOutOf: block)
			ifTrue: [
				block predecessors withIndexDo: [:predecessor :i | | name source |
					name := phi variables at: i.
					source := self definitionOf: name from: predecessor.
					phi variables at: i put: source.
					source addUse: phi at: predecessor]]
			ifFalse: [phi clearVariables; dissolve]]
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
valueOfSpecial: name
	name == #true ifTrue: [^true].
	name == #false ifTrue: [^false].
	name == #nil ifTrue: [^nil].
	self halt
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitBinaryWithConstant: instruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitBinaryWithVariable: instruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitDefineArgument: instruction
	self define: instruction as: instruction name
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitJump: aJumpInstruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitJumpFalse: aJumpInstruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitJumpTrue: aJumpInstruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitLoadConstant: aLoadImplicit
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitMessageSend: aMessageSend
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitPhi: aPhi
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitReadVariable: aReadVariable
	| binding |
	self ASSERT: (aReadVariable binding isKindOf: Binding).
	binding := aReadVariable binding.
	binding isTemporary
		ifTrue: [^self resolve: aReadVariable asTemporary: binding].
	binding isArgument
		ifTrue: [^self resolve: aReadVariable asArgument: binding].
	binding isSelf ifTrue: [^self resolveSelf: aReadVariable].
	binding isLiteral ifTrue: [^self resolve: aReadVariable asLiteral: binding].
	binding isInstVar
		ifTrue: [^self resolve: aReadVariable asInstanceVar: binding].
	binding refersToAssoc
		ifTrue: [^self resolve: aReadVariable asAssociationValue: binding].
	self ASSERT: false
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitReturn: aReturnInstruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitTernary: instruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitUnary: instruction
	
! !

!OptimizingVariableBinder methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
visitWriteVariable: aWriteVariable
	self ASSERT: (aWriteVariable binding isKindOf: Binding).
	self instructionsForWriting: aWriteVariable
! !

!OptimizingVariableBinder class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:56'!
new
	^self basicNew initialize
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
canBeInlined
	^types notEmpty
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
checkedInline: aCompiledMethod for: aBehavior on: receiverBehavior
	| compare inlined next left |
	left := receiverBehavior ifNil: [receiver].
	compare := OBinaryConstantOperation left: left right: aBehavior name: #'=='.
	inlined := self inlineMethod: aCompiledMethod.
	next := OBasicBlock new.
	currentBlock
		add: compare;
		endWithJumpFalseTo: next skipping: inlined if: compare.
	currentBlock := next
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
initialize
	types := #()
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
inline: aMessageSend in: block
	| remaining recBehavior current |
	send := aMessageSend.
	receiver := aMessageSend receiver.
	arguments := aMessageSend arguments.
	remaining := OrderedCollection withAll: types.
	currentBlock := block.
	end := block splitAfter: aMessageSend.
	phi := OPhi new.
	end afterInsert: phi.
	self needsBehavior ifTrue: [recBehavior := self loadReceiverBehavior].
	current := remaining removeFirst.
	[remaining isEmpty] whileFalse: [
		self checkedInline: current value for: current key on: recBehavior.
		current := remaining removeFirst].
	self lastInline: current value.
	aMessageSend replaceAllUsesWith: phi; dissolve.
	^phi -> end
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
inlineMethod: aCompiledMethod
	| nativizer initial last return source |
	nativizer := OptimizingNativizer new.
	initial := nativizer
		environment: methodInliner environment;
		method: aCompiledMethod;
		decompose;
		firstBlock.
	methodInliner
		bindArgumentsOf: initial with: send;
		bindTemporariesOf: initial activationRecord.
	last := initial lastBlock.
	return := last lastValue.
	self _ASSERT: return isReturn.
	source := return source.
	phi addVariable: source from: last.
	return dissolve.
	last endWithJumpTo: end.
	^initial
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
lastInline: aCompiledMethod
	| inlined |
	inlined := self inlineMethod: aCompiledMethod.
	currentBlock endWithJumpTo: inlined
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
loadReceiverBehavior
	| constant heap header test merge join |
	constant := OLoadConstant valued: SmallInteger instanceBehavior.
	currentBlock add: constant.
	heap := OBasicBlock new.
	header := OLoadOperation base: receiver longSlotAtImm: 0.
	heap add: header.
	test := OUnaryOperation receiver: receiver name: #_isSmallInteger.
	merge := OBasicBlock new.
	currentBlock
		add: test;
		endWithJumpTrueTo: merge skipping: heap if: test.
	join := OPhi with: constant from: currentBlock with: header from: heap.
	merge add: join.
	currentBlock := merge.
	^join
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
methodInliner: anOptimizingMethodInliner
	methodInliner := anOptimizingMethodInliner
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
needsBehavior
	^types anySatisfy: [:assoc | assoc key class == Behavior]
! !

!ODispatchInliner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:53:03'!
types: aSequenceableCollection
	types := aSequenceableCollection
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
initialize
	firstBlock := OBasicBlock new.
	currentBlock := firstBlock.
	isReceiver := true
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
insertDefineArgument: name
	| instruction |
	instruction := ODefineArgument named: name.
	currentBlock add: instruction.
	^instruction
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
insertReturnSelf
	| receiver frame instruction |
	receiver := firstBlock firstInstruction next.
	frame := firstBlock firstInstruction.
	instruction := OReturn new
		source: receiver;
		frame: frame;
		argumentsCount: argumentsCount.
	receiver addUse: instruction at: #source.
	frame addUse: instruction at: #frame.
	currentBlock add: instruction.
	^instruction
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
isReceiver
	^isReceiver
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
store: operation into: anIdentifierNode
	| instruction |
	instruction := OWriteVariable
		binding: anIdentifierNode binding
		valued: operation.
	operation addUse: instruction at: #source.
	currentBlock add: instruction.
	^instruction
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visit: aParseNode
	super visit: aParseNode.
	^firstBlock
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitAssignment: anAssignmentNode
	| result |
	result := anAssignmentNode expression acceptVisitor: self.
	anAssignmentNode assignees do: [:node | self store: result into: node]
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitBlock: aBlockNode
	| previous cfg |
	previous := currentBlock.
	cfg := OBasicBlock new.
	currentBlock := cfg.
	self visitScript: aBlockNode.
	currentBlock := previous.
	^OBlockClosure containing: cfg
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitCascade: aCascadeNode
	| result |
	aCascadeNode receiver acceptVisitor: self.
	aCascadeNode messages do: [:node | result := node acceptVisitor: self].
	^result
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitCascadeReceiver: aCascadeReceiverNode
	^aCascadeReceiverNode receiver acceptVisitor: self
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitIdentifier: anIdentifierNode
	| load |
	load := OReadVariable binding: anIdentifierNode binding.
	currentBlock add: load.
	^load
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitLiteral: aLiteralNode
	| load |
	load := OLoadConstant valued: aLiteralNode value.
	currentBlock add: load.
	^load
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitMessage: aMessageNode
	| receiver arguments send block |
	block := currentBlock.
	receiver := aMessageNode receiver acceptVisitor: self.
	arguments := aMessageNode arguments
		collect: [:node | node acceptVisitor: self].
	send := OMessageSend
		receiver: receiver
		selector: aMessageNode selector value asSymbol
		arguments: arguments.
	receiver addUse: send at: #receiver.
	arguments
		withIndexDo: [:argument :i | argument isInstruction
			ifTrue: [argument addUse: send at: i]].
	block add: send.
	^send
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitMethod: aMethodNode
	| last |
	self insertDefineArgument: #activationRecord; insertDefineArgument: #self.
	aMethodNode arguments
		do: [:node | self insertDefineArgument: node value asSymbol].
	argumentsCount := aMethodNode arguments size.
	self visitScript: aMethodNode.
	last := currentBlock lastValue.
	last isReturn ifFalse: [self insertReturnSelf]
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitNumericLiteral: aNumericLiteralNode
	^self visitLiteral: aNumericLiteralNode
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitReturn: aReturnNode
	| source frame instruction |
	source := aReturnNode expression acceptVisitor: self.
	frame := firstBlock firstInstruction.
	instruction := OReturn new
		source: source;
		frame: frame;
		argumentsCount: argumentsCount.
	source addUse: instruction at: #source.
	frame addUse: instruction at: #frame.
	currentBlock add: instruction.
	^instruction
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitScript: aScriptNode
	[
		aScriptNode arguments do: [:node | node acceptVisitor: self].
		aScriptNode temporaries do: [:node | node acceptVisitor: self]].
	aScriptNode statements do: [:node | node acceptVisitor: self]
! !

!OptimizingVisitor methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
visitSelector: aSelectorNode
	
! !

!OptimizingVisitor class methodsFor: 'unclassified' stamp: 'KenD 11/22/2023 13:59:58'!
new
	^self basicNew initialize
! !

!MessageInliner methodsFor: 'transforming' stamp: 'KenD 11/22/2023 07:41:23'!
inline: aMessageNode
	| s keywords |
	message := aMessageNode.
	message receiver isSuper
		ifTrue: [ ^ self ].
	(message isCascadeMessage and: [ message receiver isBlockNode ])
		ifTrue: [ ^ self ].
	s := message selector value.
	s == #ifTrue:
		ifTrue: [ ^ self inlineConditional ].
	s == #ifFalse:
		ifTrue: [ ^ self inlineConditional ].
	s == #or:
		ifTrue: [ ^ self inlineConditional ].
	s == #and:
		ifTrue: [ ^ self inlineConditional ].
	s == #timesRepeat:
		ifTrue: [ ^ self inlineConditional ].
	s == #ifTrue:ifFalse:
		ifTrue: [ ^ self inlineConditional ].
	s == #ifFalse:ifTrue:
		ifTrue: [ ^ self inlineConditional ].
	s == #andNot:
		ifTrue: [ ^ self inlineConditional ].
	s == #orNot:
		ifTrue: [ ^ self inlineConditional ].
	s == #ifNil:
		ifTrue: [ ^ self inlineConditional ].
	s == #ifNotNil:
		ifTrue: [ ^ self inlineIfNotNil ].
	s == #ifNil:ifNotNil:
		ifTrue: [ ^ self inlineIfNilIfNotNil ].
	s == #ifNotNil:ifNil:
		ifTrue: [ ^ self inlineIfNotNilIfNil ].
	s == #whileTrue:
		ifTrue: [ ^ self inlineWhile ].
	s == #whileFalse:
		ifTrue: [ ^ self inlineWhile ].
	s == #whileTrue
		ifTrue: [ ^ self inlineUnitaryWhile ].
	s == #whileFalse
		ifTrue: [ ^ self inlineUnitaryWhile ].
	s == #repeat
		ifTrue: [ ^ self inlineRepeat ].
	s == #to:do:
		ifTrue: [ ^ self inlineToDo ].
	"s == #to:by:do:
		ifTrue: [ ^ self inlineToByDo ]."
	keywords := $: split: s.
	keywords last = ''
		ifTrue: [ keywords := keywords allButLast ].
	(keywords conform: [ :k | k = 'and' ])
		ifTrue: [ ^ self inlineConditional ].
	(keywords conform: [ :k | k = 'or' ])
		ifTrue: [ ^ self inlineConditional ].
	((keywords allButLast conform: [ :k | k = 'and' ])
		and: [ #('ifTrue' 'ifFalse') includes: keywords last ])
		ifTrue: [ ^ self inlineConditional ].
	((keywords allButLast conform: [ :k | k = 'or' ])
		and: [ #('ifTrue' 'ifFalse') includes: keywords last ])
		ifTrue: [ self inlineConditional ]
! !

!MessageInliner methodsFor: 'transforming' stamp: 'KenD 11/22/2023 07:41:23'!
inlineRepeat
	| receiver arguments |
	receiver := message receiver.
	receiver isEvaluable
		ifFalse: [ ^ self ].
	arguments := message arguments.
	arguments isEmpty
		ifFalse: [ ^ self ].
	receiver isBlockNode
		ifFalse: [ ^ self ].
	message beInlined.
	receiver beInlined
! !

!MessageInliner methodsFor: 'transforming' stamp: 'KenD 11/22/2023 07:41:23'!
inlineUnitaryWhile
	| receiver arguments |
	receiver := message receiver.
	receiver isEvaluable ifFalse: [^self].
	arguments := message arguments.
	arguments size = 0 ifFalse: [^self].
	self inlineConditional.
	receiver isBlockNode ifTrue: [
		message beInlined.
		receiver beInlined]
! !

!MessageInliner methodsFor: 'inlining' stamp: 'KenD 11/22/2023 07:41:23'!
inlineConditional
	| arguments |
	arguments := message arguments.
	arguments size >= 1 ifFalse: [^self].
	arguments do: [:arg | arg isEvaluable ifFalse: [^self]].
	message beInlined.
	arguments select: #isBlockNode thenDo: #beInlined
! !

!MessageInliner methodsFor: 'inlining' stamp: 'KenD 11/22/2023 07:41:23'!
inlineIfNilIfNotNil
	| arguments arg |
	arguments := message arguments.
	arguments size = 2 ifFalse: [^self].
	arguments first isEvaluable ifFalse: [^self].
	arg := arguments second.
	(arg isEvaluable or: [arg isBlockNode and: [arg arguments size = 1]])
		ifFalse: [^self].
	message beInlined.
	arguments select: #isBlockNode thenDo: #beInlined
	
! !

!MessageInliner methodsFor: 'inlining' stamp: 'KenD 11/22/2023 07:41:23'!
inlineIfNotNil
	| arguments arg |
	arguments := message arguments.
	arguments size = 1 ifFalse: [^self].
	arg := arguments first.
	(arg isEvaluable or: [arg isBlockNode and: [arg arguments size = 1]])
		ifFalse: [^self].
	message beInlined.
	arg isBlockNode ifTrue: [arg beInlined]
! !

!MessageInliner methodsFor: 'inlining' stamp: 'KenD 11/22/2023 07:41:23'!
inlineIfNotNilIfNil
	| arguments arg |
	arguments := message arguments.
	arguments size = 2 ifFalse: [^self].
	arguments second isEvaluable ifFalse: [^self].
	arg := arguments first.
	(arg isEvaluable or: [arg isBlockNode and: [arg arguments size = 1]])
		ifFalse: [^self].
	message beInlined.
	arguments select: #isBlockNode thenDo: #beInlined
! !

!MessageInliner methodsFor: 'inlining' stamp: 'KenD 11/22/2023 07:41:23'!
inlineToByDo
	| arguments arg step |
	arguments := message arguments.
	arguments size = 3 ifFalse: [^self].
	arg := arguments at: 3.
	arg isBlockNode ifFalse: [^self].
	arg arguments size = 1 ifFalse: [^self].
	step := arguments at: 2.
	(step isNumberNode and: [step value isSmallInteger]) ifFalse: [^self].
	message beInlined.
	arg beInlined
! !

!MessageInliner methodsFor: 'inlining' stamp: 'KenD 11/22/2023 07:41:23'!
inlineToDo
	| arguments last |
	arguments := message arguments.
	arguments size = 2 ifFalse: [^self].
	last := arguments at: 2.
	last isBlockNode ifFalse: [^self].
	last arguments size = 1 ifFalse: [^self].
	message beInlined.
	last beInlined
! !

!MessageInliner methodsFor: 'inlining' stamp: 'KenD 11/22/2023 07:41:23'!
inlineWhile
	| receiver arguments |
	receiver := message receiver.
	receiver isEvaluable
		ifFalse: [ ^ self ].
	arguments := message arguments.
	arguments size = 1
		ifFalse: [ ^ self ].
	arguments last isNullary
		ifFalse: [ ^ self ].
	self inlineConditional.
	receiver isBlockNode
		ifTrue: [ receiver beInlined ]
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
argumentCount
	^format bitsAt: BlockArgCount
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
argumentCount: anInteger
	format := format bitsAt: BlockArgCount put: anInteger
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
capturesHome
	^ format anyMask: BlockCapturesHome
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
capturesHome: aBoolean
	format := aBoolean
				  ifTrue: [ format bitOr: BlockCapturesHome ]
				  ifFalse: [ format bitClear: BlockCapturesHome ]
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
capturesSelf
	^format anyMask: BlockCapturesSelf
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
capturesSelf: aBoolean
	format := aBoolean
		ifTrue: [ format bitOr: BlockCapturesSelf ]
		ifFalse: [ format bitClear: BlockCapturesSelf ]
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
environmentCount
	^ format bitsAt: BlockEnvCount
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
environmentCount: anInteger
	format := format bitsAt: BlockEnvCount put: anInteger
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
format
	^ format
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
id
	^format bitsAt: BlockId
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
id: anInteger
	format := format bitsAt: BlockId put: anInteger
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
initialize
	super initialize.
	format := 0
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
isBlock
	^true
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
method
	^method
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
newClosure
	| closure |
	closure := SClosure new: self environmentCount.
	^ closure block: self
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
optimizedCode
	^optimizedCode
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
optimizedCode: anObject
	optimizedCode := anObject
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
printOn: aStream
	aStream
		print: method classBinding;
		nextPutAll: '>>';
		print: method selector;
		nextPutAll: ' [block ';
		print: self id;
		nextPutAll: ']'

! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
tempCount
	^format bitsAt: BlockTempCount
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
tempCount: anInteger
	format := format bitsAt: BlockTempCount put: anInteger
! !

!SCompiledBlock methodsFor: 'constants' stamp: 'KenD 11/22/2023 07:41:18'!
value
self halt
"	<primitive: BlockValue>
	^ self primitiveFailed" 
! !

!SCompiledBlock methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
method: aCompiledMethod
	method := aCompiledMethod
! !

!SCompiledBlock class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:18'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!Binding methodsFor: 'actions' stamp: 'KenD 11/22/2023 07:41:18'!
beReferencedFrom: aScriptNode
	
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
canBeAssigned
	^true
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
declaration
	^self
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
encodeUsing: anAstcodeEncoder
	self ASSERT: false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isArgument
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isClassBinding
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isClassVariable
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isConstantBinding
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isDynamic
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isGlobal
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isInStack
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isInstVar
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isLiteral
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isLocal
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isPoolVariableBinding
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isSelf
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isSelfOrSuper
	^self isSelf or: [self isSuper]
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isSuper
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
isTemporary
	^false
! !

!Binding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:18'!
literal
	^nil
! !

!Binding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
name
	^name
! !

!Binding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
name: aString
	name := aString
! !

!Binding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:18'!
printNameOn: aStream
		aStream
		print: name

! !

!Binding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:18'!
printOn: aStream
	self printNameOn: aStream.
	aStream
		nextPutAll: ' ('.
	super printOn: aStream.
	aStream nextPutAll: ')'
! !

!DynamicBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
beReferencedFrom: aScriptNode
	"a dynamic binding could refer to an ivar, so we have to be conservative"
	aScriptNode useSelf
! !

!DynamicBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
encodeUsing: anAstcodeEmitter
	anAstcodeEmitter encodeDynamicVar: name
! !

!DynamicBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isDynamic
	^true
! !

!DynamicBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
literal
	^name asSymbol
! !

!DynamicBinding class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
default
	^Default ifNil: [Default := self new name: '<unresolved>']
! !

!DynamicBinding class methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
named: aString
	| index first second |
	index := aString indexOf: $..
	index = 0 ifTrue: [ ^self new name: aString ].
	first := aString copyFrom: 1 to: index - 1.
	second := aString copyFrom: index + 1 to: aString size.
	^NestedDynamicBinding new name: { first. second }
! !

!NestedDynamicBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
encodeUsing: anAstcodeEmitter
	anAstcodeEmitter encodeNestedDynamicVar: name
! !

!NestedDynamicBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
literal
	^name collect: [ :n | n asSymbol]
! !

!NestedDynamicBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
printNameOn: aStream
	name do: [ :n | aStream nextPutAll: n ] separatedBy: [ aStream nextPut: $. ]
! !

!LiteralBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isLiteral
	^true
! !

!FalseBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
encodeUsing: anAstcodeEmitter
	anAstcodeEmitter encodeFalse
! !

!FalseBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
name
	^'false'
! !

!FalseBinding methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:41:15'!
value
	^false
! !

!NilBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:27'!
encodeUsing: anAstcodeEmitter
	anAstcodeEmitter encodeNil
! !

!NilBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:27'!
name
	^'nil'
! !

!NilBinding methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:42:27'!
value
	^nil
! !

!TrueBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
encodeUsing: anAstcodeEmitter
	anAstcodeEmitter encodeTrue
! !

!TrueBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
name
	^'true'
! !

!TrueBinding methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:41:15'!
value
	^true
! !

!LocalBinding methodsFor: 'actions' stamp: 'KenD 11/22/2023 07:42:25'!
beInArray
	environment := ArrayEnvironment new
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
declaration
	^declaration
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
declaration: anIdentifierNode
	declaration := anIdentifierNode
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
environment
	^environment index
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
environmentIndex
	^environment index
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
environmentIndex: anInteger
	environment index: anInteger
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
environmentObject
	^environment
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
environmentType
	^environment environmentType
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
index
	^index
! !

!LocalBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
index: aNumber
	index := aNumber
! !

!LocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:25'!
isInArray
	^self isInStack not
! !

!LocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:25'!
isInStack
	^environment isStack
! !

!LocalBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:25'!
isLocal
	^true
! !

!ArgumentBinding methodsFor: 'actions' stamp: 'KenD 11/22/2023 07:41:17'!
beInlined
	environment := InlinedArgEnvironment new
! !

!ArgumentBinding methodsFor: 'actions' stamp: 'KenD 11/22/2023 07:41:17'!
description
	^'argument ' , name
! !

!ArgumentBinding methodsFor: 'actions' stamp: 'KenD 11/22/2023 07:41:17'!
encodeUsing: anAstcodeEncoder
	anAstcodeEncoder encodeArgument: index env: environment
! !

!ArgumentBinding methodsFor: 'actions' stamp: 'KenD 11/22/2023 07:41:17'!
isInlined
	^environment isInlinedArgument
! !

!ArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:17'!
canBeAssigned
	^false
! !

!ArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:17'!
index: aNumber
	index := aNumber.

! !

!ArgumentBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:17'!
isArgument
	^true
! !

!ArgumentBinding methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:17'!
initialize
	super initialize.
	environment := ArgumentEnvironment new
! !

!ArgumentBinding class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:17'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!TemporaryBinding methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:25'!
description
	^'temporary ' , name
! !

!TemporaryBinding methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:25'!
encodeUsing: anAstcodeEncoder
	anAstcodeEncoder encodeTemporary: index env: environment
! !

!TemporaryBinding methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:25'!
initialize
	super initialize.
	environment := StackEnvironment new
! !

!TemporaryBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:25'!
isTemporary
	^true
! !

!TemporaryBinding class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:25'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SelfBinding methodsFor: 'actions' stamp: 'KenD 11/22/2023 07:41:17'!
beReferencedFrom: aScriptNode
	aScriptNode useSelf
! !

!SelfBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:17'!
canBeAssigned
	^false
! !

!SelfBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:17'!
encodeUsing: anAstcodeEmitter
	anAstcodeEmitter encodeSelf
! !

!SelfBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:17'!
isSelf
	^true
! !

!SelfBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:17'!
name
	^'self'
! !

!SuperBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
encodeUsing: anAstcodeEmitter
	anAstcodeEmitter encodeSuper
! !

!SuperBinding methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
name
	^'super'
! !

!SuperBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isSelf
	^false
! !

!SuperBinding methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isSuper
	^true
! !

!LocalEnvironment methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:19'!
isInlinedArgument
	^false
! !

!ArrayEnvironment methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:24'!
environmentType
	^EnvironmentValue
! !

!ArrayEnvironment methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:24'!
index
	^index
! !

!ArrayEnvironment methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:24'!
index: anInteger
	index := anInteger
! !

!ArrayEnvironment methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:24'!
isCurrent
	^index isNil
! !

!ArrayEnvironment methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:24'!
isIndirect
	^self isCurrent not
! !

!ArrayEnvironment methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:24'!
isStack
	^false
! !

!StackEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
index
	^nil
! !

!StackEnvironment methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
isStack
	^true
! !

!ArgumentEnvironment methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:15'!
environmentType
	^LocalArgument
! !

!InlinedArgEnvironment methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
isInlinedArgument
	^true
! !

!SCompilationResult methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:25'!
ast
	^ast
! !

!SCompilationResult methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:25'!
ast: aParseNode
	ast := aParseNode
! !

!SCompilationResult methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:25'!
compiler: aSmalltalkCompiler
	compiler := aSmalltalkCompiler
! !

!SCompilationResult methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:25'!
method
	^method
! !

!SCompilationResult methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:25'!
method: aCompiledMethod
	method := aCompiledMethod
! !

!SCompilationResult methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:25'!
beSuccessful
	error := nil
! !

!SCompilationResult methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:25'!
error
	^error
! !

!SCompilationResult methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:25'!
error: aCompilationError
	error := aCompilationError
! !

!SCompiler methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:27'!
canBeInIdentifier: aCharacter
	^aCharacter isLetter or: [aCharacter isDigit] or: [aCharacter = $_]
! !

!SCompiler methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:27'!
canStartIdentifier: aCharacter
	^aCharacter isLetter or: [aCharacter = $_]
! !

!SCompiler methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:27'!
peekForIdentifier: aStream
	| char next |
	char := aStream peek.
	(self canBeInIdentifier: char) ifTrue: [
		aStream skip: 1.
		^true].
	char = $. ifFalse: [^false].
	aStream prev isLetter ifFalse: [
		aStream skip: 1.
		^false].
	next := aStream skip: 2; peek.
	next isNil ifTrue: [
		aStream skip: -1.
		^false].
	^next isLetter ifFalse: [aStream skip: -1]; yourself
! !

!SCompiler methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:27'!
protect: aBlock
	^aBlock value
! !

!SCompiler methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:42:27'!
classBinding
	 ^class
! !

!SCompiler methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:42:27'!
classBinding: aSpecies
	| instance |
	class := aSpecies.
	instance := aSpecies instanceSide.
	(instance respondsTo: #configureCompiler)
		ifTrue: [instance configureCompiler: self]
! !

!SCompiler methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:42:27'!
initialize: aDictionary
	class := aDictionary at: #UndefinedObject ifAbsent: nil
! !

!SCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:27'!
compile: aString
	result := self smalltalkCompiler compileMethod: aString.
	^result method
! !

!SCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:27'!
parse: aString
	result := self smalltalkCompiler parseMethod: aString.
	^result ast
! !

!SCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:27'!
smalltalkCompiler
	^ SSmalltalkCompiler new frontend: self
! !

!SCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:27'!
smalltalkParser
	^ self smalltalkCompiler parser
! !

!SCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:27'!
smalltalkScanner
	^ self smalltalkCompiler scanner
! !

!SCompiler methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:27'!
forClass: aClass
	| c |
	c := aClass ifNil: [UndefinedObject].
	self classBinding: c
! !

!SCompiler class methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:27'!
compile: aString in: aClass
	| compiler |
	compiler := self forClass: aClass.
	^compiler compile: aString
! !

!SCompiler class methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:27'!
parse: aString in: aClass
	| compiler |
	compiler := self forClass: aClass.
	^compiler parse: aString
! !

!SCompiler class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:42:27'!
forClass: aClass
	^self new forClass: aClass
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
activate: aScriptNode while: aBlock
	| current |
	current := activeScript.
	activeScript := aScriptNode.
	aBlock value.
	activeScript := current
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
activeScope
	^activeScript scope
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
activeScript
	^activeScript
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
activeScript: aParseNode
	activeScript := aParseNode
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
ast
	^ast
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
frontend
	^frontend
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
frontend: aCompiler
	frontend := aCompiler
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
parser
	^SSmalltalkParser new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
result
	^result
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
scanner
	^SSmalltalkScanner new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
sourceCode
	^source
! !

!SSmalltalkCompiler methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:25'!
sourceCode: aString
	source := aString
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
assignmentNode
	^SAssignmentNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
blockNode
	^SBlockNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
braceNode
	^SBraceNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
buildMethod
	result method: ast buildMethod
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
cascadeMessageNode
	^SCascadeMessageNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
cascadeNode
	^SCascadeNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
commentNode
	^SCommentNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
compileMethod: aString
	source := aString.
	frontend protect: [
		self
			parseMethod;
			resolveSemantics;
			buildMethod].
	^result
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
delimiterToken
	^SDelimiterToken new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
endToken
	^SEndToken new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
hasBlocks
	^ blocks > 0
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
hasSends
^ leaf not
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
identifierNode
	^SIdentifierNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
initialize
	self reset

! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
literalNode
	^SLiteralNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
messageNode
	^SMessageNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
methodNode
	^SMethodNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
noticeSend
	leaf := false
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
numericLiteralNode
	^SNumberNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
pragmaNode
	^SPragmaNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
reset
	self resetResult.
	leaf := true.
	blocks := 0.
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
returnNode
	^SReturnNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
selectorNode
	^SSelectorNode new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'nodes' stamp: 'KenD 11/22/2023 07:42:25'!
stringToken
	^SStringToken new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'emitting' stamp: 'KenD 11/22/2023 07:42:25'!
blockCount
	^blocks
! !

!SSmalltalkCompiler methodsFor: 'emitting' stamp: 'KenD 11/22/2023 07:42:25'!
blockIndex
	blocks := blocks + 1.
	^blocks - 1
! !

!SSmalltalkCompiler methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:42:25'!
compilationError: aString stretch: aStretch
	^SCompilationError new
		compiler: self;
		stretch: aStretch;
		description: aString
! !

!SSmalltalkCompiler methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:42:25'!
error: aString at: anInteger
	| stretch |
	stretch := anInteger thru: anInteger.
	^self error: aString stretch: stretch
! !

!SSmalltalkCompiler methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:42:25'!
error: aString stretch: aStretch
	| error |
	error := self compilationError: aString stretch: aStretch.
	^error beFatal; signal
! !

!SSmalltalkCompiler methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:42:25'!
warning: aString at: aStretch
	| error |
	error := self compilationError: aString stretch: aStretch.
	error beWarning; signal
! !

!SSmalltalkCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:25'!
parseFragment
	headless := false.
	self reset.
	ast := self parser methodFragment.
	result ast: ast
! !

!SSmalltalkCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:25'!
parseFragment: aString
	source := aString.
	[self parseFragment; resolveSemantics] on: SCompilationError do: [].
	^ast
! !

!SSmalltalkCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:25'!
parseMethod
	headless := false.
	self reset.
	ast := self parser method.
	result ast: ast
! !

!SSmalltalkCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:25'!
parseMethod: aString
	source := aString.
	frontend protect: [self parseMethod; resolveSemantics].
	^result
! !

!SSmalltalkCompiler methodsFor: 'services' stamp: 'KenD 11/22/2023 07:42:25'!
resolveSemantics
	ast acceptVisitor: SSemanticVisitor new
! !

!SSmalltalkCompiler methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:25'!
resetResult
	result := SCompilationResult new compiler: self
! !

!SSmalltalkCompiler methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:25'!
supportsBraceNodes
	^true
! !

!SSmalltalkCompiler class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:42:25'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!IdentifierBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
contents
	^contents
! !

!IdentifierBinder methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:26'!
keyFor: aString
	^self subclassResponsibility
! !

!IdentifierBinder methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:42:26'!
printOn: aStream
	self printOn: aStream indent: 0
! !

!IdentifierBinder methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:42:26'!
printOn: aStream indent: anInteger
	self subclassResponsibility
! !

!IdentifierBinder class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:42:26'!
new
	^super new initialize
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
at: aString
	^contents at: aString ifAbsent: nil
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
at: aString ifAbsentPut: aBlock
	^contents at: aString ifAbsentPut: aBlock
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
at: aString put: aBinding
	contents at: aString put: aBinding
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
define: aString as: aBinding
	contents at: aString put: aBinding
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
defines: identifier
	^contents includesKey: identifier
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
do: aBlock
	contents do: aBlock
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
select: aBlock
	^contents select: aBlock
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
values
	^contents values
! !

!StaticBinder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:18'!
withIndexDo: aBlock
	contents withIndexDo: aBlock
! !

!StaticBinder methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:18'!
initialize
	super initialize.
	contents := OrderedDictionary new
! !

!StaticBinder methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:18'!
printOn: aStream indent: anInteger
	aStream tab: anInteger; nextPut: $<.
	contents keys
		do: [:name | name printOn: aStream]
		separatedBy: [aStream space].
	aStream nextPut: $>
! !

!StaticBinder class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:18'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visit: aParseNode
	^aParseNode notNil ifTrue: [aParseNode acceptVisitor: self] 
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitAssignment: anAssignmentNode
	^self visitParseNode: anAssignmentNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitBlock: aBlockNode
	^self visitParseNode: aBlockNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitBraceNode: aBraceNode
	^self visitParseNode: aBraceNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitCascade: aCascadeNode
	^self visitParseNode: aCascadeNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitCascadeMessage: aCascadeMessageNode
	^self visitMessage: aCascadeMessageNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitForeignNode: anForeignNode
	self visitLiteral: anForeignNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitIdentifier: anIdentifierNode
	^self visitParseNode: anIdentifierNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitLiteral: aLiteralNode
	^self visitParseNode: aLiteralNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitMessage: aMessageNode
	^self visitParseNode: aMessageNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitMethod: aMethodNode
	^self visitParseNode: aMethodNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitNumberNode: aNumberNode
	^self visitLiteral: aNumberNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitParseNode: aParseNode
	^self subclassResponsibility
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitPragma: aPragmaNode
	^self visitParseNode: aPragmaNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitReturn: aReturnNode
	^self visitParseNode: aReturnNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitSelector: aSelectorNode
	^self visitParseNode: aSelectorNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitString: aStringNode
	^self visitLiteral: aStringNode
! !

!SParseTreeVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
visitSymbolicPragma: aPragmaNode
	^self visitPragma: aPragmaNode
! !

!SParseTreeVisitor class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:15'!
new
	^super new initialize
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
compiledBlockIndexOf: aBlockNode
	| index |
	index := method
		findFirst: [:literal | literal isBlock
			and: [literal id == aBlockNode index]].
	^index
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeArgument: anInteger env: environment
	| encoded |
	encoded := self encodedEnvironment: environment.
	self
		nextPut: ArgumentId;
		nextIntegerPut: anInteger;
		nextIntegerPut: encoded
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeClosureElements: aBlockNode
	| scope parent |
	scope := aBlockNode scope.
	parent := aBlockNode realParent.
	^Array streamContents: [:s |
		scope capturesSelf ifTrue: [ s nextPut: Self ].
		scope capturedEnvironments do: [:e | | index |
			e == parent ifTrue: [s nextPut: Environment] ifFalse: [
				index := aBlockNode environmentIndexOf: e.
				self ASSERT: index notNil.
				s nextPut: EnvironmentValue; nextPut: index]].
		scope capturedArguments do: [:a | | binding |
			binding := aBlockNode parent scope resolve: a name.
			s 	nextPut: binding environmentType; nextPut: binding index]]
	
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeDynamicVar: name
	stream nextPut: DynamicVarId.
	self nextSymbolPut: name
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeFalse
	stream nextPut: FalseId
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeLoadRvisitingReceiver
	stream nextPut: LoadRvisitingReceiverId
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeNestedDynamicVar: name
	stream nextPut: NestedDynamicVarId.
	self nextLiteralPut: name 
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeNil
	stream nextPut: NilId
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodePopR
	stream nextPut: PopRid 
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodePushR
	stream nextPut: PushRid 
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeSelf
	stream nextPut: SelfId
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeSuper
	stream nextPut: SuperId
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeTemporary: anInteger env: environment
	| encoded |
	encoded := self encodedEnvironment: environment.
	self
		nextPut: TemporaryId;
		nextIntegerPut: anInteger;
		nextIntegerPut: encoded
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodeTrue
	stream nextPut: TrueId
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
encodedEnvironment: aLocalEnvironment
	aLocalEnvironment isStack
		ifTrue: [ ^ aLocalEnvironment isInlinedArgument
				ifTrue: [ -1 ]
				ifFalse: [ -2 ] ].
	aLocalEnvironment isCurrent
		ifTrue: [ ^ 0 ].
	^ aLocalEnvironment index
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextBigIntegerPut: anInteger
	stream
		nextPut: 16r80;
		int64: anInteger
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextBooleanPut: aBoolean
	stream nextPut: aBoolean asBit

! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextIntegerPut: anInteger
	| value |
	(anInteger > 127 or: [ anInteger < -127 ])
		ifTrue: [ ^ self nextBigIntegerPut: anInteger ].
	value := anInteger >= 0
		ifTrue: [ anInteger ]
		ifFalse: [ anInteger + 16r100 ].
	stream nextPut: value
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextLiteralPut: anObject
	| index |
	index := method
		indexOf: anObject
		ifAbsent: [ self ASSERT: false ].
	self nextIntegerPut: index
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextPut: anInteger
	stream nextPut: anInteger
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextPutAll: aCollection
	stream nextPut: aCollection size; nextPutAll: aCollection
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextSymbolPut: aSymbol
	| index |
	index := method
		indexOf: aSymbol asSymbol
		ifAbsent: [ self ASSERT: false ].
	self nextIntegerPut: index
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
nextTypePut: anInteger
	stream nextPut: anInteger
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitAssignment: anAssignmentNode
	| assignees |
	self nextTypePut: AssignmentId.
	assignees := anAssignmentNode assignees.
	self nextIntegerPut: assignees size.
	assignees do: [ :node | node acceptVisitor: self ].
	anAssignmentNode expression acceptVisitor: self
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitBlock: aBlockNode
	| args inlined |
	self nextTypePut: BlockId.
	inlined := aBlockNode isInlined.
	self nextBooleanPut: inlined.
	inlined
		ifTrue: [ args := aBlockNode arguments collect: [ :id | id binding index ].
			self nextPutAll: args asArray ]
		ifFalse: [ | index captured |
			index := self compiledBlockIndexOf: aBlockNode.
			self nextPut: index.
			captured := self encodeClosureElements: aBlockNode.
			self nextPutAll: captured ].
	self visitScript: aBlockNode
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitBraceNode: aBraceNode
	aBraceNode isLiteral
		ifTrue: [self visitLiteral: aBraceNode asLiteralNode]
		ifFalse: [self visitCascade: aBraceNode asMessageNode]
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitCascade: aCascadeNode
	| messages |
	self nextTypePut: CascadeId.
	aCascadeNode receiver acceptVisitor: self.
	messages := aCascadeNode messages.
	self nextIntegerPut: messages size.
	messages do: [ :node | self visitCascadeMessage: node ]
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitCascadeMessage: aCascadeMessageNode
	| arguments |
	self nextSymbolPut: aCascadeMessageNode selector symbol.
	arguments := aCascadeMessageNode arguments.
	self nextIntegerPut: arguments size.
	arguments do: [ :arg | arg acceptVisitor: self ]
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitIdentifier: anIdentifierNode
	self nextTypePut: IdentifierId.
	anIdentifierNode binding encodeUsing: self
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitLiteral: aLiteralNode
	| index |
	index := method indexOf: aLiteralNode value.
	self
		nextTypePut: LiteralId;
		nextIntegerPut: index.
	index = 0
		ifTrue: [ self nextIntegerPut: aLiteralNode value ]
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitMessage: aMessageNode
	| arguments |
	self
		nextTypePut: MessageId;
		nextBooleanPut: aMessageNode isInlined;
		nextSymbolPut: aMessageNode selector symbol.
	aMessageNode receiver acceptVisitor: self.
	arguments := aMessageNode arguments.
	self nextIntegerPut: arguments size.
	arguments do: [ :arg | arg acceptVisitor: self ]
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitMethod: aMethodNode
	| pragma |
	self nextTypePut: MethodId.
	pragma := aMethodNode pragma.
	pragma isUsed
		ifTrue: [ self nextTypePut: PragmaId.
			pragma name
				ifNotNil: [ self nextSymbolPut: pragma name ]
				ifNil: [ self nextPut: 0 ] ].
	self visitScript: aMethodNode.
	^ stream contents 
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitParseNode: aParseNode
	^self ASSERT: false
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitReturn: aReturnNode
	self
		nextTypePut: ReturnId;
		nextBooleanPut: script realScript isMethod.
	
		aReturnNode expression acceptVisitor: self
! !

!AstcodeEncoder methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:24'!
visitScript: aScriptNode
	| prev statements |
	prev := script.
	script := aScriptNode.
	statements := aScriptNode statements.
	self nextIntegerPut: statements size.
	statements do: [ :node | node acceptVisitor: self ].
	script := prev
! !

!AstcodeEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:24'!
initialize
	stream := #[] writeStream
! !

!AstcodeEncoder methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:24'!
method: aCompiledMethod
	method := aCompiledMethod
! !

!AstcodeEncoder class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:42:24'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeAssignment: anAssignmentNode
	anAssignmentNode assignees
		do: [:v | self analyzeIdentifier: v assignee: true]
! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeBlock: aBlockNode while: aBlock
	aBlockNode isInlined
		ifFalse: [aBlockNode index: aBlockNode compiler blockIndex].
	self analyzeScript: aBlockNode while: aBlock
! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeIdentifier: anIdentifierNode
	self analyzeIdentifier: anIdentifierNode assignee: false
! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeIdentifier: anIdentifierNode assignee: aBoolean
	| script binding |
	anIdentifierNode resolveAssigning: aBoolean.
	aBoolean ifTrue: [anIdentifierNode beAssigned].
	script := anIdentifierNode compiler activeScript.
	binding := anIdentifierNode binding.
	script reference: binding.
	binding isLocal ifTrue: [binding := script scope captureLocal: binding].
	anIdentifierNode binding: binding
! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeMessage: aMessageNode
	inliner inline: aMessageNode.
	aMessageNode isInlined ifFalse: [aMessageNode compiler noticeSend]
! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeMethod: aMethodNode while: aBlock
	self analyzeScript: aMethodNode while: aBlock
! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeReturn: aReturnNode
	aReturnNode compiler activeScript realScript captureHome
! !

!SSemanticVisitor methodsFor: 'analizing' stamp: 'KenD 11/22/2023 07:42:21'!
analyzeScript: aScriptNode while: aBlock
	aScriptNode compiler activate: aScriptNode while: aBlock
! !

!SSemanticVisitor methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:42:21'!
initialize
	super initialize.
	inliner := MessageInliner new
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitAssignment: anAssignmentNode
	| c |
	self analyzeAssignment: anAssignmentNode.
	anAssignmentNode expression acceptVisitor: self.
	c := anAssignmentNode compiler.

! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitBlock: aBlockNode
	self
		analyzeBlock: aBlockNode
		while: [aBlockNode statements do: [:node | node acceptVisitor: self]]
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitBraceNode: aBraceNode
	aBraceNode isLiteral
		ifFalse: [aBraceNode asMessageNode acceptVisitor: self]
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitCascade: aCascadeNode
	aCascadeNode receiver acceptVisitor: self.
	aCascadeNode messages do: [:msg | msg acceptVisitor: self]
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitCascadeMessage: aCascadeMessageNode
	"we do not inline cascade messages for now"
	aCascadeMessageNode compiler noticeSend.
	aCascadeMessageNode receiver acceptVisitor: self.
	aCascadeMessageNode arguments do: [:arg | arg acceptVisitor: self]
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitIdentifier: anIdentifierNode
	self analyzeIdentifier: anIdentifierNode
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitMessage: aMessageNode
	self analyzeMessage: aMessageNode.
	aMessageNode receiver acceptVisitor: self.
	aMessageNode arguments do: [:arg | arg acceptVisitor: self]
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitMethod: aMethodNode
	self analyzeMethod: aMethodNode while: [
		aMethodNode bindLocals.
		aMethodNode statements do: [:s | s acceptVisitor: self].
		aMethodNode positionLocals]
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitParseNode: aParseNode
	"
	do nothing
	"
	
! !

!SSemanticVisitor methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:21'!
visitReturn: aReturnNode
	aReturnNode expression acceptVisitor: self.
	self analyzeReturn: aReturnNode
! !

!SSemanticVisitor class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:42:21'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
addBodyTo: aMethodNode
	self
		addTemporariesTo: aMethodNode;
		addPragmaTo: aMethodNode;
		addStatementsTo: aMethodNode
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
addStatementsTo: aMethodNode
	aMethodNode
		position: token position;
		addStatements: self statements;
		end: token position;
		moveCommentsFrom: token.
	token isEnd
		ifFalse: [^self unexpectedStatementError: aMethodNode statements]
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
addTemporariesTo: aMethodNode
	aMethodNode temporaries: self temporaries
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
cascadeSequence: aMessageNode
	| cascade receiver messages msg node |
	(token is: $;) ifFalse: [^aMessageNode].
	cascade := self buildNode: compiler cascadeNode at: aMessageNode position.
	receiver := aMessageNode receiver.
	cascade receiver: receiver.
	node := compiler cascadeMessageNode from: aMessageNode.
	node cascade: cascade.
	messages := OrderedCollection with: node.
	[token is: $;] whileTrue: [
		self step.
		msg := self buildCascadeMessageNode: receiver.
		msg
			cascade: cascade;
			position: token position;
			moveCommentsFrom: token.
		messages add: msg.
		self cascadeMessage: msg].
	^cascade messages: messages asArray; end: msg end
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
expression
	| primary expression |
	(token isNameToken and: [self peek isAssignment]) ifTrue: [^self assignment].
	primary := self primary ifNil: [^self missingExpression].
	expression := self unarySequence: primary.
	expression := self binarySequence: expression.
	expression := self keywordSequence: expression.
	expression == primary
		ifFalse: [expression := self cascadeSequence: expression].
	token endsExpression ifFalse: [self errorIn: primary].
	^expression
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
keywordSignature
	| selector arguments node |
	selector := '' writeStream.
	arguments := OrderedCollection new.
	node := self buildNode: compiler selectorNode at: token position.
	[token isKeyword] whileTrue: [
		selector nextPutAll: token value.
		node addKeyword: token asSelectorNode.
		self step.
		token isNameToken ifFalse: [self missingArgument].
		arguments add: token asIdentifierNode.
		self step].
	arguments isEmpty ifTrue: [^nil].
	node
		symbol: selector contents;
		end: token end;
		moveCommentsFrom: token.
	^self buildMethodNode: node arguments: arguments
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
methodPragma
	self step.
	^[| method |
		method := self methodSignature.
		self addTemporariesTo: method; attachPragmaTo: method.
		method pragma]
		on: SCompilationError
		do: [:ex | ex return: compiler pragmaNode]
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
methodSignature
	self keywordSignature ifNotNil: [:m | ^m].
	self binarySignature ifNotNil: [:m | ^m].
	self unarySignature ifNotNil: [:m | ^m].
	self error: 'method signature expected'
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
parenthesizedExpression
	| start open expression |
	start := token position.
	open := self step.
	expression := self expression.
	expression moveCommentsFrom: open.
	(token is: $)) ifFalse: [self missingToken: ')'].
	expression isImmediate
		ifFalse: [expression position: start; end: token position].
	self step.
	^expression
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
primary
	token isNameToken ifTrue: [^self step asIdentifierNode].
	token isLiteral ifTrue: [^self step].
	(token is: $[) ifTrue: [^self block].
	(token is: $() ifTrue: [^self parenthesizedExpression].
	(token is: #'#(') ifTrue: [^self literalArray].
	(token is: #'#[') ifTrue: [^self literalByteArray].
	(compiler supportsBraceNodes and: [token is: ${]) ifTrue: [^self bracedArray].
	(token is: #'-') ifTrue: [^self negativeNumber].
	(token is: #'<') ifTrue: [^self taggedNode].
	^nil
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
return
	| return expression end node |
	return := self step.
	expression := self expression.
	expression moveCommentsFrom: token.
	end := token position.
	self skipDots.
	node := self buildNode: compiler returnNode at: return position.
	^node
		return: return;
		end: end;
		expression: expression;
		moveCommentsFrom: return
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
statement
	| expression |
	((token is: $^) or: [token is: $↑]) ifTrue: [^self return].
	expression := self expression.
	token moveCommentsTo: expression.
	^expression
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
statements
	| statements |
	statements := OrderedCollection new.
	[
		token endsExpression ifTrue: [^statements].
		statements add: self statement.
		token is: $.]
		whileTrue: [self skipDots].
	^statements
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
step
	| save comments |
	save := token.
	self next isComment ifFalse: [^save].
	comments := OrderedCollection new: 2.
	[
		comments add: token.
		self next isComment] whileTrue.
	token comments: comments.
	^save
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
temporaries
	| temporaries |
	(token is: #'||') ifTrue: [
		self step.
		^#()].
	token isBar ifFalse: [^#()].
	temporaries := OrderedCollection new.
	[
		self step.
		token isNameToken]
		whileTrue: [
			self validateLocalName: token.
			temporaries add: token asIdentifierNode].
	token isBar ifFalse: [self missingToken: '|'].
	self step.
	^temporaries
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
unaryMessage: aMessageNode
	| selector |
	selector := self unarySelector.
	aMessageNode
		selector: selector;
		end: selector end;
		arguments: #();
		moveCommentsFrom: selector
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
unarySelector
	| selector start end node |
	selector := token value.
	start := token position.
	end := start + selector size - 1.
	self step.
	node := self buildNode: compiler selectorNode at: start.
	^node
		symbol: selector;
		end: end;
		moveCommentsFrom: token
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
unarySequence: aParseNode
	| node receiver |
	node := aParseNode.
	node isNameToken ifTrue: [node := node asIdentifierNode].
	[
		receiver := node.
		self hasUnarySelector]
		whileTrue: [
			node := self buildMessageNode: receiver.
			self unaryMessage: node].
	^node moveCommentsFrom: token
! !

!SSmalltalkParser methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:19'!
unarySignature
	self hasUnarySelector ifFalse: [^nil].
	^self buildMethodNode: self unarySelector arguments: #()
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
addByteTo: aCollection
	| byte |
	byte := token isLiteral ifTrue: [token value] ifFalse: [token literalValue].
	byte isInteger ifFalse: [self nonIntegerToken].
	(byte between: 0 and: 255) ifFalse: [self invalidByteValue].
	aCollection add: byte
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
assignment
	| position variable delimiter expression assignment |
	position := token position.
	variable := self step asIdentifierNode moveCommentsFrom: token.
	delimiter := self step.
	expression := self expression.
	expression isAssign
		ifTrue: [^expression assign: variable operator: delimiter].
	expression moveCommentsFrom: token.
	assignment := self buildNode: compiler assignmentNode at: position.
	^assignment assign: variable with: expression operator: delimiter
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
attachPragmaTo: aMethodNode
	| start pragma |
	(aMethodNode isHeadless orNot: [token is: #'<']) ifTrue: [^false].
	start := token position.
	self step.
	pragma := token isKeyword
		ifTrue: [self ffiOrPrimitive: aMethodNode]
		ifFalse: [self symbolicPragma].
	pragma position: start; end: token position.
	aMethodNode pragma: pragma.
	(token is: #'>') ifFalse: [self missingToken: '>'].
	^true
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
buildBraceNode: elements at: position
	| node |
	node := self buildNode: compiler braceNode at: position.
	^node elements: elements
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
buildCascadeMessageNode: receiver
	| node |
	node := self buildNode: compiler cascadeMessageNode at: receiver position.
	^node receiver: receiver
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
buildMessageNode: receiver
	| node |
	node := self buildNode: compiler messageNode at: receiver position.
	^node receiver: receiver
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
buildMethodNode: selector arguments: arguments
	| node |
	node := self buildNode: compiler methodNode at: selector position.
	compiler activeScript: node.
	^node selector: selector; arguments: arguments
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
buildNode: aParserNode at: anInteger
	^aParserNode position: anInteger; end: token position
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
buildNode: aParseNode at: anInteger with: anObject
	| node |
	node := scanner buildToken: aParseNode at: anInteger with: anObject.
	^node end: token position
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
cascadeMessage: aMessageNode
	| msg |
	self hasUnarySelector ifTrue: [^self unaryMessage: aMessageNode].
	self hasBinarySelector ifTrue: [^self binaryMessage: aMessageNode].
	self hasKeywordSelector ifTrue: [^self keywordMessage: aMessageNode].
	msg := token value = ''
		ifTrue: ['unfinished cascade']
		ifFalse: [token value asString , ' not allowed in cascade'].
	self error: msg
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
ffiArguments
	| args type |
	args := OrderedCollection new.
	self step.
	token value !!= $(
		ifTrue: [ self error: 'expected "("' ].
	self peek value = $)
		ifTrue: [ self step.
			^ args ].
	[ type := self ffiType.
	args add: type.
	self step.
	token value = #, ] whileTrue.
	token value !!= $)
		ifTrue: [ self error: 'expected ")"' ].
	^ args
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
ffiCall: aBoolean method: aMethodNode
	| cc return name args descriptor |
	cc := token value.
	return := self ffiType.
	aBoolean
		ifTrue: [ self step.
			name := token value ifNil: [ self error: 'invalid function name' ] ].
	args := self ffiArguments.
	args size = aMethodNode selector arity
		ifFalse:
			[ ^ self error: 'method arity does not match with function arguments' ].
	self step.
	descriptor := SFFIDescriptor ret: return args: args cc: cc.
	^ compiler pragmaNode ffi: cc name: name with: descriptor
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
ffiOrPrimitive: aMethodNode
	| tag |
	tag := token value asLowercase.
	tag last = $: ifFalse: [self invalidPragma].
	tag := tag allButLast.
	token value: tag.
	tag = 'primitive' ifTrue: [^self primitive].
	tag = 'callback' ifTrue: [ ^self ffiCall: false method: aMethodNode ].
	tag = 'callout' ifTrue: [ ^self ffiCall: true method: aMethodNode ].	
	self invalidPragma
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
ffiType
	| type |
	self step.
	token isNameToken ifFalse: [self error: 'expected type name'].
	type := token value.
	type = 'struct' ifFalse: [ ^type].
	self step.
	token isNameToken ifFalse: [self error: 'expected type name'].	
	^token value
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
hasKeywordSelector
	^token isKeyword
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
hasUnarySelector
	^token isNameToken
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
invalidPragma
	| position stretch |
	position := token position.
 	stretch := position thru: position.
	^SInvalidPragmaError new stretch: stretch; signal
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
keywordArgument
	| arg |
	arg := self primary ifNil: [self missingArgument].
	arg := self unarySequence: arg.
	^self binarySequence: arg
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
keywordMessage: aMessageNode
	| selector arguments node |
	node := self buildNode: compiler selectorNode at: token position.
	selector := '' writeStream.
	arguments := OrderedCollection new.
	[token isKeyword] whileTrue: [
		selector nextPutAll: token value.
		node addKeyword: self step.
		arguments add: self keywordArgument].
	node symbol: selector contents; end: token prevPosition.
	aMessageNode
		arguments: arguments;
		end: token prevPosition;
		selector: node
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
keywordSequence: aParseNode
	| expression |
	self hasKeywordSelector ifFalse: [^aParseNode].
	expression := self buildMessageNode: aParseNode.
	self keywordMessage: expression.
	^expression
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
literalKeyword
	| keyword |
	keyword := token value , scanner nextKeyword value.
	^keyword reduced asSymbol
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
namedPrimitive
	| name pragma |
	token isNameToken
		ifFalse: [ self invalidPragma ].
	name := token value.
	pragma := self buildNode: compiler pragmaNode at: token position.
	^ pragma primitive: 0 name: name asSymbol
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
negativeNumber
	token := nil.
	^self negativeNumberOrBinary; step
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
numberedPrimitive
	| number pragma |
	number := token value.
	number isInteger ifFalse: [self invalidPragma].
	pragma := self buildNode: compiler pragmaNode at: token position.
	^pragma primitive: number name: nil
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
primitive
	| primitive |
	self step.
	primitive := token isNumberNode
		ifTrue: [self numberedPrimitive]
		ifFalse: [self namedPrimitive].
	self step.
	^primitive
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
pseudoLiteralValue
	| value |
	token isPoolLiteral ifTrue: [^token literalValue].
	value := token value.
	value = 'nil' ifTrue: [^nil].
	value = 'true' ifTrue: [^true].
	value = 'false' ifTrue: [^false].
	^token isPoolLiteral ifTrue: [token literalValue] ifFalse: [value asSymbol]
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
skipDots
	[token is: $.] whileTrue: [self step]
! !

!SSmalltalkParser methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:19'!
validateLocalName: aSmalltalkToken
	aSmalltalkToken isDelimitedIdentifier ifTrue: [^self].
	(aSmalltalkToken value includes: $.)
		ifTrue: [self error: 'invalid embedded dot']
! !

!SSmalltalkParser methodsFor: 'api support' stamp: 'KenD 11/22/2023 07:41:19'!
addPragmaTo: aMethodNode
	(self attachPragmaTo: aMethodNode) ifTrue: [self step]
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
arrayBody
	| literals position |
	literals := OrderedCollection new.
	position := token position.
	[
		self step.
		(token is: $)) or: [token isEnd]]
		whileFalse: [| element |
			element := self arrayElement.
			literals add: element].
	token isEnd ifTrue: [self missingToken: ')'].
	^self buildNode: compiler literalNode at: position with: literals asArray
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
arrayElement
	token isLiteral ifTrue: [^token value].
	token isNameToken ifTrue: [^self pseudoLiteralValue].
	token isKeyword ifTrue: [^self literalKeyword].
	(token is: #'-') ifTrue: [^self negativeNumberOrBinary].
	token hasSymbol ifTrue: [^token value].
	(token is: $() ifTrue: [^self arrayBody value].
	(token is: #'#(') ifTrue: [^self arrayBody value].
	(token is: #'#[') ifTrue: [^self byteArrayBody value].
	self invalidArrayToken
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
braceBody
	| elements position |
	elements := OrderedCollection new.
	position := token position.
	self step.
	[
		token isEnd ifTrue: [self missingToken: '}'].
		token is: $}]
		whileFalse: [
			elements add: self expression.
			(token is: $.) ifTrue: [self step]].
	^self buildBraceNode: elements at: position
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
bracedArray
	| array |
	array := self braceBody.
	self step.
	^array
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
byteArrayBody
	| bytes save start array node |
	bytes := OrderedCollection new.
	save := token.
	start := token position.
	[
		self step.
		token isLiteral or: [token isPoolLiteral]]
		whileTrue: [self addByteTo: bytes].
	(token is: $]) ifFalse: [
		token isNameToken
			ifTrue: [self missingLiteral]
			ifFalse: [self missingToken: ']']].
	array := ByteArray new: bytes size.
	bytes withIndexDo: [:b :i | array at: i put: b].
	node := self buildNode: compiler literalNode at: start with: array.
	^node moveCommentsFrom: save
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
literalArray
	| array |
	array := self arrayBody.
	self step.
	^array
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
literalByteArray
	| node |
	node := self byteArrayBody.
	self step.
	^node
! !

!SSmalltalkParser methodsFor: 'arrays' stamp: 'KenD 11/22/2023 07:41:19'!
negativeNumberOrBinary
	self peek isNumberNode
		ifTrue: [token := self next negate position: token position - 1].
	^token value
! !

!SSmalltalkParser methodsFor: 'binary' stamp: 'KenD 11/22/2023 07:41:19'!
binaryMessage: aMessageNode
	| selector primary argument |
	selector := self step.
	primary := self primary.
	primary isNil ifTrue: [
		((selector is: $:) and: [token is: #'='])
			ifTrue: [self
				error: 'stray whitespaces left in assignment'
				at: token position - 1]
			ifFalse: [self error: 'primary missing']].
	argument := self unarySequence: primary.
	aMessageNode
		selector: selector asSelectorNode;
		end: argument end;
		arguments: {argument}
! !

!SSmalltalkParser methodsFor: 'binary' stamp: 'KenD 11/22/2023 07:41:19'!
binarySequence: aParseNode
	| node rcvr |
	node := aParseNode.
	[
		rcvr := node.
		self hasBinarySelector]
		whileTrue: [
			node := self buildMessageNode: rcvr.
			self binaryMessage: node].
	^node
! !

!SSmalltalkParser methodsFor: 'binary' stamp: 'KenD 11/22/2023 07:41:19'!
binarySignature
	| selector arguments |
	((token isStringToken and: [token hasSymbol])
		or: [token is: $^]
		or: [token is: $:])
		ifFalse: [^nil].
	selector := self step asSelectorNode.
	token isNameToken ifFalse: [self missingArgument].
	self validateLocalName: token.
	arguments := {token asIdentifierNode}.
	self step.
	token moveCommentsTo: selector.
	^self buildMethodNode: selector arguments: arguments
! !

!SSmalltalkParser methodsFor: 'binary' stamp: 'KenD 11/22/2023 07:41:19'!
hasBinarySelector
	^(token isStringToken and: [token hasSymbol])
		or: [token is: $^]
		or: [token is: $:]
! !

!SSmalltalkParser methodsFor: 'blocks' stamp: 'KenD 11/22/2023 07:41:19'!
block
	| block |
	block := self buildNode: compiler blockNode at: token position.
	block parent: compiler activeScript.
	compiler activate: block while: [
		token moveCommentsTo: block.
		self step.
		block
			arguments: self blockArguments;
			temporaries: self temporaries;
			addStatements: self statements.
		(token is: $]) ifFalse: [self missingToken: ']'].
		block end: token position.
		token moveCommentsTo: block.
		self step].
	^block
! !

!SSmalltalkParser methodsFor: 'blocks' stamp: 'KenD 11/22/2023 07:41:19'!
blockArguments
	| arguments |
	(token is: $:) ifFalse: [^#()].
	arguments := OrderedCollection new.
	[
		self step.
		token isNameToken ifFalse: [self missingArgument].
		self validateLocalName: token.
		arguments add: self step asIdentifierNode.
		token is: $:] whileTrue.
	token isBar ifTrue: [self step] ifFalse: [
		(token is: #'||')
			ifTrue: [token value: #'|']
			ifFalse: [self missingToken: '|']].
	^arguments
! !

!SSmalltalkParser methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
compiler
	^compiler
! !

!SSmalltalkParser methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
compiler: aSmalltalkCompiler
	compiler := aSmalltalkCompiler.
	scanner := compiler scanner
! !

!SSmalltalkParser methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
next
	token := next.
	next := nil.
	^token ifNil: [token := scanner next]
! !

!SSmalltalkParser methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
on: aString
	scanner on: aString
! !

!SSmalltalkParser methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
peek
	| comments |
	next ifNotNil: [^next].
	next := scanner next.
	next isComment ifFalse: [^next].
	comments := OrderedCollection new: 2.
	[
		comments add: next.
		next := scanner next.
		next isComment] whileTrue.
	^next comments: comments
! !

!SSmalltalkParser methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
token
	^token
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
error: aString
	self error: aString at: token position
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
error: aString at: position
	^compiler error: aString at: position
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
invalidArrayToken
	self error: 'invalid literal entry'
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
invalidByteValue
	self error: 'value not between 0 and 255'
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
missingArgument
	self error: 'argument missing'
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
missingExpression
	self error: 'missing expression'
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
missingLiteral
	self error: 'missing literal or named literal'
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
missingToken: aString
	self error: 'missing ' , aString
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
nonIntegerToken
	self error: 'non-integer token'
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
notify: aString
	compiler notify: aString at: token position
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
notify: aString at: position
	compiler notify: aString at: position
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
warning: aString
	compiler warning: aString at: token position
! !

!SSmalltalkParser methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:19'!
warning: aString at: position
	compiler warning: aString at: position
! !

!SSmalltalkParser methodsFor: 'productions' stamp: 'KenD 11/22/2023 07:41:19'!
headlessMethod
	| method |
	self step.
	method := compiler methodNode.
	compiler activeScript: method.
	self addBodyTo: method.
	^method
! !

!SSmalltalkParser methodsFor: 'productions' stamp: 'KenD 11/22/2023 07:41:19'!
method
	| method |
	self step.
	method := self methodSignature.
	method isNil ifTrue: [^nil].
	self addBodyTo: method.
	^method
! !

!SSmalltalkParser methodsFor: 'productions' stamp: 'KenD 11/22/2023 07:41:19'!
methodFragment
	| method |
	self step.
	method := self methodSignature.
	method isNil ifTrue: [^nil].
	[self addBodyTo: method] on: SCompilationError do: [].
	^method
! !

!SSmalltalkParser methodsFor: 'productions' stamp: 'KenD 11/22/2023 07:41:19'!
methodSelector
	self step.
	^self methodSignature ifNotNil: [:m | m selectorNode]
! !

!SSmalltalkParser methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:19'!
parse: aString
	^self on: aString; method
! !

!SSmalltalkParser methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:19'!
parseExpression: aString
	^self on: aString; headlessMethod
! !

!SSmalltalkParser methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:19'!
parseFragment: aString
	| method |
	self on: aString; step.
	[
		method := self methodSignature.
		method notNil ifTrue: [self addBodyTo: method]]
		on: SCompilationError
		do: [].
	^method
! !

!SSmalltalkParser methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:19'!
parseTemporaries: aString
	self on: aString; step.
	^self methodSignature notNil ifTrue: [self temporaries]
! !

!SSmalltalkParser methodsFor: 'ffi support' stamp: 'KenD 11/22/2023 07:41:19'!
symbolicPragma
	| position symbol pragma |
	position := token position.
	symbol := self step value.
	pragma := self buildNode: compiler pragmaNode at: position.
	^pragma symbol: symbol
! !

!SSmalltalkScanner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:16'!
buildToken: aSmalltalkToken
	^self buildToken: aSmalltalkToken at: stream position
! !

!SSmalltalkScanner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:16'!
buildToken: aSmalltalkToken at: anInteger
	| string |
	string := stream copyFrom: anInteger to: stream position.
	^self buildToken: aSmalltalkToken at: anInteger with: string
! !

!SSmalltalkScanner methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:16'!
buildToken: aSmalltalkToken at: anInteger with: anObject
	^aSmalltalkToken
		position: anInteger;
		value: anObject;
		end: stream position
! !

!SSmalltalkScanner methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:16'!
canBeInIdentifier: aCharacter
	^compiler frontend canBeInIdentifier: aCharacter
! !

!SSmalltalkScanner methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:16'!
canStartIdentifier: aCharacter
	(compiler frontend canStartIdentifier: aCharacter) ifFalse: [^false].
	aCharacter = $_
		ifTrue: [^stream peek ifNil: [false] ifNotNil: [:ch | ch asInteger >= 33]].
	^true
! !

!SSmalltalkScanner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:16'!
compiler
	^compiler
! !

!SSmalltalkScanner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:16'!
compiler: aSmalltalkCompiler
	compiler := aSmalltalkCompiler.
	compiler sourceCode ifNotNil: [:s | self sourceCode: s]
! !

!SSmalltalkScanner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:16'!
on: aString
	stream := aString readStream.
	compiler notNil ifTrue: [compiler sourceCode: aString]
! !

!SSmalltalkScanner methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:16'!
sourceCode: aString
	stream := aString readStream
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
end
	^self buildToken: compiler endToken at: stream position + 1
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
isBinary: aCharacter
	| code |
	aCharacter isNil ifTrue: [^false].
	code := aCharacter asInteger.
	code < 128 ifTrue: [
		^#($+ $- $< $> $= $* $/ $\ $| $& $~ $, $@ $% $? $!! $: $^)
			includes: aCharacter].
	^code > 255
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
next
	^self nextToken
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextArrayPrefix
	| string |
	string := stream copyFrom: stream position - 1 to: stream position.
	^self
		buildToken: compiler delimiterToken
		at: stream position - 1
		with: string
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextAssignment
	^self buildToken: compiler delimiterToken at: stream position with: #':='
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextBinarySelector
	stream back.
	^self
		buildToken: compiler stringToken
		at: stream position + 1
		with: self scanBinarySymbol
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextBinarySymbol
	^self
		buildToken: compiler literalNode
		at: stream position
		with: self scanBinarySymbol
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextColon
	| start char |
	start := stream position.
	char := stream peek.
	((char = Character space or: [char = Character tab]) and: [(stream peek: 2) second = $=]) ifTrue: [
		stream skip: 1.
		char := $=].
	char = $= ifTrue: [
		stream skip.
		^self nextAssignment position: start].
	^(self isBinary: stream peek)
		ifTrue: [self nextBinarySelector]
		ifFalse: [self nextSpecialCharacter]

! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextComment
	| start comment |
	start := stream position.
	[ stream atEnd not and:[stream peek !!== $"] ] whileTrue: [stream next].
	stream atEnd ifTrue: [self error: 'unfinished comment' at: start].
	stream position: start.
	comment := stream upTo: $".
	^self buildToken: compiler commentNode at: start with: comment

! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextIdentifierOrKeyword
	| start |
	start := stream position.
	self skipIdentifier.
	((stream peekFor: $:) and: [stream peekFor: $=]) ifTrue: [stream skip: -2].
	^self buildToken: compiler stringToken at: start
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextKeyword
	| start string |
	start := stream position + 1.
	self skipKeyword.
	string := stream copyFrom: start to: stream position.
	^self buildToken: compiler literalNode at: start - 1 with: string asSymbol
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextLiteralCharacter
	stream atEnd ifTrue: [^self error: 'character expected'].
	^self
		buildToken: compiler literalNode
		at: stream position
		with: stream next
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextLiteralString
	^self
		buildToken: compiler literalNode
		at: stream position
		with: self scanString reduced
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextNumber
	| parser assoc |
	stream skip: -1.
	parser := NumberParser2 new on: stream.
	assoc := parser next.
	parser error ifNotNil: [:e | ^self error: e key at: e value].
	^self
		buildToken: compiler numericLiteralNode
		at: assoc value start
		with: assoc key
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextQuotedSymbol
	| node |
	node := self nextLiteralString.
	^node beSymbol; position: node position - 1
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextSpecialCharacter
	| token |
	token := self buildToken: compiler delimiterToken.
	^token beCharacter
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextSymbolOrArrayPrefix
	| char |
	stream atEnd ifTrue: [self error: 'character expected'].
	char := stream peek.
	(self canBeInIdentifier: char) ifTrue: [^self nextKeyword].
	(self isBinary: char) ifTrue: [^self nextBinarySymbol].
	stream next.
	(char = $[ or: [char = $(]) ifTrue: [^self nextArrayPrefix].
	char = $' ifTrue: [^self nextQuotedSymbol].
	self error: 'character expected'
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
nextToken
	| first |
	first := self scanChar.
	first isNil ifTrue: [^self end].
	(self canStartIdentifier: first) ifTrue: [^self nextIdentifierOrKeyword].
	(first = $→ or: [first = $_]) ifTrue: [^self nextAssignment].
	first = $: ifTrue: [^self nextColon].
	first = $' ifTrue: [^self nextLiteralString].
	first = $$ ifTrue: [^self nextLiteralCharacter].
	first = $# ifTrue: [^self nextSymbolOrArrayPrefix].
	first = $" ifTrue: [^self nextComment].
	first isDigit ifTrue: [^self nextNumber].
	(first !!= $^ and: [first !!= $↑ and: [self isBinary: first]])
		ifTrue: [^self nextBinarySelector].
	^self nextSpecialCharacter
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
scanBinarySymbol
	| start symbol |
	start := stream position.
	self skipBinary.
	symbol := stream copyFrom: start + 1 to: stream position.
	^symbol asSymbol
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
scanChar
	^(stream skipSeparators; atEnd) ifFalse: [stream next]

! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
scanString
	| current start |
	start := current := stream position.
	^String streamContents: [:writer | 
		[| fragment |
			fragment := stream upTo: $'.
			writer nextPutAll: fragment.
			(current < stream position and: [(stream back; next) = $'])
				ifFalse: [self error: 'string end expected' at: start].
			stream peekFor: $']
			whileTrue: [
				writer nextPut: $'.
				current := stream position]]
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
skipBinary
	[self isBinary: stream peek] whileTrue: [stream next]
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
skipIdentifier
	| frontend |
	frontend := compiler frontend.
	[stream atEnd]
		whileFalse: [(frontend peekForIdentifier: stream) ifFalse: [^self]]
! !

!SSmalltalkScanner methodsFor: 'scanning' stamp: 'KenD 11/22/2023 07:41:16'!
skipKeyword
	| frontend continue pos |
	frontend := compiler frontend.
	[
		self skipIdentifier.
		continue := false.
		(stream peekFor: $:) ifTrue: [
			pos := stream position.
			stream atEnd
				ifFalse: [continue := frontend canStartIdentifier: stream peek]].
		continue] whileTrue.
	pos isNil ifFalse: [stream position: pos]
! !

!SSmalltalkScanner methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:16'!
error: aString
	^self error: aString at: stream position
! !

!SSmalltalkScanner methodsFor: 'errors' stamp: 'KenD 11/22/2023 07:41:16'!
error: aString at: anInteger
	^compiler error: aString at: anInteger
! !

!SToken methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:15'!
comment
	^comments notNil ifTrue: [comments anyOne]
! !

!SToken methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:15'!
comments
	^comments
! !

!SToken methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:15'!
comments: aCollection
	aCollection isNil ifTrue: [^self].
	comments isNil
		ifTrue: [comments := aCollection]
		ifFalse: [comments addAll: aCollection]
! !

!SToken methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:15'!
moveCommentsTo: aParseNode
	aParseNode comments: comments.
	comments := nil
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
compileWarning: aString
	compiler notify: aString at: self stretch
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
compiler
	^compiler
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
compiler: aSmalltalkCompiler
	compiler := aSmalltalkCompiler
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
end
	^stretch end
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
end: aNumber
	stretch end: aNumber
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
position
	^stretch start
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
position: aNumber
	stretch start: aNumber
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
prevPosition
	^stretch start - 1
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
source
	^compiler sourceCode copyFrom: stretch start to: stretch end
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
stretch
	^stretch
! !

!SToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
stretch: aStretch
	stretch := aStretch
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
endsExpression
	^self isEnd
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
hasSymbol
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
is: anObject
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isAssignment
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isBar
	^(self is: #'|') or: [self is: #'/']
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isBlockNode
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isComment
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isDelimiter
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isEnd
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isIdentifier
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isKeyword
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isLiteral
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isNameToken
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isNumberNode
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isPoolLiteral
	^false
! !

!SToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isStringToken
	^false
! !

!SToken methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:15'!
initialize
	super initialize.
	stretch := 1 thru: 0
! !

!SToken methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
isDelimitedIdentifier
	^false
! !

!SToken class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:15'!
new
	"return an initialized instance"

	^ self basicNew initialize.

! !

!SEndToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:21'!
isEnd
	^true
! !

!SEndToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:21'!
position: aNumber
	super position: aNumber - 1
! !

!SEndToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:21'!
prevPosition
	^stretch start
! !

!SEndToken methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:42:21'!
value: aString
	''
! !

!SParseNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:22'!
acceptVisitor: visitor
	^visitor visitParseNode: self
! !

!SParseNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:22'!
allNodesDo: aBlock
	self nodesDo: aBlock includingDeclarations: true
! !

!SParseNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:22'!
nodeWithLiteral: anObject
	^self nodesDetect: [:n | (n isLiteral or: [n isSelector]) and: [n value = anObject]] ifAbsent: nil

! !

!SParseNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:22'!
nodesDetect: aBlock ifAbsent: absentBlock
	self nodesDo: [:node | (aBlock value: node) ifTrue: [ ^node ] ] includingDeclarations: false.
	^absentBlock value
! !

!SParseNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:22'!
nodesDo: aBlock
	self nodesDo: aBlock includingDeclarations: false
! !

!SParseNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:22'!
nodesDo: aBlock includingDeclarations: aBoolean
	aBlock value: self
! !

!SParseNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:22'!
ast
	^compiler ast
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
hasAssign
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isAssign
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isBraceNode
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isCascade
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isCascadeMessage
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isEvaluable
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isImmediate
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isMessageNode
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isMethod
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isMethodArgument
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isMethodTemporary
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isReturn
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isSelector
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isSelf
	^false
! !

!SParseNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isSuper
	^false
! !

!SParseNode methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:22'!
moveCommentsFrom: aParseNode
	aParseNode moveCommentsTo: self
! !

!SParseNode methodsFor: 'printing' stamp: 'KenD 11/22/2023 07:41:22'!
variableNamed: aString
	self
		allNodesDo: [:node | (node isIdentifier and: [node name = aString])
			ifTrue: [^node]].
	^nil
! !

!SAssignmentNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
acceptVisitor: visitor
	^visitor visitAssignment: self
! !

!SAssignmentNode methodsFor: 'adding / removing' stamp: 'KenD 11/22/2023 07:41:15'!
assign: anIdentifierNode operator: aDelimiterToken
	assignees add: anIdentifierNode.
	operators add: aDelimiterToken
! !

!SAssignmentNode methodsFor: 'adding / removing' stamp: 'KenD 11/22/2023 07:41:15'!
assign: anIdentifierNode with: aParseNode operator: aDelimiterToken
	assignees add: anIdentifierNode.
	operators add: aDelimiterToken.
	expression := aParseNode
! !

!SAssignmentNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
assignees
	^assignees
! !

!SAssignmentNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
expression
	^expression
! !

!SAssignmentNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
operators
	^operators
! !

!SAssignmentNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
hasAssign
	^true
! !

!SAssignmentNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isAssign
	^true
! !

!SAssignmentNode methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:15'!
initialize
	super initialize.
	assignees := OrderedCollection new: 1.
	operators := OrderedCollection new: 1
! !

!SAssignmentNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:15'!
nodesDo: aBlock includingDeclarations: aBoolean
	super nodesDo: aBlock includingDeclarations: aBoolean.
	assignees do: [:v | v nodesDo: aBlock includingDeclarations: aBoolean].
	expression nodesDo: aBlock includingDeclarations: aBoolean
! !

!SBraceNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
acceptVisitor: visitor
	^visitor visitBraceNode: self
! !

!SBraceNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
asMessageNode
	message notNil ifTrue: [^message].
	^message := self expanded
! !

!SBraceNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isBraceNode
	^true
! !

!SBraceNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
elements
	^elements
! !

!SBraceNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
elements: aCollection
	elements := aCollection asArray
! !

!SBraceNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
expanded
	| receiver n new argument array messages i you yourself cascade |
	receiver := compiler identifierNode name: 'Array'.
	n := elements size.
	new := compiler selectorNode symbol: #new:.
	argument := compiler numericLiteralNode value: n.
	array := compiler messageNode.
	array receiver: receiver.
	array selector: new.
	array arguments: (Array with: argument).
	i := 0.
	messages := elements collect: [:elem | | msg sel idx args |
		i := i + 1.
		msg := compiler cascadeMessageNode position: elem position; end: elem end.
		sel := compiler selectorNode symbol: #at:put:.
		idx := compiler numericLiteralNode value: i.
		args := Array with: idx with: elem.
		msg selector: sel; arguments: args].
	you := compiler selectorNode symbol: #yourself.
	yourself := compiler cascadeMessageNode.
	yourself selector: you.
	yourself arguments: #().
	messages := messages copyWith: yourself.
	cascade := compiler cascadeNode receiver: array.
	messages do: [:msg | msg cascade: cascade].
	^cascade messages: messages
! !

!SBraceNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:15'!
nodesDo: aBlock includingDeclarations: aBoolean
	super nodesDo: aBlock includingDeclarations: aBoolean.
	elements do: [:n | n nodesDo: aBlock includingDeclarations: aBoolean]
! !

!SCascadeNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:19'!
acceptVisitor: visitor
	^visitor visitCascade: self
! !

!SCascadeNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:19'!
hasAssign
	receiver hasAssign ifTrue: [^true].
	messages detect: [:msg | msg hasAssign] ifNone: [^false].
	^true
! !

!SCascadeNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:19'!
isCascade
	^true
! !

!SCascadeNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:19'!
nodesDo: aBlock includingDeclarations: aBoolean
	super nodesDo: aBlock includingDeclarations: aBoolean.
	receiver nodesDo: aBlock includingDeclarations: aBoolean.
	messages do: [:msg | msg nodesDo: aBlock includingDeclarations: aBoolean]
! !

!SCascadeNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
messages
	^messages
! !

!SCascadeNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
messages: aCollection
	messages := aCollection
! !

!SCascadeNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
receiver
	^receiver
! !

!SCascadeNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:19'!
receiver: rcvr
	receiver := rcvr
! !

!SCommentNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isComment
	^true
! !

!SCommentNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
value
	^value
! !

!SCommentNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
value: aString
	value := aString
! !

!SIdentifierNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:20'!
acceptVisitor: visitor
	^visitor visitIdentifier: self
! !

!SIdentifierNode methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:42:20'!
beAssigned
	| immutable |
	binding canBeAssigned ifTrue: [^self].
	immutable := binding isClassBinding
		ifTrue: ['class']
		ifFalse: [compiler activeScope describe: binding name].
	self compileError: 'cannot assign to ' , immutable
! !

!SIdentifierNode methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:42:20'!
resolveAssigning: aBoolean
	binding := compiler activeScope resolve: name.
	^binding

! !

!SIdentifierNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:20'!
binding
	^binding
! !

!SIdentifierNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:20'!
binding: aBinding
	binding := aBinding
! !

!SIdentifierNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:20'!
initialize
	super initialize.
	binding := DynamicBinding default
! !

!SIdentifierNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:20'!
name
	^name
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
checkLowercase
	| char |
	char := name first.
	(char isLetter and: [char isUppercase]) ifFalse: [^self].
	self compileWarning: name storeString , ' should start with lowercase'
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isEvaluable
	^self isIdentifierLiteral
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isIdentifier
	^true
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isIdentifierLiteral
	binding isDynamic ifFalse: [^binding isLiteral].
	^self ast ifNil: [false] ifNotNil: [:ast | | b |
		b := ast scope resolve: name.
		b isLiteral]
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isImmediate
	^true
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isLocal
	^binding isLocal
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isMethodArgument
	| ast |
	binding isArgument ifFalse: [^false].
	ast := self ast ifNil: [^false].
	^ast arguments includes: self declaration
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isMethodTemporary
	^self ast temporaries includes: self declaration
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isSelf
	^binding isSelf
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
isSuper
	^binding isSuper
! !

!SIdentifierNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:20'!
sourceIntervals
	| stretchs declaration ast string code index |
	stretchs := OrderedCollection new.
	declaration := binding declaration.
	ast := self ast.
	ast allNodesDo: [:node | 
		(node class == self class and: [node binding declaration == declaration])
			ifTrue: [stretchs add: node stretch]].
	string := self source.
	code := compiler sourceCode.
	index := ast stretch end.
	[
		index := code indexOfString: string startingAt: index + 1.
		index > 0]
		whileTrue: [stretchs add: (index to: index + string size - 1)].
	^stretchs
! !

!SIdentifierNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:20'!
declaration
	^binding declaration
! !

!SIdentifierNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:20'!
defineArgumentIn: aScriptScope
	binding := aScriptScope defineArgument: name.
	binding declaration: self
! !

!SIdentifierNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:20'!
defineTemporaryIn: scope
	binding := scope defineTemporary: name.
	binding declaration: self
! !

!SIdentifierNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:20'!
printOn: aStream
	aStream nextPut: $<;
	nextPutAll: name;
	nextPutAll: '> ('.
	super printOn: aStream.
	aStream nextPut: $)
! !

!SIdentifierNode methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:42:20'!
name: aString
	name := aString reduced
! !

!SLiteralNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
acceptVisitor: visitor
	^visitor visitLiteral: self
! !

!SLiteralNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
hasSymbol
	^value isSymbol
! !

!SLiteralNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isEvaluable
	^true
! !

!SLiteralNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isImmediate
	^true
! !

!SLiteralNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
isLiteral
	^true
! !

!SLiteralNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
beSymbol
	value := value asSymbol
! !

!SLiteralNode methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:41:22'!
value
	^value
! !

!SLiteralNode methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:41:22'!
value: anObject
	value := anObject
! !

!SNumberNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:23'!
acceptVisitor: visitor
	^visitor visitNumberNode: self
! !

!SNumberNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:23'!
isNumberNode
	^true
! !

!SNumberNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:23'!
negate
	value := value negated
! !

!SStringNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:27'!
acceptVisitor: visitor
	^visitor visitString: self
! !

!SMessageNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:15'!
acceptVisitor: visitor
	^visitor visitMessage: self
! !

!SMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
arguments
	^arguments
! !

!SMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
arguments: aCollection
	arguments := aCollection
! !

!SMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
receiver
	^receiver
! !

!SMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
receiver: node
	receiver := node
! !

!SMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
selector
	^selector
! !

!SMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
selector: node
	selector := node
! !

!SMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
symbol
	^selector symbol
! !

!SMessageNode methodsFor: 'emitting - inlined' stamp: 'KenD 11/22/2023 07:41:15'!
beInlined
	inlined := true
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
hasAssign
	receiver hasAssign ifTrue: [^true].
	^arguments anySatisfy: [:arg | arg hasAssign]
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
hasVolatileArguments
	^arguments anySatisfy: [:arg | 
		arg isIdentifier
			ifTrue: [arg binding canBeAssigned]
			ifFalse: [arg isBlockNode not andNot: [arg isLiteral]]]
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
hasVolatileReceiver
	^ compiler hasBlocks
		  or: [ receiver isMethodTemporary not ]
		  or: [ arguments anySatisfy: [ :arg | arg hasAssign ] ]
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
initialize
	super initialize.
	inlined := false
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isCascadeMessage
	^false
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isInlined
	^inlined
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isMessageNode
	^true
! !

!SMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
needsStrictEvaluationOrder
	arguments size = 0 ifTrue: [^false].
	receiver isBlockNode ifTrue: [^false].
	receiver isLiteral ifTrue: [^false].
	receiver isSelf ifTrue: [^false].
	receiver isSuper ifTrue: [^false].
	receiver isMethodArgument ifTrue: [^false].
	self hasVolatileReceiver ifFalse: [^false].
	(receiver isImmediate
		and: [arguments conform: [:arg | arg isImmediate or: [arg isBlockNode]]])
		ifTrue: [^false].
	receiver hasAssign ifTrue: [^true].
	receiver isMessageNode ifTrue: [ ^true ]. 
	^self hasVolatileArguments
! !

!SMessageNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:15'!
nodesDo: aBlock includingDeclarations: aBoolean
	super nodesDo: aBlock includingDeclarations: aBoolean.
	receiver nodesDo: aBlock includingDeclarations: aBoolean.
	arguments do: [:arg | arg nodesDo: aBlock includingDeclarations: aBoolean].
	selector nodesDo: aBlock includingDeclarations: aBoolean
! !

!SCascadeMessageNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:23'!
acceptVisitor: visitor
	^visitor visitCascadeMessage: self
! !

!SCascadeMessageNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:23'!
cascade: aCascadeNode
	cascade := aCascadeNode.
	receiver := cascade receiver
! !

!SCascadeMessageNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:23'!
from: aMessageNode
	arguments := aMessageNode arguments.
	receiver := aMessageNode receiver.
	selector := aMessageNode selector.
	inlined := aMessageNode isInlined.
	stretch := aMessageNode stretch.
	comments := aMessageNode comments
! !

!SCascadeMessageNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:23'!
isCascadeMessage
	^true
! !

!SCascadeMessageNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:23'!
nodesDo: aBlock includingDeclarations: aBoolean
	aBlock value: self.
	arguments do: [:arg | arg nodesDo: aBlock includingDeclarations: aBoolean]
! !

!SReturnNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:23'!
acceptVisitor: visitor
	^visitor visitReturn: self
! !

!SReturnNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:23'!
expression
	^expression
! !

!SReturnNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:23'!
expression: node
	expression := node
! !

!SReturnNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:23'!
return: aSmalltalkToken
	return := aSmalltalkToken
! !

!SReturnNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:23'!
hasAssign
	^expression hasAssign
! !

!SReturnNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:23'!
isReturn
	^true
! !

!SReturnNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:23'!
nodesDo: aBlock includingDeclarations: aBoolean
	super nodesDo: aBlock includingDeclarations: aBoolean.
	expression nodesDo: aBlock includingDeclarations: aBoolean
! !

!SScriptNode methodsFor: 'add/remove' stamp: 'KenD 11/22/2023 07:41:15'!
addChild: aBlockNode
	children add: aBlockNode
! !

!SScriptNode methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:15'!
addStatements: anOrderedCollection
	statements addAll: anOrderedCollection
! !

!SScriptNode methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:15'!
identifiers
	| result |
	result := OrderedCollection new.
	self nodesDo: [:node | node isIdentifier ifTrue: [result add: node]].
	^result removeDuplicates
! !

!SScriptNode methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:15'!
initialize
	super initialize.
	statements := OrderedCollection new.
	arguments := #().
	temporaries := #().
	children := OrderedCollection new
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
arguments
	^arguments
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
arguments: aCollection
	arguments := aCollection
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
children
	^children
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
environmentSize
	^scope environmentSize
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
realScript
	self subclassResponsibility
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
statements
	^statements
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
temporaries
	^temporaries
! !

!SScriptNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:15'!
temporaries: aCollection
	temporaries := aCollection
! !

!SScriptNode methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:15'!
bindLocals
	arguments do: [:arg | arg defineArgumentIn: scope].
	temporaries do: [:temp | temp checkLowercase; defineTemporaryIn: scope].
	children do: [:block | block bindLocals]
! !

!SScriptNode methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:15'!
positionLocals
	scope positionLocals.
	children do: [:b | b positionLocals]
! !

!SScriptNode methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:15'!
reference: aBinding
	aBinding beReferencedFrom: self
! !

!SScriptNode methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:15'!
scope
	^scope
! !

!SScriptNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
hasAssign
	statements do: [:s | s hasAssign ifTrue: [^true]].
	^false
! !

!SScriptNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:15'!
nodesDo: aBlock includingDeclarations: aBoolean
	super nodesDo: aBlock includingDeclarations: aBoolean.
	aBoolean ifTrue: [
		arguments do: [:a | a nodesDo: aBlock includingDeclarations: aBoolean].
		temporaries do: [:a | a nodesDo: aBlock includingDeclarations: aBoolean]].
	statements do: [:s | s nodesDo: aBlock includingDeclarations: aBoolean]
! !

!SScriptNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:15'!
useSelf
	scope captureSelf
! !

!SBlockNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:42:26'!
acceptVisitor: visitor
	^visitor visitBlock: self
! !

!SBlockNode methodsFor: 'emitting - inlined' stamp: 'KenD 11/22/2023 07:42:26'!
beInlined
	inlined := true.
	arguments do: [:arg | arg binding beInlined]
! !

!SBlockNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:26'!
buildBlock
	| block |
	self isInlined ifTrue: [ ^ nil ].
	block := SCompiledBlock new.
	^ block
		  id: index;
		  argumentCount: arguments size;
		  tempCount: scope stackSize;
		  environmentCount: scope environmentSize;
		  capturesSelf: scope capturesSelf;
			capturesHome: scope capturesHome
! !

!SBlockNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:42:26'!
captureHome
	scope captureEnvironment: self ast
! !

!SBlockNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
environmentIndexOf: aParseNode
	^scope environmentIndexOf: aParseNode
! !

!SBlockNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
isBlockNode
	^true
! !

!SBlockNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
isEvaluable
	^self isNullary
! !

!SBlockNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
isInlined
	^inlined
! !

!SBlockNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
isNullary
	^arguments isEmpty
! !

!SBlockNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
usesHome
	^inlined
		ifTrue: [children anySatisfy: [:block | block usesHome]]
		ifFalse: [scope capturesHome]
! !

!SBlockNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
index
	^index
! !

!SBlockNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
index: aNumber
	index := aNumber
! !

!SBlockNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
parent
	^parent
! !

!SBlockNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
parent: aScriptNode
	parent := aScriptNode addChild: self
! !

!SBlockNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
realParent
	^parent realScript
! !

!SBlockNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
realScript
	^inlined ifTrue: [parent realScript] ifFalse: [self]
! !

!SBlockNode methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:42:26'!
initialize
	super initialize.
	inlined := false.
	scope := BlockScope on: self
! !

!SMethodNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:24'!
acceptVisitor: visitor
	^visitor visitMethod: self
! !

!SMethodNode methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:24'!
buildMethod
	| cm encoder astcodes |
	cm := self methodClass withAll: self literals.
	cm
		blockCount: compiler blockCount;
		tempCount: scope stackSize;
		argumentCount: arguments size;
		environmentCount: scope environmentSize;
		capturesSelf: scope capturesSelf;
		hasEnvironment: self needsEnvironment;
		hasFrame: self needsFrame;
		selector: self selector;
		source: compiler sourceCode;
		classBinding: compiler frontend classBinding.
	cm pragma: pragma.
	cm blocks do: [ :block | block method: cm ].
	encoder := AstcodeEncoder new method: cm.
	astcodes := self acceptVisitor: encoder.
	^ cm astcodes: astcodes
! !

!SMethodNode methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:24'!
captureHome
	
! !

!SMethodNode methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:24'!
literals
	| literals v l |
	literals := OrderedCollection new.
	pragma isUsed
		ifTrue: [ literals add: pragma name ].
	self
		nodesDo: [ :n | 
			n isLiteral
				ifTrue: [ v := n value.
					v isSmallInteger
						ifFalse: [ literals add: v ] ].
			n isMessageNode
				ifTrue: [ literals add: n symbol ].
			n isBraceNode
				ifTrue: [ n isLiteral
						ifTrue: [ self halt ]
						ifFalse: [ literals
								add: #Array;
								add: #new:;
								add: #at:put:;
								add: #yourself ] ].
			(n isIdentifier
				and: [ l := n binding literal.
					l notNil ])
				ifTrue: [ literals add: l ].
			(n isBlockNode andNot: [ n isInlined ])
				ifTrue: [ literals add: n buildBlock ] ].
	^ literals removeDuplicates
! !

!SMethodNode methodsFor: 'parsing' stamp: 'KenD 11/22/2023 07:41:24'!
methodClass
	| type |
	type := pragma type.
	type = #callback
		ifTrue: [ ^ SCallbackMethod ].
	type = #callout
		ifTrue: [ ^ SCalloutMethod ].
	^ SCompiledMethod
! !

!SMethodNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
compiler: aSmalltalkCompiler
	super compiler: aSmalltalkCompiler.
	scope := MethodScope new script: self.
	pragma := aSmalltalkCompiler pragmaNode
! !

!SMethodNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
pragma
	^pragma
! !

!SMethodNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
pragma: anObject
	pragma := anObject
! !

!SMethodNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
realScript
	^self
! !

!SMethodNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
selector
	^selector value
! !

!SMethodNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
selector: aSelectorNode
	selector := aSelectorNode
! !

!SMethodNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
selectorNode
	^selector
! !

!SMethodNode methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
environmentIndexOf: aParseNode
	^nil
! !

!SMethodNode methodsFor: 'inquiries' stamp: 'KenD 11/22/2023 07:41:24'!
header
	"
	(Object >> #printOn:) ast header
	"
	| interval |
	interval := selector stretch.
	arguments notEmpty
		ifTrue: [interval := interval start thru: arguments last stretch end].
	^compiler sourceCode copyFrom: interval start to: interval end
! !

!SMethodNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:24'!
isHeadless
	^selector isNil
! !

!SMethodNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:24'!
isMethod
	^true
! !

!SMethodNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:24'!
needsEnvironment
	^scope environmentSize > 0
		or: [children anySatisfy: [:block | block usesHome]]
! !

!SMethodNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:24'!
needsFrame
	scope stackSize > 0 ifTrue: [ ^ true ].
	arguments size > 16 ifTrue: [ ^ true ].
	compiler hasSends ifTrue: [ ^ true ].
	compiler hasBlocks ifTrue: [ ^ true ].
	^ false
! !

!SMethodNode methodsFor: 'enumerating' stamp: 'KenD 11/22/2023 07:41:24'!
nodesDo: aBlock includingDeclarations: aBoolean
	super nodesDo: aBlock includingDeclarations: aBoolean.
	(aBoolean and: [selector notNil]) ifTrue: [aBlock value: selector]
! !

!SSelectorNode methodsFor: 'visiting' stamp: 'KenD 11/22/2023 07:41:24'!
acceptVisitor: visitor
	^visitor visitSelector: self
! !

!SSelectorNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
addKeyword: aSelectorNode
	keywords isNil ifTrue: [keywords := OrderedCollection new: 1].
	keywords add: aSelectorNode
! !

!SSelectorNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
end
	stretch end ifNotNil: [:e | ^e].
	^keywords notNil ifTrue: [keywords last end]
! !

!SSelectorNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
keywords
	^keywords isNil ifTrue: [{self}] ifFalse: [keywords]
! !

!SSelectorNode methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
positions
	^self keywords collect: [:node | node position]
! !

!SSelectorNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:24'!
hasSymbol
	^symbol isSymbol
! !

!SSelectorNode methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:24'!
isSelector
	^true
! !

!SSelectorNode methodsFor: 'queries' stamp: 'KenD 11/22/2023 07:41:24'!
isBinary
	^symbol isBinary
! !

!SSelectorNode methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:41:24'!
symbol
	^symbol
! !

!SSelectorNode methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:41:24'!
symbol: aString
	symbol := aString asSymbol
! !

!SSelectorNode methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:41:24'!
value
	^symbol
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
acceptVisitor: aVisitor
	self isFFI ifTrue: [^aVisitor visitFFIPragma: self].
	self isPrimitive ifTrue: [^aVisitor visitPrimitivePragma: self].
	self isSymbolic ifTrue: [^aVisitor visitSymbolicPragma: self]
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
ffi: cc name: aString with: anFFIDescriptor
	type := cc.
	name := aString.
	info := anFFIDescriptor
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
ffi: aString with: anFFIDescriptor
	type := #ffi.
	name := aString.
	info := anFFIDescriptor
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
info
	^info
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
isUsed
	^type notNil
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
name
	^name
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
primitive: anInteger name: aString
	type := #primitive.
	name := aString.
	info := anInteger
! !

!SPragmaNode methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:42:27'!
type
	^type
! !

!SSymbolicToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:22'!
is: anObject
	^value == anObject
! !

!SSymbolicToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:22'!
value
	^value
! !

!SSymbolicToken methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:22'!
value: anObject
	value := anObject
! !

!SDelimiterToken methodsFor: 'converting' stamp: 'KenD 11/22/2023 07:42:27'!
asSelectorNode
	^compiler selectorNode symbol: value asString; stretch: stretch
! !

!SDelimiterToken methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:42:27'!
beCharacter
	value := value isCharacter ifTrue: [value] ifFalse: [value first]
! !

!SDelimiterToken methodsFor: 'evaluating' stamp: 'KenD 11/22/2023 07:42:27'!
value: aString
	super value: aString asSymbol
! !

!SDelimiterToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:27'!
endsExpression
	^value = $. or: [value = $]] or: [value = $)] or: [value = $}]
! !

!SDelimiterToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:27'!
isAssignment
	^self is: #':='
! !

!SDelimiterToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:27'!
isDelimiter
	^true
! !

!SStringToken methodsFor: 'converting' stamp: 'KenD 11/22/2023 07:41:15'!
asIdentifierNode
	^compiler identifierNode
		name: value;
		stretch: stretch;
		comments: comments
! !

!SStringToken methodsFor: 'converting' stamp: 'KenD 11/22/2023 07:41:15'!
asSelectorNode
	^compiler selectorNode symbol: value; stretch: stretch
! !

!SStringToken methodsFor: 'converting' stamp: 'KenD 11/22/2023 07:41:15'!
isStringToken
	^true
! !

!SStringToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
hasSymbol
	^value isSymbol
! !

!SStringToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isBinary
	^value isSymbol
! !

!SStringToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isDelimitedIdentifier
	^value first = ${
! !

!SStringToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isKeyword
	^value last = $:
! !

!SStringToken methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:15'!
isNameToken
	^(self isKeyword or: [self isBinary]) not
! !

!ScriptScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:24'!
capturesSelf
	^ captureSelf
! !

!ScriptScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:24'!
describe: identifier
	| binding type |
	binding := self resolve: identifier.
	type := self class name asLowercase allButLast: 'scope' size.
	^binding description , ' of ' , type
! !

!ScriptScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:24'!
environmentSize
	^envSize
! !

!ScriptScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:24'!
scopeOf: aString
	| s |
	s := self scriptDefining: aString.
	^s notNil ifTrue: [s scope]
! !

!ScriptScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:24'!
stackSize
	^stackSize
! !

!ScriptScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:24'!
defineArgument: identifier
	| binding |
	(self resolves: identifier) ifTrue: [self redefinitionError: identifier].
	binding := ArgumentBinding new name: identifier.
	arguments define: identifier as: binding.
	^binding
! !

!ScriptScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:24'!
defineTemporary: identifier
	| binding |
	(temporaries defines: identifier)
		ifTrue: [self redefinitionError: identifier].
	binding := TemporaryBinding new name: identifier.
	temporaries define: identifier as: binding.
	^binding
! !

!ScriptScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:24'!
defines: aString
	^(temporaries defines: aString) or: [arguments defines: aString]
! !

!ScriptScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:24'!
localBindings
	^arguments values , temporaries values
! !

!ScriptScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:24'!
resolveLocal: aString
	(temporaries at: aString) ifNotNil: [:binding | ^binding].
	^arguments at: aString
! !

!ScriptScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:24'!
resolves: aString
	^(self resolve: aString) isDynamic not
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
growEnvironment
	^envSize := envSize + 1
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
growStack
	^stackSize := stackSize + 1
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
positionDefinedArguments
	arguments withIndexDo: [:binding :index | binding index: index]
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
positionDefinedLocals
	self positionDefinedTemporariesIn: self; positionDefinedArguments
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
positionDefinedTemporariesIn: aScriptScope
	temporaries do: [:binding | | position |
		position := binding isInStack
			ifTrue: [aScriptScope growStack]
			ifFalse: [aScriptScope growEnvironment].
		binding index: position]
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
positionLocals
	self positionDefinedLocals
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
realScope
	^script realScript scope
! !

!ScriptScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:24'!
redefinitionError: name
	| scope description |
	scope := self scopeOf: name.
	description := scope describe: name.
	script compiler
		warning: name , ' already declared as ' , description
		at: script stretch
! !

!ScriptScope methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:24'!
initialize
	super initialize.
	arguments := StaticBinder new.
	temporaries := StaticBinder new.
	stackSize := envSize := 0.
		captureSelf := false.
! !

!ScriptScope methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:41:24'!
script: aScriptNode
	script := aScriptNode
! !

!ScriptScope class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:24'!
new
	^super new initialize
! !

!ScriptScope class methodsFor: 'instance creation' stamp: 'KenD 11/22/2023 07:41:24'!
on: aScriptNode
	^self new script: aScriptNode
! !

!BlockScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:22'!
captureArgument: anArgumentBinding
	| name |
	name := anArgumentBinding name.
	^captured at: name ifAbsentPut: [| transferred copy |
		transferred := self parent transferLocal: name.
		copy := self copyLocal: transferred.
		(anArgumentBinding isInlined and: [copy !!= anArgumentBinding])
			ifTrue: [anArgumentBinding beInArray].
		copy declaration: transferred declaration]
! !

!BlockScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:22'!
localBindings
	^super localBindings , captured values
! !

!BlockScope methodsFor: 'binding' stamp: 'KenD 11/22/2023 07:41:22'!
resolve: aString
	(self resolveLocal: aString) ifNotNil: [:binding | ^binding].
	^self parent resolve: aString
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
captureEnvironment: aScriptNode
	script == aScriptNode ifTrue: [^self].
	(environments identityIncludes: aScriptNode) ifTrue: [^self].
	self realParent captureEnvironment: aScriptNode.
	aScriptNode isMethod
		ifTrue: [environments addFirst: aScriptNode]
		ifFalse: [environments addLast: aScriptNode]
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
capturedEnvironmentIndexOf: aScriptNode
	| index |
	aScriptNode realScript == script realScript
		ifTrue: [ ^ nil ].
	index := environments indexOf: aScriptNode ifAbsent: nil.
	self ASSERT: index notNil.
	^self capturesSelf ifTrue: [ index + 1 ] ifFalse: [ index ]
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
copyLocal: binding
	^script isInlined ifTrue: [binding] ifFalse: [binding copy beInArray]
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
environmentIndexOf: aScriptNode
	"
	temporal compatibility
	"
	(aScriptNode isKindOf: SScriptNode)
		ifFalse: [ self ASSERT: false. ^nil ].
	^self capturedEnvironmentIndexOf: aScriptNode
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
environmentSizeUpToCapturedArguments
	^self environmentSizeUpToEnvironments + self capturedArguments size
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
environmentSizeUpToEnvironments
	| receiver |
	receiver := self capturesSelf ifTrue: [ 1 ] ifFalse: [ 0 ].
	^receiver + environments size
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
parent
	^script parent scope
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
positionCapturedArgument: anArgumentBinding
	anArgumentBinding index: self growEnvironment
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
positionCapturedLocals
	script isInlined ifTrue: [^self].
	envSize := self environmentSizeUpToEnvironments.
	captured do: [:binding | 
		binding isArgument
			ifTrue: [self positionCapturedArgument: binding]
			ifFalse: [self positionCapturedTemporary: binding]]
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
positionCapturedTemporary: aTemporaryBinding
	| outest index declaration |
	outest := self scriptDefining: aTemporaryBinding name.
	index := self capturedEnvironmentIndexOf: outest realScript.
	aTemporaryBinding environmentIndex: index.
	declaration := outest scope resolve: aTemporaryBinding name.
	self ASSERT: declaration index isInteger.
	aTemporaryBinding index: declaration index
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
positionDefinedArgumentsIn: aScriptScope
	arguments do: [:binding | | index |
		index := binding isInArray
			ifTrue: [aScriptScope growEnvironment]
			ifFalse: [aScriptScope growStack].
		binding index: index]
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
positionDefinedLocals
	| real |
	script isInlined
		ifTrue: [
			real := self realScope.
			self
				positionDefinedTemporariesIn: real;
				positionDefinedArgumentsIn: real]
		ifFalse: [super positionDefinedLocals]
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
positionLocals
	self positionCapturedLocals.
	super positionLocals
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
realParent
	^script realParent scope
! !

!BlockScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:22'!
transferLocal: name
	| binding copy |
	(self resolveLocal: name) ifNotNil: [:b | ^b].
	binding := self parent transferLocal: name.
	copy := self copyLocal: binding.
	captured at: name put: copy.
	^copy
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
captureLocal: aLocalBinding
	(self defines: aLocalBinding name) ifTrue: [^aLocalBinding].
	^aLocalBinding isTemporary
		ifTrue: [self captureTemporary: aLocalBinding]
		ifFalse: [self captureArgument: aLocalBinding]
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
captureSelf
	captureSelf ifTrue: [^self].
	captureSelf := true.
	self parent captureSelf
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
captureTemporary: aTemporaryBinding
	| name |
	name := aTemporaryBinding name.
	(self defines: name) ifTrue: [^aTemporaryBinding].
	^captured at: name ifAbsentPut: [| parent declaration transferred copy |
		parent := self parent.
		declaration := parent scriptDefining: name.
		self realScope captureEnvironment: declaration realScript.
		transferred := parent transferLocal: name.
		copy := self copyLocal: transferred.
		copy isInArray ifTrue: [aTemporaryBinding beInArray].
		copy declaration: transferred declaration]
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
capturedArguments
	^captured select: [:b | b isArgument]
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
capturedEnvironments
	^environments
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
capturesHome
	^self home notNil
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
environments
	"
	compatibility, removes the home environment
	"
	| first |
	environments isEmpty ifTrue: [^#()].
	first := environments first.
	^first isMethod ifTrue: [environments allButFirst] ifFalse: [environments]
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
home
	| first |
	environments isEmpty ifTrue: [^nil].
	first := environments first.
	^first isMethod ifTrue: [first]
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
resolveLocal: aString
	(super resolveLocal: aString) ifNotNil: [:binding | ^binding].
	^captured at: aString
! !

!BlockScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:22'!
scriptDefining: aString
	(self defines: aString) ifTrue: [^script].
	^self parent scriptDefining: aString
! !

!BlockScope methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:22'!
initialize
	super initialize.
	captured := StaticBinder new.
	environments := OrderedCollection new
! !

!MethodScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:18'!
captureEnvironment: aScriptNode
	self ASSERT: aScriptNode == script
! !

!MethodScope methodsFor: 'private' stamp: 'KenD 11/22/2023 07:41:18'!
transferLocal: name
	^self resolveLocal: name
! !

!MethodScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:18'!
captureLocal: aLocalBinding
	self ASSERT: (self resolveLocal: aLocalBinding name) notNil.
	^aLocalBinding
! !

!MethodScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:18'!
captureSelf
	captureSelf := true.

! !

!MethodScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:18'!
environmentIndexOf: aScriptNode
	self ASSERT: aScriptNode == script.
	^nil
! !

!MethodScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:18'!
resolve: aString
	(self resolveLocal: aString) ifNotNil: [ :binding | ^ binding ].
	(self resolvePseudo: aString) ifNotNil: [ :binding | ^ binding ].
	^ DynamicBinding named: aString
! !

!MethodScope methodsFor: 'services' stamp: 'KenD 11/22/2023 07:41:18'!
scriptDefining: aString
	(self resolveLocal: aString) ifNotNil: [^script].
	self ASSERT: false.
	^nil
! !

!MethodScope methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:18'!
initialize
	super initialize.
	self initializePseudoVars
! !

!MethodScope methodsFor: 'initialization' stamp: 'KenD 11/22/2023 07:41:18'!
initializePseudoVars
	pseudo := StaticBinder new.
	pseudo
		at: 'nil' put: NilBinding new;
		at: 'true' put: TrueBinding new;
		at: 'false' put: FalseBinding new;
		at: 'self' put: SelfBinding new;
		at: 'super' put: SuperBinding new
! !

!MethodScope methodsFor: 'as yet unclassified' stamp: 'KenD 11/22/2023 07:41:18'!
resolvePseudo: aString
	^pseudo at: aString

! !

!PowertalkEvaluatorError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
context
	^context
! !

!PowertalkEvaluatorError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:49:10'!
context: anEvaluationContext

	context := anEvaluationContext
! !

!PowertalkEvaluatorError class methodsFor: 'signalling' stamp: 'KenD 11/22/2023 07:49:10'!
signal: aString on: anEvaluationContext

	^ self new 
		  context: anEvaluationContext;
		  signal: aString
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
beFatal
	resumable := retryable := false
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
beResumable
	resumable := true
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
beWarning
	resumable := true
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
compiler
	^compiler
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
compiler: aCompiler
	compiler := aCompiler.
	compiler result error: self
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
description: aString
	messageText := aString
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
isResumable
	^resumable

! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
proceed
	retryable := false.
	compiler result beSuccessful.
	self isResumable ifTrue: [ self resume ] ifFalse: [ self return ]
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
source
	^compiler sourceCode copyFrom: stretch start to: stretch end
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
stretch
	^stretch
! !

!SCompilationError methodsFor: 'accessing' stamp: 'KenD 11/22/2023 07:42:26'!
stretch: aStretch
	stretch := aStretch
! !

!SCompilationError methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
isUndeclaredAccess
	^false
! !

!SCompilationError methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:42:26'!
isUndeclaredAssignment
	^ false
! !

!SUndeclaredIdentifierError methodsFor: 'accessing-token' stamp: 'KenD 11/22/2023 07:41:16'!
assignment: aBoolean
	assigned := aBoolean
! !

!SUndeclaredIdentifierError methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:16'!
identifier
	^ identifier
! !

!SUndeclaredIdentifierError methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:16'!
isUndeclaredAccess
	^assigned not
! !

!SUndeclaredIdentifierError methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:16'!
isUndeclaredAssignment
	^assigned
! !

!SUndeclaredIdentifierError methodsFor: 'testing' stamp: 'KenD 11/22/2023 07:41:16'!
stretch: aStretch
	super stretch: aStretch.
	identifier := self source
! !
CharacterConstants initialize!
OperandTypeFlags initialize!
Prefixes initialize!
Registers initialize!
ObjectHeaderMasks initialize!
ObjectHeaderOffsets initialize!
InlineMessageLinkerFlags initialize!
SendSiteFlags initialize!
SExpressionTypes initialize!
AstBindingTypes initialize!
AstNodeTypes initialize!
ClosureElementTypes initialize!
SCompiledBlockFlags initialize!
SCompiledMethodFlags initialize!
RegistersRISCV initialize!
Subject initialize!
SFFIDescriptor initialize!
Register initialize!
ISAOperandType initialize!
InstructionEncoder initialize!
InstructionSpec initialize!
Assembler initialize!
SmalltalkInterpreter initialize!
AstcodeDecoder initialize!
